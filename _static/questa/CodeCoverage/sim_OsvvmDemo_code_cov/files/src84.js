var g_data = {"name":"C:/SynthWorks/Dev/_osvvm/OsvvmLibraries/AXI4/Axi4/src/Axi4Memory.vhd","src":"--\n--  File Name:         Axi4Memory.vhd\n--  Design Unit Name:  Axi4Memory\n--  Revision:          OSVVM MODELS STANDARD VERSION\n--\n--  Maintainer:        Jim Lewis      email:  jim@synthworks.com\n--  Contributor(s):\n--     Jim Lewis      jim@synthworks.com\n--\n--\n--  Description:\n--      Simple AXI Full Memory Subordinate Model\n--\n--\n--  Developed by:\n--        SynthWorks Design Inc.\n--        VHDL Training Classes\n--        http://www.SynthWorks.com\n--\n--  Revision History:\n--    Date      Version    Description\n--    05/2023   2023.05    Adding Randomization of Valid and Ready timing   \n--    10/2022   2022.10    Changed enum value PRIVATE to PRIVATE_NAME due to VHDL-2019 keyword conflict.   \n--    05/2022   2022.05    Updated FIFOs so they are Search => PRIVATE\n--    03/2022   2022.03    Updated calls to NewID for AlertLogID and FIFOs\n--    02/2022   2022.02    Replaced to_hstring with to_hxstring\n--                         Added Search by NAME to NewID.\n--    01/2022   2022.01    Moved MODEL_INSTANCE_NAME and MODEL_NAME to entity declarative region\n--    07/2021   2021.07    All FIFOs and Scoreboards now use the New Scoreboard/FIFO capability \n--    06/2021   2021.06    GHDL support + new memory data structure  \n--    02/2021   2021.02    Added MultiDriver Detect.  Updated Generics.   \n--    06/2020   2020.06    Derived from Axi4Subordinate.vhd\n--\n--\n--  This file is part of OSVVM.\n--\n--  Copyright (c) 2020 - 2023 by SynthWorks Design Inc.\n--\n--  Licensed under the Apache License, Version 2.0 (the \"License\");\n--  you may not use this file except in compliance with the License.\n--  You may obtain a copy of the License at\n--\n--      https://www.apache.org/licenses/LICENSE-2.0\n--\n--  Unless required by applicable law or agreed to in writing, software\n--  distributed under the License is distributed on an \"AS IS\" BASIS,\n--  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n--  See the License for the specific language governing permissions and\n--  limitations under the License.\n--\n\nlibrary ieee ;\n  use ieee.std_logic_1164.all ;\n  use ieee.numeric_std.all ;\n  use ieee.numeric_std_unsigned.all ;\n  use ieee.math_real.all ;\n\nlibrary osvvm ;\n  context osvvm.OsvvmContext ;\n  use osvvm.ScoreboardPkg_slv.all ;\n\nlibrary osvvm_common ;\n  context osvvm_common.OsvvmCommonContext ;\n\n  use work.Axi4OptionsPkg.all ;\n  use work.Axi4InterfaceCommonPkg.all ;\n  use work.Axi4InterfacePkg.all ;\n  use work.Axi4CommonPkg.all ;\n  use work.Axi4ModelPkg.all ;\n\nentity Axi4Memory is\ngeneric (\n  MODEL_ID_NAME   : string := \"\" ;\n  MEMORY_NAME     : string := \"\" ;\n  tperiod_Clk     : time   := 10 ns ;\n\n  DEFAULT_DELAY   : time   := 1 ns ; \n\n  tpd_Clk_AWReady : time   := DEFAULT_DELAY ;\n\n  tpd_Clk_WReady  : time   := DEFAULT_DELAY ;\n\n  tpd_Clk_BValid  : time   := DEFAULT_DELAY ;\n  tpd_Clk_BResp   : time   := DEFAULT_DELAY ;\n  tpd_Clk_BID     : time   := DEFAULT_DELAY ;\n  tpd_Clk_BUser   : time   := DEFAULT_DELAY ;\n\n  tpd_Clk_ARReady : time   := DEFAULT_DELAY ;\n\n  tpd_Clk_RValid  : time   := DEFAULT_DELAY ;\n  tpd_Clk_RData   : time   := DEFAULT_DELAY ;\n  tpd_Clk_RResp   : time   := DEFAULT_DELAY ;\n  tpd_Clk_RID     : time   := DEFAULT_DELAY ;\n  tpd_Clk_RUser   : time   := DEFAULT_DELAY ;\n  tpd_Clk_RLast   : time   := DEFAULT_DELAY\n) ;\nport (\n  -- Globals\n  Clk         : in   std_logic ;\n  nReset      : in   std_logic ;\n\n  -- AXI Subordinate Interface\n  AxiBus      : inout Axi4RecType ;\n\n  -- Testbench Transaction Interface\n  TransRec    : inout AddressBusRecType\n) ;\n\n  -- Model Configuration\n  -- Access via transactions or external name\n  shared variable Params : ModelParametersPType ;\n  \n  -- Derive AXI interface properties from the AxiBus\n  constant AXI_ADDR_WIDTH : integer := AxiBus.WriteAddress.Addr'length ;\n  constant AXI_DATA_WIDTH : integer := AxiBus.WriteData.Data'length ;\n  \n  -- Derive ModelInstance label from path_name\n  constant MODEL_INSTANCE_NAME : string :=\n    -- use MODEL_ID_NAME Generic if set, otherwise use instance label (preferred if set as entityname_1)\n    IfElse(MODEL_ID_NAME /= \"\", MODEL_ID_NAME, PathTail(to_lower(Axi4Memory'PATH_NAME))) ;\n\n  -- Memory Data Structure, Access via MemoryName\n  constant LOCAL_MEMORY_NAME : string := \n    IfElse(MEMORY_NAME /= \"\", MEMORY_NAME, MODEL_INSTANCE_NAME & \":memory\") ;\n--    IfElse(MEMORY_NAME /= \"\", MEMORY_NAME, to_lower(Axi4Memory'PATH_NAME) & \":memory\") ;\n    \n  constant MODEL_NAME : string := \"Axi4Memory\" ;\n\nend entity Axi4Memory ;\n\narchitecture MemorySubordinate of Axi4Memory is\n  constant AXI_DATA_BYTE_WIDTH  : integer := AXI_DATA_WIDTH / 8 ;\n  constant AXI_BYTE_ADDR_WIDTH  : integer := integer(ceil(log2(real(AXI_DATA_BYTE_WIDTH)))) ;\n\n  signal ModelID, BusFailedID, DataCheckID : AlertLogIDType ;\n  signal WriteAddressDelayCov, WriteDataDelayCov, WriteResponseDelayCov : DelayCoverageIDType ;\n  signal ReadAddressDelayCov,  ReadDataDelayCov : DelayCoverageIDType ;\n  signal UseCoverageDelays : boolean := FALSE ; \n  \n  signal MemoryID : MemoryIDType ; \n\n--  constant MemoryID : MemoryIDType := NewID(\n--      Name       => LOCAL_MEMORY_NAME, \n--      AddrWidth  => AXI_ADDR_WIDTH,  -- Address is byte address\n--      DataWidth  => 8,               -- Memory is byte oriented\n--      Search     => NAME\n--    ) ; \n\n  signal WriteAddressFifo     : osvvm.ScoreboardPkg_slv.ScoreboardIDType ;\n  signal WriteDataFifo        : osvvm.ScoreboardPkg_slv.ScoreboardIDType ;\n  signal WriteResponseFifo    : osvvm.ScoreboardPkg_slv.ScoreboardIDType ;\n  \n  signal ReadAddressFifo      : osvvm.ScoreboardPkg_slv.ScoreboardIDType ;\n  signal ReadDataFifo         : osvvm.ScoreboardPkg_slv.ScoreboardIDType ;\n\n  -- Setup so that if no configuration is done, accept transactions\n  signal WriteAddressExpectCount     : integer := 0 ;\n  signal WriteDataExpectCount        : integer := 0 ;\n\n  signal WriteAddressReceiveCount    : integer := 0 ;\n  signal WriteDataReceiveCount       : integer := 0 ;\n  signal WriteReceiveCount           : integer := 0 ;\n  signal WriteResponseDoneCount      : integer := 0 ;\n\n  signal ReadAddressReceiveCount     : integer := 0 ;\n\n  signal ReadDataRequestCount        : integer := 0 ;\n  signal ReadDataDoneCount           : integer := 0 ;\n\n\n  -- A hack of a way to set the parameters for now.\n  signal ModelBResp  : Axi4RespType := to_Axi4RespType(OKAY) ;\n  signal ModelRResp  : Axi4RespType := to_Axi4RespType(OKAY) ;\n  \n  signal ModelBUSER  : std_logic_vector(AxiBus.WriteResponse.User'length - 1 downto 0) := (others => '0') ;\n  signal ModelBID    : std_logic_vector(AxiBus.WriteResponse.ID'length - 1 downto 0) := (others => '0') ;\n\n  signal ModelRUSER  : std_logic_vector(AxiBus.ReadData.User'length - 1 downto 0) := (others => '0') ;\n  signal ModelRID    : std_logic_vector(AxiBus.ReadData.ID'length - 1 downto 0) := (others => '0') ;\n\nbegin\n\n  ------------------------------------------------------------\n  -- Turn off drivers not being driven by this model\n  ------------------------------------------------------------\n  InitAxi4Rec (AxiBusRec => AxiBus ) ;\n\n\n  ------------------------------------------------------------\n  --  Initialize AlertLogIDs\n  ------------------------------------------------------------\n  InitalizeAlertLogIDs : process\n    variable ID : AlertLogIDType ;\n  begin\n    -- Alerts\n    ID           := NewID(MODEL_INSTANCE_NAME) ;\n    ModelID      <= ID ;\n    BusFailedID  <= NewID(\"No response\", ID ) ;\n    DataCheckID  <= NewID(\"Data Check\", ID ) ;\n    \n    -- MEMORY_NAME\n    MemoryID <= NewID(\n      Name       => LOCAL_MEMORY_NAME, \n      AddrWidth  => AXI_ADDR_WIDTH,  -- Address is byte address\n      DataWidth  => 8,               -- Memory is byte oriented\n      ParentID   => ID, \n      Search     => NAME\n    ) ; \n\n\n    -- FIFOs get an AlertLogID with NewID, however, it does not print in ReportAlerts (due to DoNotReport)\n    --   FIFOS only generate usage type errors \n    WriteAddressFifo    <= NewID(\"WriteAddressFIFO\",   ID, ReportMode => DISABLED, Search => PRIVATE_NAME);\n    WriteDataFifo       <= NewID(\"WriteDataFifo\",      ID, ReportMode => DISABLED, Search => PRIVATE_NAME);\n    WriteResponseFifo   <= NewID(\"WriteResponseFifo\",  ID, ReportMode => DISABLED, Search => PRIVATE_NAME);\n    ReadAddressFifo     <= NewID(\"ReadAddressFifo\",    ID, ReportMode => DISABLED, Search => PRIVATE_NAME);\n    ReadDataFifo        <= NewID(\"ReadDataFifo\",       ID, ReportMode => DISABLED, Search => PRIVATE_NAME);\n    wait ;\n  end process InitalizeAlertLogIDs ;\n\n\n  ------------------------------------------------------------\n  --  Initialize Model Options\n  ------------------------------------------------------------\n  InitalizeOptions : process\n  begin\n    InitAxiOptions (\n      Params => Params\n    ) ;\n    wait ;\n  end process InitalizeOptions ;\n\n\n  ------------------------------------------------------------\n  --  Transaction Dispatcher\n  --    Handles transactions between TestCtrl and Model\n  ------------------------------------------------------------\n  TransactionDispatcher : process\n    variable Address          : std_logic_vector(AxiBus.WriteAddress.Addr'range) ;\n    variable Data             : std_logic_vector(AxiBus.WriteData.Data'range) ;\n    variable ExpectedData     : std_logic_vector(AxiBus.WriteData.Data'range) ;\n    variable ByteData         : std_logic_vector(7 downto 0) ;\n    variable DataWidth        : integer ;\n    variable NumBytes         : integer ;\n    variable Count            : integer ;\n    variable TransactionCount : integer := 0 ; \n    variable Axi4Option       : Axi4OptionsType ;\n    variable Axi4OptionVal    : integer ; \n  begin\n    wait for 0 ns ; -- Allow ModelID to become valid\n    TransRec.WriteBurstFifo <= NewID(\"WriteBurstFifo\",         ModelID, Search => PRIVATE_NAME) ;\n    TransRec.ReadBurstFifo  <= NewID(\"ReadBurstFifo\",          ModelID, Search => PRIVATE_NAME) ;\n    WriteAddressDelayCov    <= NewID(\"WriteAddressDelayCov\",   ModelID, ReportMode => DISABLED) ; \n    WriteDataDelayCov       <= NewID(\"WriteDataDelayCov\",      ModelID, ReportMode => DISABLED) ; \n    WriteResponseDelayCov   <= NewID(\"WriteResponseDelayCov\",  ModelID, ReportMode => DISABLED) ; \n    ReadAddressDelayCov     <= NewID(\"ReadAddressDelayCov\",    ModelID, ReportMode => DISABLED) ; \n    ReadDataDelayCov        <= NewID(\"ReadDataDelayCov\",       ModelID, ReportMode => DISABLED) ; \n    \n--!! AWCache, ARCache Defaults\n    DispatchLoop : loop\n      WaitForTransaction(\n         Clk      => Clk,\n         Rdy      => TransRec.Rdy,\n         Ack      => TransRec.Ack\n      ) ;\n      TransactionCount := TransactionCount + 1 ; \n\n      case TransRec.Operation is\n        when WAIT_FOR_TRANSACTION =>\n          -- Wait for either next write or read access of memory to complete\n          Count := WriteAddressReceiveCount + ReadAddressReceiveCount ;\n          wait until (WriteAddressReceiveCount + ReadAddressReceiveCount) = Count + 1 ;\n\n        when WAIT_FOR_WRITE_TRANSACTION =>\n          -- Wait for next write to memory to complete\n          Count := WriteAddressReceiveCount ;\n          wait until WriteAddressReceiveCount = Count + 1 ;\n\n        when WAIT_FOR_READ_TRANSACTION =>\n          -- Wait for next read from memory to complete\n          Count := ReadAddressReceiveCount ;\n          wait until ReadAddressReceiveCount = Count + 1 ;\n\n        when WAIT_FOR_CLOCK =>\n          WaitForClock(Clk, TransRec.IntToModel) ;\n\n        when GET_ALERTLOG_ID =>\n          TransRec.IntFromModel <= integer(ModelID) ;\n          wait for 0 ns ;\n\n        when SET_USE_RANDOM_DELAYS =>        \n          UseCoverageDelays      <= TransRec.BoolToModel ; \n\n        when GET_USE_RANDOM_DELAYS =>\n          TransRec.BoolFromModel <= UseCoverageDelays ;\n\n        when SET_DELAYCOV_ID =>\n          case TransRec.Options is\n            when WRITE_ADDRESS_ID  =>  WriteAddressDelayCov  <= GetDelayCoverage(TransRec.IntToModel) ;\n            when WRITE_DATA_ID     =>  WriteDataDelayCov     <= GetDelayCoverage(TransRec.IntToModel) ;\n            when WRITE_RESPONSE_ID =>  WriteResponseDelayCov <= GetDelayCoverage(TransRec.IntToModel) ;\n            when READ_ADDRESS_ID   =>  ReadAddressDelayCov   <= GetDelayCoverage(TransRec.IntToModel) ;\n            when READ_DATA_ID      =>  ReadDataDelayCov      <= GetDelayCoverage(TransRec.IntToModel) ;\n            when others =>  Alert(ModelID, \"SetDelayCoverageID, Invalid ID requested = \" & to_string(TransRec.IntToModel), FAILURE) ;  \n          end case ; \n          UseCoverageDelays <= TRUE ; \n\n        when GET_DELAYCOV_ID =>\n          case TransRec.Options is\n            when WRITE_ADDRESS_ID  =>  TransRec.IntFromModel <= WriteAddressDelayCov.ID  ;\n            when WRITE_DATA_ID     =>  TransRec.IntFromModel <= WriteDataDelayCov.ID     ;\n            when WRITE_RESPONSE_ID =>  TransRec.IntFromModel <= WriteResponseDelayCov.ID ;\n            when READ_ADDRESS_ID   =>  TransRec.IntFromModel <= ReadAddressDelayCov.ID   ;\n            when READ_DATA_ID      =>  TransRec.IntFromModel <= ReadDataDelayCov.ID      ;\n            when others =>  Alert(ModelID, \"GetDelayCoverageID, Invalid ID requested = \" & to_string(TransRec.IntToModel), FAILURE) ;  \n          end case ; \n          UseCoverageDelays <= TRUE ; \n\n        when GET_TRANSACTION_COUNT =>\n          TransRec.IntFromModel <= integer(TransRec.Rdy) ;\n          wait for 0 ns ;\n\n        when GET_WRITE_TRANSACTION_COUNT =>\n          TransRec.IntFromModel <= WriteAddressReceiveCount ;\n          wait for 0 ns ;\n\n        when GET_READ_TRANSACTION_COUNT =>\n          TransRec.IntFromModel <= ReadAddressReceiveCount ;\n          wait for 0 ns ;\n\n        when WRITE_OP =>\n          -- Back door Write access to memory.  Completes without time passing.\n          Address    := SafeResize(TransRec.Address, Address'length) ;\n          Data       := SafeResize(TransRec.DataToModel, Data'length) ;\n          DataWidth  := TransRec.DataWidth ;\n          NumBytes   := DataWidth / 8 ;\n\n  --!9        -- Do checks  Is address appropriate for NumBytes\n  --        AlignCheckWriteData (ModelID, Data, Strb, TransRec.DataWidth, ByteAddr) ;\n\n          -- Memory is byte oriented.  Access as Bytes\n          for i in 0 to NumBytes-1 loop\n            ByteData := Data((8*i + 7)  downto 8*i) ;\n            MemWrite(MemoryID, Address + i, ByteData) ;\n          end loop ;\n\n        when READ_OP | READ_CHECK =>\n          -- Back door Read access to memory.  Completes without time passing.\n          Address    := SafeResize(TransRec.Address, Address'length) ;\n  --        ByteAddr   := CalculateByteAddress(Address, AXI_BYTE_ADDR_WIDTH);\n          Data       := (others => '0') ;\n          DataWidth  := TransRec.DataWidth ;\n          NumBytes   := DataWidth / 8 ;\n\n  --!9        -- Do checks  Is address appropriate for NumBytes\n  --??  What if 32 bit read, but address is byte oriented??\n  --??  ERROR, or OK & return unaddressed bytes as X?\n\n          -- Memory is byte oriented.  Access as Bytes\n          for i in 0 to NumBytes-1 loop\n            MemRead(MemoryID, Address + i, ByteData) ;\n            Data((8*i + 7)  downto 8*i) := ByteData ;\n          end loop ;\n\n          TransRec.DataFromModel <= SafeResize(Data, TransRec.DataFromModel'length) ;\n\n          if IsReadCheck(TransRec.Operation) then\n            ExpectedData := SafeResize(TransRec.DataToModel, ExpectedData'length) ;\n            AffirmIf( DataCheckID, Data = ExpectedData,\n              \"Read Address: \" & to_hxstring(Address) &\n              \"  Data: \" & to_hxstring(Data) &\n              \"  Expected: \" & to_hxstring(ExpectedData),\n              IsLogEnabled(ModelID, INFO) ) ;\n          else\n  --!! TODO:  Change format to Address, Data Transaction #, Read Data\n            Log( ModelID,\n              \"Read Address: \" & to_hxstring(Address) &\n              \"  Data: \" & to_hxstring(Data),\n              INFO\n            ) ;\n          end if ;\n\n        when SET_MODEL_OPTIONS =>\n  --!!        Params.Set(TransRec.Options, TransRec.IntToModel) ;\n          Axi4Option := Axi4OptionsType'val(TransRec.Options) ;\n          if IsAxiParameter(Axi4Option) then\n            SetAxi4Parameter(Params, Axi4Option, TransRec.IntToModel) ;\n          else\n            case Axi4Option is\n              -- RESP Settings\n              when BRESP =>                ModelBResp <= to_slv(TransRec.IntToModel, ModelBResp'length) ;\n              when RRESP =>                ModelRResp <= to_slv(TransRec.IntToModel, ModelRResp'length) ;\n              -- ID Settings\n              when BID =>                  ModelBID <= to_slv(TransRec.IntToModel, ModelBID'length) ;\n              when RID =>                  ModelRID <= to_slv(TransRec.IntToModel, ModelRID'length) ;\n              -- User Settings\n              when BUSER =>                ModelBUser <= to_slv(TransRec.IntToModel, ModelBUser'length) ;\n              when RUSER =>                ModelRUser <= to_slv(TransRec.IntToModel, ModelRUser'length) ;\n              --\n              -- The End -- Done\n              when others =>        \n                Alert(ModelID, \"SetOptions, Unimplemented Option: \" & to_string(Axi4OptionsType'val(TransRec.Options)), FAILURE) ;\n            end case ;\n          end if ;\n\n        when GET_MODEL_OPTIONS =>\n  --!!        TransRec.IntFromModel <= Params.Get(TransRec.Options) ;\n          Axi4Option := Axi4OptionsType'val(TransRec.Options) ;\n          if IsAxiParameter(Axi4Option) then\n            GetAxi4Parameter(Params, Axi4Option, Axi4OptionVal) ;\n            TransRec.IntFromModel <= Axi4OptionVal ;\n          else\n            case Axi4Option is\n              -- RESP Settings\n              when BRESP =>                TransRec.IntFromModel <= to_integer(ModelBResp) ;\n              when RRESP =>                TransRec.IntFromModel <= to_integer(ModelRResp) ;\n              -- ID Settings\n              when BID =>                  TransRec.IntFromModel <= to_integer(ModelBID) ;\n              when RID =>                  TransRec.IntFromModel <= to_integer(ModelRID) ;\n              -- User Settings\n              when BUSER =>                TransRec.IntFromModel <= to_integer(ModelBUser) ;\n              when RUSER =>                TransRec.IntFromModel <= to_integer(ModelRUser) ;\n              --\n              -- The End -- Done\n              when others =>              \n                Alert(ModelID, \"GetOptions, Unimplemented Option: \" & to_string(Axi4OptionsType'val(TransRec.Options)), FAILURE) ;\n            end case ;\n          end if ;\n\n          when MULTIPLE_DRIVER_DETECT =>\n            Alert(ModelID, \"Multiple Drivers on Transaction Record.\" & \n                           \"  Transaction # \" & to_string(TransRec.Rdy), FAILURE) ;\n\n        when others =>\n            Alert(ModelID, \"Unimplemented Transaction: \" & to_string(TransRec.Operation), FAILURE) ;\n      end case ;\n\n      -- Wait for 1 delta cycle, required if a wait is not in all case branches above\n      wait for 0 ns ;\n    end loop DispatchLoop ; \n\n  end process TransactionDispatcher ;\n\n\n  ------------------------------------------------------------\n  --  WriteAddressHandler\n  --    Execute Write Address Transactions\n  ------------------------------------------------------------\n  WriteAddressHandler : process\n    alias    AW : AxiBus.WriteAddress'subtype is AxiBus.WriteAddress ;\n    variable ReadyBeforeValid    : boolean := TRUE ;\n    variable intReadyBeforeValid : integer ;\n    variable ReadyDelayCycles    : integer := 0 ;\n  begin\n    AW.Ready <= '0' ;\n    wait for 0 ns ; -- Allow Cov models to initialize \n    wait for 0 ns ; -- Allow Cov models to initialize \n    AddBins (WriteAddressDelayCov.BurstLengthCov,  GenBin(2,10,1)) ;\n    -- Delays for Ready\n    AddCross(WriteAddressDelayCov.BurstDelayCov,   GenBin(0,1,1), GenBin(2,5,1)) ;\n    AddCross(WriteAddressDelayCov.BeatDelayCov,    GenBin(0),     GenBin(0)) ;  -- No beat delay\n    WaitForClock(Clk, 2) ;  -- Initialize\n\n    WriteAddressOperation : loop\n      if UseCoverageDelays then \n        -- BurstCoverage Delays\n        (intReadyBeforeValid, ReadyDelayCycles)  := GetRandDelay(WriteAddressDelayCov) ; \n        ReadyBeforeValid := intReadyBeforeValid = 0 ; \n      else\n        -- Deprecated static settings\n        GetAxi4Parameter(Params, WRITE_ADDRESS_READY_BEFORE_VALID, ReadyBeforeValid) ;\n        GetAxi4Parameter(Params, WRITE_ADDRESS_READY_DELAY_CYCLES, ReadyDelayCycles) ;\n      end if ; \n      \n      ---------------------\n      DoAxiReadyHandshake (\n      ---------------------\n        Clk                     => Clk,\n        Valid                   => AxiBus.WriteAddress.Valid,\n        Ready                   => AxiBus.WriteAddress.Ready,\n        ReadyBeforeValid        => ReadyBeforeValid,\n        ReadyDelayCycles        => ReadyDelayCycles * tperiod_Clk,\n        tpd_Clk_Ready           => tpd_Clk_AWReady\n      ) ;\n\n--!9 Resolve Level\n      Log(ModelID,\n        \"Write Address.\" &\n        \"  AWAddr: \"    & to_hxstring(AW.Addr) &\n        \"  AWProt: \"    & to_string (AW.Prot) &\n        \"  AWLen: \"     & to_string (AW.Len) &\n        \"  AWSize: \"    & to_string (AW.Size) &\n        \"  AWBurst: \"   & to_string (AW.Burst) &\n        \"  AWID: \"      & to_string (AW.ID) &\n        \"  AWUser: \"    & to_string (AW.User) &\n        \"  Operation# \" & to_string (WriteAddressReceiveCount + 1),\n        DEBUG\n      ) ;\n\n      -- Send Address Information to WriteHandler\n      push(WriteAddressFifo, AW.Addr & AW.Len & AW.Prot & AW.Size & AW.Burst & AW.ID & AW.User ) ;\n\n      -- Signal completion\n      increment(WriteAddressReceiveCount) ;\n      wait for 0 ns ;\n\n--?6 Add delay between accepting addresses determined by type of address: Single Word, First Burst, Burst, Last Burst\n\n    end loop WriteAddressOperation ;\n  end process WriteAddressHandler ;\n\n\n  ------------------------------------------------------------\n  --  WriteDataHandler\n  --    Execute Write Data Transactions\n  ------------------------------------------------------------\n  WriteDataHandler : process\n    alias    WD : AxiBus.WriteData'subtype is AxiBus.WriteData ;\n    variable ReadyBeforeValid     : boolean := TRUE ;\n    variable intReadyBeforeValid  : integer ;\n    variable ReadyDelayCycles     : integer := 0 ;\n  begin\n    WD.Ready <= '0' ;\n    wait for 0 ns ; -- Allow Cov models to initialize \n    wait for 0 ns ; -- Allow Cov models to initialize \n    AddBins (WriteDataDelayCov.BurstLengthCov,  GenBin(2,10,1)) ;\n    -- Delays for Ready\n    AddCross(WriteDataDelayCov.BurstDelayCov,   GenBin(0,1,1), GenBin(2,5,1)) ;\n    AddCross(WriteDataDelayCov.BeatDelayCov,    GenBin(0),     GenBin(0)) ;  -- No beat delay\n    WaitForClock(Clk, 2) ;  -- Initialize\n\n    WriteDataOperation : loop\n      if UseCoverageDelays then \n        -- BurstCoverage Delays\n        (intReadyBeforeValid, ReadyDelayCycles)  := GetRandDelay(WriteDataDelayCov) ; \n        ReadyBeforeValid := intReadyBeforeValid = 0 ; \n      else\n        -- Deprecated static delays\n        GetAxi4Parameter(Params, WRITE_DATA_READY_BEFORE_VALID, ReadyBeforeValid) ;\n        GetAxi4Parameter(Params, WRITE_DATA_READY_DELAY_CYCLES, ReadyDelayCycles) ;\n      end if ; \n      \n      ---------------------\n      DoAxiReadyHandshake(\n      ---------------------\n        Clk                     => Clk,\n        Valid                   => AxiBus.WriteData.Valid,\n        Ready                   => AxiBus.WriteData.Ready,\n        ReadyBeforeValid        => ReadyBeforeValid,\n        ReadyDelayCycles        => ReadyDelayCycles * tperiod_Clk,\n        tpd_Clk_Ready           => tpd_Clk_WReady\n      ) ;\n\n\n      -- Send to WriteHandler\n      push(WriteDataFifo, WD.Data & WD.Strb) ;\n\n--!! Add AXI Full Information\n--!9 Resolve Level\n      Log(ModelID,\n        \"Write Data.\" &\n        \"  WData: \"  & to_hxstring(WD.Data) &\n        \"  WStrb: \"  & to_string(WD.Strb) &\n        \"  Operation# \" & to_string(WriteDataReceiveCount + 1),\n        DEBUG\n      ) ;\n\n      -- Signal completion\n      increment(WriteDataReceiveCount) ;\n\n--!9 Delay between accepting words determined by type of write address: Single Word, First Burst, Burst, Last Burst\n\n    end loop WriteDataOperation ;\n    wait ; -- remove \"no wait\" warning\n  end process WriteDataHandler ;\n\n\n  ------------------------------------------------------------\n  --  WriteHandler\n  --    Collect Write Address and Data transactions\n  ------------------------------------------------------------\n  WriteHandler : process\n    variable LAW : AxiBus.WriteAddress'subtype ;\n    alias AW : AxiBus.WriteAddress'subtype is AxiBus.WriteAddress ;\n    variable LWD : AxiBus.WriteData'subtype ;\n    alias    WD  : AxiBus.WriteData'subtype is AxiBus.WriteData ;\n    variable BurstLen         : integer ;\n    variable ByteAddressBits  : integer ;\n    variable BytesPerTransfer : integer ;\n    variable TransferAddress, MemoryAddress : std_logic_vector(LAW.Addr'range) ;\n    variable ByteData         : std_logic_vector(7 downto 0) ;\n  begin\n    wait for 0 ns ; -- Allow WriteAddressFifo to initialize\n    \n    WriteHandlerLoop : loop \n      -- Find Write Address and Data transaction\n      if empty(WriteAddressFifo) then\n        WaitForToggle(WriteAddressReceiveCount) ;\n      end if ;\n      (LAW.Addr, LAW.Len, LAW.Prot, LAW.Size, LAW.Burst, LAW.ID, LAW.User) := pop(WriteAddressFifo) ;\n\n      if LAW.Len'length > 0 then\n        BurstLen := to_integer(LAW.Len) + 1 ;\n      else\n        BurstLen := 1 ;\n      end if ;\n\n      if LAW.Size'length > 0 then\n        ByteAddressBits   := to_integer(LAW.Size) ;\n        BytesPerTransfer  := 2 ** ByteAddressBits ;\n      else\n        ByteAddressBits   := AXI_BYTE_ADDR_WIDTH ;\n        BytesPerTransfer  := AXI_DATA_BYTE_WIDTH ;\n      end if ;\n\n      -- first word in a burst or single word transfer\n      TransferAddress  := LAW.Addr(LAW.Addr'left downto ByteAddressBits) & (ByteAddressBits downto 1 => '0') ;\n      -- GetWordAddr(Addr, BytesPerTransfer) ;\n      MemoryAddress    := TransferAddress(LAW.Addr'left downto AXI_BYTE_ADDR_WIDTH) & (AXI_BYTE_ADDR_WIDTH downto 1 => '0') ;\n      -- GetWordAddr(TransferAddress, AXI_BYTE_ADDR_WIDTH) ;\n\n  --!3 Delay before first word - burst vs. single word\n\n      -- Burst transfers\n      BurstLoop : for i in 1 to BurstLen loop\n        -- Wait for Data\n        if empty(WriteDataFifo) then\n          WaitForToggle(WriteDataReceiveCount) ;\n        end if ;\n        (LWD.Data, LWD.Strb) := pop(WriteDataFifo) ;\n\n        if i = 1 then\n          Log(ModelID,\n            \"Memory Write.\" &\n            \"  AWAddr: \"    & to_hxstring(LAW.Addr) &\n            \"  AWProt: \"    & to_string (LAW.Prot) &\n            \"  WData: \"     & to_hxstring(LWD.Data) &\n            \"  WStrb: \"     & to_string (LWD.Strb) &\n            \"  Operation# \" & to_string (WriteReceiveCount),\n            INFO\n          ) ;\n        end if ;\n\n        -- Memory is byte oriented.  Access as Bytes\n        for j in 0 to AXI_DATA_BYTE_WIDTH-1 loop\n          if LWD.Strb(j) = '1' then\n            ByteData := LWD.Data((8*j + 7)  downto 8*j) ;\n            MemWrite(MemoryID, MemoryAddress + j, ByteData) ;\n          end if ;\n        end loop ;\n\n  --!5        GetNextBurstAddress(Address, BurstType) ;  -- to support Wrap addressing\n        TransferAddress := TransferAddress + BytesPerTransfer ;\n        MemoryAddress   := TransferAddress(LAW.Addr'left downto AXI_BYTE_ADDR_WIDTH) & (AXI_BYTE_ADDR_WIDTH downto 1 => '0') ;\n        -- GetWordAddr(TransferAddress, AXI_BYTE_ADDR_WIDTH) ;\n\n        --!3 Delay between burst words - burst vs. single word\n\n      end loop BurstLoop ;\n\n  --!3 Delay after last word - burst vs. single word\n\n  --!9 Get response from Params\n  --!9 Does response vary with Address?\n  --!! Only one response per burst cycle.  Last cycle of a burst only\n      push(WriteResponseFifo, ModelBResp & LAW.ID & LAW.User) ;\n      increment(WriteReceiveCount) ;\n      wait for 0 ns ;\n    end loop WriteHandlerLoop ; \n  end process WriteHandler ;\n\n\n  ------------------------------------------------------------\n  -- WriteResponseHandler\n  --   Receive and Check Write Responses\n  ------------------------------------------------------------\n  WriteResponseHandler : process\n    alias    WR    : AxiBus.WriteResponse'subtype is AxiBus.WriteResponse ;\n    variable Local : AxiBus.WriteResponse'subtype ;\n    variable WriteResponseReadyTimeOut : integer := 25 ;\n    variable DelayCycles : integer ; \n  begin\n    -- initialize\n    WR.Valid <= '0' ;\n    WR.Resp  <= (Local.Resp'range => '0') ;\n    WR.ID    <= (Local.ID'range => '0') ;\n    WR.User  <= (Local.User'range => '0') ;\n    wait for 0 ns ; -- Allow WriteResponseFifo to initialize\n    wait for 0 ns ; -- Allow Cov models to initialize \n    AddBins (WriteResponseDelayCov.BurstLengthCov,  GenBin(2,10,1)) ;\n    AddBins (WriteResponseDelayCov.BurstDelayCov,   GenBin(2,5,1)) ;\n    AddBins (WriteResponseDelayCov.BeatDelayCov,    GenBin(0)) ;\n\n    WriteResponseLoop : loop\n      -- Find Transaction\n      if empty(WriteResponseFifo) then\n        WaitForToggle(WriteReceiveCount) ;\n      end if ;\n      (Local.Resp, Local.ID, Local.User) := pop(WriteResponseFifo) ;\n\n      if UseCoverageDelays then \n        -- BurstCoverage Delays\n        DelayCycles := GetRandDelay(WriteResponseDelayCov) ; \n        WaitForClock(Clk, DelayCycles) ;\n      else\n        -- Deprecated delays\n        WaitForClock(Clk, integer'(Params.Get(Axi4OptionsType'POS(WRITE_RESPONSE_VALID_DELAY_CYCLES)))) ; \n      end if ; \n\n      -- Do Transaction\n      WR.Resp  <= Local.Resp  after tpd_Clk_BResp ;\n      WR.ID    <= Local.ID    after tpd_Clk_BID ;\n      WR.User  <= Local.User  after tpd_Clk_BUser ;\n\n      Log(ModelID,\n        \"Write Response.\" &\n        \"  BResp: \"  & to_hxstring(Local.Resp) &\n        \"  BID: \"    & to_hxstring(Local.ID) &\n        \"  BUser: \"  & to_hxstring(Local.User) &\n        \"  Operation# \" & to_string(WriteResponseDoneCount + 1),\n        DEBUG\n      ) ;\n\n      GetAxi4Parameter(Params, WRITE_RESPONSE_READY_TIME_OUT, WriteResponseReadyTimeOut) ;\n\n      ---------------------\n      DoAxiValidHandshake (\n      ---------------------\n        Clk            =>  Clk,\n        Valid          =>  AxiBus.WriteResponse.Valid,\n        Ready          =>  AxiBus.WriteResponse.Ready,\n        tpd_Clk_Valid  =>  tpd_Clk_BValid,\n        AlertLogID     =>  BusFailedID,\n        TimeOutMessage =>  \"Write Response # \" & to_string(WriteResponseDoneCount + 1),\n        TimeOutPeriod  =>  WriteResponseReadyTimeOut * tperiod_Clk\n      ) ;\n\n      -- State after operation\n      WR.Resp  <= not Local.Resp  after tpd_Clk_BResp ;\n      WR.ID    <= not Local.ID    after tpd_Clk_BID ;\n      WR.User  <= not Local.User  after tpd_Clk_BUser ;\n\n      -- Signal completion\n      Increment(WriteResponseDoneCount) ;\n      wait for 0 ns ;\n\n--!9 response delay based on type of write address: Single Word, First Burst, Burst, Last Burst\n\n    end loop WriteResponseLoop ;\n  end process WriteResponseHandler ;\n\n\n  ------------------------------------------------------------\n  --  ReadAddressHandler\n  --    Execute Read Address Transactions\n  --    Handles addresses as received, adds appropriate interface characterists\n  ------------------------------------------------------------\n  ReadAddressHandler : process\n    alias    AR : AxiBus.ReadAddress'subtype is AxiBus.ReadAddress ;\n    variable ReadyBeforeValid    : boolean := TRUE ;\n    variable intReadyBeforeValid : integer ;\n    variable ReadyDelayCycles    : integer := 0 ;\n  begin\n    -- Initialize\n    AR.Ready <= '0' ;\n    wait for 0 ns ; -- Allow Cov models to initialize \n    wait for 0 ns ; -- Allow Cov models to initialize \n    AddBins (ReadAddressDelayCov.BurstLengthCov,  GenBin(2,10,1)) ;\n    -- Delays for Ready\n    AddCross(ReadAddressDelayCov.BurstDelayCov,   GenBin(0,1,1), GenBin(2,5,1)) ;\n    AddCross(ReadAddressDelayCov.BeatDelayCov,    GenBin(0),     GenBin(0)) ;  -- No beat delay\n    WaitForClock(Clk, 2) ;  -- Initialize\n\n    ReadAddressOperation : loop\n--!! ToDo Add Delay calculation here that is f(ReadAddressBurstCov) \n      if UseCoverageDelays then \n        -- BurstCoverage Delays\n        (intReadyBeforeValid, ReadyDelayCycles)  := GetRandDelay(ReadAddressDelayCov) ; \n        ReadyBeforeValid := intReadyBeforeValid = 0 ; \n      else\n        -- Deprecated static settings\n        GetAxi4Parameter(Params, READ_ADDRESS_READY_BEFORE_VALID, ReadyBeforeValid) ;\n        GetAxi4Parameter(Params, READ_ADDRESS_READY_DELAY_CYCLES, ReadyDelayCycles) ;\n      end if ; \n  \n      ---------------------\n      DoAxiReadyHandshake (\n      ---------------------\n        Clk                     => Clk,\n        Valid                   => AxiBus.ReadAddress.Valid,\n        Ready                   => AxiBus.ReadAddress.Ready,\n        ReadyBeforeValid        => ReadyBeforeValid,\n        ReadyDelayCycles        => ReadyDelayCycles * tperiod_Clk,\n        tpd_Clk_Ready           => tpd_Clk_ARReady\n      ) ;\n\n--!9 Resolve Level\n      Log(ModelID,\n        \"Read Address.\" &\n        \"  ARAddr: \"    & to_hxstring(AR.Addr) &\n        \"  ARProt: \"    & to_string (AR.Prot) &\n        \"  ARLen: \"     & to_string (AR.Len) &\n        \"  ARSize: \"    & to_string (AR.Size) &\n        \"  ARBurst: \"   & to_string (AR.Burst) &\n        \"  ARID: \"      & to_string (AR.ID) &\n        \"  ARUser: \"    & to_string (AR.User) &\n        \"  Operation# \" & to_string (ReadAddressReceiveCount+1),\n        DEBUG\n      ) ;\n\n      -- Send Address Information to ReadHandler\n      push(ReadAddressFifo, AR.Addr & AR.Len & AR.Prot & AR.Size & AR.Burst & AR.ID & AR.User ) ;\n\n    -- Signal completion\n      increment(ReadAddressReceiveCount) ;\n--      ReadAddressReceiveCount <= ReadAddressReceiveCount + BurstCount ;\n\n--?6 Add delay between accepting addresses determined by type of address: Single Word, First Burst, Burst, Last Burst\n\n    end loop ReadAddressOperation ;\n    wait ; -- remove \"no wait\" warning\n  end process ReadAddressHandler ;\n\n\n  ------------------------------------------------------------\n  --  ReadHandler\n  --    Accesses Memory\n  --    Introduces cycle delays due to accessing memory\n  ------------------------------------------------------------\n  ReadHandler : process\n    variable LAR : AxiBus.ReadAddress'subtype ;\n    alias    AR  : AxiBus.ReadAddress'subtype is AxiBus.ReadAddress ;\n    -- variable LAR : Axi4ReadAddressRecType (\n                          -- Addr(AR.Addr'range),\n                          -- ID(AR.ID'range),\n                          -- User(AR.User'range)\n                        -- ) ;\n    variable LRD : AxiBus.ReadData'subtype ;\n    alias    RD  : AxiBus.ReadData'subtype is AxiBus.ReadData ;\n    -- variable LRD : Axi4ReadDataRecType (\n                      -- Data(RD.Data'range),\n                      -- User(RD.User'range),\n                      -- ID(RD.ID'range)\n                    -- );\n\n    variable BurstLen         : integer ;\n    variable ByteAddressBits  : integer ;\n    variable BytesPerTransfer : integer ;\n    variable MemoryAddress, TransferAddress : std_logic_vector(LAR.Addr'length-1 downto 0) ;\n    variable ByteData         : std_logic_vector(7 downto 0) ;\n  begin\n    wait for 0 ns ; -- Allow ReadAddressFifo to initialize\n\n    ReadHandlerLoop : loop \n      if empty(ReadAddressFifo) then\n        WaitForToggle(ReadAddressReceiveCount) ;\n      end if ;\n      (LAR.Addr, LAR.Len, LAR.Prot, LAR.Size, LAR.Burst, LAR.ID, LAR.User) := pop(ReadAddressFifo) ;\n\n  --!6 Add delay to access memory by type of address: Single Word, First Burst, Burst, Last Burst\n\n      if LAR.Len'length > 0 then\n        BurstLen := to_integer(LAR.Len) + 1 ;\n      else\n        BurstLen := 1 ;\n      end if ;\n\n      if LAR.Size'length > 0 then\n        ByteAddressBits   := to_integer(LAR.Size) ;\n        BytesPerTransfer  := 2 ** ByteAddressBits ;\n      else\n        ByteAddressBits   := AXI_BYTE_ADDR_WIDTH ;\n        BytesPerTransfer  := AXI_DATA_BYTE_WIDTH ;\n      end if ;\n\n      -- first word in a burst or single word transfer\n      TransferAddress  := LAR.Addr(LAR.Addr'left downto ByteAddressBits) & (ByteAddressBits downto 1 => '0') ;\n      -- GetWordAddr(Addr, BytesPerTransfer) ;\n      MemoryAddress    := TransferAddress(LAR.Addr'left downto AXI_BYTE_ADDR_WIDTH) & (AXI_BYTE_ADDR_WIDTH downto 1 => '0') ;\n      -- GetWordAddr(TransferAddress, AXI_BYTE_ADDR_WIDTH) ;\n\n      LRD.Last := '0' ;\n      BurstLoop : for i in 1 to BurstLen loop\n        -- Memory is byte oriented.  Access as Bytes\n        for i in 0 to AXI_DATA_BYTE_WIDTH-1 loop\n          MemRead(MemoryID, MemoryAddress + i, ByteData) ;\n          LRD.Data((8*i + 7)  downto 8*i) := ByteData ;\n        end loop ;\n\n        if i = 1 then\n          Log(ModelID,\n            \"Memory Read.\" &\n            \"  ARAddr: \"    & to_hxstring(LAR.Addr) &\n            \"  ARProt: \"    & to_string (LAR.Prot) &\n            \"  RData: \"     & to_hxstring(LRD.Data) &\n            \"  Operation# \" & to_string (ReadDataRequestCount),\n            INFO\n          ) ;\n        end if ;\n\n  --!5        GetNextBurstAddress(TransferAddress, BurstType) ;  -- to support Wrap\n        TransferAddress := TransferAddress + BytesPerTransfer ;\n        MemoryAddress    := TransferAddress(TransferAddress'left downto AXI_BYTE_ADDR_WIDTH) & (AXI_BYTE_ADDR_WIDTH downto 1 => '0') ;\n        -- GetWordAddr(TransferAddress, AXI_BYTE_ADDR_WIDTH) ;\n\n        if i = BurstLen then\n          LRD.Last := '1' ;\n        end if ;\n        push(ReadDataFifo, LRD.Data & LRD.Last & ModelRResp & LAR.ID & LAR.User) ;\n        increment(ReadDataRequestCount) ;\n        if i /= BurstLen then \n          wait until Rising_Edge(Clk) ; -- read memory location per clock\n        else\n          wait for 0 ns ;\n        end if ; \n\n      end loop BurstLoop ;\n    end loop ReadHandlerLoop ;\n  end process ReadHandler ;\n\n\n  ------------------------------------------------------------\n  --  ReadDataHandler\n  --    Create Read Data Response Transactions\n  --    All delays at this point are due to AXI Read Data interface operations\n  ------------------------------------------------------------\n  ReadDataHandler : process\n    alias    RD    : AxiBus.ReadData'subtype is AxiBus.ReadData ;\n    variable Local : AxiBus.ReadData'subtype ;\n    -- variable Local : Axi4ReadDataRecType (\n                      -- Data(RD.Data'range),\n                      -- User(RD.User'range),\n                      -- ID(RD.ID'range)\n                    -- );\n    variable ReadDataReadyTimeOut : integer := 25 ;\n    variable NewTransfer : std_logic := '1' ; \n    variable DelayCycles : integer ; \n  begin\n    -- initialize\n    RD.Valid <= '0' ;\n    RD.Data  <= (Local.Data'range => '0') ;\n    RD.Resp  <= (Local.Resp'range => '0') ;\n    RD.ID    <= (Local.ID'range => '0') ;\n    RD.User  <= (Local.User'range => '0') ;\n    RD.Last  <= '0' ;\n    wait for 0 ns ; -- Allow ReadDataFifo to initialize\n    wait for 0 ns ; -- Allow Cov models to initialize \n    AddBins (ReadDataDelayCov.BurstLengthCov,  GenBin(2,10,1)) ;\n    AddBins (ReadDataDelayCov.BurstDelayCov,   GenBin(2,5,1)) ;\n    AddBins (ReadDataDelayCov.BeatDelayCov,    GenBin(0)) ;\n\n    ReadDataLoop : loop\n      if empty(ReadDataFifo) then\n        WaitForToggle(ReadDataRequestCount) ;\n      end if ;\n      (Local.Data, Local.Last, Local.Resp, Local.ID, Local.User) := pop(ReadDataFifo) ;\n\n--?6 Add delay that is a function of the access: Single Word, First Burst, Burst, Last Burst\n      if UseCoverageDelays then \n        -- BurstCoverage Delays\n        DelayCycles := GetRandDelay(ReadDataDelayCov) ; \n        WaitForClock(Clk, DelayCycles) ;\n      else\n        -- Deprecated delays\n        if NewTransfer then\n          WaitForClock(Clk, integer'(Params.Get(Axi4OptionsType'POS(READ_DATA_VALID_DELAY_CYCLES)))) ; \n    --      elsif Burst then \n        else \n          WaitForClock(Clk, integer'(Params.Get(Axi4OptionsType'POS(READ_DATA_VALID_BURST_DELAY_CYCLES)))) ; \n        end if ; \n      end if ; \n      \n      NewTransfer := Local.Last ; -- Last is '1' for burst end and single word transfers\n\n      -- Transaction Values\n      RD.Data  <= Local.Data  after tpd_Clk_RDATA ;\n      RD.Resp  <= Local.Resp  after tpd_Clk_RResp ;\n      RD.ID    <= Local.ID    after tpd_Clk_RID ;\n      RD.User  <= Local.User  after tpd_Clk_RUser ;\n      RD.Last  <= Local.Last  after tpd_Clk_RLast ;\n\n--!9 Resolve Level\n      Log(ModelID,\n        \"Read Data.\" &\n        \"  RData: \"     & to_hxstring(Local.Data) &\n        \"  RResp: \"     & to_hxstring(Local.Resp) &\n        \"  RID: \"       & to_hxstring(Local.ID) &\n        \"  RUser: \"     & to_hxstring(Local.User) &\n        \"  Operation# \" & to_string(ReadDataDoneCount + 1),\n        DEBUG\n      ) ;\n\n      GetAxi4Parameter(Params, READ_DATA_READY_TIME_OUT, ReadDataReadyTimeOut) ;\n\n      ---------------------\n      DoAxiValidHandshake (\n      ---------------------\n        Clk            =>  Clk,\n        Valid          =>  AxiBus.ReadData.Valid,\n        Ready          =>  AxiBus.ReadData.Ready,\n        tpd_Clk_Valid  =>  tpd_Clk_RValid,\n        AlertLogID     =>  BusFailedID,\n        TimeOutMessage =>  \"Read Data # \" & to_string(ReadDataDoneCount + 1),\n        TimeOutPeriod  =>  ReadDataReadyTimeOut * tperiod_Clk\n      ) ;\n\n      -- State after operation\n      RD.Data  <= not Local.Data  after tpd_Clk_RDATA ;\n      RD.Resp  <= not Local.Resp  after tpd_Clk_RResp ;\n      RD.ID    <= Local.ID    after tpd_Clk_RID ;\n      RD.User  <= Local.User  after tpd_Clk_RUser ;\n      RD.Last  <= not Local.Last  after tpd_Clk_RLast ;\n\n      -- Signal completion\n      Increment(ReadDataDoneCount) ;\n      wait for 0 ns ;\n    end loop ReadDataLoop ;\n  end process ReadDataHandler ;\n\nend architecture MemorySubordinate ;\n","lang":"vhdl"};
processSrcData(g_data);