var g_data = {"name":"C:/SynthWorks/Dev/_osvvm/OsvvmLibraries/Ethernet/src/xMiiTbPkg.vhd","src":"--\n--  File Name:         xMiiTbPkg.vhd\n--  Design Unit Name:  xMiiTbPkg\n--  OSVVM Release:     OSVVM MODELS STANDARD VERSION\n--\n--  Maintainer:        Jim Lewis      email:  jim@synthworks.com\n--  Contributor(s):\n--     Jim Lewis      jim@synthworks.com\n--\n--\n--  Description:\n--      Defines types, constants, and subprograms used by\n--      OSVVM Axi4 Transaction Based Models (aka: TBM, TLM, VVC)\n--\n--\n--  Developed by:\n--        SynthWorks Design Inc.\n--        VHDL Training Classes\n--        http://www.SynthWorks.com\n--\n--  Revision History:\n--    Date      Version    Description\n--    10/2022   2022.10    Initial Release\n--\n--\n--  This file is part of OSVVM.\n--  \n--  Copyright (c) 2022 by SynthWorks Design Inc.  \n--  \n--  Licensed under the Apache License, Version 2.0 (the \"License\");\n--  you may not use this file except in compliance with the License.\n--  You may obtain a copy of the License at\n--  \n--      https://www.apache.org/licenses/LICENSE-2.0\n--  \n--  Unless required by applicable law or agreed to in writing, software\n--  distributed under the License is distributed on an \"AS IS\" BASIS,\n--  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n--  See the License for the specific language governing permissions and\n--  limitations under the License.\n-- \n\nlibrary ieee ;\n  use ieee.std_logic_1164.all ;\n  use ieee.numeric_std.all ;\n  use ieee.numeric_std_unsigned.all ;\n  use ieee.math_real.all ;\n\n  use std.textio.all ;\n\nlibrary OSVVM ; \n  context OSVVM.OsvvmContext ;  \n\nlibrary osvvm_common ;\n  context osvvm_common.OsvvmCommonContext ;\n  \npackage xMiiTbPkg is \n\n  subtype EthernetRecType is StreamRecType(\n      DataToModel   (7 downto 0),\n      DataFromModel (7 downto 0),\n      ParamToModel  (0 downto 1),\n      ParamFromModel(0 downto 1)\n    ) ;  \n\n  type xMiiPhyOrMacType is (PHY, MAC) ; \n  type xMiiInterfaceType is (MII, RMII, GMII, RGMII) ; \n  type xMiiBpsType is (BPS_10M, BPS_100M, BPS_1G) ; \n\n  constant CLK_1G_PERIOD        : time := 1 Sec / 125E6 ;\n  constant CLK_100M_MII_PERIOD  : time := 1 Sec / 25E6 ;\n  constant CLK_100M_RMII_PERIOD : time := 1 Sec / 50E6 ;\n  constant CLK_10M_MII_PERIOD   : time := 1 Sec / 25E5 ;\n  constant CLK_10M_RMII_PERIOD  : time := 1 Sec / 5E6 ;\n  \n  constant MaxPacketLength : integer := 1600 ;\n\n  ------------------------------------------------------------\n  function CalcPeriod (\n    Bps           : xMiiBpsType ;\n    xMiiInterface : xMiiInterfaceType\n  ) return time ; \n\n  ------------------------------------------------------------\n  procedure SendByte (\n  ------------------------------------------------------------\n    signal   Clk           : in  std_logic ; \n    constant iData         : in  std_logic_vector(0 to 7);  \n    constant iEnDv         : in  std_logic ; \n    constant iEr           : in  std_logic ;\n    constant Tpd           : in  time ; \n    constant xMiiInterface : in  xMiiInterfaceType ;\n    signal   oData         : out std_logic_vector(0 to 7);  \n    signal   oEnDv         : out std_logic ; \n    signal   oEr           : out std_logic ;\n    signal   oCtl          : out std_logic  \n  ) ; \n\n  ------------------------------------------------------------\n  function xMiiEnable (\n  ------------------------------------------------------------\n    constant xMiiInterface : in  xMiiInterfaceType ;\n    constant iEnDv         : in  std_logic ; \n    constant iCtl          : in  std_logic  \n  ) return std_logic ;\n\n  ------------------------------------------------------------\n  procedure GetByte (\n  ------------------------------------------------------------\n    signal   Clk           : in  std_logic ; \n    variable oData         : out std_logic_vector(0 to 7);  \n    variable oEnDv         : out std_logic ; \n    variable oEr           : out std_logic ;\n    constant Tpd           : in  time ; \n    constant xMiiInterface : in  xMiiInterfaceType ;\n    signal   iData         : in  std_logic_vector(0 to 7);  \n    signal   iEnDv         : in  std_logic ; \n    signal   iEr           : in  std_logic ;\n    signal   iCtl          : in  std_logic  \n  ) ;\nend package xMiiTbPkg ;\n\npackage body xMiiTbPkg is \n\n  ------------------------------------------------------------\n  function CalcPeriod (\n  ------------------------------------------------------------\n    Bps           : xMiiBpsType ;\n    xMiiInterface : xMiiInterfaceType\n  ) return time is \n  begin\n    if Bps = BPS_1G then             -- 1 Gb/s\n      return CLK_1G_PERIOD ; \n    elsif Bps = BPS_100M then        -- 100 Mb/s\n      if xMiiInterface /= RMII then\n        return CLK_100M_MII_PERIOD ;\n      else\n        return CLK_100M_RMII_PERIOD ;\n      end if ; \n    else                             -- 10 Mb/s\n      if xMiiInterface /= RMII then  \n        return CLK_10M_MII_PERIOD ;\n      else\n        return CLK_10M_RMII_PERIOD ;\n      end if ; \n    end if ;  \n  end function CalcPeriod ; \n\n\n  ------------------------------------------------------------\n  procedure SendByte (\n  ------------------------------------------------------------\n    signal   Clk           : in  std_logic ; \n    constant iData         : in  std_logic_vector(0 to 7);  \n    constant iEnDv         : in  std_logic ; \n    constant iEr           : in  std_logic ;\n    constant Tpd           : in  time ; \n    constant xMiiInterface : in  xMiiInterfaceType ;\n    signal   oData         : out std_logic_vector(0 to 7);  \n    signal   oEnDv         : out std_logic ; \n    signal   oEr           : out std_logic ;\n    signal   oCtl          : out std_logic  \n  ) is\n    variable Error : std_logic ; \n  begin\n    Error := '1' when is_x(iData) else iEr ; \n    \n    case xMiiInterface is\n      when GMII =>\n        -- Data is Source Synchronous - no delays on data\n        oData   <= iData ;\n        oEnDv   <= iEnDv ; \n        oEr     <= Error ; \n        oCtl    <= iEnDv ; -- 'X' ; \n        wait until Rising_Edge(Clk) ; \n      \n      when RGMII =>\n        -- Data is Source Synchronous - no delays on data\n        oData   <= iData(0 to 3) & \"XXXX\" ; \n        oEnDv   <= iEnDv ; -- 'X' ; \n        oEr     <= Error ; -- 'X' ; \n        oCtl    <= iEnDv ; \n        wait until Falling_Edge(Clk) ;\n        \n        oData   <= iData(4 to 7) & \"XXXX\" ; \n        oCtl    <= Error ; \n        wait until Rising_Edge(Clk) ;\n        \n      when MII =>\n        -- Common Clock, data has a propagation delay\n        oData   <= iData(0 to 3) & \"XXXX\" after Tpd ; \n        oEnDv   <= iEnDv   after Tpd ; \n        oEr     <= Error   after Tpd ; \n        oCtl    <= iEnDv   after Tpd ;  -- 'X'     after Tpd ; \n        wait until Rising_Edge(Clk) ; \n        \n        oData   <= iData(4 to 7) & \"XXXX\" after Tpd ; \n        wait until Rising_Edge(Clk) ; \n      \n      when RMII =>\n        oData   <= iData(0 to 1) & \"XXXXXX\" after Tpd ; \n        oEnDv   <= iEnDv after Tpd ; \n        oEr     <= Error after Tpd ; \n        oCtl    <= iEnDv after Tpd ; -- 'X' ; \n        wait until Rising_Edge(Clk) ; \n        oData   <= iData(2 to 3) & \"XXXXXX\" after Tpd ; \n        wait until Rising_Edge(Clk) ; \n        oData   <= iData(4 to 5) & \"XXXXXX\" after Tpd ; \n        wait until Rising_Edge(Clk) ; \n        oData   <= iData(6 to 7) & \"XXXXXX\" after Tpd ; \n        wait until Rising_Edge(Clk) ; \n    end case ; \n  end procedure SendByte ; \n\n  ------------------------------------------------------------\n  function xMiiEnable (\n  ------------------------------------------------------------\n    constant xMiiInterface : in  xMiiInterfaceType ;\n    constant iEnDv         : in  std_logic ; \n    constant iCtl          : in  std_logic  \n  ) return std_logic is\n  begin\n    case xMiiInterface is\n      when RGMII =>\n        return iCtl ; \n      when others =>\n        return iEnDv ; \n    end case ; \n  end function xMiiEnable ; \n\n  ------------------------------------------------------------\n  procedure GetByte (\n  ------------------------------------------------------------\n    signal   Clk           : in  std_logic ; \n    variable oData         : out std_logic_vector(0 to 7);  \n    variable oEnDv         : out std_logic ; \n    variable oEr           : out std_logic ;\n    constant Tpd           : in  time ; \n    constant xMiiInterface : in  xMiiInterfaceType ;\n    signal   iData         : in  std_logic_vector(0 to 7);  \n    signal   iEnDv         : in  std_logic ; \n    signal   iEr           : in  std_logic ;\n    signal   iCtl          : in  std_logic  \n  ) is\n  begin\n    case xMiiInterface is\n      when GMII =>\n        -- Data is Source Synchronous - no delays on data\n        oData := iData  ;           \n        oEnDv := iEnDv ; \n        oEr   := iEr ; \n        wait until Rising_Edge(Clk) ; \n      \n      when RGMII =>\n        oData(0 to 3) := iData(0 to 3) ; \n        oEnDv := iCtl ; \n        wait until Falling_Edge(Clk) ;\n        \n        oData(4 to 7) := iData(0 to 3) ; \n        oEr   := iCtl ; \n        wait until Rising_Edge(Clk) ;\n        \n      when MII =>\n        oData(0 to 3) := iData(0 to 3) ; \n        oEnDv := iEnDv ; \n        oEr   := iEr ; \n        wait until Rising_Edge(Clk) ; \n        \n        oData(4 to 7) := iData(0 to 3) ; \n        wait until Rising_Edge(Clk) ; \n      \n      when RMII =>\n        oData(0 to 1)  := iData(0 to 1) ; \n        oEnDv          := iEnDv ; \n        oEr            := iEr ; \n        wait until Rising_Edge(Clk) ; \n        oData(2 to 3)  := iData(0 to 1) ; \n        wait until Rising_Edge(Clk) ; \n        oData(4 to 5)  := iData(0 to 1) ; \n        wait until Rising_Edge(Clk) ; \n        oData(6 to 7)  := iData(0 to 1) ; \n        wait until Rising_Edge(Clk) ; \n    end case ; \n  end procedure GetByte ; \n\nend package body xMiiTbPkg ;\n","lang":"vhdl"};
processSrcData(g_data);