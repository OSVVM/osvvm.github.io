var g_data = {"name":"C:/SynthWorks/Dev/_osvvm/OsvvmLibraries/AXI4/AxiStream/src/AxiStreamTransmitter.vhd","src":"--\n--  File Name:         AxiStreamTransmitter.vhd\n--  Design Unit Name:  AxiStreamTransmitter\n--  Revision:          OSVVM MODELS STANDARD VERSION\n--\n--  Maintainer:        Jim Lewis      email:  jim@synthworks.com\n--  Contributor(s):\n--     Jim Lewis      jim@synthworks.com\n--\n--\n--  Description:\n--      AXI Stream Transmitter Model\n--\n--\n--  Developed by:\n--        SynthWorks Design Inc.\n--        VHDL Training Classes\n--        http://www.SynthWorks.com\n--\n--  Revision History:\n--    Date      Version    Description\n--    05/2023   2023.05    Updated methods for Randomized delays \n--    04/2023   2023.04    Update delays on TValid to be randomized\n--    10/2022   2022.10    Changed enum value PRIVATE to PRIVATE_NAME due to VHDL-2019 keyword conflict.   \n--    05/2022   2022.05    Updated FIFOs so they are Search => PRIVATE\n--    03/2022   2022.03    Updated calls to NewID for AlertLogID and FIFOs\n--                         Updated TKeep and TStrb generation\n--    02/2022   2022.02    Replaced to_hstring to to_hxstring\n--    01/2022   2022.01    Moved MODEL_INSTANCE_NAME and MODEL_NAME to entity declarative region\n--    07/2021   2021.07    All FIFOs and Scoreboards now use the New Scoreboard/FIFO capability \n--    06/2021   2021.06    Updated Burst FIFOs.\n--    02/2021   2021.02    Added Valid Delays.  Added MultiDriver Detect.  Updated Generics.\n--    10/2020   2020.10    Added Bursting per updates to Model Independent Transactions\n--    07/2020   2020.07    Updated for Streaming Model Independent Transactions\n--    01/2020   2020.01    Updated license notice\n--    05/2018   2018.05    First Release\n--\n--\n--  This file is part of OSVVM.\n--\n--  Copyright (c) 2018 - 2023 by SynthWorks Design Inc.\n--\n--  Licensed under the Apache License, Version 2.0 (the \"License\");\n--  you may not use this file except in compliance with the License.\n--  You may obtain a copy of the License at\n--\n--      https://www.apache.org/licenses/LICENSE-2.0\n--\n--  Unless required by applicable law or agreed to in writing, software\n--  distributed under the License is distributed on an \"AS IS\" BASIS,\n--  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n--  See the License for the specific language governing permissions and\n--  limitations under the License.\n--\n\nlibrary ieee ;\n  use ieee.std_logic_1164.all ;\n  use ieee.numeric_std.all ;\n  use ieee.numeric_std_unsigned.all ;\n  use ieee.math_real.all ;\n\nlibrary osvvm ;\n  context osvvm.OsvvmContext ;\n  use osvvm.ScoreboardPkg_slv.all ;\n\nlibrary osvvm_common ;\n  context osvvm_common.OsvvmCommonContext ;\n\n  use work.AxiStreamOptionsPkg.all ;\n  use work.Axi4CommonPkg.all ;\n  use work.AxiStreamTbPkg.all ;\n\nentity AxiStreamTransmitter is\n  generic (\n    MODEL_ID_NAME  : string := \"\" ;\n    INIT_ID        : std_logic_vector := \"\" ;\n    INIT_DEST      : std_logic_vector := \"\" ;\n    INIT_USER      : std_logic_vector := \"\" ;\n    INIT_LAST      : natural := 0 ;\n\n    tperiod_Clk    : time := 10 ns ;\n\n    DEFAULT_DELAY  : time := 1 ns ;\n\n    tpd_Clk_TValid : time := DEFAULT_DELAY ;\n    tpd_Clk_TID    : time := DEFAULT_DELAY ;\n    tpd_Clk_TDest  : time := DEFAULT_DELAY ;\n    tpd_Clk_TUser  : time := DEFAULT_DELAY ;\n    tpd_Clk_TData  : time := DEFAULT_DELAY ;\n    tpd_Clk_TStrb  : time := DEFAULT_DELAY ;\n    tpd_Clk_TKeep  : time := DEFAULT_DELAY ;\n    tpd_Clk_TLast  : time := DEFAULT_DELAY\n  ) ;\n  port (\n    -- Globals\n    Clk       : in  std_logic ;\n    nReset    : in  std_logic ;\n\n    -- AXI Transmitter Functional Interface\n    TValid    : out std_logic ;\n    TReady    : in  std_logic ;\n    TID       : out std_logic_vector ;\n    TDest     : out std_logic_vector ;\n    TUser     : out std_logic_vector ;\n    TData     : out std_logic_vector ;\n    TStrb     : out std_logic_vector ;\n    TKeep     : out std_logic_vector ;\n    TLast     : out std_logic ;\n\n    -- Testbench Transaction Interface\n    TransRec  : inout StreamRecType\n  ) ;\n\n  -- Derive AXI interface properties from interface signals\n  constant AXI_STREAM_DATA_WIDTH   : integer := TData'length ;\n\n  -- Use MODEL_ID_NAME Generic if set, otherwise,\n  -- use model instance label (preferred if set as entityname_1)\n  constant MODEL_INSTANCE_NAME : string :=\n    ifelse(MODEL_ID_NAME'length > 0, MODEL_ID_NAME, \n      to_lower(PathTail(AxiStreamTransmitter'PATH_NAME))) ;\n\nend entity AxiStreamTransmitter ;\narchitecture SimpleTransmitter of AxiStreamTransmitter is\n  signal ModelID, BusFailedID : AlertLogIDType ;\n--  signal ProtocolID, DataCheckID : AlertLogIDType ;\n  signal BurstCov : DelayCoverageIDType ;\n  \n  signal UseCoverageDelays : Boolean := FALSE ;\n\n  constant AXI_STREAM_DATA_BYTE_WIDTH  : integer := integer(ceil(real(AXI_STREAM_DATA_WIDTH) / 8.0)) ;\n  constant AXI_ID_WIDTH   : integer    := TID'length ;\n  constant AXI_DEST_WIDTH : integer    := TDest'length ;\n\n  signal TransmitFifo : osvvm.ScoreboardPkg_slv.ScoreboardIDType ;\n\n  signal TransmitRequestCount, TransmitDoneCount      : integer := 0 ;\n\n  -- Verification Component Configuration\n  signal TransmitReadyTimeOut : integer := 0 ;  -- No timeout\n\n  signal ParamID               : std_logic_vector(TID'range)   := ifelse(INIT_ID'length > 0,   INIT_ID,   (TID'range => '0')) ;\n  signal ParamDest             : std_logic_vector(TDest'range) := ifelse(INIT_DEST'length > 0, INIT_DEST, (TDest'range => '0')) ;\n  signal ParamUser             : std_logic_vector(TUser'range) := ifelse(INIT_USER'length > 0, INIT_USER, (TUser'range => '0')) ;\n  signal ParamLast             : natural := INIT_LAST ;\n  signal LastOffsetCount       : integer := 0 ;\n  signal ValidDelayCycles      : integer := 0 ;\n  signal ValidBurstDelayCycles : integer := 0 ;\n\n  constant DEFAULT_BURST_MODE : StreamFifoBurstModeType := STREAM_BURST_WORD_MODE ;\n  signal   BurstFifoMode      : StreamFifoBurstModeType := DEFAULT_BURST_MODE ;\n  signal   BurstFifoByteMode  : boolean := (DEFAULT_BURST_MODE = STREAM_BURST_BYTE_MODE) ;\n\nbegin\n\n  ------------------------------------------------------------\n  --  Initialize alerts\n  ------------------------------------------------------------\n  Initialize : process\n    variable ID : AlertLogIDType ;\n  begin\n    -- Alerts\n    ID               := NewID(MODEL_INSTANCE_NAME) ;\n    ModelID          <= ID ;\n--    ProtocolID       <= NewID(\"Protocol Error\", ID ) ;\n--    DataCheckID      <= NewID(\"Data Check\", ID ) ;\n    BusFailedID      <= NewID(\"No response\",  ID) ;\n    TransmitFifo     <= NewID(\"TransmitFifo\", ID, ReportMode => DISABLED, Search => PRIVATE_NAME) ; \n    wait ;\n  end process Initialize ;\n\n\n  ------------------------------------------------------------\n  --  Transaction Dispatcher\n  --    Dispatches transactions to\n  ------------------------------------------------------------\n  TransactionDispatcher : process\n    variable Data : std_logic_vector(TData'range) ;\n    variable Param : std_logic_vector(TransRec.ParamToModel'length-1 downto 0) ;\n    variable BytesToSend, NumberTransfers : integer ;\n    variable PopValid : boolean ;\n    variable Last : std_logic ;\n    variable User : std_logic_vector(TUser'range) ;\n  begin\n    wait for 0 ns ; \n    TransRec.BurstFifo <= NewID(\"TxBurstFifo\", ModelID, Search => PRIVATE_NAME) ;\n    BurstCov           <= NewID(\"DelayCov\", ModelID, ReportMode => DISABLED, Search => NAME_AND_PARENT) ;\n    \n    DispatchLoop : loop \n      WaitForTransaction(\n         Clk      => Clk,\n         Rdy      => TransRec.Rdy,\n         Ack      => TransRec.Ack\n      ) ;\n\n      case TransRec.Operation is\n        when WAIT_FOR_CLOCK =>\n          WaitForClock(Clk, TransRec.IntToModel) ;\n\n        when WAIT_FOR_TRANSACTION =>\n          if TransmitRequestCount /= TransmitDoneCount then\n            wait until TransmitRequestCount = TransmitDoneCount ;\n          end if ;\n\n        when GET_TRANSACTION_COUNT =>\n          TransRec.IntFromModel <= TransmitDoneCount ;\n          wait for 0 ns ;\n\n        when GET_ALERTLOG_ID =>\n          TransRec.IntFromModel <= integer(ModelID) ;\n          wait for 0 ns ;\n\n        when SET_USE_RANDOM_DELAYS =>        \n          UseCoverageDelays      <= TransRec.BoolToModel ; \n\n        when GET_USE_RANDOM_DELAYS =>\n          TransRec.BoolFromModel <= UseCoverageDelays ;\n\n        when SET_DELAYCOV_ID =>\n          BurstCov          <= GetDelayCoverage(TransRec.IntToModel) ;\n          UseCoverageDelays <= TRUE ; \n\n        when GET_DELAYCOV_ID =>\n          TransRec.IntFromModel <= BurstCov.ID ;\n          UseCoverageDelays <= TRUE ; \n\n        when SET_BURST_MODE =>\n          BurstFifoMode       <= TransRec.IntToModel ;\n          BurstFifoByteMode   <= (TransRec.IntToModel = STREAM_BURST_BYTE_MODE) ;\n\n        when GET_BURST_MODE =>\n          TransRec.IntFromModel <= BurstFifoMode ;\n\n        when SEND | SEND_ASYNC =>\n          Data   := SafeResize(TransRec.DataToModel, Data'length) ;\n          Param  := UpdateOptions(\n                      Param      => SafeResize(TransRec.ParamToModel, TransRec.ParamToModel'length),\n                      ParamID    => ParamID,\n                      ParamDest  => ParamDest,\n                      ParamUser  => ParamUser,\n                      ParamLast  => ParamLast,\n                      Count      => ((TransmitRequestCount+1) - LastOffsetCount)\n                    ) ;\n          Push(TransmitFifo, '0' & Data & Param) ;\n          Increment(TransmitRequestCount) ;\n          wait for 0 ns ;\n          if IsBlocking(TransRec.Operation) then\n            wait until TransmitRequestCount = TransmitDoneCount ;\n          end if ;\n\n        when SEND_BURST | SEND_BURST_ASYNC =>\n          Param  := UpdateOptions(\n                      Param      => SafeResize(TransRec.ParamToModel, TransRec.ParamToModel'length),\n                      ParamID    => ParamID,\n                      ParamDest  => ParamDest,\n                      ParamUser  => ParamUser,\n--Last                      ParamLast  => ParamLast,\n                      ParamLast  => 1,\n                      Count      => ((TransmitRequestCount+1) - LastOffsetCount)\n                    ) ;\n          if BurstFifoByteMode then\n            BytesToSend := TransRec.IntToModel ;\n            NumberTransfers := integer(ceil(real(BytesToSend) / real(AXI_STREAM_DATA_BYTE_WIDTH))) ;\n          else\n            NumberTransfers := TransRec.IntToModel ;\n          end if ;\n          TransmitRequestCount <= TransmitRequestCount + NumberTransfers ;\n          Last := Param(0) ;\n          for i in NumberTransfers-1 downto 0 loop\n            case BurstFifoMode is\n              when STREAM_BURST_BYTE_MODE =>\n                PopWord(TransRec.BurstFifo, PopValid, Data, BytesToSend) ;\n                AlertIfNot(ModelID, PopValid, \"BurstFifo Empty during burst transfer\", FAILURE) ;\n\n              when STREAM_BURST_WORD_MODE =>\n                Data := Pop(TransRec.BurstFifo) ;\n\n              when STREAM_BURST_WORD_PARAM_MODE =>\n                (Data, User) := Pop(TransRec.BurstFifo) ;\n                Param(User'length downto 1) := User ;\n\n  --            when WORD_USER_LAST_MODE =>\n  --              (Data, User, Last) := BurstFifo.Pop ;\n  --              Param(User'length downto 1) := User ;\n\n              when others =>\n                Alert(ModelID, \"BurstFifoMode: Invalid Mode: \" & to_string(BurstFifoMode)) ;\n            end case ;\n--Last            Param(0) := '1' when i = 0 else '0' ;  -- TLast\n            Param(0) := Last when i = 0 else '0' ;  -- TLast\n            Push(TransmitFifo, '1' & Data & Param) ;\n          end loop ;\n\n          wait for 0 ns ;\n          if IsBlocking(TransRec.Operation) then\n            wait until TransmitRequestCount = TransmitDoneCount ;\n          end if ;\n\n        when SET_MODEL_OPTIONS =>\n          case AxiStreamOptionsType'val(TransRec.Options) is\n            when TRANSMIT_VALID_DELAY_CYCLES =>\n              ValidDelayCycles <= TransRec.IntToModel ;\n              UseCoverageDelays <= FALSE ; \n\n            when TRANSMIT_VALID_BURST_DELAY_CYCLES =>\n              ValidBurstDelayCycles <= TransRec.IntToModel ;\n              UseCoverageDelays <= FALSE ; \n\n            when TRANSMIT_READY_TIME_OUT =>\n              TransmitReadyTimeOut      <= TransRec.IntToModel ;\n\n            when DEFAULT_ID =>\n              ParamID         <= SafeResize(TransRec.ParamToModel, ParamID'length) ;\n\n            when DEFAULT_DEST =>\n              ParamDest       <= SafeResize(TransRec.ParamToModel, ParamDest'length) ;\n\n            when DEFAULT_USER =>\n              ParamUser       <= SafeResize(TransRec.ParamToModel, ParamUser'length) ;\n\n            when DEFAULT_LAST =>\n              ParamLast       <= TransRec.IntToModel ;\n              LastOffsetCount <= TransmitRequestCount ;\n\n            when others =>\n              Alert(ModelID, \"SetOptions, Unimplemented Option: \" & to_string(AxiStreamOptionsType'val(TransRec.Options)), FAILURE) ;\n              wait for 0 ns ;\n          end case ;\n\n        when GET_MODEL_OPTIONS =>\n          case AxiStreamOptionsType'val(TransRec.Options) is\n            when TRANSMIT_VALID_DELAY_CYCLES =>\n              TransRec.IntFromModel   <= ValidDelayCycles ;\n\n            when TRANSMIT_VALID_BURST_DELAY_CYCLES =>\n              TransRec.IntFromModel   <= ValidBurstDelayCycles ;\n              \n            when TRANSMIT_READY_TIME_OUT =>\n              TransRec.IntFromModel   <=  TransmitReadyTimeOut ;\n\n            when DEFAULT_ID =>\n              TransRec.ParamFromModel <= SafeResize(ParamID, TransRec.ParamFromModel'length) ;\n\n            when DEFAULT_DEST =>\n              TransRec.ParamFromModel <= SafeResize(ParamDest, TransRec.ParamFromModel'length) ;\n\n            when DEFAULT_USER =>\n              TransRec.ParamFromModel <= SafeResize(ParamUser, TransRec.ParamFromModel'length) ;\n\n            when DEFAULT_LAST =>\n              TransRec.IntFromModel   <= ParamLast ;\n\n            when others =>\n              Alert(ModelID, \"GetOptions, Unimplemented Option: \" & to_string(AxiStreamOptionsType'val(TransRec.Options)), FAILURE) ;\n          end case ;\n\n        when MULTIPLE_DRIVER_DETECT =>\n          Alert(ModelID, \"Multiple Drivers on Transaction Record.\" & \n                         \"  Transaction # \" & to_string(TransRec.Rdy), FAILURE) ;\n\n        -- The End -- Done\n        when others =>\n          Alert(ModelID, \"Unimplemented Transaction: \" & to_string(TransRec.Operation), FAILURE) ;\n      end case ;\n\n      -- Wait for 1 delta cycle, required if a wait is not in all case branches above\n      wait for 0 ns ;\n    end loop DispatchLoop ;\n  end process TransactionDispatcher ;\n\n\n  ------------------------------------------------------------\n  --  TransmitHandler\n  --    Execute Write Address Transactions\n  ------------------------------------------------------------\n  TransmitHandler : process\n    variable ID    : std_logic_vector(TID'range)   ;\n    variable Dest  : std_logic_vector(TDest'range) ;\n    variable User  : std_logic_vector(TUser'range) ;\n    variable Data  : std_logic_vector(TData'length-1 downto 0) ;\n    variable Strb  : std_logic_vector(TStrb'length-1 downto 0) ;\n    variable Keep  : std_logic_vector(TKeep'length-1 downto 0) ;\n    variable Last  : std_logic ;\n    variable NewTransfer : std_logic := '1' ;\n    variable Burst : std_logic ;\n    variable DelayCycles : integer ; \n    variable BurstLength : integer := 0 ; \n  begin\n    -- Initialize\n    TValid  <= '0' ;\n    TID     <= (TID'range => 'X') ;\n    TDest   <= (TDest'range => 'X') ;\n    TUser   <= (TUser'range => 'X') ;\n    TData   <= (TData'range => 'X') ;\n    TStrb   <= (TStrb'range => 'X') ;\n    TKeep   <= (TKeep'range => 'X') ;\n    TLast   <= 'X' ;\n    wait for 0 ns ; -- Allow Cov models to initialize \n    wait for 0 ns ; -- Allow Cov models to initialize \n    -- BurstLength - once per BurstLength, use BurstDelay, otherwise use BeatDelay\n    AddBins (BurstCov.BurstLengthCov,  80, GenBin(3,11,1)) ;     -- 80% Small Burst Length\n    AddBins (BurstCov.BurstLengthCov,  20, GenBin(109,131,1)) ;  -- 20% Large Burst Length\n    -- BurstDelay - happens at BurstLength boundaries\n    AddBins (BurstCov.BurstDelayCov,   80, GenBin(2,8,1)) ;   -- 80% Small delay\n    AddBins (BurstCov.BurstDelayCov,   20, GenBin(108,156,1)) ; -- 20% Large delay\n    -- BeatDelay - happens between each transfer it not at a BurstLength boundary\n    -- These are all small\n    AddBins (BurstCov.BeatDelayCov,    85, GenBin(0)) ;       -- 85%  0 Delay\n    AddBins (BurstCov.BeatDelayCov,    10, GenBin(1)) ;       -- 10%  1 Delay\n    AddBins (BurstCov.BeatDelayCov,     5, GenBin(2)) ;       --  5%  2 Delay\n\n    TransmitLoop : loop\n      -- Find Transaction\n      if Empty(TransmitFifo) then\n         WaitForToggle(TransmitRequestCount) ;\n      end if ;\n\n      -- Get Transaction\n      (Burst, Data, ID, Dest, User, Last) := Pop(TransmitFifo) ;\n\n      -- Delay between consecutive signaling of Valid\n      if UseCoverageDelays then \n        -- BurstCoverage Delays\n        DelayCycles := GetRandDelay(BurstCov) ; \n        WaitForClock(Clk, DelayCycles) ;\n      else\n        -- Deprecated static settings\n        if NewTransfer or not Burst then\n          WaitForClock(Clk, ValidDelayCycles) ; -- delay cycles\n        else\n          WaitForClock(Clk, ValidBurstDelayCycles) ;  -- beat delays\n        end if ;\n        NewTransfer := Last or not Burst ;\n      end if ; \n\n      -- Calculate Strb. 1 when data else 0\n      -- If Strb is unused it may be null range\n      for i in Strb'range loop\n        if Data(i*8) = 'W' or Data(i*8) = 'U' then\n          Strb(i) := '0' ;\n        else\n          Strb(i) := '1' ;\n        end if ;\n      end loop ;\n\n      -- Calculate Keep.  1 when data /= 'U' else 0\n      -- If Keep is unused it may be null range\n      for i in Keep'range loop\n        if Data(i*8) = 'U' then\n          Keep(i) := '0' ;\n        else\n          Keep(i) := '1' ;\n        end if ;\n      end loop ;\n\n      -- Do Transaction\n      TID     <= ID   after tpd_Clk_tid ;\n      TDest   <= Dest after tpd_Clk_TDest ;\n      TUser   <= User after tpd_Clk_TUser ;\n      TData   <= to_x01(Data) after tpd_Clk_TData ;\n      TStrb   <= Strb after tpd_Clk_TStrb ;\n      TKeep   <= Keep after tpd_Clk_TKeep ;\n      TLast   <= Last after tpd_Clk_TLast ;\n\n      Log(ModelID,\n        \"Axi Stream Send.\" &\n        \"  TData: \"     & to_hxstring(to_x01(Data)) &\n        ifelse(TStrb'length > 0, \"  TStrb: \"     & to_string( Strb), \"\") &\n        ifelse(TKeep'length > 0, \"  TKeep: \"     & to_string( Keep), \"\") &\n        ifelse(TID'length   > 0, \"  TID: \"       & to_hxstring(ID),   \"\") &\n        ifelse(TDest'length > 0, \"  TDest: \"     & to_hxstring(Dest), \"\") &\n        ifelse(TUser'length > 0, \"  TUser: \"     & to_hxstring(User), \"\") &\n        \"  TLast: \"     & to_string( Last) &\n        -- Must be DoneCount and not RequestCount due to queuing/Async and burst operations\n        \"  Operation# \" & to_string( TransmitDoneCount + 1),\n        INFO\n      ) ;\n\n      ---------------------\n      DoAxiValidHandshake (\n      ---------------------\n        Clk            =>  Clk,\n        Valid          =>  TValid,\n        Ready          =>  TReady,\n        tpd_Clk_Valid  =>  tpd_Clk_TValid,\n        AlertLogID     =>  BusFailedID,\n        TimeOutMessage =>  \"AXI Stream Send Operation # \" & to_string(TransmitDoneCount + 1),\n        TimeOutPeriod  =>  TransmitReadyTimeOut * tperiod_Clk\n      ) ;\n\n      -- State after transaction\n      TID     <= ID + 1    after tpd_Clk_tid ;\n      TDest   <= Dest + 1  after tpd_Clk_TDest ;\n      TUser   <= not User  after tpd_Clk_TUser ;\n      TData   <= not Data  after tpd_Clk_TData ;\n      TStrb   <= (TStrb'range => '1') after tpd_Clk_TStrb ;\n      TKeep   <= (TKeep'range => '1') after tpd_Clk_TKeep ;\n\n      -- Signal completion\n      Increment(TransmitDoneCount) ;\n      wait for 0 ns ;\n    end loop TransmitLoop ;\n  end process TransmitHandler ;\nend architecture SimpleTransmitter ;\n","lang":"vhdl"};
processSrcData(g_data);