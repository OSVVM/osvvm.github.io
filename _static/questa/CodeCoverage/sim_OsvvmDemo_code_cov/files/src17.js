var g_data = {"name":"C:/SynthWorks/Dev/_osvvm/OsvvmLibraries/osvvm/AlertLogPkg.vhd","src":"--\n--  File Name:         AlertLogPkg.vhd\n--  Design Unit Name:  AlertLogPkg\n--  Revision:          STANDARD VERSION\n--\n--  Maintainer:        Jim Lewis      email:  jim@synthworks.com\n--  Contributor(s):\n--     Jim Lewis      jim@synthworks.com\n--     Rob Gaddi      Highland Technology.    Inspired SetAlertLogPrefix / Suffix\n--     Markus Ferringer                       Proposed printing time first with output formatter \n--\n--\n--  Description:\n--        Alert handling and log filtering (verbosity control)\n--        Alert handling provides a method to count failures, errors, and warnings\n--          To accumlate counts, a data structure is created in a shared variable\n--          It is of type AlertLogStructPType which is defined in AlertLogBasePkg\n--        Log filtering provides verbosity control for logs (display or do not display)\n--        AlertLogPkg provides a simplified interface to the shared variable\n--\n--\n--  Developed for:\n--        SynthWorks Design Inc.\n--        VHDL Training Classes\n--        11898 SW 128th Ave.  Tigard, Or  97223\n--        http://www.SynthWorks.com\n--\n--  Revision History:\n--    Date      Version    Description\n--    07/2023   2023.07    Added WriteRequirementsYaml.\n--    04/2023   2023.04    Added GetTranscriptName.\n--    01/2023   2023.01    OSVVM_OUTPUT_DIRECTORY replaced REPORTS_DIRECTORY.\n--    11/2022   2022.11    Added GetTestName\n--    06/2022   2022.06    Added Output Formatting - WriteTimeLast (vs First)\n--                         Minor printing updates to AffirmIfDiff and AlertIfDiff\n--                         Added SetTestName in preference of now deprecated SetAlertLogName\n--    02/2022   2022.02    SetAlertPrintCount and GetAlertPrintCount\n--                         Added NewID with ReportMode, PrintParent\n--                         Updated Alert s.t. on StopCount prints WriteAlertSummaryYaml and WriteAlertYaml\n--    01/2022   2022.01    For AlertIfEqual and AffirmIfEqual, all arrays of std_ulogic use to_hxstring\n--                         Updated return value for PathTail\n--    10/2021   2021.10    Moved EndOfTestSummary to ReportPkg\n--    09/2021   2021.09    Added EndOfTestSummary and CreateYamlReport - Experimental Release\n--    07/2021   2021.07    When printing time value from GetOsvvmDefaultTimeUnits is used.\n--    06/2021   2021.06    FindAlertLogID updated to allow an ID name to match the name set by SetAlertLogName (ALERTLOG_BASE_ID)\n--    12/2020   2020.12    Added MetaMatch to AffirmIfEqual and AffirmIfNotEqual for std_logic family to use MetaMatch\n--                         Added AffirmIfEqual for boolean\n--    10/2020   2020.10    Added MetaMatch.\n--                         Updated AlertIfEqual and AlertIfNotEqual for std_logic family to use MetaMatch\n--    08/2020   2020.08    Alpha Test Release of Specification Tracking - Changes are provisional and subject to change\n--                         Added Passed Goals - reported with ReportAlerts and ReportRequirements.\n--                         Added WriteAlerts - CSV format of the information in ReportAlerts\n--                         Tests fail when requirements are not met and FailOnRequirementErrors is true (default TRUE).\n--                             Set using:  SetAlertLogOptions(FailOnRequirementErrors => TRUE)\n--                         Turn on requirements printing in summary and details with PrintRequirements (default FALSE,\n--                         Turn on requirements printing in summary with PrintIfHaveRequirements (Default TRUE)\n--                         Added Requirements Bin, ReadSpecification, GetReqID, SetPassedGoal\n--                         Added AffirmIf(\"Req ID 1\", ...) -- will work even if ID not set by GetReqID or ReadSpecification\n--                         Added ReportRequirements, WriteRequirements, and ReadRequirements (to merge results of multiple tests)\n--                         Added WriteTestSummary, ReadTestSummaries, ReportTestSummaries, and WriteTestSummaries.\n--    05/2020   2020.05    Added internal variables AlertCount (W, E, F) and ErrorCount (integer)\n--                         that hold the error state.   These can be displayed in wave windows\n--                         in simulation to track number of errors.\n--                         Calls to std.env.stop now return ErrorCount\n--                         Updated calls to check for valid AlertLogIDs\n--                         Added affirmation count for each level.\n--                           Turn off reporting with SetAlertLogOptions (PrintAffirmations => TRUE) ;\n--                         Disabled Alerts now handled in separate bins and reported separately.\n--                         Turn off reporting with SetAlertLogOptions (PrintDisabledAlerts => TRUE) ;\n--    01/2020   2020.01    Updated Licenses to Apache\n--    10/2018   2018.10    Added pragmas to allow alerts, logs, and affirmations in RTL code\n--                         Added local variable to mirror top level ErrorCount and display in simulator\n--                         Added prefix and suffix\n--                         Debug printing with number of errors as prefix\n--    04/2018   2018.04    Fix to PathTail.  Prep to change AlertLogIDType to a type.\n--    05/2017   2017.05    AffirmIfEqual, AffirmIfDiff,\n--                         GetAffirmCount (deprecates GetAffirmCheckCount), IncAffirmCount (deprecates IncAffirmCheckCount),\n--                         IsAlertEnabled (alias), IsLogEnabled (alias)\n--    02/2016   2016.02    Fixed IsLogEnableType (for PASSED), AffirmIf (to pass AlertLevel)\n--                         Created LocalInitialize\n--    07/2015   2016.01    Fixed AlertLogID issue with > 32 IDs\n--    05/2015   2015.06    Added IncAlertCount, AffirmIf\n--    03/2015   2015.03    Added:  AlertIfEqual, AlertIfNotEqual, AlertIfDiff, PathTail,\n--                         ReportNonZeroAlerts, ReadLogEnables\n--    01/2015   2015.01    Initial revision\n--\n--  This file is part of OSVVM.\n--\n--  Copyright (c) 2015 - 2023 by SynthWorks Design Inc.\n--\n--  Licensed under the Apache License, Version 2.0 (the \"License\");\n--  you may not use this file except in compliance with the License.\n--  You may obtain a copy of the License at\n--\n--      https://www.apache.org/licenses/LICENSE-2.0\n--\n--  Unless required by applicable law or agreed to in writing, software\n--  distributed under the License is distributed on an \"AS IS\" BASIS,\n--  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n--  See the License for the specific language governing permissions and\n--  limitations under the License.\n--\n\n\nuse std.textio.all ;\n\nuse work.OsvvmScriptSettingsPkg.all ;\nuse work.OsvvmGlobalPkg.all ;\nuse work.TranscriptPkg.all ;\nuse work.TextUtilPkg.all ;\n\nlibrary IEEE ;\nuse ieee.std_logic_1164.all ;\nuse ieee.numeric_std.all ;\n\npackage AlertLogPkg is\n\n--  type   AlertLogIDType       is range integer'low to integer'high ; -- next revision\n  subtype  AlertLogIDType       is integer ;\n  type     AlertLogIDVectorType is array (integer range <>) of AlertLogIDType ;\n  type     AlertType            is (FAILURE, ERROR, WARNING) ;  -- NEVER\n  subtype  AlertIndexType       is AlertType range FAILURE to WARNING ;\n  type     AlertCountType       is array (AlertIndexType) of integer ;\n  type     AlertEnableType      is array(AlertIndexType) of boolean ;\n  type     LogType              is (ALWAYS, DEBUG, FINAL, INFO, PASSED) ;  -- NEVER  -- See function IsLogEnableType\n  subtype  LogIndexType         is LogType range DEBUG to PASSED ;\n  type     LogEnableType        is array (LogIndexType) of boolean ;\n  type     AlertLogReportModeType  is (DISABLED, ENABLED, NONZERO) ;\n  type     AlertLogPrintParentType is (PRINT_NAME, PRINT_NAME_AND_PARENT) ;\n\n  constant  ALERTLOG_BASE_ID               : AlertLogIDType := 0 ;  -- Careful as some code may assume this is 0.\n  constant  ALERTLOG_DEFAULT_ID            : AlertLogIDType := ALERTLOG_BASE_ID + 1 ;\n  constant  OSVVM_ALERTLOG_ID              : AlertLogIDType := ALERTLOG_BASE_ID + 2 ; -- reporting for packages\n  constant  REQUIREMENT_ALERTLOG_ID        : AlertLogIDType := ALERTLOG_BASE_ID + 3 ;\n  -- May have its own ID or OSVVM_ALERTLOG_ID as default - most scoreboards allocate their own ID\n  constant  OSVVM_SCOREBOARD_ALERTLOG_ID   : AlertLogIDType := OSVVM_ALERTLOG_ID ;\n  constant  OSVVM_COV_ALERTLOG_ID          : AlertLogIDType := OSVVM_ALERTLOG_ID ;\n\n  -- Same as ALERTLOG_DEFAULT_ID\n  constant  ALERT_DEFAULT_ID               : AlertLogIDType := ALERTLOG_DEFAULT_ID ;\n  constant  LOG_DEFAULT_ID                 : AlertLogIDType := ALERTLOG_DEFAULT_ID ;\n\n  constant  ALERTLOG_ID_NOT_FOUND          : AlertLogIDType := -1 ;  -- alternately integer'right\n  constant  ALERTLOG_ID_NOT_ASSIGNED       : AlertLogIDType := -1 ;\n  constant  MIN_NUM_AL_IDS                 : AlertLogIDType := 32 ; -- Number IDs initially allocated\n\n  ------------------------------------------------------------\n  --  Alert always goes to the transcript file\n  procedure Alert(\n    AlertLogID   : AlertLogIDType ;\n    Message      : string ;\n    Level        : AlertType := ERROR\n  ) ;\n  procedure Alert( Message : string ; Level : AlertType := ERROR ) ;\n\n  ------------------------------------------------------------\n  procedure IncAlertCount(   -- A silent form of alert\n    AlertLogID   : AlertLogIDType ;\n    Level        : AlertType := ERROR\n  ) ;\n  procedure IncAlertCount( Level : AlertType := ERROR ) ;\n\n  ------------------------------------------------------------\n  -- Similar to assert, except condition is positive\n  procedure AlertIf( AlertLogID : AlertLogIDType ; condition : boolean ; Message : string ; Level : AlertType := ERROR )  ;\n  procedure AlertIf( condition : boolean ; Message : string ; Level : AlertType := ERROR ) ;\n  impure function  AlertIf( AlertLogID : AlertLogIDType ; condition : boolean ; Message : string ; Level : AlertType := ERROR ) return boolean ;\n  impure function  AlertIf( condition : boolean ; Message : string ; Level : AlertType := ERROR ) return boolean ;\n\n  ------------------------------------------------------------\n  -- Direct replacement for assert\n  procedure AlertIfNot( AlertLogID : AlertLogIDType ; condition : boolean ; Message : string ; Level : AlertType := ERROR )  ;\n  procedure AlertIfNot( condition : boolean ; Message : string ; Level : AlertType := ERROR ) ;\n  impure function  AlertIfNot( AlertLogID : AlertLogIDType ; condition : boolean ; Message : string ; Level : AlertType := ERROR ) return boolean ;\n  impure function  AlertIfNot( condition : boolean ; Message : string ; Level : AlertType := ERROR ) return boolean ;\n\n  ------------------------------------------------------------\n  -- overloading for common functionality\n  procedure AlertIfEqual( AlertLogID : AlertLogIDType ;  L, R : std_logic ;         Message : string ; Level : AlertType := ERROR )  ;\n  procedure AlertIfEqual( AlertLogID : AlertLogIDType ;  L, R : std_logic_vector ;  Message : string ; Level : AlertType := ERROR )  ;\n  procedure AlertIfEqual( AlertLogID : AlertLogIDType ;  L, R : unsigned ;          Message : string ; Level : AlertType := ERROR )  ;\n  procedure AlertIfEqual( AlertLogID : AlertLogIDType ;  L, R : signed ;            Message : string ; Level : AlertType := ERROR )  ;\n  procedure AlertIfEqual( AlertLogID : AlertLogIDType ;  L, R : integer ;           Message : string ; Level : AlertType := ERROR )  ;\n  procedure AlertIfEqual( AlertLogID : AlertLogIDType ;  L, R : real ;              Message : string ; Level : AlertType := ERROR )  ;\n  procedure AlertIfEqual( AlertLogID : AlertLogIDType ;  L, R : character ;         Message : string ; Level : AlertType := ERROR )  ;\n  procedure AlertIfEqual( AlertLogID : AlertLogIDType ;  L, R : string ;            Message : string ; Level : AlertType := ERROR )  ;\n  procedure AlertIfEqual( AlertLogID : AlertLogIDType ;  L, R : time ;              Message : string ; Level : AlertType := ERROR )  ;\n\n  procedure AlertIfEqual( L, R : std_logic ;        Message : string ; Level : AlertType := ERROR )  ;\n  procedure AlertIfEqual( L, R : std_logic_vector ; Message : string ; Level : AlertType := ERROR )  ;\n  procedure AlertIfEqual( L, R : unsigned ;         Message : string ; Level : AlertType := ERROR )  ;\n  procedure AlertIfEqual( L, R : signed ;           Message : string ; Level : AlertType := ERROR )  ;\n  procedure AlertIfEqual( L, R : integer ;          Message : string ; Level : AlertType := ERROR )  ;\n  procedure AlertIfEqual( L, R : real ;             Message : string ; Level : AlertType := ERROR )  ;\n  procedure AlertIfEqual( L, R : character ;        Message : string ; Level : AlertType := ERROR )  ;\n  procedure AlertIfEqual( L, R : string ;           Message : string ; Level : AlertType := ERROR )  ;\n  procedure AlertIfEqual( L, R : time ;             Message : string ; Level : AlertType := ERROR )  ;\n\n  procedure AlertIfNotEqual( AlertLogID : AlertLogIDType ;  L, R : std_logic ;        Message : string ; Level : AlertType := ERROR )  ;\n  procedure AlertIfNotEqual( AlertLogID : AlertLogIDType ;  L, R : std_logic_vector ; Message : string ; Level : AlertType := ERROR )  ;\n  procedure AlertIfNotEqual( AlertLogID : AlertLogIDType ;  L, R : unsigned ;         Message : string ; Level : AlertType := ERROR )  ;\n  procedure AlertIfNotEqual( AlertLogID : AlertLogIDType ;  L, R : signed ;           Message : string ; Level : AlertType := ERROR )  ;\n  procedure AlertIfNotEqual( AlertLogID : AlertLogIDType ;  L, R : integer ;          Message : string ; Level : AlertType := ERROR )  ;\n  procedure AlertIfNotEqual( AlertLogID : AlertLogIDType ;  L, R : real ;             Message : string ; Level : AlertType := ERROR )  ;\n  procedure AlertIfNotEqual( AlertLogID : AlertLogIDType ;  L, R : character ;        Message : string ; Level : AlertType := ERROR )  ;\n  procedure AlertIfNotEqual( AlertLogID : AlertLogIDType ;  L, R : string ;           Message : string ; Level : AlertType := ERROR )  ;\n  procedure AlertIfNotEqual( AlertLogID : AlertLogIDType ;  L, R : time ;             Message : string ; Level : AlertType := ERROR )  ;\n\n  procedure AlertIfNotEqual( L, R : std_logic ;        Message : string ; Level : AlertType := ERROR )  ;\n  procedure AlertIfNotEqual( L, R : std_logic_vector ; Message : string ; Level : AlertType := ERROR )  ;\n  procedure AlertIfNotEqual( L, R : unsigned ;         Message : string ; Level : AlertType := ERROR )  ;\n  procedure AlertIfNotEqual( L, R : signed ;           Message : string ; Level : AlertType := ERROR )  ;\n  procedure AlertIfNotEqual( L, R : integer ;          Message : string ; Level : AlertType := ERROR )  ;\n  procedure AlertIfNotEqual( L, R : real ;             Message : string ; Level : AlertType := ERROR )  ;\n  procedure AlertIfNotEqual( L, R : character ;        Message : string ; Level : AlertType := ERROR )  ;\n  procedure AlertIfNotEqual( L, R : string ;           Message : string ; Level : AlertType := ERROR )  ;\n  procedure AlertIfNotEqual( L, R : time ;             Message : string ; Level : AlertType := ERROR )  ;\n\n  ------------------------------------------------------------\n  -- Simple Diff for file comparisons\n  procedure AlertIfDiff (AlertLogID : AlertLogIDType ; Name1, Name2 : string; Message : string := \"\" ; Level : AlertType := ERROR ) ;\n  procedure AlertIfDiff (Name1, Name2 : string; Message : string := \"\" ; Level : AlertType := ERROR ) ;\n  procedure AlertIfDiff (AlertLogID : AlertLogIDType ; file File1, File2 : text; Message : string := \"\" ; Level : AlertType := ERROR ) ;\n  procedure AlertIfDiff (file File1, File2 : text; Message : string := \"\" ; Level : AlertType := ERROR ) ;\n\n  ------------------------------------------------------------\n  ------------------------------------------------------------\n  ------------------------------------------------------------\n  procedure AffirmIf(\n  ------------------------------------------------------------\n    AlertLogID       : AlertLogIDType ;\n    condition        : boolean ;\n    ReceivedMessage  : string ;\n    ExpectedMessage  : string ;\n    Enable           : boolean  := FALSE   -- override internal enable\n  ) ;\n\n  procedure AffirmIf( condition : boolean ; ReceivedMessage, ExpectedMessage : string ; Enable : boolean := FALSE ) ;\n  impure function AffirmIf( AlertLogID : AlertLogIDType ; condition : boolean ; ReceivedMessage, ExpectedMessage : string ; Enable : boolean := FALSE ) return boolean ;\n  impure function AffirmIf( condition : boolean ; ReceivedMessage, ExpectedMessage : string ; Enable : boolean := FALSE ) return boolean ;\n\n  procedure AffirmIf(\n    AlertLogID   : AlertLogIDType ;\n    condition    : boolean ;\n    Message      : string ;\n    Enable       : boolean := FALSE -- override internal enable\n  ) ;\n\n  procedure AffirmIf(condition : boolean ; Message : string ;  Enable : boolean := FALSE ) ;\n  impure function  AffirmIf( AlertLogID  : AlertLogIDType ; condition : boolean ; Message : string ; Enable : boolean := FALSE ) return boolean ;\n  impure function  AffirmIf( condition : boolean ; Message : string ; Enable : boolean := FALSE ) return boolean ;\n\n  ------------------------------------------------------------\n  procedure AffirmIfNot( AlertLogID : AlertLogIDType ; condition : boolean ; ReceivedMessage, ExpectedMessage : string ; Enable : boolean := FALSE ) ;\n  procedure AffirmIfNot( condition : boolean ; ReceivedMessage, ExpectedMessage : string ; Enable : boolean := FALSE ) ;\n  impure function  AffirmIfNot( AlertLogID  : AlertLogIDType ; condition : boolean ; ReceivedMessage, ExpectedMessage : string ; Enable : boolean := FALSE ) return boolean ;\n  impure function  AffirmIfNot( condition : boolean ; ReceivedMessage, ExpectedMessage : string ; Enable : boolean := FALSE ) return boolean ;\n\n  ------------------------------------------------------------\n  procedure AffirmIfNot( AlertLogID : AlertLogIDType ; condition : boolean ; Message : string ; Enable : boolean := FALSE ) ;\n  procedure AffirmIfNot( condition : boolean ; Message : string ; Enable : boolean := FALSE ) ;\n  impure function  AffirmIfNot( AlertLogID  : AlertLogIDType ; condition : boolean ; Message : string ; Enable : boolean := FALSE ) return boolean ;\n  impure function  AffirmIfNot( condition : boolean ; Message : string ; Enable : boolean := FALSE ) return boolean ;\n\n  ------------------------------------------------------------\n  procedure AffirmPassed( AlertLogID : AlertLogIDType ; Message : string ; Enable : boolean := FALSE ) ;\n  procedure AffirmPassed( Message : string ; Enable : boolean := FALSE ) ;\n  procedure AffirmError( AlertLogID : AlertLogIDType ; Message : string ) ;\n  procedure AffirmError( Message : string ) ;\n\n  ------------------------------------------------------------\n  procedure AffirmIfEqual( AlertLogID : AlertLogIDType ; Received, Expected : boolean ;  Message : string := \"\" ; Enable : boolean := FALSE ) ;\n  procedure AffirmIfEqual( AlertLogID : AlertLogIDType ; Received, Expected : std_logic ;  Message : string := \"\" ; Enable : boolean := FALSE ) ;\n  procedure AffirmIfEqual( AlertLogID : AlertLogIDType ; Received, Expected : std_logic_vector ; Message : string := \"\" ; Enable : boolean := FALSE ) ;\n  procedure AffirmIfEqual( AlertLogID : AlertLogIDType ; Received, Expected : unsigned ; Message : string := \"\" ; Enable : boolean := FALSE ) ;\n  procedure AffirmIfEqual( AlertLogID : AlertLogIDType ; Received, Expected : signed ; Message : string := \"\" ; Enable : boolean := FALSE );\n  procedure AffirmIfEqual( AlertLogID : AlertLogIDType ; Received, Expected : integer ; Message : string := \"\" ; Enable : boolean := FALSE ) ;\n  procedure AffirmIfEqual( AlertLogID : AlertLogIDType ; Received, Expected : real ; Message : string := \"\" ; Enable : boolean := FALSE ) ;\n  procedure AffirmIfEqual( AlertLogID : AlertLogIDType ; Received, Expected : character ; Message : string := \"\" ; Enable : boolean := FALSE ) ;\n  procedure AffirmIfEqual( AlertLogID : AlertLogIDType ; Received, Expected : string ; Message : string := \"\" ; Enable : boolean := FALSE ) ;\n  procedure AffirmIfEqual( AlertLogID : AlertLogIDType ; Received, Expected : time ; Message : string := \"\" ; Enable : boolean := FALSE ) ;\n\n  -- Without AlertLogID\n  ------------------------------------------------------------\n  procedure AffirmIfEqual( Received, Expected : boolean ;  Message : string := \"\" ; Enable : boolean := FALSE ) ;\n  procedure AffirmIfEqual( Received, Expected : std_logic ;  Message : string := \"\" ; Enable : boolean := FALSE ) ;\n  procedure AffirmIfEqual( Received, Expected : std_logic_vector ; Message : string := \"\" ; Enable : boolean := FALSE ) ;\n  procedure AffirmIfEqual( Received, Expected : unsigned ; Message : string := \"\" ; Enable : boolean := FALSE ) ;\n  procedure AffirmIfEqual( Received, Expected : signed ; Message : string := \"\" ; Enable : boolean := FALSE ) ;\n  procedure AffirmIfEqual( Received, Expected : integer ; Message : string := \"\" ; Enable : boolean := FALSE ) ;\n  procedure AffirmIfEqual( Received, Expected : real ; Message : string := \"\" ; Enable : boolean := FALSE ) ;\n  procedure AffirmIfEqual( Received, Expected : character ; Message : string := \"\" ; Enable : boolean := FALSE ) ;\n  procedure AffirmIfEqual( Received, Expected : string ; Message : string := \"\" ; Enable : boolean := FALSE ) ;\n  procedure AffirmIfEqual( Received, Expected : time ; Message : string := \"\" ; Enable : boolean := FALSE ) ;\n\n  ------------------------------------------------------------\n  procedure AffirmIfNotDiff (AlertLogID : AlertLogIDType ; Name1, Name2 : string; Message : string := \"\" ; Enable : boolean := FALSE ) ;\n  procedure AffirmIfNotDiff (Name1, Name2 : string; Message : string := \"\" ; Enable : boolean := FALSE ) ;\n  procedure AffirmIfNotDiff (AlertLogID : AlertLogIDType ; file File1, File2 : text; Message : string := \"\" ; Enable : boolean := FALSE ) ;\n  procedure AffirmIfNotDiff (file File1, File2 : text; Message : string := \"\" ; Enable : boolean := FALSE ) ;\n-- Deprecated as they are misnamed - should be AffirmIfNotDiff\n  procedure AffirmIfDiff (AlertLogID : AlertLogIDType ; Name1, Name2 : string; Message : string := \"\" ; Enable : boolean := FALSE ) ;\n  procedure AffirmIfDiff (Name1, Name2 : string; Message : string := \"\" ; Enable : boolean := FALSE ) ;\n  procedure AffirmIfDiff (AlertLogID : AlertLogIDType ; file File1, File2 : text; Message : string := \"\" ; Enable : boolean := FALSE ) ;\n  procedure AffirmIfDiff (file File1, File2 : text; Message : string := \"\" ; Enable : boolean := FALSE ) ;\n\n  ------------------------------------------------------------\n  -- Support for Specification / Requirements Tracking\n  procedure AffirmIf( RequirementsIDName : string ; condition : boolean ; ReceivedMessage, ExpectedMessage : string ; Enable : boolean := FALSE ) ;\n  procedure AffirmIf( RequirementsIDName : string ; condition : boolean ; Message : string ; Enable : boolean := FALSE ) ;\n\n  ------------------------------------------------------------\n  procedure SetAlertLogJustify (Enable : boolean := TRUE) ;\n  procedure ReportAlerts ( Name : String ; AlertCount : AlertCountType ) ;\n  procedure ReportRequirements ;\n  procedure ReportAlerts (\n    Name           : string          := OSVVM_STRING_INIT_PARM_DETECT ;\n    AlertLogID     : AlertLogIDType  := ALERTLOG_BASE_ID ;\n    ExternalErrors : AlertCountType  := (others => 0) ;\n    ReportAll      : Boolean         := FALSE\n  ) ;\n\n  procedure ReportNonZeroAlerts (\n    Name           : string          := OSVVM_STRING_INIT_PARM_DETECT ;\n    AlertLogID     : AlertLogIDType  := ALERTLOG_BASE_ID ;\n    ExternalErrors : AlertCountType  := (others => 0)\n  ) ;\n\n  procedure WriteAlertYaml (\n    FileName       : string ;\n    ExternalErrors : AlertCountType := (0,0,0) ;\n    Prefix         : string := \"\" ;\n    PrintSettings  : boolean := TRUE ;\n    PrintChildren  : boolean := TRUE ;\n    OpenKind       : File_Open_Kind := WRITE_MODE\n  ) ;\n  procedure WriteAlertSummaryYaml (FileName : string := \"\" ; ExternalErrors : AlertCountType := (0,0,0)) ;\n  procedure CreateYamlReport (ExternalErrors : AlertCountType := (0,0,0)) ;  -- Deprecated.  Use WriteAlertSummaryYaml.\n\n  ------------------------------------------------------------\n  procedure WriteRequirementsYaml (\n    FileName    : string ;\n    AlertLogID  : AlertLogIDType := REQUIREMENT_ALERTLOG_ID ;\n    OpenKind    : File_Open_Kind := WRITE_MODE\n  ) ;\n\n  impure function GotRequirements return boolean ;\n\n-- These are in ReportPkg due to circular dependencies\n--  impure function EndOfTestReports (\n--    ReportAll      : boolean        := FALSE ;\n--    ExternalErrors : AlertCountType := (0,0,0)\n--  ) return integer ;\n--\n--  procedure EndOfTestReports (\n--    ReportAll      : boolean        := FALSE ;\n--    ExternalErrors : AlertCountType := (0,0,0) ;\n--    Stop           : boolean        := FALSE\n--  ) ;\n--\n--  alias EndOfTestSummary is EndOfTestReports[boolean, AlertCountType return integer] ;\n--  alias EndOfTestSummary is EndOfTestReports[boolean, AlertCountType, boolean] ;\n\n  procedure WriteTestSummary   (\n    FileName       : string ;\n    OpenKind       : File_Open_Kind := APPEND_MODE ;\n    Prefix         : string := \"\" ;\n    Suffix         : string := \"\" ;\n    ExternalErrors : AlertCountType := (0,0,0) ;\n    WriteFieldName : boolean := FALSE\n  ) ;\n  procedure WriteTestSummaries ( FileName : string ; OpenKind : File_Open_Kind := WRITE_MODE ) ;\n  procedure ReportTestSummaries ;\n  procedure WriteAlerts (\n    FileName    : string ;\n    AlertLogID  : AlertLogIDType := ALERTLOG_BASE_ID ;\n    OpenKind    : File_Open_Kind := WRITE_MODE\n  ) ;\n  procedure WriteRequirements (\n    FileName        : string ;\n    AlertLogID      : AlertLogIDType := REQUIREMENT_ALERTLOG_ID ;\n    OpenKind        : File_Open_Kind := WRITE_MODE\n  ) ;\n  procedure ReadSpecification (FileName : string ; PassedGoal : integer := -1) ;\n  procedure ReadRequirements (\n    FileName        : string ;\n    ThresholdPassed : boolean := FALSE\n  ) ;\n  procedure ReadTestSummaries (FileName : string) ;\n  procedure ClearAlerts ;\n  procedure ClearAlertStopCounts ;\n  procedure ClearAlertCounts ;\n  function \"ABS\" (L : AlertCountType) return AlertCountType ;\n  function \"+\" (L, R : AlertCountType) return AlertCountType ;\n  function \"-\" (L, R : AlertCountType) return AlertCountType ;\n  function \"-\" (R : AlertCountType) return AlertCountType ;\n  impure function SumAlertCount(AlertCount: AlertCountType) return integer ;\n  impure function GetAlertCount(AlertLogID : AlertLogIDType := ALERTLOG_BASE_ID) return AlertCountType ;\n  impure function GetAlertCount(AlertLogID : AlertLogIDType := ALERTLOG_BASE_ID) return integer ;\n  impure function GetEnabledAlertCount(AlertLogID : AlertLogIDType := ALERTLOG_BASE_ID) return AlertCountType ;\n  impure function GetEnabledAlertCount(AlertLogID : AlertLogIDType := ALERTLOG_BASE_ID) return integer ;\n  impure function GetDisabledAlertCount return AlertCountType ;\n  impure function GetDisabledAlertCount return integer ;\n  impure function GetDisabledAlertCount(AlertLogID: AlertLogIDType) return AlertCountType ;\n  impure function GetDisabledAlertCount(AlertLogID: AlertLogIDType) return integer ;\n\n  ------------------------------------------------------------\n  --  log filtering for verbosity control, optionally has a separate file parameter\n  procedure Log(\n    AlertLogID   : AlertLogIDType ;\n    Message      : string ;\n    Level        : LogType := ALWAYS ;\n    Enable       : boolean := FALSE    -- override internal enable\n  ) ;\n  procedure Log( Message : string ; Level : LogType := ALWAYS ; Enable : boolean := FALSE) ;\n\n  ------------------------------------------------------------\n  -- Alert Enables\n  procedure SetAlertEnable(Level : AlertType ;  Enable : boolean) ;\n  procedure SetAlertEnable(AlertLogID : AlertLogIDType ;  Level : AlertType ;  Enable : boolean ; DescendHierarchy : boolean := TRUE) ;\n  impure function GetAlertEnable(AlertLogID : AlertLogIDType ;  Level : AlertType) return boolean ;\n  impure function GetAlertEnable(Level : AlertType) return boolean ;\n  alias IsAlertEnabled is GetAlertEnable[AlertLogIDType, AlertType return boolean] ;\n  alias IsAlertEnabled is GetAlertEnable[AlertType return boolean] ;\n\n  -- Log Enables\n  procedure SetLogEnable(Level : LogType ;  Enable : boolean) ;\n  procedure SetLogEnable(AlertLogID : AlertLogIDType ;  Level : LogType ;  Enable : boolean ; DescendHierarchy : boolean := TRUE) ;\n  impure function GetLogEnable(AlertLogID : AlertLogIDType ;  Level : LogType) return boolean ;\n  impure function GetLogEnable(Level : LogType) return boolean ;\n  alias IsLogEnabled is GetLogEnable [AlertLogIDType, LogType return boolean] ;  -- same as GetLogEnable\n  alias IsLogEnabled is GetLogEnable [LogType return boolean] ;  -- same as GetLogEnable\n\n  procedure ReportLogEnables ;\n\n  procedure SetTestName(Name : string ) ;\n  alias SetAlertLogName is SetTestName [string] ;\n\n  -- synthesis translate_off\n  impure function GetTestName return string ;\n  impure function GetTranscriptName return string ;\n  impure function GetAlertLogName(AlertLogID : AlertLogIDType := ALERTLOG_BASE_ID) return string ;\n  -- synthesis translate_on\n  procedure DeallocateAlertLogStruct ;\n  procedure InitializeAlertLogStruct ;\n  impure function FindAlertLogID(Name : string ) return AlertLogIDType ;\n  impure function FindAlertLogID(Name : string ; ParentID : AlertLogIDType) return AlertLogIDType ;\n  impure function NewID(\n    Name            : string ;\n    ParentID        : AlertLogIDType          := ALERTLOG_ID_NOT_ASSIGNED ;\n    ReportMode      : AlertLogReportModeType  := ENABLED ;\n    PrintParent     : AlertLogPrintParentType := PRINT_NAME_AND_PARENT ;\n    CreateHierarchy : boolean                 := TRUE\n  ) return AlertLogIDType ;\n  impure function GetReqID(Name : string ; PassedGoal : integer := -1 ; ParentID : AlertLogIDType := ALERTLOG_ID_NOT_ASSIGNED ; CreateHierarchy : Boolean := TRUE) return AlertLogIDType ;\n  procedure SetPassedGoal(AlertLogID : AlertLogIDType ; PassedGoal : integer ) ;\n  impure function GetAlertLogParentID(AlertLogID : AlertLogIDType) return AlertLogIDType ;\n  procedure SetAlertLogPrefix(AlertLogID : AlertLogIDType; Name : string ) ;\n  procedure UnSetAlertLogPrefix(AlertLogID : AlertLogIDType) ;\n  -- synthesis translate_off\n  impure function GetAlertLogPrefix(AlertLogID : AlertLogIDType) return string ;\n  -- synthesis translate_on\n  procedure SetAlertLogSuffix(AlertLogID : AlertLogIDType; Name : string ) ;\n  procedure UnSetAlertLogSuffix(AlertLogID : AlertLogIDType) ;\n  -- synthesis translate_off\n  impure function GetAlertLogSuffix(AlertLogID : AlertLogIDType) return string ;\n  -- synthesis translate_on\n\n  ------------------------------------------------------------\n  -- Accessor Methods\n  procedure SetGlobalAlertEnable (A : boolean := TRUE) ;\n  impure function SetGlobalAlertEnable (A : boolean := TRUE) return boolean ;\n  impure function GetGlobalAlertEnable return boolean ;\n  procedure IncAffirmCount(AlertLogID : AlertLogIDType := ALERTLOG_BASE_ID) ;\n  impure function GetAffirmCount return natural ;\n  procedure IncAffirmPassedCount(AlertLogID : AlertLogIDType := ALERTLOG_BASE_ID) ;\n  impure function GetAffirmPassedCount return natural ;\n\n  procedure SetAlertStopCount(AlertLogID : AlertLogIDType ;  Level : AlertType ;  Count : integer) ;\n  procedure SetAlertStopCount(Level : AlertType ;  Count : integer) ;\n  impure function GetAlertStopCount(AlertLogID : AlertLogIDType ;  Level : AlertType) return integer ;\n  impure function GetAlertStopCount(Level : AlertType) return integer ;\n\n  procedure SetAlertPrintCount(AlertLogID : AlertLogIDType ;  Level : AlertType ;  Count : integer) ;\n  procedure SetAlertPrintCount(                               Level : AlertType ;  Count : integer) ;\n  impure function GetAlertPrintCount(AlertLogID : AlertLogIDType ;  Level : AlertType) return integer ;\n  impure function GetAlertPrintCount(                               Level : AlertType) return integer ;\n  procedure SetAlertPrintCount(AlertLogID : AlertLogIDType ;  Count : AlertCountType) ;\n  procedure SetAlertPrintCount(                               Count : AlertCountType) ;\n  impure function GetAlertPrintCount(AlertLogID : AlertLogIDType) return AlertCountType ;\n  impure function GetAlertPrintCount                              return AlertCountType ;\n\n  procedure SetAlertLogPrintParent(AlertLogID : AlertLogIDType ;  PrintParent : AlertLogPrintParentType) ;\n  procedure SetAlertLogPrintParent(                               PrintParent : AlertLogPrintParentType) ;\n  impure function GetAlertLogPrintParent(AlertLogID : AlertLogIDType) return AlertLogPrintParentType ;\n  impure function GetAlertLogPrintParent                              return AlertLogPrintParentType ;\n\n  procedure SetAlertLogReportMode(AlertLogID : AlertLogIDType ;  ReportMode : AlertLogReportModeType) ;\n  procedure SetAlertLogReportMode(                               ReportMode : AlertLogReportModeType) ;\n  impure function GetAlertLogReportMode(AlertLogID : AlertLogIDType) return AlertLogReportModeType ;\n  impure function GetAlertLogReportMode                              return AlertLogReportModeType ;\n\n  ------------------------------------------------------------\n  procedure SetAlertLogOptions (\n    FailOnWarning            : OsvvmOptionsType := OPT_INIT_PARM_DETECT ;\n    FailOnDisabledErrors     : OsvvmOptionsType := OPT_INIT_PARM_DETECT ;\n    FailOnRequirementErrors  : OsvvmOptionsType := OPT_INIT_PARM_DETECT ;\n    ReportHierarchy          : OsvvmOptionsType := OPT_INIT_PARM_DETECT ;\n    WriteAlertErrorCount     : OsvvmOptionsType := OPT_INIT_PARM_DETECT ;\n    WriteAlertLevel          : OsvvmOptionsType := OPT_INIT_PARM_DETECT ;\n    WriteAlertName           : OsvvmOptionsType := OPT_INIT_PARM_DETECT ;\n    WriteAlertTime           : OsvvmOptionsType := OPT_INIT_PARM_DETECT ;\n    WriteLogErrorCount       : OsvvmOptionsType := OPT_INIT_PARM_DETECT ;\n    WriteLogLevel            : OsvvmOptionsType := OPT_INIT_PARM_DETECT ;\n    WriteLogName             : OsvvmOptionsType := OPT_INIT_PARM_DETECT ;\n    WriteLogTime             : OsvvmOptionsType := OPT_INIT_PARM_DETECT ;\n    PrintPassed              : OsvvmOptionsType := OPT_INIT_PARM_DETECT ;\n    PrintAffirmations        : OsvvmOptionsType := OPT_INIT_PARM_DETECT ;\n    PrintDisabledAlerts      : OsvvmOptionsType := OPT_INIT_PARM_DETECT ;\n    PrintRequirements        : OsvvmOptionsType := OPT_INIT_PARM_DETECT ;\n    PrintIfHaveRequirements  : OsvvmOptionsType := OPT_INIT_PARM_DETECT ;\n    DefaultPassedGoal        : integer             := integer'left ;\n    AlertPrefix              : string := OSVVM_STRING_INIT_PARM_DETECT ;\n    LogPrefix                : string := OSVVM_STRING_INIT_PARM_DETECT ;\n    ReportPrefix             : string := OSVVM_STRING_INIT_PARM_DETECT ;\n    DoneName                 : string := OSVVM_STRING_INIT_PARM_DETECT ;\n    PassName                 : string := OSVVM_STRING_INIT_PARM_DETECT ;\n    FailName                 : string := OSVVM_STRING_INIT_PARM_DETECT ;\n    IdSeparator              : string := OSVVM_STRING_INIT_PARM_DETECT ;\n    WriteTimeLast            : OsvvmOptionsType := OPT_INIT_PARM_DETECT ;\n    TimeJustifyAmount        : integer             := integer'left \n  ) ;\n\n  procedure ReportAlertLogOptions ;\n\n\n  -- synthesis translate_off\n\n  impure function GetAlertLogFailOnWarning            return OsvvmOptionsType ;\n  impure function GetAlertLogFailOnDisabledErrors     return OsvvmOptionsType ;\n  impure function GetAlertLogFailOnRequirementErrors  return OsvvmOptionsType ;\n  impure function GetAlertLogReportHierarchy          return OsvvmOptionsType ;\n  impure function GetAlertLogFoundReportHier          return boolean ;\n  impure function GetAlertLogFoundAlertHier           return boolean ;\n  impure function GetAlertLogWriteAlertErrorCount     return OsvvmOptionsType ;\n  impure function GetAlertLogWriteAlertLevel          return OsvvmOptionsType ;\n  impure function GetAlertLogWriteAlertName           return OsvvmOptionsType ;\n  impure function GetAlertLogWriteAlertTime           return OsvvmOptionsType ;\n  impure function GetAlertLogWriteLogErrorCount       return OsvvmOptionsType ;\n  impure function GetAlertLogWriteLogLevel            return OsvvmOptionsType ;\n  impure function GetAlertLogWriteLogName             return OsvvmOptionsType ;\n  impure function GetAlertLogWriteLogTime             return OsvvmOptionsType ;\n  impure function GetAlertLogPrintPassed              return OsvvmOptionsType ;\n  impure function GetAlertLogPrintAffirmations        return OsvvmOptionsType ;\n  impure function GetAlertLogPrintDisabledAlerts      return OsvvmOptionsType ;\n  impure function GetAlertLogPrintRequirements        return OsvvmOptionsType ;\n  impure function GetAlertLogPrintIfHaveRequirements  return OsvvmOptionsType ;\n  impure function GetAlertLogDefaultPassedGoal        return integer ;\n\n  impure function GetAlertLogAlertPrefix              return string ;\n  impure function GetAlertLogLogPrefix                return string ;\n\n  impure function GetAlertLogReportPrefix             return string ;\n  impure function GetAlertLogDoneName                 return string ;\n  impure function GetAlertLogPassName                 return string ;\n  impure function GetAlertLogFailName                 return string ;\n\n  impure function GetAlertLogWriteTimeLast            return OsvvmOptionsType ;\n\n  -- File Reading Utilities\n  function IsLogEnableType (Name : String) return boolean ;\n  procedure ReadLogEnables (file AlertLogInitFile : text) ;\n  procedure ReadLogEnables (FileName : string) ;\n\n  -- String Helper Functions -- This should be in a more general string package\n  function PathTail (A : string) return string ;\n\n  ------------------------------------------------------------\n  -- MetaMatch\n  --   Similar to STD_MATCH, except\n  --   it returns TRUE for U=U, X=X, Z=Z, and W=W\n  --   All other values are consistent with STD_MATCH\n  --   MetaMatch, BooleanTableType, and MetaMatchTable are derivatives\n  --   of STD_MATCH from IEEE.Numeric_Std copyright by IEEE.\n  --   Numeric_Std is also released under the Apache License, Version 2.0.\n  --   Coding Styles were updated to match OSVVM\n  ------------------------------------------------------------\n  function MetaMatch (l, r : std_ulogic) return boolean ;\n  function MetaMatch (L, R : std_ulogic_vector) return boolean ;\n  function MetaMatch (L, R : unresolved_unsigned) return boolean ;\n  function MetaMatch (L, R : unresolved_signed) return boolean ;\n\n  ------------------------------------------------------------\n  -- Helper function for NewID in data structures\n  function ResolvePrintParent (\n  ------------------------------------------------------------\n    UniqueParent : boolean ;\n    PrintParent  : AlertLogPrintParentType\n  ) return AlertLogPrintParentType ;\n\n\n  -- synthesis translate_on\n\n  --  ------------------------------------------------------------\n  -- Deprecated\n  --\n  -- See NewID - consistency and parameter update.  DoNotReport replaced by ReportMode\n  impure function GetAlertLogID(Name : string; ParentID : AlertLogIDType := ALERTLOG_ID_NOT_ASSIGNED; CreateHierarchy : Boolean := TRUE; DoNotReport : Boolean := FALSE) return AlertLogIDType ;\n\n  -- deprecated\n  procedure AlertIf( condition : boolean ; AlertLogID : AlertLogIDType ; Message : string ; Level : AlertType := ERROR )  ;\n  impure function  AlertIf( condition : boolean ; AlertLogID : AlertLogIDType ; Message : string ; Level : AlertType := ERROR ) return boolean ;\n\n  -- deprecated\n  procedure AlertIfNot( condition : boolean ; AlertLogID : AlertLogIDType ; Message : string ; Level : AlertType := ERROR )  ;\n  impure function  AlertIfNot( condition : boolean ; AlertLogID : AlertLogIDType ; Message : string ; Level : AlertType := ERROR ) return boolean ;\n\n  -- deprecated\n  procedure AffirmIf(\n    AlertLogID   : AlertLogIDType ;\n    condition    : boolean ;\n    Message      : string ;\n    LogLevel     : LogType  ;  -- := PASSED\n    AlertLevel   : AlertType := ERROR\n  )  ;\n  procedure AffirmIf( AlertLogID : AlertLogIDType ; condition : boolean ; Message : string ; AlertLevel : AlertType ) ;\n  procedure AffirmIf(condition : boolean ; Message : string ;  LogLevel : LogType  ; AlertLevel : AlertType := ERROR) ;\n  procedure AffirmIf(condition : boolean ; Message : string ;  AlertLevel : AlertType ) ;\n\n  alias IncAffirmCheckCount is IncAffirmCount [AlertLogIDType] ;\n  alias GetAffirmCheckCount is GetAffirmCount [return natural] ;\n  alias IsLoggingEnabled is GetLogEnable [AlertLogIDType, LogType return boolean] ;  -- same as IsLogEnabled\n  alias IsLoggingEnabled is GetLogEnable [LogType return boolean] ;  -- same as IsLogEnabled\n\n\nend AlertLogPkg ;\n\n--- ///////////////////////////////////////////////////////////////////////////\n--- ///////////////////////////////////////////////////////////////////////////\n--- ///////////////////////////////////////////////////////////////////////////\n\nuse work.NamePkg.all ;\n\npackage body AlertLogPkg is\n\n-- synthesis translate_off\n\n  -- instead of justify(to_upper(to_string())), just look up the upper case, left justified values\n  type     AlertNameType is array(AlertType) of string(1 to 7) ;\n  constant ALERT_NAME : AlertNameType := (WARNING => \"WARNING\", ERROR => \"ERROR  \", FAILURE => \"FAILURE\") ;  -- , NEVER => \"NEVER  \"\n  type     LogNameType is array(LogType) of string(1 to 7) ;\n  constant LOG_NAME : LogNameType := (DEBUG => \"DEBUG  \", FINAL => \"FINAL  \", INFO => \"INFO   \", ALWAYS => \"ALWAYS \", PASSED => \"PASSED \") ; -- , NEVER => \"NEVER  \"\n\n  ------------------------------------------------------------\n  -- Package Local\n  function LeftJustify(A : String;  Amount : integer) return string is\n  ------------------------------------------------------------\n    constant Spaces : string(1 to  maximum(1, Amount)) := (others => ' ') ;\n  begin\n    if A'length >= Amount then\n      return A ;\n    else\n      return A & Spaces(1 to Amount - A'length) ;\n    end if ;\n  end function LeftJustify ;\n\n\n  type AlertLogStructPType is protected\n\n    ------------------------------------------------------------\n    procedure alert (\n    ------------------------------------------------------------\n      AlertLogID   : AlertLogIDType ;\n      message      : string ;\n      level        : AlertType := ERROR\n    ) ;\n\n    ------------------------------------------------------------\n    procedure IncAlertCount ( AlertLogID : AlertLogIDType ; level : AlertType := ERROR ) ;\n    procedure SetJustify (\n      Enable      : boolean := TRUE ;\n      AlertLogID  : AlertLogIDType := ALERTLOG_BASE_ID\n    ) ;\n    procedure ReportAlerts ( Name : string ; AlertCount : AlertCountType ) ;\n    procedure ReportRequirements ;\n    procedure ReportAlerts (\n      Name           : string := OSVVM_STRING_INIT_PARM_DETECT ;\n      AlertLogID     : AlertLogIDType := ALERTLOG_BASE_ID ;\n      ExternalErrors : AlertCountType := (0,0,0) ;\n      ReportAll      : boolean := FALSE ;\n      ReportWhenZero : boolean := TRUE\n    ) ;\n    procedure WriteAlertYaml (\n      FileName       : string ;\n      ExternalErrors : AlertCountType := (0,0,0) ;\n      Prefix         : string := \"\" ;\n      PrintSettings  : boolean := TRUE ;\n      PrintChildren  : boolean := TRUE ;\n      OpenKind       : File_Open_Kind := WRITE_MODE\n    ) ;\n    procedure WriteRequirementsYaml (\n      FileName    : string ;\n      AlertLogID  : AlertLogIDType ;\n      OpenKind    : File_Open_Kind\n    ) ;\n    impure function GotRequirements return boolean ;\n\n    procedure WriteTestSummary (\n      FileName       : string ;\n      OpenKind       : File_Open_Kind ;\n      Prefix         : string ;\n      Suffix         : string ;\n      ExternalErrors : AlertCountType ;\n      WriteFieldName : boolean\n    ) ;\n    procedure WriteTestSummaries ( FileName : string ; OpenKind : File_Open_Kind ) ;\n    procedure ReportTestSummaries ;\n    procedure WriteAlerts (\n      FileName    : string ;\n      AlertLogID  : AlertLogIDType ;\n      OpenKind    : File_Open_Kind\n    ) ;\n    procedure WriteRequirements (\n      FileName    : string ;\n      AlertLogID  : AlertLogIDType ;\n      OpenKind    : File_Open_Kind\n    ) ;\n    procedure ReadSpecification (FileName : string ; PassedGoal : integer ) ;\n    procedure ReadRequirements (\n      FileName        : string ;\n      ThresholdPassed : boolean ;\n      TestSummary     : boolean\n    ) ;\n    procedure ClearAlerts ;\n    procedure ClearAlertStopCounts ;\n    impure function GetAlertCount(AlertLogID : AlertLogIDType := ALERTLOG_BASE_ID) return AlertCountType ;\n    impure function GetEnabledAlertCount(AlertLogID : AlertLogIDType := ALERTLOG_BASE_ID) return AlertCountType ;\n    impure function GetDisabledAlertCount return AlertCountType ;\n    impure function GetDisabledAlertCount(AlertLogID: AlertLogIDType) return AlertCountType ;\n\n    ------------------------------------------------------------\n    procedure log (\n    ------------------------------------------------------------\n      AlertLogID   : AlertLogIDType ;\n      Message      : string ;\n      Level        : LogType := ALWAYS ;\n      Enable       : boolean := FALSE    -- override internal enable\n    ) ;\n\n    ------------------------------------------------------------\n    -- FILE IO Controls\n--    procedure SetTranscriptEnable (A : boolean := TRUE) ;\n--    impure function IsTranscriptEnabled return boolean ;\n--    procedure MirrorTranscript (A : boolean := TRUE) ;\n--    impure function IsTranscriptMirrored return boolean ;\n\n    ------------------------------------------------------------\n    ------------------------------------------------------------\n    -- AlertLog Structure Creation and Interaction Methods\n\n    ------------------------------------------------------------\n    procedure SetTestName(Name : string ) ;\n    procedure SetNumAlertLogIDs (NewNumAlertLogIDs : AlertLogIDType) ;\n    impure function FindAlertLogID(Name : string ) return AlertLogIDType ;\n    impure function FindAlertLogID(Name : string ; ParentID : AlertLogIDType) return AlertLogIDType ;\n    impure function NewID(\n      Name            : string ;\n      ParentID        : AlertLogIDType ;\n      ReportMode      : AlertLogReportModeType ;\n      PrintParent     : AlertLogPrintParentType ;\n      CreateHierarchy : boolean\n    ) return AlertLogIDType ;\n    -- impure function GetAlertLogID(Name : string; ParentID : AlertLogIDType; CreateHierarchy : Boolean; DoNotReport : Boolean) return AlertLogIDType ;\n    impure function GetReqID(Name : string ; PassedGoal : integer ; ParentID : AlertLogIDType ; CreateHierarchy : Boolean) return AlertLogIDType ;\n    procedure SetPassedGoal(AlertLogID : AlertLogIDType ; PassedGoal : integer ) ;\n    impure function GetAlertLogParentID(AlertLogID : AlertLogIDType) return AlertLogIDType ;\n    procedure Initialize(NewNumAlertLogIDs : AlertLogIDType := MIN_NUM_AL_IDS) ;\n    procedure DeallocateAlertLogStruct ;\n    procedure SetAlertLogPrefix(AlertLogID : AlertLogIDType; Name : string ) ;\n    procedure UnSetAlertLogPrefix(AlertLogID : AlertLogIDType) ;\n    impure function GetAlertLogPrefix(AlertLogID : AlertLogIDType) return string ;\n    procedure SetAlertLogSuffix(AlertLogID : AlertLogIDType; Name : string ) ;\n    procedure UnSetAlertLogSuffix(AlertLogID : AlertLogIDType) ;\n    impure function GetAlertLogSuffix(AlertLogID : AlertLogIDType) return string ;\n\n    ------------------------------------------------------------\n    ------------------------------------------------------------\n    -- Accessor Methods\n    ------------------------------------------------------------\n    procedure SetGlobalAlertEnable (A : boolean := TRUE) ;\n    impure function GetAlertLogName(AlertLogID : AlertLogIDType) return string ;\n    impure function GetGlobalAlertEnable return boolean ;\n    procedure IncAffirmCount(AlertLogID : AlertLogIDType) ;\n    impure function GetAffirmCount return natural ;\n    procedure IncAffirmPassedCount(AlertLogID : AlertLogIDType) ;\n    impure function GetAffirmPassedCount return natural ;\n\n    procedure SetAlertStopCount(AlertLogID : AlertLogIDType ;  Level : AlertType ;  Count : integer) ;\n    impure function GetAlertStopCount(AlertLogID : AlertLogIDType ;  Level : AlertType) return integer ;\n\n    procedure SetAlertPrintCount(AlertLogID : AlertLogIDType ;  Level : AlertType ;  Count : integer) ;\n    impure function GetAlertPrintCount(AlertLogID : AlertLogIDType ;  Level : AlertType) return integer ;\n\n    procedure SetAlertPrintCount(AlertLogID : AlertLogIDType ;  Count : AlertCountType) ;\n    impure function GetAlertPrintCount(AlertLogID : AlertLogIDType) return AlertCountType ;\n\n    procedure SetAlertLogPrintParent(AlertLogID : AlertLogIDType ;  PrintParent : AlertLogPrintParentType) ;\n    impure function GetAlertLogPrintParent(AlertLogID : AlertLogIDType) return AlertLogPrintParentType ;\n\n    procedure SetAlertLogReportMode(AlertLogID : AlertLogIDType ;  ReportMode : AlertLogReportModeType) ;\n    impure function GetAlertLogReportMode(AlertLogID : AlertLogIDType) return AlertLogReportModeType ;\n\n    procedure SetAlertEnable(Level : AlertType ;  Enable : boolean) ;\n    procedure SetAlertEnable(AlertLogID : AlertLogIDType ;  Level : AlertType ;  Enable : boolean ; DescendHierarchy : boolean := TRUE) ;\n    impure function GetAlertEnable(AlertLogID : AlertLogIDType ;  Level : AlertType) return boolean ;\n\n    procedure SetLogEnable(Level : LogType ;  Enable : boolean) ;\n    procedure SetLogEnable(AlertLogID : AlertLogIDType ;  Level : LogType ;  Enable : boolean ; DescendHierarchy : boolean := TRUE) ;\n    impure function GetLogEnable(AlertLogID : AlertLogIDType ;  Level : LogType) return boolean ;\n\n    procedure ReportLogEnables ;\n\n    ------------------------------------------------------------\n    -- Reporting Accessor\n    procedure SetAlertLogOptions (\n      FailOnWarning            : OsvvmOptionsType ;\n      FailOnDisabledErrors     : OsvvmOptionsType ;\n      FailOnRequirementErrors  : OsvvmOptionsType ;\n      ReportHierarchy          : OsvvmOptionsType ;\n      WriteAlertErrorCount     : OsvvmOptionsType ;\n      WriteAlertLevel          : OsvvmOptionsType ;\n      WriteAlertName           : OsvvmOptionsType ;\n      WriteAlertTime           : OsvvmOptionsType ;\n      WriteLogErrorCount       : OsvvmOptionsType ;\n      WriteLogLevel            : OsvvmOptionsType ;\n      WriteLogName             : OsvvmOptionsType ;\n      WriteLogTime             : OsvvmOptionsType ;\n      PrintPassed              : OsvvmOptionsType ;\n      PrintAffirmations        : OsvvmOptionsType ;\n      PrintDisabledAlerts      : OsvvmOptionsType ;\n      PrintRequirements        : OsvvmOptionsType ;\n      PrintIfHaveRequirements  : OsvvmOptionsType ;\n      DefaultPassedGoal        : integer ;\n      AlertPrefix              : string ;\n      LogPrefix                : string ;\n      ReportPrefix             : string ;\n      DoneName                 : string ;\n      PassName                 : string ;\n      FailName                 : string ;\n      IdSeparator              : string ;\n      WriteTimeLast            : OsvvmOptionsType ;\n      TimeJustifyAmount        : integer \n    ) ;\n    procedure ReportAlertLogOptions ;\n\n    impure function GetAlertLogFailOnWarning        return OsvvmOptionsType ;\n    impure function GetAlertLogFailOnDisabledErrors return OsvvmOptionsType ;\n    impure function GetAlertLogFailOnRequirementErrors return OsvvmOptionsType ;\n    impure function GetAlertLogReportHierarchy      return OsvvmOptionsType ;\n    impure function GetAlertLogFoundReportHier      return boolean ;\n    impure function GetAlertLogFoundAlertHier       return boolean ;\n    impure function GetAlertLogWriteAlertErrorCount return OsvvmOptionsType ;\n    impure function GetAlertLogWriteAlertLevel      return OsvvmOptionsType ;\n    impure function GetAlertLogWriteAlertName       return OsvvmOptionsType ;\n    impure function GetAlertLogWriteAlertTime       return OsvvmOptionsType ;\n    impure function GetAlertLogWriteLogErrorCount   return OsvvmOptionsType ;\n    impure function GetAlertLogWriteLogLevel        return OsvvmOptionsType ;\n    impure function GetAlertLogWriteLogName         return OsvvmOptionsType ;\n    impure function GetAlertLogWriteLogTime         return OsvvmOptionsType ;\n    impure function GetAlertLogPrintPassed          return OsvvmOptionsType ;\n    impure function GetAlertLogPrintAffirmations    return OsvvmOptionsType ;\n    impure function GetAlertLogPrintDisabledAlerts  return OsvvmOptionsType ;\n    impure function GetAlertLogPrintRequirements    return OsvvmOptionsType ;\n    impure function GetAlertLogPrintIfHaveRequirements  return OsvvmOptionsType ;\n    impure function GetAlertLogDefaultPassedGoal    return integer ;\n\n    impure function GetAlertLogAlertPrefix          return string ;\n    impure function GetAlertLogLogPrefix            return string ;\n\n    impure function GetAlertLogReportPrefix return string ;\n    impure function GetAlertLogDoneName return string ;\n    impure function GetAlertLogPassName return string ;\n    impure function GetAlertLogFailName return string ;\n\n    impure function GetAlertLogWriteTimeLast        return OsvvmOptionsType ;\n\n  end  protected AlertLogStructPType ;\n\n  --- ///////////////////////////////////////////////////////////////////////////\n\n  type AlertLogStructPType is protected body\n\n    variable GlobalAlertEnabledVar     : boolean := TRUE ; -- Allows turn off and on\n\n    variable AffirmCheckCountVar       : natural := 0 ;\n    variable PassedCountVar            : natural := 0 ;\n\n    variable ErrorCount                : integer := 0 ;\n    variable AlertCount                : AlertCountType := (0, 0, 0) ;\n    \n    ------------------------------------------------------------\n    type AlertLogRecType is record\n    ------------------------------------------------------------\n      Name                : Line ;\n      NameLower           : Line ;\n      Prefix              : Line ;\n      Suffix              : Line ;\n      ParentID            : AlertLogIDType ;\n      ParentIDSet         : Boolean ;\n      SiblingID           : AlertLogIDType ;\n      ChildID             : AlertLogIDType ;\n      ChildIDLast         : AlertLogIDType ;\n      AlertCount          : AlertCountType ;\n      DisabledAlertCount  : AlertCountType ;\n      PassedCount         : Integer ;\n      AffirmCount         : Integer ;\n      PassedGoal          : Integer ;\n      PassedGoalSet       : Boolean ;\n      AlertStopCount      : AlertCountType ;\n      AlertPrintCount     : AlertCountType ;\n      AlertEnabled        : AlertEnableType ;\n      LogEnabled          : LogEnableType ;\n      ReportMode          : AlertLogReportModeType ;\n      PrintParent         : AlertLogPrintParentType ;\n      -- Used only by ReadTestSummaries\n      TotalErrors         : integer ;\n      AffirmPassedCount   : integer ;\n--      IsRequirment        : boolean ;\n    end record AlertLogRecType ;\n\n    ------------------------------------------------------------\n    -- Basis for AlertLog Data Structure\n    variable NumAlertLogIDsVar          : AlertLogIDType := 0 ; -- defined by initialize\n    variable NumAllocatedAlertLogIDsVar : AlertLogIDType := 0 ;\n\n    type AlertLogRecPtrType   is access AlertLogRecType ;\n    type AlertLogArrayType    is array (AlertLogIDType range <>) of AlertLogRecPtrType ;\n    type AlertLogArrayPtrType is access AlertLogArrayType ;\n    variable AlertLogPtr  : AlertLogArrayPtrType ;\n\n    ------------------------------------------------------------\n    -- Report formatting settings, with defaults\n    variable PrintPassedVar              : boolean := TRUE ;\n    variable PrintAffirmationsVar        : boolean := FALSE ;\n    variable PrintDisabledAlertsVar      : boolean := FALSE ;\n    variable PrintRequirementsVar        : boolean := FALSE ;\n    variable HasRequirementsVar          : boolean := FALSE ;\n    variable PrintIfHaveRequirementsVar  : boolean := TRUE ;\n\n    variable DefaultPassedGoalVar        : integer := 1 ;\n\n    variable FailOnWarningVar            : boolean := TRUE ;\n    variable FailOnDisabledErrorsVar     : boolean := TRUE ;\n    variable FailOnRequirementErrorsVar  : boolean := TRUE ;\n\n    variable ReportHierarchyVar          : boolean := TRUE ;\n    variable FoundReportHierVar          : boolean := FALSE ;\n    variable FoundAlertHierVar           : boolean := FALSE ;\n\n    variable WriteAlertErrorCountVar     : boolean := FALSE ;\n    variable WriteAlertLevelVar          : boolean := TRUE ;\n    variable WriteAlertNameVar           : boolean := TRUE ;\n    variable WriteAlertTimeVar           : boolean := TRUE ;\n    variable WriteLogErrorCountVar       : boolean := FALSE ;\n    variable WriteLogLevelVar            : boolean := TRUE ;\n    variable WriteLogNameVar             : boolean := TRUE ;\n    variable WriteLogTimeVar             : boolean := TRUE ;\n\n    variable AlertPrefixVar              : NamePType ;\n    variable LogPrefixVar                : NamePType ;\n    variable ReportPrefixVar             : NamePType ;\n    variable DoneNameVar                 : NamePType ;\n    variable PassNameVar                 : NamePType ;\n    variable FailNameVar                 : NamePType ;\n    variable IdSeparatorVar              : NamePType ;\n\n    variable AlertLogJustifyAmountVar    : integer := 0 ;\n    variable ReportJustifyAmountVar      : integer := 0 ;\n    variable TimeJustifyAmountVar        : integer := 0 ;\n    \n    variable WriteTimeLastVar            : boolean := TRUE ;\n\n    ------------------------------------------------------------\n    -- PT Local\n    impure function VerifyID(\n      AlertLogID : AlertLogIDType ;\n      LowestID   : AlertLogIDType := ALERTLOG_BASE_ID ;\n      InvalidID  : AlertLogIDType := ALERTLOG_DEFAULT_ID\n    ) return AlertLogIDType is\n    ------------------------------------------------------------\n    begin\n      if AlertLogID < LowestID or AlertLogID > NumAlertLogIDsVar then\n        Alert(\"Invalid AlertLogID\") ;\n        return InvalidID ;\n      else\n        return AlertLogID ;\n      end if ;\n    end function VerifyID ;\n\n    ------------------------------------------------------------\n    procedure IncAffirmCount(AlertLogID : AlertLogIDType) is\n    ------------------------------------------------------------\n      variable localAlertLogID : AlertLogIDType ;\n    begin\n      if GlobalAlertEnabledVar then\n        localAlertLogID := VerifyID(AlertLogID) ;\n        AlertLogPtr(localAlertLogID).AffirmCount := AlertLogPtr(localAlertLogID).AffirmCount + 1 ;\n        AffirmCheckCountVar := AffirmCheckCountVar + 1 ;\n      end if ;\n    end procedure IncAffirmCount ;\n\n    ------------------------------------------------------------\n    impure function GetAffirmCount return natural is\n    ------------------------------------------------------------\n    begin\n      return AffirmCheckCountVar ;\n    end function GetAffirmCount ;\n\n    ------------------------------------------------------------\n    procedure IncAffirmPassedCount(AlertLogID : AlertLogIDType) is\n    ------------------------------------------------------------\n      variable localAlertLogID : AlertLogIDType ;\n    begin\n      if GlobalAlertEnabledVar then\n        localAlertLogID := VerifyID(AlertLogID) ;\n        AlertLogPtr(localAlertLogID).PassedCount := AlertLogPtr(localAlertLogID).PassedCount + 1 ;\n        PassedCountVar := PassedCountVar + 1 ;\n        AlertLogPtr(localAlertLogID).AffirmCount := AlertLogPtr(localAlertLogID).AffirmCount + 1 ;\n        AffirmCheckCountVar := AffirmCheckCountVar + 1 ;\n      end if ;\n    end procedure IncAffirmPassedCount ;\n\n    ------------------------------------------------------------\n    impure function GetAffirmPassedCount return natural is\n    ------------------------------------------------------------\n    begin\n      return PassedCountVar ;\n    end function GetAffirmPassedCount ;\n\n    ------------------------------------------------------------\n    -- PT Local\n    procedure IncrementAlertCount(\n    ------------------------------------------------------------\n      constant AlertLogID        : in    AlertLogIDType ;\n      constant Level             : in    AlertType ;\n      variable StopDueToCount    : inout boolean ;\n      variable IncrementByAmount : in    integer := 1\n    ) is\n    begin\n      if AlertLogPtr(AlertLogID).AlertEnabled(Level) then\n        AlertLogPtr(AlertLogID).AlertCount(Level) := AlertLogPtr(AlertLogID).AlertCount(Level) + IncrementByAmount ;\n        -- Exceeded Stop Count at this level?\n        if AlertLogPtr(AlertLogID).AlertCount(Level) >= AlertLogPtr(AlertLogID).AlertStopCount(Level) then\n          StopDueToCount := TRUE ;\n        end if ;\n        -- Propagate counts to parent(s)  -- Ascend Hierarchy\n        if AlertLogID /= ALERTLOG_BASE_ID then\n          IncrementAlertCount(AlertLogPtr(AlertLogID).ParentID, Level, StopDueToCount, IncrementByAmount) ;\n        end if ;\n      else\n        -- Disabled, increment disabled count\n        AlertLogPtr(AlertLogID).DisabledAlertCount(Level) := AlertLogPtr(AlertLogID).DisabledAlertCount(Level) + IncrementByAmount ;\n      end if ;\n    end procedure IncrementAlertCount ;\n    \n    ------------------------------------------------------------\n    -- PT Local\n    procedure LocalPrint (\n    ------------------------------------------------------------\n      AlertLogID      : AlertLogIDType ;\n      AlertLogName    : string ; \n      WriteErrorCount : boolean ; \n      WriteLevel      : boolean ; \n      LevelName       : string ; \n      WriteName       : boolean ; \n      Message         : string ;\n      WriteTime       : boolean\n    ) is\n      variable buf : line ;\n      variable ParentID : AlertLogIDType ;\n    begin\n      write(buf, ResolveOsvvmWritePrefix(ReportPrefixVar.GetOpt) ) ; -- Print  \n      -- Debug Mode\n      if WriteErrorCount then\n        if ErrorCount > 0 then\n          write(buf, justify(to_string(ErrorCount), RIGHT, 3) & \"  \") ;\n        else\n          swrite(buf, \"     \") ;\n        end if ;\n      end if ;\n      -- Write Time\n      if WriteTime and not WriteTimeLastVar then\n--        write(buf, justify(to_string(NOW, 1 ns), TimeJustifyAmountVar, RIGHT) & \"    \") ;\n        write(buf, justify(to_string(NOW, GetOsvvmDefaultTimeUnits), TimeJustifyAmountVar, RIGHT) & \"    \") ;\n      end if ;\n      -- Alert or Log\n      write(buf, AlertLogName) ;\n      -- Level Name, when enabled (default)\n      if WriteLevel then\n        write(buf, \"  \" & LevelName) ;\n      end if ;\n      -- AlertLog Name\n      if FoundAlertHierVar and WriteName then\n        if AlertLogPtr(AlertLogID).PrintParent = PRINT_NAME then\n          write(buf, \"   in \" & LeftJustify(AlertLogPtr(AlertLogID).Name.all & ',', AlertLogJustifyAmountVar) ) ;\n        else\n          ParentID := AlertLogPtr(AlertLogID).ParentID ;\n          write(buf, \"   in \" & LeftJustify(AlertLogPtr(ParentID).Name.all & ResolveOsvvmIdSeparator(IdSeparatorVar.GetOpt) &\n            AlertLogPtr(AlertLogID).Name.all & ',', AlertLogJustifyAmountVar) ) ;\n        end if ;\n      end if ;\n      -- Spacing before message\n      swrite(buf, \"  \") ;\n      -- Prefix\n      if AlertLogPtr(AlertLogID).Prefix /= NULL then\n        write(buf, ' ' & AlertLogPtr(AlertLogID).Prefix.all) ;\n      end if ;\n      -- Message\n      write(buf, \" \" & Message) ;\n      -- Suffix\n      if AlertLogPtr(AlertLogID).Suffix /= NULL then\n        write(buf, ' ' & AlertLogPtr(AlertLogID).Suffix.all) ;\n      end if ;\n      -- Time Last\n      if WriteTime and WriteTimeLastVar then\n--        write(buf, \" at \" & to_string(NOW, 1 ns)) ;\n        write(buf, \" at \" & to_string(NOW, GetOsvvmDefaultTimeUnits)) ;\n      end if ;\n      writeline(buf) ;\n    end procedure LocalPrint ;\n    \n    ------------------------------------------------------------\n    procedure alert (\n    ------------------------------------------------------------\n      AlertLogID   : AlertLogIDType ;\n      message      : string ;\n      level        : AlertType := ERROR\n    ) is\n      variable buf : Line ;\n      -- constant AlertPrefix : string := AlertPrefixVar.Get(OSVVM_DEFAULT_ALERT_PREFIX) ;\n      variable StopDueToCount  : boolean := FALSE ;\n      variable localAlertLogID : AlertLogIDType ;\n    begin\n      -- Only write and count when GlobalAlertEnabledVar is enabled\n      if GlobalAlertEnabledVar then\n        localAlertLogID := VerifyID(AlertLogID) ;\n        \n        -- Always Count (before printing so have current ErrorCount\n        IncrementAlertCount(localAlertLogID, Level, StopDueToCount) ;\n        AlertCount := AlertLogPtr(ALERTLOG_BASE_ID).AlertCount;\n        ErrorCount := SumAlertCount(AlertCount);\n        \n         -- Write when Alert is Enabled\n        if AlertLogPtr(localAlertLogID).AlertEnabled(Level) and (AlertLogPtr(localAlertLogID).AlertCount(Level) <= AlertLogPtr(localAlertLogID).AlertPrintCount(Level)) then\n          LocalPrint(\n            AlertLogID       => localAlertLogID,\n            AlertLogName     => AlertPrefixVar.Get(OSVVM_DEFAULT_ALERT_PREFIX),  \n            WriteErrorCount  => WriteAlertErrorCountVar,\n            WriteLevel       => WriteAlertLevelVar,\n            LevelName        => ALERT_NAME(Level),\n            WriteName        => WriteAlertNameVar,\n            Message          => Message,\n            WriteTime        => WriteAlertTimeVar \n          ) ;\n        end if ;\n        \n        if StopDueToCount then\n--          write(buf, LF & AlertPrefix & \" Stop Count on \" & ALERT_NAME(Level) & \" reached\") ;\n          write(buf, LF & ResolveOsvvmWritePrefix(ReportPrefixVar.GetOpt) & \n            AlertPrefixVar.Get(OSVVM_DEFAULT_ALERT_PREFIX) & \" Stop Count on \" & \n            ALERT_NAME(Level) & \" reached\") ;\n          if FoundAlertHierVar then\n            write(buf, \" in \" & AlertLogPtr(localAlertLogID).Name.all) ;\n          end if ;\n          write(buf, \" at \" & to_string(NOW, 1 ns) & \" \") ;\n          writeline(buf) ;\n          ReportAlerts(ReportWhenZero => TRUE) ;\n          if FileExists(OSVVM_BUILD_YAML_FILE) then\n--          work.ReportPkg.EndOfTestReports ;  -- creates circular package issues\n            WriteAlertSummaryYaml(\n              FileName        => OSVVM_BUILD_YAML_FILE\n            ) ;\n            WriteAlertYaml (\n              FileName        => OSVVM_OUTPUT_DIRECTORY & GetAlertLogName(ALERTLOG_BASE_ID) & \"_alerts.yml\"\n            ) ;\n          end if ;\n          std.env.stop(ErrorCount) ;\n        end if ;\n      end if ;\n    end procedure alert ;\n\n    ------------------------------------------------------------\n    procedure IncAlertCount (\n    ------------------------------------------------------------\n      AlertLogID   : AlertLogIDType ;\n      level        : AlertType := ERROR\n    ) is\n      variable buf : Line ;\n      -- constant AlertPrefix : string := AlertPrefixVar.Get(OSVVM_DEFAULT_ALERT_PREFIX) ;\n      variable StopDueToCount : boolean := FALSE ;\n      variable localAlertLogID : AlertLogIDType ;\n    begin\n      if GlobalAlertEnabledVar then\n        localAlertLogID := VerifyID(AlertLogID) ;\n        IncrementAlertCount(localAlertLogID, Level, StopDueToCount) ;\n        AlertCount := AlertLogPtr(ALERTLOG_BASE_ID).AlertCount;\n        ErrorCount := SumAlertCount(AlertCount);\n        if StopDueToCount then\n--          write(buf, LF & AlertPrefix & \" Stop Count on \" & ALERT_NAME(Level) & \" reached\") ;\n          write(buf, LF & AlertPrefixVar.Get(OSVVM_DEFAULT_ALERT_PREFIX) & \" Stop Count on \" & ALERT_NAME(Level) & \" reached\") ;\n          if FoundAlertHierVar then\n            write(buf, \" in \" & AlertLogPtr(localAlertLogID).Name.all) ;\n          end if ;\n          write(buf, \" at \" & to_string(NOW, 1 ns) & \" \") ;\n          writeline(buf) ;\n          ReportAlerts(ReportWhenZero => TRUE) ;\n          std.env.stop(ErrorCount) ;\n        end if ;\n      end if ;\n    end procedure IncAlertCount ;\n\n    ------------------------------------------------------------\n    -- PT Local\n    impure function CalcJustify (AlertLogID : AlertLogIDType; CurrentLength : integer; IndentAmount : integer; IdSeparatorLength : integer) return integer_vector is\n    ------------------------------------------------------------\n      variable ResultValues, LowerLevelValues : integer_vector(1 to 2) ;  -- 1 = Max, 2 = Indented\n      variable CurID, ParentID : AlertLogIDType ;\n      variable ParentNameLen   : integer ;\n    begin\n      ResultValues(1) := CurrentLength + 1 ;            -- AlertLogJustifyAmountVar\n      ResultValues(2) := CurrentLength + IndentAmount ; -- ReportJustifyAmountVar\n      if AlertLogPtr(AlertLogID).PrintParent = PRINT_NAME_AND_PARENT then\n        ParentID := AlertLogPtr(AlertLogID).ParentID ;\n        ParentNameLen := AlertLogPtr(ParentID).Name'length ;\n        ResultValues(1) := IdSeparatorLength + ParentNameLen + ResultValues(1) ;  -- AlertLogJustifyAmountVar\n--        ResultValues(2) := IdSeparatorLength + ParentNameLen + ResultValues(2) ;  -- ReportJustifyAmountVar\n      end if ;\n      CurID := AlertLogPtr(AlertLogID).ChildID ;\n      while CurID > ALERTLOG_BASE_ID loop\n        if CurID = REQUIREMENT_ALERTLOG_ID and HasRequirementsVar = FALSE then\n          CurID := AlertLogPtr(CurID).SiblingID ;\n          next ;\n        end if ;\n        LowerLevelValues := CalcJustify(CurID, AlertLogPtr(CurID).Name'length, IndentAmount + 2, IdSeparatorLength) ;\n        ResultValues(1)  := maximum(ResultValues(1), LowerLevelValues(1)) ;\n        if AlertLogPtr(AlertLogID).ReportMode /= DISABLED then\n          ResultValues(2)  := maximum(ResultValues(2), LowerLevelValues(2)) ;\n        end if ;\n        CurID := AlertLogPtr(CurID).SiblingID ;\n      end loop ;\n      return ResultValues ;\n    end function CalcJustify ;\n\n    ------------------------------------------------------------\n    procedure SetJustify (\n    ------------------------------------------------------------\n      Enable      : boolean := TRUE ;\n      AlertLogID  : AlertLogIDType := ALERTLOG_BASE_ID\n    ) is\n      constant Separator : string := ResolveOsvvmIdSeparator(IdSeparatorVar.GetOpt) ;\n    begin\n      if Enable then\n        (AlertLogJustifyAmountVar, ReportJustifyAmountVar) := CalcJustify(AlertLogID, 0, 0, Separator'length) ;\n      else\n        AlertLogJustifyAmountVar := 0 ;\n        ReportJustifyAmountVar   := 0 ;\n      end if;\n    end procedure SetJustify ;\n\n    ------------------------------------------------------------\n    impure function GetAlertCount(AlertLogID : AlertLogIDType := ALERTLOG_BASE_ID) return AlertCountType is\n    ------------------------------------------------------------\n      variable localAlertLogID : AlertLogIDType ;\n    begin\n      localAlertLogID := VerifyID(AlertLogID) ;\n      return AlertLogPtr(localAlertLogID).AlertCount ;\n    end function GetAlertCount ;\n\n    ------------------------------------------------------------\n    -- Local\n    impure function RemoveNonFailingWarnings(A : AlertCountType) return AlertCountType is\n    ------------------------------------------------------------\n      variable Count : AlertCountType ;\n    begin\n      Count := A ;\n      if not FailOnWarningVar then\n        Count(WARNING) := 0 ;\n      end if ;\n      return Count ;\n    end function RemoveNonFailingWarnings ;\n\n    ------------------------------------------------------------\n    impure function GetEnabledAlertCount(AlertLogID : AlertLogIDType := ALERTLOG_BASE_ID) return AlertCountType is\n    ------------------------------------------------------------\n      variable localAlertLogID : AlertLogIDType ;\n      variable Count : AlertCountType ;\n    begin\n      localAlertLogID := VerifyID(AlertLogID) ;\n      return RemoveNonFailingWarnings( AlertLogPtr(localAlertLogID).AlertCount ) ;\n    end function GetEnabledAlertCount ;\n\n\n    ------------------------------------------------------------\n    impure function GetDisabledAlertCount return AlertCountType is\n    ------------------------------------------------------------\n      variable Count : AlertCountType := (others => 0) ;\n    begin\n      for i in ALERTLOG_BASE_ID to NumAlertLogIDsVar loop\n        Count := Count + AlertLogPtr(i).DisabledAlertCount ;\n--? Should excluded warnings get counted as disabled errors?\n--?        if not FailOnWarningVar then\n--?          Count(WARNING) := Count(WARNING) + AlertLogPtr(i).AlertCount(WARNING) ;\n--?        end if ;\n      end loop ;\n      return Count ;\n    end function GetDisabledAlertCount ;\n\n    ------------------------------------------------------------\n    impure function LocalGetDisabledAlertCount(AlertLogID: AlertLogIDType) return AlertCountType is\n    ------------------------------------------------------------\n      variable Count : AlertCountType ;\n      variable CurID : AlertLogIDType ;\n    begin\n      Count := AlertLogPtr(AlertLogID).DisabledAlertCount ;\n      -- Find Children of this ID\n      CurID := AlertLogPtr(AlertLogID).ChildID ;\n      while CurID > ALERTLOG_BASE_ID loop\n        Count := Count + LocalGetDisabledAlertCount(CurID) ; -- Recursively descend into children\n        CurID := AlertLogPtr(CurID).SiblingID ;\n      end loop ;\n      return Count ;\n    end function LocalGetDisabledAlertCount ;\n\n    ------------------------------------------------------------\n    impure function GetDisabledAlertCount(AlertLogID: AlertLogIDType) return AlertCountType is\n    ------------------------------------------------------------\n      variable localAlertLogID : AlertLogIDType ;\n    begin\n      localAlertLogID := VerifyID(AlertLogID) ;\n      return LocalGetDisabledAlertCount(localAlertLogID) ;\n    end function GetDisabledAlertCount ;\n\n    ------------------------------------------------------------\n    -- Local  GetRequirementsCount\n    --    Each bin contains a separate requirement\n    --    RequirementsGoal   = # of bins with PassedGoal > 0\n    --    RequirementsPassed = # bins with PassedGoal > 0 and PassedCount > PassedGoal\n    procedure GetRequirementsCount(\n      AlertLogID              : AlertLogIDType;\n      RequirementsPassed      : out integer ;\n      RequirementsGoal        : out integer\n    )  is\n    ------------------------------------------------------------\n      variable ChildRequirementsPassed, ChildRequirementsGoal  : integer ;\n      variable CurID : AlertLogIDType ;\n    begin\n      RequirementsPassed := 0 ;\n      RequirementsGoal   := 0 ;\n      if AlertLogPtr(AlertLogID).PassedGoal > 0 then\n        RequirementsGoal := 1 ;\n        if AlertLogPtr(AlertLogID).PassedCount >= AlertLogPtr(AlertLogID).PassedGoal then\n          RequirementsPassed := 1 ;\n        end if ;\n      end if ;\n      -- Find Children of this ID\n      CurID := AlertLogPtr(AlertLogID).ChildID ;\n      while CurID > ALERTLOG_BASE_ID loop\n        GetRequirementsCount(CurID, ChildRequirementsPassed, ChildRequirementsGoal) ;\n        RequirementsPassed := RequirementsPassed + ChildRequirementsPassed ;\n        RequirementsGoal   := RequirementsGoal   + ChildRequirementsGoal ;\n        CurID := AlertLogPtr(CurID).SiblingID ;\n      end loop ;\n    end procedure GetRequirementsCount ;\n\n    ------------------------------------------------------------\n-- Only used at top level and superceded by variables PassedCountVar AffirmCheckCountVar\n    -- Local\n    procedure GetPassedAffirmCount(\n      AlertLogID       : AlertLogIDType;\n      PassedCount      : out integer ;\n      AffirmCount      : out integer\n    )  is\n    ------------------------------------------------------------\n      variable ChildPassedCount, ChildAffirmCount  : integer ;\n      variable CurID : AlertLogIDType ;\n    begin\n      PassedCount   := AlertLogPtr(AlertLogID).PassedCount ;\n      AffirmCount   := AlertLogPtr(AlertLogID).AffirmCount ;\n      -- Find Children of this ID\n      CurID := AlertLogPtr(AlertLogID).ChildID ;\n      while CurID > ALERTLOG_BASE_ID loop\n        GetPassedAffirmCount(CurID, ChildPassedCount, ChildAffirmCount) ;\n        PassedCount := PassedCount + ChildPassedCount ;\n        AffirmCount := AffirmCount + ChildAffirmCount ;\n        CurID := AlertLogPtr(CurID).SiblingID ;\n      end loop ;\n    end procedure GetPassedAffirmCount ;\n\n    ------------------------------------------------------------\n    -- Local\n    procedure CalcTopTotalErrors (\n    ------------------------------------------------------------\n      constant ExternalErrors           : in  AlertCountType ;\n      variable TotalErrors              : out integer ;\n      variable TotalAlertCount          : out AlertCountType ;\n      variable TotalRequirementsPassed  : out integer ;\n      variable TotalRequirementsCount   : out integer\n    ) is\n      variable DisabledAlertCount : AlertCountType ;\n      variable TotalAlertErrors, TotalDisabledAlertErrors : integer ;\n      variable TotalRequirementErrors : integer ;\n    begin\n      TotalAlertCount        := AlertLogPtr(ALERTLOG_BASE_ID).AlertCount + ExternalErrors ;\n      TotalAlertErrors       := SumAlertCount( RemoveNonFailingWarnings(TotalAlertCount)) ;\n      TotalErrors            := TotalAlertErrors ;\n\n      DisabledAlertCount        := GetDisabledAlertCount(ALERTLOG_BASE_ID) ;\n      TotalDisabledAlertErrors  := SumAlertCount( RemoveNonFailingWarnings(DisabledAlertCount) ) ;\n      if FailOnDisabledErrorsVar then\n        TotalAlertCount := TotalAlertCount + DisabledAlertCount ;\n        TotalErrors := TotalErrors + TotalDisabledAlertErrors ;\n      end if ;\n\n      -- Perspective, 1 requirement per bin\n      GetRequirementsCount(ALERTLOG_BASE_ID, TotalRequirementsPassed, TotalRequirementsCount) ;\n      TotalRequirementErrors := TotalRequirementsCount - TotalRequirementsPassed ;\n      if FailOnRequirementErrorsVar then\n        TotalErrors := TotalErrors + TotalRequirementErrors ;\n      end if ;\n\n      -- Set AffirmCount for top level\n      AlertLogPtr(ALERTLOG_BASE_ID).PassedCount := PassedCountVar ;\n      AlertLogPtr(ALERTLOG_BASE_ID).AffirmCount := AffirmCheckCountVar ;\n    end procedure CalcTopTotalErrors ;\n\n    ------------------------------------------------------------\n    -- Local\n    impure function CalcTotalErrors (AlertLogID : AlertLogIDType) return integer is\n    ------------------------------------------------------------\n      variable TotalErrors : integer ;\n      variable TotalAlertCount, DisabledAlertCount : AlertCountType ;\n      variable TotalAlertErrors, TotalDisabledAlertErrors : integer ;\n      variable TotalRequirementErrors : integer ;\n      variable TotalRequirementsPassed, TotalRequirementsCount : integer ;\n    begin\n      TotalAlertCount        := AlertLogPtr(AlertLogID).AlertCount ;\n      TotalAlertErrors       := SumAlertCount( RemoveNonFailingWarnings(TotalAlertCount)) ;\n      TotalErrors            := TotalAlertErrors ;\n\n      DisabledAlertCount        := GetDisabledAlertCount(AlertLogID) ;\n      TotalDisabledAlertErrors  := SumAlertCount( RemoveNonFailingWarnings(DisabledAlertCount) ) ;\n      if FailOnDisabledErrorsVar then\n        TotalErrors := TotalErrors + TotalDisabledAlertErrors ;\n      end if ;\n\n      -- Perspective, 1 requirement per bin\n      GetRequirementsCount(AlertLogID, TotalRequirementsPassed, TotalRequirementsCount) ;\n      TotalRequirementErrors := TotalRequirementsCount - TotalRequirementsPassed ;\n      if FailOnRequirementErrorsVar then\n        TotalErrors := TotalErrors + TotalRequirementErrors ;\n      end if ;\n\n      return TotalErrors ;\n    end function CalcTotalErrors ;\n\n    ------------------------------------------------------------\n    -- PT Local\n    procedure PrintTopAlerts (\n    ------------------------------------------------------------\n      AlertLogID                  : AlertLogIDType ;\n      Name                        : string ;\n      ExternalErrors              : AlertCountType ;\n      variable HasDisabledAlerts  : inout Boolean ;\n      variable TestFailed         : inout Boolean\n    ) is\n--      constant ReportPrefix    : string := ResolveOsvvmWritePrefix(ReportPrefixVar.GetOpt ) ;\n--      constant DoneName        : string := ResolveOsvvmDoneName(DoneNameVar.GetOpt     ) ;\n--      constant PassName        : string := ResolveOsvvmPassName(PassNameVar.GetOpt     ) ;\n--      constant FailName        : string := ResolveOsvvmFailName(FailNameVar.GetOpt     ) ;\n      variable buf : line ;\n      variable TotalErrors : integer ;\n      variable TotalAlertErrors, TotalDisabledAlertErrors : integer ;\n      variable TotalRequirementsPassed, TotalRequirementsGoal, TotalRequirementErrors : integer ;\n      variable AlertCountVar, DisabledAlertCount : AlertCountType ;\n      variable PassedCount, AffirmCheckCount : integer ;\n    begin\n--!!\n--!! Update to use CalcTopTotalErrors\n--!!\n      AlertCountVar     := AlertLogPtr(AlertLogID).AlertCount + ExternalErrors ;\n      TotalAlertErrors  := SumAlertCount( RemoveNonFailingWarnings(AlertCountVar)) ;\n\n      DisabledAlertCount        := GetDisabledAlertCount(AlertLogID) ;\n      TotalDisabledAlertErrors  := SumAlertCount( RemoveNonFailingWarnings(DisabledAlertCount) ) ;\n      HasDisabledAlerts         := TotalDisabledAlertErrors /= 0 ;\n\n      GetRequirementsCount(AlertLogID, TotalRequirementsPassed, TotalRequirementsGoal) ;\n      TotalRequirementErrors := TotalRequirementsGoal - TotalRequirementsPassed ;\n\n      TotalErrors := TotalAlertErrors ;\n      if FailOnDisabledErrorsVar then\n        TotalErrors := TotalErrors + TotalDisabledAlertErrors ;\n      end if ;\n      if FailOnRequirementErrorsVar then\n        TotalErrors := TotalErrors + TotalRequirementErrors ;\n      end if ;\n\n      TestFailed := TotalErrors /= 0 ;\n\n      GetPassedAffirmCount(AlertLogID, PassedCount, AffirmCheckCount) ;\n\n      write(buf, ResolveOsvvmWritePrefix(ReportPrefixVar.GetOpt)) ;\n      if not WriteTimeLastVar then\n        write(buf, justify(to_string(NOW, 1 ns), TimeJustifyAmountVar, RIGHT) & \"    \") ;\n      end if ;\n\n      if not TestFailed then\n        write(buf, \n          ResolveOsvvmDoneName(DoneNameVar.GetOpt) & \"   \" &  -- DoneName\n          ResolveOsvvmPassName(PassNameVar.GetOpt) & \"   \" &  -- PassName\n          Name\n        ) ;\n      else\n        write(buf,\n          ResolveOsvvmDoneName(DoneNameVar.GetOpt) & \"   \" &  -- DoneName\n          ResolveOsvvmFailName(FailNameVar.GetOpt) & \"   \" &  -- FailName\n          Name\n        ) ;\n      end if ;\n--?  Also print when warnings exist and are hidden by FailOnWarningVar=FALSE\n      if TestFailed then\n        write(buf, \"  Total Error(s) = \" & to_string(TotalErrors) ) ;\n        write(buf, \"  Failures: \"        & to_string(AlertCountVar(FAILURE)) ) ;\n        write(buf, \"  Errors: \"          & to_string(AlertCountVar(ERROR) ) ) ;\n        write(buf, \"  Warnings: \"        & to_string(AlertCountVar(WARNING) ) ) ;\n      end if ;\n      if HasDisabledAlerts or PrintDisabledAlertsVar then   -- print if exist or enabled\n          write(buf, \"   Total Disabled Error(s) = \" & to_string(TotalDisabledAlertErrors)) ;\n      end if ;\n      if (HasDisabledAlerts and FailOnDisabledErrorsVar) or PrintDisabledAlertsVar then  -- print if enabled\n        write(buf, \"  Failures: \"  & to_string(DisabledAlertCount(FAILURE)) ) ;\n        write(buf, \"  Errors: \"    & to_string(DisabledAlertCount(ERROR) ) ) ;\n        write(buf, \"  Warnings: \"  & to_string(DisabledAlertCount(WARNING) ) ) ;\n      end if ;\n      if PrintPassedVar or (AffirmCheckCount /= 0) or PrintAffirmationsVar then -- Print if passed or printing affirmations\n        write(buf, \"  Passed: \" & to_string(PassedCount)) ;\n      end if;\n      if (AffirmCheckCount /= 0) or PrintAffirmationsVar then\n        write(buf, \"  Affirmations Checked: \" & to_string(AffirmCheckCount)) ;\n      end if ;\n      if  PrintRequirementsVar or\n          (PrintIfHaveRequirementsVar and HasRequirementsVar) or\n          (FailOnRequirementErrorsVar and TotalRequirementErrors /= 0)\n      then\n        write(buf, \"  Requirements Passed: \" & to_string(TotalRequirementsPassed) &\n                   \" of \" & to_string(TotalRequirementsGoal) ) ;\n      end if ;\n      if WriteTimeLastVar then\n        write(buf, \"  at \" & to_string(NOW, 1 ns)) ;\n      end if ;\n      WriteLine(buf) ;\n    end procedure PrintTopAlerts ;\n\n    ------------------------------------------------------------\n    -- PT Local\n    procedure PrintOneChild(\n    ------------------------------------------------------------\n      AlertLogID        : AlertLogIDType ;\n      Prefix            : string ;\n      IndentAmount      : integer ;\n      ReportWhenZero    : boolean ;\n      HasErrors         : boolean ;\n      HasDisabledErrors : boolean\n    ) is\n      variable buf : line ;\n      alias CurID  : AlertLogIDType is AlertLogID ;\n    begin\n      if ReportWhenZero or HasErrors then\n        write(buf, Prefix &  \" \"   & LeftJustify(AlertLogPtr(CurID).Name.all, ReportJustifyAmountVar - IndentAmount)) ;\n        write(buf, \"  Failures: \"  & to_string(AlertLogPtr(CurID).AlertCount(FAILURE) ) ) ;\n        write(buf, \"  Errors: \"    & to_string(AlertLogPtr(CurID).AlertCount(ERROR) ) ) ;\n        write(buf, \"  Warnings: \"  & to_string(AlertLogPtr(CurID).AlertCount(WARNING) ) ) ;\n        if (HasDisabledErrors and FailOnDisabledErrorsVar) or PrintDisabledAlertsVar then\n          write(buf, \"  Disabled Failures: \"  & to_string(AlertLogPtr(CurID).DisabledAlertCount(FAILURE) ) ) ;\n          write(buf, \"  Errors: \"    & to_string(AlertLogPtr(CurID).DisabledAlertCount(ERROR) ) ) ;\n          write(buf, \"  Warnings: \"  & to_string(AlertLogPtr(CurID).DisabledAlertCount(WARNING) ) ) ;\n        end if ;\n        if PrintPassedVar or PrintRequirementsVar then\n          write(buf, \"  Passed: \" & to_string(AlertLogPtr(CurID).PassedCount)) ;\n        end if;\n        if PrintRequirementsVar then\n          write(buf, \" of \" & to_string(AlertLogPtr(CurID).PassedGoal) ) ;\n        end if ;\n        if PrintAffirmationsVar then\n          write(buf, \"  Affirmations: \"  & to_string(AlertLogPtr(CurID).AffirmCount ) ) ;\n        end if ;\n        WriteLine(buf) ;\n      end if ;\n    end procedure PrintOneChild ;\n\n    ------------------------------------------------------------\n    -- PT Local\n    procedure IterateAndPrintChildren(\n    ------------------------------------------------------------\n      AlertLogID        : AlertLogIDType ;\n      Prefix            : string ;\n      IndentAmount      : integer ;\n      ReportWhenZero    : boolean ;\n      HasDisabledErrors : boolean\n    ) is\n      variable buf : line ;\n      variable CurID : AlertLogIDType ;\n      variable HasErrors : boolean ;\n    begin\n      CurID := AlertLogPtr(AlertLogID).ChildID ;\n      while CurID > ALERTLOG_BASE_ID loop\n        -- Don't print requirements if there no requirements\n        if CurID = REQUIREMENT_ALERTLOG_ID and HasRequirementsVar = FALSE then\n          CurID := AlertLogPtr(CurID).SiblingID ;\n          next ;\n        end if ;\n        HasErrors :=\n          (SumAlertCount(AlertLogPtr(CurID).AlertCount) > 0) or\n          (FailOnDisabledErrorsVar and (SumAlertCount(AlertLogPtr(CurID).DisabledAlertCount) > 0)) or\n          (FailOnRequirementErrorsVar and (AlertLogPtr(CurID).PassedCount < AlertLogPtr(CurID).PassedGoal)) ;\n\n        if AlertLogPtr(CurID).ReportMode = ENABLED or (AlertLogPtr(CurID).ReportMode = NONZERO and HasErrors) then\n          PrintOneChild(\n            AlertLogID         => CurID,\n            Prefix             => Prefix,\n            IndentAmount       => IndentAmount,\n            ReportWhenZero     => ReportWhenZero,\n            HasErrors          => HasErrors,\n            HasDisabledErrors  => HasDisabledErrors\n          ) ;\n          IterateAndPrintChildren(\n            AlertLogID         => CurID,\n            Prefix             => Prefix & \"  \",\n            IndentAmount       => IndentAmount + 2,\n            ReportWhenZero     => ReportWhenZero,\n            HasDisabledErrors  => HasDisabledErrors\n          ) ;\n        end if ;\n        CurID := AlertLogPtr(CurID).SiblingID ;\n      end loop ;\n    end procedure IterateAndPrintChildren ;\n\n    ------------------------------------------------------------\n    procedure ReportAlerts (\n      Name           : string := OSVVM_STRING_INIT_PARM_DETECT ;\n      AlertLogID     : AlertLogIDType := ALERTLOG_BASE_ID ;\n      ExternalErrors : AlertCountType := (0,0,0) ;\n      ReportAll      : boolean := FALSE ;\n      ReportWhenZero : boolean := TRUE\n    ) is\n    ------------------------------------------------------------\n      variable TestFailed, HasDisabledErrors : boolean ;\n      -- constant ReportPrefix : string := ResolveOsvvmWritePrefix(ReportPrefixVar.GetOpt) ;\n      variable TurnedOnJustify : boolean := FALSE ;\n      variable localAlertLogID : AlertLogIDType ;\n    begin\n      localAlertLogID := VerifyID(AlertLogID) ;\n      if ReportJustifyAmountVar <= 0 then\n        TurnedOnJustify := TRUE ;\n        SetJustify ;\n      end if ;\n\n      if IsOsvvmStringSet(Name) then\n        PrintTopAlerts (\n          AlertLogID         => localAlertLogID,\n          Name               => Name,\n          ExternalErrors     => ExternalErrors,\n          HasDisabledAlerts  => HasDisabledErrors,\n          TestFailed         => TestFailed\n        ) ;\n      else\n        PrintTopAlerts (\n          AlertLogID         => localAlertLogID,\n          Name               => AlertLogPtr(localAlertLogID).Name.all,\n          ExternalErrors     => ExternalErrors,\n          HasDisabledAlerts  => HasDisabledErrors,\n          TestFailed         => TestFailed\n        ) ;\n      end if ;\n      --Print Hierarchy when enabled and test failed\n      if ReportAll or (FoundReportHierVar and ReportHierarchyVar and TestFailed) then\n      -- (NumErrors /= 0 or (NumDisabledErrors /=0 and FailOnDisabledErrorsVar)) then\n        IterateAndPrintChildren(\n          AlertLogID         => localAlertLogID,\n--          Prefix             => ReportPrefix & \"  \",\n          Prefix             => ResolveOsvvmWritePrefix(ReportPrefixVar.GetOpt) & \"  \",\n          IndentAmount       => 2,\n          ReportWhenZero     => ReportAll or ReportWhenZero,\n          HasDisabledErrors  => HasDisabledErrors -- NumDisabledErrors /= 0\n        ) ;\n      end if ;\n      if TurnedOnJustify then\n        -- Turn it back off\n        SetJustify(FALSE) ;\n      end if ;\n    end procedure ReportAlerts ;\n\n    ------------------------------------------------------------\n    procedure ReportRequirements is\n    ------------------------------------------------------------\n      variable TestFailed, HasDisabledErrors : boolean ;\n--      constant ReportPrefix : string := ResolveOsvvmWritePrefix(ReportPrefixVar.GetOpt) ;\n      variable TurnedOnJustify : boolean := FALSE ;\n      variable SavedPrintRequirementsVar : boolean ;\n    begin\n      SavedPrintRequirementsVar := PrintRequirementsVar ;\n      PrintRequirementsVar := TRUE ;\n\n      if ReportJustifyAmountVar <= 0 then\n        TurnedOnJustify := TRUE ;\n        SetJustify ;\n      end if ;\n      PrintTopAlerts (\n        AlertLogID         => ALERTLOG_BASE_ID,\n        Name               => AlertLogPtr(ALERTLOG_BASE_ID).Name.all,\n        ExternalErrors     => (0,0,0),\n        HasDisabledAlerts  => HasDisabledErrors,\n        TestFailed         => TestFailed\n      ) ;\n      IterateAndPrintChildren(\n        AlertLogID         => REQUIREMENT_ALERTLOG_ID,\n--        Prefix             => ReportPrefix & \"  \",\n        Prefix             => ResolveOsvvmWritePrefix(ReportPrefixVar.GetOpt) & \"  \",\n        IndentAmount       => 2,\n        ReportWhenZero     => TRUE,\n        HasDisabledErrors  => HasDisabledErrors -- NumDisabledErrors /= 0\n      ) ;\n      if TurnedOnJustify then\n        -- Turn it back off\n        SetJustify(FALSE) ;\n      end if ;\n      PrintRequirementsVar := SavedPrintRequirementsVar ;\n    end procedure ReportRequirements ;\n\n    ------------------------------------------------------------\n    procedure ReportAlerts ( Name : string ; AlertCount : AlertCountType ) is\n    ------------------------------------------------------------\n      -- constant ReportPrefix    : string := ResolveOsvvmWritePrefix(ReportPrefixVar.GetOpt ) ;\n      -- constant DoneName        : string := ResolveOsvvmDoneName(DoneNameVar.GetOpt     ) ;\n      -- constant PassName        : string := ResolveOsvvmPassName(PassNameVar.GetOpt     ) ;\n      -- constant FailName        : string := ResolveOsvvmFailName(FailNameVar.GetOpt     ) ;\n      variable buf : line ;\n      variable NumErrors : integer ;\n    begin\n      NumErrors := SumAlertCount(AlertCount) ;\n      if  NumErrors = 0 then\n        -- Passed\n        -- write(buf, ReportPrefix & DoneName & \"  \" & PassName & \"  \" & Name) ;\n        write(buf,\n          ResolveOsvvmWritePrefix(ReportPrefixVar.GetOpt ) & -- ReportPrefix\n          ResolveOsvvmDoneName(DoneNameVar.GetOpt) & \"  \" &  -- DoneName\n          ResolveOsvvmPassName(PassNameVar.GetOpt) & \"  \" &  -- PassName\n          Name\n        ) ;\n        write(buf, \"  at \"  & to_string(NOW, 1 ns)) ;\n        WriteLine(buf) ;\n      else\n        -- Failed\n        -- write(buf, ReportPrefix & DoneName & \"  \" & FailName & \"  \"& Name) ;\n        write(buf,\n          ResolveOsvvmWritePrefix(ReportPrefixVar.GetOpt ) & -- ReportPrefix\n          ResolveOsvvmDoneName(DoneNameVar.GetOpt) & \"  \" &  -- DoneName\n          ResolveOsvvmFailName(FailNameVar.GetOpt) & \"  \" &  -- FailName\n          Name\n        ) ;\n        write(buf, \"  Total Error(s) = \"      & to_string(NumErrors) ) ;\n        write(buf, \"  Failures: \"  & to_string(AlertCount(FAILURE)) ) ;\n        write(buf, \"  Errors: \"    & to_string(AlertCount(ERROR) ) ) ;\n        write(buf, \"  Warnings: \"  & to_string(AlertCount(WARNING) ) ) ;\n        write(buf, \"  at \"  & to_string(NOW, 1 ns)) ;\n        writeLine(buf) ;\n      end if ;\n    end procedure ReportAlerts ;\n\n    ------------------------------------------------------------\n    --  pt local\n    procedure WriteOneAlertYaml (\n    ------------------------------------------------------------\n      file TestFile : text ;\n      AlertLogID           : AlertLogIDType ;\n      TotalErrors          : integer ;\n      RequirementsPassed   : integer ;\n      RequirementsGoal     : integer ;\n      FirstPrefix          : string := \"\" ;\n      Prefix               : string := \"\"\n    ) is\n      variable buf : line ;\n      constant DELIMITER : string := \", \" ;\n    begin\n      Write(buf,\n        FirstPrefix & \"Name: \" & '\"' & AlertLogPtr(AlertLogID).Name.all & '\"'  & LF  &\n        Prefix & \"Status: \" & IfElse(TotalErrors=0, \"PASSED\", \"FAILED\")        & LF  &\n        Prefix & \"Results: {\" &\n          \"TotalErrors: \"        & to_string( TotalErrors )          & DELIMITER &\n          \"AlertCount: {\" &\n            \"Failure: \"            & to_string( AlertLogPtr(AlertLogID).AlertCount(FAILURE) )  & DELIMITER &\n            \"Error: \"              & to_string( AlertLogPtr(AlertLogID).AlertCount(ERROR) )    & DELIMITER &\n            \"Warning: \"            & to_string( AlertLogPtr(AlertLogID).AlertCount(WARNING) )  &\n          \"}\" & DELIMITER &\n          \"PassedCount: \"        & to_string( AlertLogPtr(AlertLogID).PassedCount )          & DELIMITER &\n          \"AffirmCount: \"        & to_string( AlertLogPtr(AlertLogID).AffirmCount )          & DELIMITER &\n          \"RequirementsPassed: \" & to_string( RequirementsPassed )   & DELIMITER &\n          \"RequirementsGoal: \"   & to_string( RequirementsGoal )     & DELIMITER &\n          \"DisabledAlertCount: {\" &\n            \"Failure: \"            & to_string( AlertLogPtr(AlertLogID).DisabledAlertCount(FAILURE) )  & DELIMITER &\n            \"Error: \"              & to_string( AlertLogPtr(AlertLogID).DisabledAlertCount(ERROR) )    & DELIMITER &\n            \"Warning: \"            & to_string( AlertLogPtr(AlertLogID).DisabledAlertCount(WARNING) )  &\n          \"}\" &\n        \"}\"\n      ) ;\n      WriteLine(TestFile, buf) ;\n    end procedure WriteOneAlertYaml ;\n\n    ------------------------------------------------------------\n    -- PT Local\n    procedure IterateAndWriteChildrenYaml(\n    ------------------------------------------------------------\n      file TestFile     : text ;\n      AlertLogID        : AlertLogIDType ;\n      Prefix            : string\n    ) is\n      variable buf : line ;\n      variable CurID : AlertLogIDType ;\n      variable RequirementsPassed, RequirementsGoal : integer ;\n    begin\n      CurID := AlertLogPtr(AlertLogID).ChildID ;\n      if CurID >= ALERTLOG_BASE_ID then\n        -- Write \"Children:\" at current level\n        Write(buf, Prefix & \"Children: \" ) ;\n        WriteLine(TestFile, buf) ;\n        while CurID > ALERTLOG_BASE_ID loop\n          -- Don't print requirements if there no requirements\n          if CurID = REQUIREMENT_ALERTLOG_ID and HasRequirementsVar = FALSE then\n            CurID := AlertLogPtr(CurID).SiblingID ;\n            next ;\n          end if ;\n          RequirementsGoal   := AlertLogPtr(CurID).PassedGoal ;\n          if AlertLogPtr(CurID).PassedGoalSet and (RequirementsGoal > 0) then\n            RequirementsPassed := AlertLogPtr(CurID).PassedCount ;\n          else\n            RequirementsPassed := 0 ;\n            RequirementsGoal   := 0 ;\n          end if ;\n          if AlertLogPtr(CurID).ReportMode /= DISABLED then\n            WriteOneAlertYaml(\n              TestFile             => TestFile,\n              AlertLogID           => CurID,\n              TotalErrors          => CalcTotalErrors(CurID),\n              RequirementsPassed   => RequirementsPassed,\n              RequirementsGoal     => RequirementsGoal,\n              FirstPrefix          => Prefix & \"  - \",\n              Prefix               => Prefix & \"    \"\n            ) ;\n            IterateAndWriteChildrenYaml(\n              TestFile             => TestFile,\n              AlertLogID           => CurID,\n              Prefix               => Prefix & \"    \"\n            ) ;\n          end if ;\n          CurID := AlertLogPtr(CurID).SiblingID ;\n        end loop ;\n      else\n        -- No Children, Print Empty List\n        Write(buf, Prefix & \"Children: {}\" ) ;\n        WriteLine(TestFile, buf) ;\n      end if ;\n    end procedure IterateAndWriteChildrenYaml ;\n\n    ------------------------------------------------------------\n    --  pt local\n    procedure WriteSettingsYaml (\n    ------------------------------------------------------------\n      file TestFile  : text ;\n      ExternalErrors : AlertCountType ;\n      Prefix         : string := \"\"\n    ) is\n      variable buf : line ;\n      constant DELIMITER : string := \", \" ;\n    begin\n      Write(buf,\n        Prefix & \"Settings: {\" &\n          \"ExternalErrors: {\" &\n            \"Failure: \"                & '\"' & to_string( ExternalErrors(FAILURE) )  & '\"'  & DELIMITER &\n            \"Error: \"                  & '\"' & to_string( ExternalErrors(ERROR) )    & '\"'  & DELIMITER &\n            \"Warning: \"                & '\"' & to_string( ExternalErrors(WARNING) )  & '\"'  &\n          \"}\" & DELIMITER &\n          \"FailOnDisabledErrors: \"     & '\"' & to_string( FailOnDisabledErrorsVar )     & '\"' & DELIMITER &\n          \"FailOnRequirementErrors: \"  & '\"' & to_string( FailOnRequirementErrorsVar )  & '\"' & DELIMITER &\n          \"FailOnWarning: \"            & '\"' & to_string( FailOnWarningVar )   & '\"' &\n        \"}\"\n      ) ;\n      WriteLine(TestFile, buf) ;\n    end procedure WriteSettingsYaml ;\n\n\n    ------------------------------------------------------------\n    --  pt local\n    procedure WriteAlertYaml (\n    ------------------------------------------------------------\n      file TestFile  : text ;\n      ExternalErrors : AlertCountType ;\n      Prefix         : string ;\n      PrintSettings  : boolean ;\n      PrintChildren  : boolean\n    ) is\n      -- Format:  Action Count min1 max1 min2 max2\n      variable TotalErrors : integer ;\n      variable TotalAlertCount : AlertCountType ;\n      variable TotalRequirementsPassed, TotalRequirementsCount : integer ;\n    begin\n      CalcTopTotalErrors (\n        ExternalErrors           => ExternalErrors         ,\n        TotalErrors              => TotalErrors            ,\n        TotalAlertCount          => TotalAlertCount        ,\n        TotalRequirementsPassed  => TotalRequirementsPassed,\n        TotalRequirementsCount   => TotalRequirementsCount\n      ) ;\n\n      WriteOneAlertYaml (\n        TestFile                 => TestFile,\n        AlertLogID               => ALERTLOG_BASE_ID,\n        TotalErrors              => TotalErrors,\n        RequirementsPassed       => TotalRequirementsPassed,\n        RequirementsGoal         => TotalRequirementsCount,\n        FirstPrefix              => Prefix,\n        Prefix                   => Prefix\n      ) ;\n      if PrintSettings then\n        WriteSettingsYaml(\n          TestFile               => TestFile,\n          ExternalErrors         => ExternalErrors,\n          Prefix                 => Prefix\n        ) ;\n      end if ;\n      if PrintChildren then\n        IterateAndWriteChildrenYaml(\n          TestFile             => TestFile,\n          AlertLogID           => ALERTLOG_BASE_ID,\n          Prefix               => Prefix\n        ) ;\n      end if ;\n    end procedure WriteAlertYaml ;\n\n    ------------------------------------------------------------\n    procedure WriteAlertYaml (\n    ------------------------------------------------------------\n      FileName       : string ;\n      ExternalErrors : AlertCountType := (0,0,0) ;\n      Prefix         : string := \"\" ;\n      PrintSettings  : boolean := TRUE ;\n      PrintChildren  : boolean := TRUE ;\n      OpenKind       : File_Open_Kind := WRITE_MODE\n    ) is\n      file     FileID : text ;\n      variable status : file_open_status ;\n    begin\n      file_open(status, FileID, FileName, OpenKind) ;\n      if status = OPEN_OK then\n        WriteAlertYaml(FileID, ExternalErrors, Prefix, PrintSettings, PrintChildren) ;\n        file_close(FileID) ;\n      else\n        Alert(\"WriteAlertYaml, File: \" & FileName & \" did not open for \" & to_string(OpenKind)) ;\n      end if ;\n    end procedure WriteAlertYaml ;\n\n    ------------------------------------------------------------\n    --  pt local\n    procedure WriteOneRequirementYaml (\n    ------------------------------------------------------------\n      file TestFile : text ;\n      AlertLogID           : AlertLogIDType \n    ) is\n      variable buf : line ;\n      constant DELIMITER : string := \", \" ;\n      constant FIRST_PREFIX : string := \"- \" ;\n      constant PREFIX       : string := \"  \" ;\n      variable RequirementsGoal, RequirementsPassed, TotalErrors : integer ; \n    begin\n      RequirementsGoal   := AlertLogPtr(AlertLogID).PassedGoal ;\n      RequirementsPassed := AlertLogPtr(AlertLogID).PassedCount ;\n      -- Requirements count any error as an error and a failure of the requirement\n      TotalErrors := SumAlertCount(AlertLogPtr(AlertLogID).AlertCount + AlertLogPtr(AlertLogID).DisabledAlertCount) ;\n      Write(buf,\n        FIRST_PREFIX & \"Requirement: \" & '\"' & AlertLogPtr(AlertLogID).Name.all & '\"'  & LF  &\n        PREFIX & \"TestCases: \" &  LF  &\n        \"  \" & FIRST_PREFIX & \"TestName: \" & '\"' & GetTestName & '\"'  & LF  &\n--        \"  \" & PREFIX & \"Status: \" & IfElse(TotalErrors>0, \"FAILED\", IfElse(RequirementsPassed >= RequirementsGoal, \"PASSED\", \"TBD\"))  & LF  &\n        \"  \" & PREFIX & \"Status: \" & IfElse(TotalErrors>0, \"FAILED\", \"PASSED\")  & LF  &\n        \"  \" & PREFIX & \"Results: {\" &\n          \"Goal: \"               & to_string( RequirementsGoal )     & DELIMITER &\n          \"Passed: \"             & to_string( RequirementsPassed )   & DELIMITER &\n          \"Errors: \"             & to_string( TotalErrors )          & DELIMITER &\n          \"Checked: \"            & to_string( AlertLogPtr(AlertLogID).AffirmCount )            & DELIMITER &\n          \"AlertCount: {\" &\n            \"Failure: \"            & to_string( AlertLogPtr(AlertLogID).AlertCount(FAILURE) )  & DELIMITER &\n            \"Error: \"              & to_string( AlertLogPtr(AlertLogID).AlertCount(ERROR) )    & DELIMITER &\n            \"Warning: \"            & to_string( AlertLogPtr(AlertLogID).AlertCount(WARNING) )  &\n          \"}\" & DELIMITER &\n          \"DisabledAlertCount: {\" &\n            \"Failure: \"            & to_string( AlertLogPtr(AlertLogID).DisabledAlertCount(FAILURE) )  & DELIMITER &\n            \"Error: \"              & to_string( AlertLogPtr(AlertLogID).DisabledAlertCount(ERROR) )    & DELIMITER &\n            \"Warning: \"            & to_string( AlertLogPtr(AlertLogID).DisabledAlertCount(WARNING) )  &\n          \"}\" &\n        \"}\"\n      ) ;\n      WriteLine(TestFile, buf) ;\n    end procedure WriteOneRequirementYaml ;\n    \n    ------------------------------------------------------------\n    -- PT Local\n    procedure IterateAndWriteRequirementsYaml(\n    ------------------------------------------------------------\n      file TestFile     : text ;\n      AlertLogID        : AlertLogIDType \n    ) is\n      variable buf : line ;\n      variable CurID : AlertLogIDType ;\n      variable RequirementsPassed, RequirementsGoal : integer ;\n    begin\n      CurID := AlertLogPtr(AlertLogID).ChildID ;\n      while CurID > ALERTLOG_BASE_ID loop\n        -- Don't print requirements if there no requirements\n        if CurID = REQUIREMENT_ALERTLOG_ID and HasRequirementsVar = FALSE then\n          CurID := AlertLogPtr(CurID).SiblingID ;\n          next ;\n        end if ;\n        WriteOneRequirementYaml(\n          TestFile             => TestFile,\n          AlertLogID           => CurID\n        ) ;\n        -- Requirements generally do not have children, so it is unlikely more will be found\n        IterateAndWriteRequirementsYaml(\n          TestFile             => TestFile,\n          AlertLogID           => CurID\n        ) ;\n        CurID := AlertLogPtr(CurID).SiblingID ;\n      end loop ;\n    end procedure IterateAndWriteRequirementsYaml ;\n\n--     ------------------------------------------------------------\n--     --  pt local\n--     procedure WriteRequirementsYaml (\n--     ------------------------------------------------------------\n--       file TestFile  : text ;\n--       AlertLogID     : AlertLogIDType \n--     ) is\n--       variable buf : line ;\n--     begin\n-- --      swrite(buf, \"Requirements: \" ) ;\n-- --      WriteLine(TestFile, buf) ;\n-- \n--       IterateAndWriteRequirementsYaml(\n--         TestFile             => TestFile,\n--         AlertLogID           => AlertLogID\n--       ) ;\n--     end procedure WriteRequirementsYaml ;\n\n    ------------------------------------------------------------\n    procedure WriteRequirementsYaml (\n    ------------------------------------------------------------\n      FileName    : string ;\n      AlertLogID  : AlertLogIDType ;\n      OpenKind    : File_Open_Kind\n    ) is\n      file     FileID : text ;\n      variable status : file_open_status ;\n    begin\n      file_open(status, FileID, FileName, OpenKind) ;\n      if status = OPEN_OK then\n--        WriteRequirementsYaml(FileID, AlertLogID) ;\n        IterateAndWriteRequirementsYaml(FileID, AlertLogID) ;\n        file_close(FileID) ;\n      else\n        Alert(\"WriteRequirementsYaml, File: \" & FileName & \" did not open for \" & to_string(OpenKind)) ;\n      end if ;\n    end procedure WriteRequirementsYaml ;\n\n    ------------------------------------------------------------\n    impure function GotRequirements return boolean is\n    ------------------------------------------------------------\n    begin\n      return HasRequirementsVar ;\n    end function GotRequirements ;\n\n    ------------------------------------------------------------\n    -- PT Local\n    impure function IsRequirement(AlertLogID : AlertLogIDType) return boolean is\n    ------------------------------------------------------------\n    begin\n      if AlertLogID = REQUIREMENT_ALERTLOG_ID then\n        return TRUE ;\n      elsif AlertLogID <= ALERTLOG_BASE_ID then\n        return FALSE ;\n      else\n        return IsRequirement(AlertLogPtr(AlertLogID).ParentID) ;\n      end if ;\n    end function IsRequirement ;\n\n    ------------------------------------------------------------\n    --  pt local\n    procedure WriteOneTestSummary (\n    ------------------------------------------------------------\n      file TestFile : text ;\n      AlertLogID           : AlertLogIDType ;\n      RequirementsGoal     : integer ;\n      RequirementsPassed   : integer ;\n      TotalErrors          : integer ;\n      AlertCount           : AlertCountType ;\n      AffirmCount          : integer ;\n      PassedCount          : integer ;\n      Delimiter            : string ;\n      Prefix               : string := \"\" ;\n      Suffix               : string := \"\" ;\n      WriteFieldName       : boolean := FALSE\n    ) is\n      variable buf : line ;\n    begin\n-- Should disabled errors be included here?\n-- In the previous step, we counted DisabledErrors as a regular error if FailOnDisabledErrorsVar (default TRUE)\n\n      Write(buf,\n        Prefix &\n        IfElse(WriteFieldName, \"Status: \" & IfElse(TotalErrors=0, \"PASSED\", \"FAILED\") & LF, \"\")  &\n        IfElse(WriteFieldName, Prefix & \"Results: {Name: \", \"\") &\n        AlertLogPtr(AlertLogID).Name.all  & Delimiter &\n        IfElse(WriteFieldName, \"RequirementsGoal: \", \"\") &\n        to_string( RequirementsGoal )     & Delimiter &\n        IfElse(WriteFieldName, \"RequirementsPassed: \", \"\") &\n        to_string( RequirementsPassed )   & Delimiter &\n        IfElse(WriteFieldName, \"TotalErrors: \", \"\") &\n        to_string( TotalErrors )          & Delimiter &\n        IfElse(WriteFieldName, \"Failure: \", \"\") &\n        to_string( AlertCount(FAILURE) )  & Delimiter &\n        IfElse(WriteFieldName, \"Error: \", \"\") &\n        to_string( AlertCount(ERROR) )    & Delimiter &\n        IfElse(WriteFieldName, \"Warning: \", \"\") &\n        to_string( AlertCount(WARNING) )  & Delimiter &\n        IfElse(WriteFieldName, \"AffirmCount: \", \"\") &\n        to_string( AffirmCount )          & Delimiter &\n        IfElse(WriteFieldName, \"PassedCount: \", \"\") &\n        to_string( PassedCount ) &\n        IfElse(WriteFieldName, \"}\", \"\") &\n        Suffix\n      ) ;\n-- ##      Write(buf,\n-- ##        Prefix &\n-- ##        IfElse(WriteFieldName, \"Status: \" & IfElse(TotalErrors=0, \"PASSED\", \"FAILED\") & Delimiter, \"\")  &\n-- ##        IfElse(WriteFieldName, \"Name: \", \"\") &\n-- ##        AlertLogPtr(AlertLogID).Name.all  & Delimiter &\n-- ##        IfElse(WriteFieldName, \"RequirementsGoal: \", \"\") &\n-- ##        to_string( RequirementsGoal )     & Delimiter &\n-- ##        IfElse(WriteFieldName, \"RequirementsPassed: \", \"\") &\n-- ##        to_string( RequirementsPassed )   & Delimiter &\n-- ##        IfElse(WriteFieldName, \"TotalErrors: \", \"\") &\n-- ##        to_string( TotalErrors )          & Delimiter &\n-- ##        IfElse(WriteFieldName, \"Failure: \", \"\") &\n-- ##        to_string( AlertCount(FAILURE) )  & Delimiter &\n-- ##        IfElse(WriteFieldName, \"Error: \", \"\") &\n-- ##        to_string( AlertCount(ERROR) )    & Delimiter &\n-- ##        IfElse(WriteFieldName, \"Warning: \", \"\") &\n-- ##        to_string( AlertCount(WARNING) )  & Delimiter &\n-- ##        IfElse(WriteFieldName, \"AffirmCount: \", \"\") &\n-- ##        to_string( AffirmCount )          & Delimiter &\n-- ##        IfElse(WriteFieldName, \"PassedCount: \", \"\") &\n-- ##        to_string( PassedCount )          & Suffix\n-- ##      ) ;\n\n\n      WriteLine(TestFile, buf) ;\n    end procedure WriteOneTestSummary ;\n\n    ------------------------------------------------------------\n    --  pt local\n    procedure WriteTestSummary (\n    ------------------------------------------------------------\n      file TestFile  : text ;\n      Prefix         : string := \"\" ;\n      Suffix         : string := \"\" ;\n      ExternalErrors : AlertCountType := (0,0,0) ;\n      WriteFieldName : boolean := FALSE\n    ) is\n      -- Format:  Action Count min1 max1 min2 max2\n      variable TotalErrors : integer ;\n      variable TotalAlertErrors, TotalDisabledAlertErrors : integer ;\n      variable TotalRequirementsPassed, TotalRequirementsGoal : integer ;\n      variable TotalRequirementErrors : integer ;\n      variable TotalAlertCount, DisabledAlertCount : AlertCountType ;\n      constant AlertLogID : AlertLogIDType := ALERTLOG_BASE_ID ;\n      variable PassedCount, AffirmCount : integer ;\n      constant DELIMITER : string := \", \" ;\n    begin\n--!!\n--!! Update to use CalcTopTotalErrors\n--!!\n      TotalAlertCount        := AlertLogPtr(AlertLogID).AlertCount + ExternalErrors ;\n      TotalAlertErrors     := SumAlertCount( RemoveNonFailingWarnings(TotalAlertCount)) ;\n\n      DisabledAlertCount        := GetDisabledAlertCount(AlertLogID) ;\n      TotalDisabledAlertErrors  := SumAlertCount( RemoveNonFailingWarnings(DisabledAlertCount) ) ;\n\n      GetRequirementsCount(AlertLogID, TotalRequirementsPassed, TotalRequirementsGoal) ;\n      TotalRequirementErrors := TotalRequirementsGoal - TotalRequirementsPassed ;\n\n      TotalErrors := TotalAlertErrors ;\n      if FailOnDisabledErrorsVar then\n        TotalErrors := TotalErrors + TotalDisabledAlertErrors ;\n        TotalAlertCount := TotalAlertCount + DisabledAlertCount ;\n      end if ;\n      if FailOnRequirementErrorsVar then\n        TotalErrors := TotalErrors + TotalRequirementErrors ;\n      end if ;\n\n      GetPassedAffirmCount(AlertLogID, PassedCount, AffirmCount) ;\n\n      WriteOneTestSummary(\n        TestFile             =>  TestFile,\n        AlertLogID           =>  AlertLogID,\n        RequirementsGoal     =>  TotalRequirementsGoal,\n        RequirementsPassed   =>  TotalRequirementsPassed,\n        TotalErrors          =>  TotalErrors,\n        AlertCount           =>  TotalAlertCount,\n        AffirmCount          =>  AffirmCount,\n        PassedCount          =>  PassedCount,\n        Delimiter            =>  DELIMITER,\n        Prefix               =>  Prefix,\n        Suffix               =>  Suffix,\n        WriteFieldName       => WriteFieldName\n      ) ;\n    end procedure WriteTestSummary ;\n\n    ------------------------------------------------------------\n    procedure WriteTestSummary (\n    ------------------------------------------------------------\n      FileName       : string ;\n      OpenKind       : File_Open_Kind ;\n      Prefix         : string ;\n      Suffix         : string ;\n      ExternalErrors : AlertCountType ;\n      WriteFieldName : boolean\n    ) is\n      -- Format:  Action Count min1 max1 min2 max2\n      file TestFile : text open OpenKind is FileName ;\n    begin\n      WriteTestSummary(TestFile =>  TestFile, Prefix => Prefix, Suffix => Suffix, ExternalErrors => ExternalErrors, WriteFieldName => WriteFieldName) ;\n    end procedure WriteTestSummary ;\n\n    ------------------------------------------------------------\n    procedure WriteTestSummaries (  -- PT Local\n    ------------------------------------------------------------\n      file TestFile : text ;\n      AlertLogID    : AlertLogIDType\n    ) is\n     variable CurID : AlertLogIDType ;\n     variable TotalErrors, RequirementsGoal, RequirementsPassed : integer ;\n    begin\n      -- Descend from WriteRequirements\n      CurID := AlertLogPtr(AlertLogID).ChildID ;\n      while CurID > ALERTLOG_BASE_ID loop\n        TotalErrors        := AlertLogPtr(CurID).TotalErrors ;\n        RequirementsGoal   := AlertLogPtr(CurID).PassedGoal ;\n        RequirementsPassed := AlertLogPtr(CurID).PassedCount ;\n        if AlertLogPtr(CurID).AffirmCount <= 0 and FailOnRequirementErrorsVar and\n            (RequirementsGoal > RequirementsPassed) then\n          -- Add errors for tests that did not run.\n          TotalErrors := RequirementsGoal - RequirementsPassed ;\n        end if ;\n        WriteOneTestSummary(\n          TestFile             =>  TestFile,\n          AlertLogID           =>  CurID,\n          RequirementsGoal     =>  RequirementsGoal,\n          RequirementsPassed   =>  RequirementsPassed,\n          TotalErrors          =>  TotalErrors,\n          AlertCount           =>  AlertLogPtr(CurID).AlertCount,\n          AffirmCount          =>  AlertLogPtr(CurID).AffirmCount,\n          PassedCount          =>  AlertLogPtr(CurID).AffirmPassedCount,\n          Delimiter            =>  \",\"\n        ) ;\n        WriteTestSummaries(TestFile, CurID) ;\n        CurID := AlertLogPtr(CurID).SiblingID ;\n      end loop ;\n    end procedure WriteTestSummaries ;\n\n    ------------------------------------------------------------\n    procedure WriteTestSummaries (\n    ------------------------------------------------------------\n      FileName    : string ;\n      OpenKind    : File_Open_Kind\n    ) is\n      -- Format:  Action Count min1 max1 min2 max2\n      file TestFile : text open OpenKind is FileName ;\n    begin\n      WriteTestSummaries(\n        TestFile   =>  TestFile,\n        AlertLogID => REQUIREMENT_ALERTLOG_ID\n      ) ;\n    end procedure WriteTestSummaries ;\n\n    ------------------------------------------------------------\n    procedure ReportOneTestSummary (  -- PT Local\n    ------------------------------------------------------------\n      AlertLogID           : AlertLogIDType ;\n      RequirementsGoal     : integer ;\n      RequirementsPassed   : integer ;\n      TotalErrors          : integer ;\n      AlertCount           : AlertCountType ;\n      AffirmCount          : integer ;\n      PassedCount          : integer ;\n      Delimiter            : string\n    ) is\n      variable buf : line ;\n      -- constant ReportPrefix    : string := ResolveOsvvmWritePrefix(ReportPrefixVar.GetOpt ) ;\n      -- constant PassName        : string := ResolveOsvvmPassName(PassNameVar.GetOpt     ) ;\n      -- constant FailName        : string := ResolveOsvvmFailName(FailNameVar.GetOpt     ) ;\n    begin\n--      write(buf, ReportPrefix &  \" \") ;\n      write(buf, ResolveOsvvmWritePrefix(ReportPrefixVar.GetOpt) &  \" \") ;\n\n      if (AffirmCount > 0) and (TotalErrors = 0) then\n--        write(buf, PassName) ;\n        write(buf, ResolveOsvvmPassName(PassNameVar.GetOpt)) ;\n      elsif TotalErrors > 0 then\n--        write(buf, FailName) ;\n        write(buf, ResolveOsvvmFailName(FailNameVar.GetOpt)) ;\n      else\n        write(buf, string'(\"ReportTestSummaries Warning:  No checking done. \")) ;\n      end if ;\n      write(buf, \" \" & LeftJustify(AlertLogPtr(AlertLogID).Name.all, ReportJustifyAmountVar)) ;\n      write(buf, \"  Total Error(s) = \" & to_string(TotalErrors) ) ;\n      write(buf, \"  Failures: \"  & to_string(AlertCount(FAILURE) ) ) ;\n      write(buf, \"  Errors: \"    & to_string(AlertCount(ERROR) ) ) ;\n      write(buf, \"  Warnings: \"  & to_string(AlertCount(WARNING) ) ) ;\n      write(buf, \"  Affirmations Passed: \"  & to_string(PassedCount) &\n                 \" of \" & to_string(AffirmCount)) ;\n      write(buf, \"  Requirements Passed: \" & to_string(RequirementsPassed) &\n                 \" of \" & to_string(RequirementsGoal) ) ;\n      WriteLine(buf) ;\n    end procedure ReportOneTestSummary ;\n\n    ------------------------------------------------------------\n    procedure ReportTestSummaries (  -- PT Local\n    ------------------------------------------------------------\n      AlertLogID    : AlertLogIDType\n    ) is\n     variable CurID       : AlertLogIDType ;\n     variable TotalErrors, RequirementsGoal, RequirementsPassed : integer ;\n    begin\n      CurID := AlertLogPtr(AlertLogID).ChildID ;\n      while CurID > ALERTLOG_BASE_ID loop\n        TotalErrors        := AlertLogPtr(CurID).TotalErrors ;\n        RequirementsGoal   := AlertLogPtr(CurID).PassedGoal ;\n        RequirementsPassed := AlertLogPtr(CurID).PassedCount ;\n        if AlertLogPtr(CurID).AffirmCount <= 0 and FailOnRequirementErrorsVar and\n            (RequirementsGoal > RequirementsPassed) then\n          -- Add errors for tests that did not run.\n          TotalErrors := RequirementsGoal - RequirementsPassed ;\n        end if ;\n        ReportOneTestSummary(\n          AlertLogID           =>  CurID,\n          RequirementsGoal     =>  RequirementsGoal,\n          RequirementsPassed   =>  RequirementsPassed,\n          TotalErrors          =>  TotalErrors,\n          AlertCount           =>  AlertLogPtr(CurID).AlertCount,\n          AffirmCount          =>  AlertLogPtr(CurID).AffirmCount,\n          PassedCount          =>  AlertLogPtr(CurID).AffirmPassedCount,\n          Delimiter            =>  \",\"\n        ) ;\n        ReportTestSummaries(\n          AlertLogID   => CurID\n        ) ;\n        CurID := AlertLogPtr(CurID).SiblingID ;\n      end loop ;\n    end procedure ReportTestSummaries ;\n\n\n    ------------------------------------------------------------\n    procedure ReportTestSummaries is\n    ------------------------------------------------------------\n      variable IgnoredValue, OldReportJustifyAmount : integer ;\n      constant Separator : string := ResolveOsvvmIdSeparator(IdSeparatorVar.GetOpt) ;\n    begin\n      OldReportJustifyAmount  := ReportJustifyAmountVar ;\n      (IgnoredValue, ReportJustifyAmountVar) := CalcJustify(REQUIREMENT_ALERTLOG_ID, 0, 0, Separator'length) ;\n\n      ReportTestSummaries(AlertLogID   => REQUIREMENT_ALERTLOG_ID) ;\n      ReportJustifyAmountVar := OldReportJustifyAmount ;\n    end procedure ReportTestSummaries ;\n\n    ------------------------------------------------------------\n    --  pt local\n    procedure WriteAlerts (    -- pt local\n      file AlertsFile : text ;\n      AlertLogID : AlertLogIDType\n    ) is\n    ------------------------------------------------------------\n      -- Format:  Name, PassedGoal, #Passed, #TotalErrors, FAILURE, ERROR, WARNING, Affirmations\n      variable buf       : line ;\n      variable AlertCountVar   : AlertCountType ;\n      constant DELIMITER       : character := ',' ;\n      variable CurID : AlertLogIDType ;\n    begin\n      CurID := AlertLogPtr(AlertLogID).ChildID ;\n      while CurID > ALERTLOG_BASE_ID loop\n        write(buf, AlertLogPtr(CurID).Name.all) ;\n        write(buf, DELIMITER & to_string(AlertLogPtr(CurID).PassedGoal)) ;\n        -- Handling for PassedCount > PassedGoal done in ReadRequirements\n        write(buf, DELIMITER & to_string(AlertLogPtr(CurID).PassedCount)) ;\n        AlertCountVar := AlertLogPtr(CurID).AlertCount ;\n        if FailOnDisabledErrorsVar then\n          AlertCountVar := AlertCountVar + AlertLogPtr(CurID).DisabledAlertCount ;\n        end if;\n        -- TotalErrors\n        write(buf, DELIMITER & to_string( SumAlertCount(RemoveNonFailingWarnings(AlertCountVar)))) ;\n        write(buf, DELIMITER & to_string( AlertCountVar(FAILURE) )) ;\n        write(buf, DELIMITER & to_string( AlertCountVar(ERROR) )) ;\n        write(buf, DELIMITER & to_string( AlertCountVar(WARNING) )) ;\n        write(buf, DELIMITER & to_string( AlertLogPtr(CurID).AffirmCount )) ;\n--        write(buf, DELIMITER & to_string(AlertLogPtr(CurID).PassedCount)) ;  -- redundancy intentional, for reading WriteTestSummary\n        WriteLine(AlertsFile, buf) ;\n        WriteAlerts(AlertsFile, CurID) ;\n        CurID := AlertLogPtr(CurID).SiblingID ;\n      end loop ;\n    end procedure WriteAlerts ;\n\n    ------------------------------------------------------------\n    procedure WriteRequirements (\n    ------------------------------------------------------------\n      FileName    : string ;\n      AlertLogID  : AlertLogIDType ;\n      OpenKind    : File_Open_Kind\n    ) is\n      -- Format:  Action Count min1 max1 min2 max2\n      file RequirementsFile : text open OpenKind is FileName ;\n      variable LocalAlertLogID : AlertLogIDType ;\n    begin\n      localAlertLogID := VerifyID(AlertLogID) ;\n      WriteTestSummary(RequirementsFile) ;\n      if IsRequirement(localAlertLogID) then\n        WriteAlerts(RequirementsFile, localAlertLogID) ;\n      else\n        Alert(\"WriteRequirements: Called without a Requirement\") ;\n        WriteAlerts(RequirementsFile, REQUIREMENT_ALERTLOG_ID) ;\n      end if ;\n    end procedure WriteRequirements ;\n\n    ------------------------------------------------------------\n    procedure WriteAlerts (\n    ------------------------------------------------------------\n      FileName    : string ;\n      AlertLogID  : AlertLogIDType ;\n      OpenKind    : File_Open_Kind\n    ) is\n      -- Format:  Action Count min1 max1 min2 max2\n      file AlertsFile : text open OpenKind is FileName ;\n      variable LocalAlertLogID : AlertLogIDType ;\n    begin\n      localAlertLogID := VerifyID(AlertLogID) ;\n      WriteTestSummary(AlertsFile) ;\n      WriteAlerts(AlertsFile, localAlertLogID) ;\n    end procedure WriteAlerts ;\n\n    ------------------------------------------------------------\n    procedure ReadSpecification (file SpecificationFile : text  ; PassedGoalIn : integer ) is  -- PT Local\n    ------------------------------------------------------------\n      variable buf,Name,Description  : line ;\n      variable ReadValid             : boolean ;\n      variable Empty                 : boolean ;\n      variable MultiLineComment      : boolean := FALSE ;\n      variable PassedGoal            : integer ;\n      variable PassedGoalSet         : boolean ;\n      variable Char                  : character ;\n      constant DELIMITER             : character := ',' ;\n      variable AlertLogID            : AlertLogIDType ;\n    begin\n      HasRequirementsVar := TRUE ;\n\n      -- Format:   Spec Name, [Spec Description = \"\",] [Requirement Goal = 0]\n      ReadFileLoop : while not EndFile(SpecificationFile) loop\n        ReadLoop : loop\n          ReadLine(SpecificationFile, buf) ;\n          EmptyOrCommentLine(buf, Empty, MultiLineComment) ;\n          next ReadFileLoop when Empty ;\n\n          -- defaults\n          PassedGoal    := DefaultPassedGoalVar ;\n          PassedGoalSet := FALSE ;\n\n          -- Read Name and Remove delimiter\n          ReadUntilDelimiterOrEOL(buf, Name, DELIMITER, ReadValid) ;\n          exit ReadFileLoop when AlertIfNot(OSVVM_ALERTLOG_ID, ReadValid,\n                         \"AlertLogPkg.ReadSpecification: Failed while reading Name\", FAILURE) ;\n\n          -- If rest of line is blank or comment, then skip it.\n          EmptyOrCommentLine(buf, Empty, MultiLineComment) ;\n          exit ReadLoop when Empty ;\n\n          -- Optional: Read Description\n          ReadUntilDelimiterOrEOL(buf, Description, DELIMITER, ReadValid) ;\n          exit ReadFileLoop when AlertIfNot(OSVVM_ALERTLOG_ID, ReadValid,\n                         \"AlertLogPkg.ReadSpecification: Failed while reading Description\", FAILURE) ;\n\n          if IsNumber(Description.all) then\n            read(Description, PassedGoal, ReadValid) ;\n            deallocate(Description) ;\n            exit ReadFileLoop when AlertIfNot(OSVVM_ALERTLOG_ID, ReadValid,\n                           \"AlertLogPkg.ReadSpecification: Failed while reading PassedGoal (while skipping Description)\", FAILURE) ;\n            PassedGoalSet := TRUE ;\n          else\n            -- If rest of line is blank or comment, then skip it.\n            EmptyOrCommentLine(buf, Empty, MultiLineComment) ;\n            exit ReadLoop when Empty ;\n\n            -- Read PassedGoal\n            read(buf, PassedGoal, ReadValid) ;\n            exit ReadFileLoop when AlertIfNot(OSVVM_ALERTLOG_ID, ReadValid,\n                           \"AlertLogPkg.ReadSpecification: Failed while reading PassedGoal\", FAILURE) ;\n            PassedGoalSet := TRUE ;\n          end if ;\n          exit ReadLoop ;\n        end loop ReadLoop ;\n--        AlertLogID := GetReqID(Name.all) ;  -- For new items, sets DefaultPassedGoalVar and PassedGoalSet = FALSE.\n        AlertLogID := GetReqID(Name => Name.all, PassedGoal => -1, ParentID=> ALERTLOG_ID_NOT_ASSIGNED, CreateHierarchy => TRUE) ;\n        deallocate(Name) ;\n        deallocate(Description) ;  -- not used\n        -- Implementation 1:  Just put the values in\n        -- If Override values specified, then use them.\n        if PassedGoalIn >= 0 then\n          PassedGoal    := PassedGoalIn ;\n          PassedGoalSet := TRUE ;\n        end if ;\n        if PassedGoalSet then\n        -- Is there a goal to update?\n          if AlertLogPtr(AlertLogID).PassedGoalSet then\n            -- Merge Old and New\n            AlertLogPtr(AlertLogID).PassedGoal    := maximum(PassedGoal,   AlertLogPtr(AlertLogID).PassedGoal) ;\n          else\n            -- No Old, Just use New\n            AlertLogPtr(AlertLogID).PassedGoal    := PassedGoal ;\n          end if ;\n          AlertLogPtr(AlertLogID).PassedGoalSet := TRUE ;\n        end if ;\n      end loop ReadFileLoop ;\n    end procedure ReadSpecification ;\n\n    ------------------------------------------------------------\n    procedure ReadSpecification (FileName : string ; PassedGoal : integer ) is\n    ------------------------------------------------------------\n      -- Format:  Action Count min1 max1 min2 max2\n      file SpecificationFile : text open READ_MODE is FileName ;\n    begin\n      ReadSpecification(SpecificationFile, PassedGoal) ;\n    end procedure ReadSpecification ;\n\n    ------------------------------------------------------------\n    -- PT Local\n    procedure ReadRequirements (  -- PT Local\n      file RequirementsFile : text ;\n      ThresholdPassed       : boolean ;\n      TestSummary           : boolean\n    ) is\n    ------------------------------------------------------------\n      constant DELIMITER         : character := ',' ;\n      variable buf,Name          : line ;\n      variable ReadValid         : boolean ;\n      variable Empty             : boolean ;\n      variable MultiLineComment  : boolean := FALSE ;\n      variable StopDueToCount    : boolean := FALSE ;\n--      variable ReadFailed        : boolean := TRUE ;\n      variable Found             : boolean ;\n\n      variable ReqPassedGoal     : integer ;\n      variable ReqPassedCount    : integer ;\n      variable TotalErrorCount   : integer ;\n      variable AlertCount        : AlertCountType ;\n      variable AffirmCount       : integer ;\n      variable AffirmPassedCount : integer ;\n      variable AlertLogID        : AlertLogIDType ;\n    begin\n      if not TestSummary then\n        -- For requirements, skip the first line that has the test summary\n        ReadLine(RequirementsFile, buf) ;\n      end if ;\n\n      ReadFileLoop : while not EndFile(RequirementsFile) loop\n        ReadLoop : loop\n          ReadLine(RequirementsFile, buf) ;\n          EmptyOrCommentLine(buf, Empty, MultiLineComment) ;\n          next ReadFileLoop when Empty ;\n\n          -- defaults\n--          ReadFailed         := TRUE ;\n          ReqPassedGoal      := 0 ;\n          ReqPassedCount     := 0 ;\n          TotalErrorCount    := 0 ;\n          AlertCount         := (0, 0, 0) ;\n          AffirmCount        := 0 ;\n          AffirmPassedCount  := 0 ;\n\n        -- Read Name. Remove delimiter\n          ReadUntilDelimiterOrEOL(buf, Name, DELIMITER, ReadValid) ;\n          exit ReadFileLoop when AlertIfNot(OSVVM_ALERTLOG_ID, ReadValid,\n                         \"AlertLogPkg.ReadRequirements: Failed while reading Name\", FAILURE) ;\n\n        -- Read ReqPassedGoal\n          read(buf, ReqPassedGoal, ReadValid) ;\n          exit ReadFileLoop when AlertIfNot(OSVVM_ALERTLOG_ID, ReadValid,\n                         \"AlertLogPkg.ReadRequirements: Failed while reading PassedGoal\", FAILURE) ;\n\n          FindDelimiter(buf, DELIMITER, Found) ;\n          exit ReadFileLoop when AlertIf(OSVVM_ALERTLOG_ID, not Found,\n                         \"AlertLogPkg.ReadRequirements: Failed after reading PassedGoal\", FAILURE) ;\n\n        -- Read ReqPassedCount\n          read(buf, ReqPassedCount, ReadValid) ;\n          exit ReadFileLoop when AlertIfNot(OSVVM_ALERTLOG_ID, ReadValid,\n                         \"AlertLogPkg.ReadRequirements: Failed while reading PassedCount\", FAILURE) ;\n\n          AffirmPassedCount := ReqPassedGoal ;\n\n          FindDelimiter(buf, DELIMITER, Found) ;\n            exit ReadFileLoop when AlertIf(OSVVM_ALERTLOG_ID, not Found,\n                         \"AlertLogPkg.ReadRequirements: Failed after reading PassedCount\", FAILURE) ;\n\n        -- Read TotalErrorCount\n          read(buf, TotalErrorCount, ReadValid) ;\n          exit ReadFileLoop when AlertIfNot(OSVVM_ALERTLOG_ID, ReadValid,\n                         \"AlertLogPkg.ReadRequirements: Failed while reading TotalErrorCount\", FAILURE) ;\n          AlertCount := (0, TotalErrorCount, 0) ;  -- Default\n\n          FindDelimiter(buf, DELIMITER, Found) ;\n          exit ReadFileLoop when AlertIf(OSVVM_ALERTLOG_ID, not Found,\n                         \"AlertLogPkg.ReadRequirements: Failed after reading PassedCount\", FAILURE) ;\n\n        -- Read AlertCount\n          for i in AlertType'left to AlertType'right loop\n            read(buf, AlertCount(i), ReadValid) ;\n            exit ReadFileLoop when AlertIfNot(OSVVM_ALERTLOG_ID, ReadValid,\n                           \"AlertLogPkg.ReadRequirements: Failed while reading \" &\n                           \"AlertCount(\" & to_string(i) & \")\", FAILURE) ;\n\n            FindDelimiter(buf, DELIMITER, Found) ;\n            exit ReadFileLoop when AlertIf(OSVVM_ALERTLOG_ID, not Found,\n                           \"AlertLogPkg.ReadRequirements: Failed after reading \" &\n                           \"AlertCount(\" & to_string(i) & \")\", FAILURE) ;\n          end loop ;\n\n        -- Read AffirmCount\n          read(buf, AffirmCount, ReadValid) ;\n          exit ReadFileLoop when AlertIfNot(OSVVM_ALERTLOG_ID, ReadValid,\n                         \"AlertLogPkg.ReadRequirements: Failed while reading AffirmCount\", FAILURE) ;\n\n          if TestSummary then\n            FindDelimiter(buf, DELIMITER, Found) ;\n            exit ReadFileLoop when AlertIf(OSVVM_ALERTLOG_ID, not Found,\n                         \"AlertLogPkg.ReadRequirements: Failed after reading AffirmCount\", FAILURE) ;\n\n          -- Read AffirmPassedCount\n            read(buf, AffirmPassedCount, ReadValid) ;\n            if not ReadValid then\n              AffirmPassedCount := ReqPassedGoal ;\n              Alert(OSVVM_ALERTLOG_ID, \"AlertLogPkg.ReadRequirements: Failed while reading AffirmPassedCount\", FAILURE) ;\n              exit ReadFileLoop ;\n            end if ;\n          end if ;\n\n          exit ReadLoop ;\n        end loop ReadLoop ;\n\n--        AlertLogID := GetReqID(Name.all) ;\n        AlertLogID := GetReqID(Name => Name.all, PassedGoal => -1, ParentID=> ALERTLOG_ID_NOT_ASSIGNED, CreateHierarchy => TRUE) ;  --! GHDL\n        deallocate(Name) ;\n--        if Merge then\n          -- Passed Goal\n          if AlertLogPtr(AlertLogID).PassedGoalSet then\n            AlertLogPtr(AlertLogID).PassedGoal        := maximum(AlertLogPtr(AlertLogID).PassedGoal, ReqPassedGoal) ;\n          else\n            AlertLogPtr(AlertLogID).PassedGoal        := ReqPassedGoal ;\n          end if ;\n          -- Requirements Passed Count\n          if  ThresholdPassed then\n            ReqPassedCount := minimum(ReqPassedCount, ReqPassedGoal) ;\n          end if ;\n          AlertLogPtr(AlertLogID).PassedCount         := AlertLogPtr(AlertLogID).PassedCount + ReqPassedCount ;\n\n          AlertLogPtr(AlertLogID).TotalErrors         := AlertLogPtr(AlertLogID).TotalErrors + TotalErrorCount ;\n\n          -- AlertCount\n          IncrementAlertCount(AlertLogID, FAILURE, StopDueToCount, AlertCount(FAILURE)) ;\n          IncrementAlertCount(AlertLogID, ERROR,   StopDueToCount, AlertCount(ERROR)) ;\n          IncrementAlertCount(AlertLogID, WARNING, StopDueToCount, AlertCount(WARNING)) ;\n\n          -- AffirmCount\n          AlertLogPtr(AlertLogID).AffirmCount         := AlertLogPtr(AlertLogID).AffirmCount + AffirmCount ;\n          AlertLogPtr(AlertLogID).AffirmPassedCount   := AlertLogPtr(AlertLogID).AffirmPassedCount + AffirmPassedCount ;\n\n--        else\n--          AlertLogPtr(AlertLogID).PassedGoal          := ReqPassedGoal ;\n--          AlertLogPtr(AlertLogID).PassedCount         := ReqPassedCount ;\n--\n--          IncrementAlertCount(AlertLogID, FAILURE, StopDueToCount, AlertCount(FAILURE)) ;\n--          IncrementAlertCount(AlertLogID, ERROR,   StopDueToCount, AlertCount(ERROR)) ;\n--          IncrementAlertCount(AlertLogID, WARNING, StopDueToCount, AlertCount(WARNING)) ;\n--\n--          AlertLogPtr(AlertLogID).AffirmCount         := ReqPassedCount + TotalErrorCount ;\n--        end if;\n        AlertLogPtr(AlertLogID).PassedGoalSet := TRUE ;\n      end loop ReadFileLoop ;\n    end procedure ReadRequirements ;\n\n    ------------------------------------------------------------\n    procedure ReadRequirements (\n      FileName        : string ;\n      ThresholdPassed : boolean ;\n      TestSummary     : boolean\n    ) is\n    ------------------------------------------------------------\n      -- Format:  Action Count min1 max1 min2 max2\n      file RequirementsFile : text open READ_MODE is FileName ;\n    begin\n      ReadRequirements(RequirementsFile, ThresholdPassed, TestSummary) ;\n    end procedure ReadRequirements ;\n\n    ------------------------------------------------------------\n    procedure ClearAlerts is\n    ------------------------------------------------------------\n    begin\n      AffirmCheckCountVar  := 0 ;\n      PassedCountVar       := 0 ;\n      AlertCount           := (0, 0, 0) ;\n      ErrorCount           := 0 ;\n\n      for i in ALERTLOG_BASE_ID to NumAlertLogIDsVar loop\n        AlertLogPtr(i).AlertCount           := (0, 0, 0) ;\n        AlertLogPtr(i).DisabledAlertCount   := (0, 0, 0) ;\n        AlertLogPtr(i).AffirmCount          := 0 ;\n        AlertLogPtr(i).PassedCount          := 0 ;\n      end loop ;\n    end procedure ClearAlerts ;\n\n    ------------------------------------------------------------\n    procedure ClearAlertStopCounts is\n    ------------------------------------------------------------\n    begin\n      AlertLogPtr(ALERTLOG_BASE_ID).AlertStopCount := (FAILURE => 0, ERROR => integer'right, WARNING => integer'right) ;\n\n      for i in ALERTLOG_BASE_ID + 1 to NumAlertLogIDsVar loop\n        AlertLogPtr(i).AlertStopCount := (FAILURE => integer'right, ERROR => integer'right, WARNING => integer'right) ;\n      end loop ;\n    end procedure ClearAlertStopCounts ;\n\n    ------------------------------------------------------------\n    -- PT Local\n    procedure LocalLog (\n    ------------------------------------------------------------\n      AlertLogID   : AlertLogIDType ;\n      Message      : string ;\n      Level        : LogType\n    ) is\n    begin\n      LocalPrint(\n        AlertLogID       => AlertLogID,\n        AlertLogName     => LogPrefixVar.Get(OSVVM_DEFAULT_LOG_PREFIX),  \n        WriteErrorCount  => WriteLogErrorCountVar,\n        WriteLevel       => WriteLogLevelVar,\n        LevelName        => LOG_NAME(Level),\n        WriteName        => WriteLogNameVar,\n        Message          => Message,\n        WriteTime        => WriteLogTimeVar\n      ) ;\n    end procedure LocalLog ;\n\n    ------------------------------------------------------------\n    procedure log (\n    ------------------------------------------------------------\n      AlertLogID   : AlertLogIDType ;\n      Message      : string ;\n      Level        : LogType := ALWAYS ;\n      Enable       : boolean := FALSE    -- override internal enable\n    ) is\n      variable localAlertLogID : AlertLogIDType ;\n    begin\n      localAlertLogID := VerifyID(AlertLogID) ;\n      if Level = ALWAYS or Enable then\n        LocalLog(localAlertLogID, Message, Level) ;\n      elsif AlertLogPtr(localAlertLogID).LogEnabled(Level) then\n        LocalLog(localAlertLogID, Message, Level) ;\n      end if ;\n      if Level = PASSED then\n        IncAffirmPassedCount(AlertLogID) ;  -- count the passed and affirmation\n      end if ;\n    end procedure log ;\n\n    ------------------------------------------------------------\n    ------------------------------------------------------------\n    -- AlertLog Structure Creation and Interaction Methods\n\n    ------------------------------------------------------------\n    procedure SetTestName(Name : string ) is\n    ------------------------------------------------------------\n    begin\n      Deallocate(AlertLogPtr(ALERTLOG_BASE_ID).Name) ;\n      AlertLogPtr(ALERTLOG_BASE_ID).Name := new string'(Name) ;\n      AlertLogPtr(ALERTLOG_BASE_ID).NameLower  := new string'(to_lower(NAME)) ;\n    end procedure SetTestName ;\n\n    ------------------------------------------------------------\n    impure function GetAlertLogName(AlertLogID : AlertLogIDType) return string is\n    ------------------------------------------------------------\n      variable localAlertLogID : AlertLogIDType ;\n    begin\n      localAlertLogID := VerifyID(AlertLogID) ;\n      return AlertLogPtr(localAlertLogID).Name.all ;\n    end function GetAlertLogName ;\n\n    ------------------------------------------------------------\n    -- PT Local\n    procedure DeQueueID(AlertLogID : AlertLogIDType) is\n    ------------------------------------------------------------\n      variable ParentID, CurID : AlertLogIDType ;\n    begin\n      ParentID := AlertLogPtr(AlertLogID).ParentID ;\n      CurID    := AlertLogPtr(ParentID).ChildID ;\n\n      -- Found at top of list\n      if AlertLogPtr(ParentID).ChildID = AlertLogID then\n        AlertLogPtr(ParentID).ChildID := AlertLogPtr(AlertLogID).SiblingID ;\n      else\n        -- Find among Siblings\n        loop\n          if AlertLogPtr(CurID).SiblingID = AlertLogID then\n            AlertLogPtr(CurID).SiblingID := AlertLogPtr(AlertLogID).SiblingID ;\n            exit ;\n          end if ;\n          if AlertLogPtr(CurID).SiblingID <= ALERTLOG_BASE_ID then\n            Alert(\"DeQueueID: AlertLogID not found\") ;\n            exit ;\n          end if ;\n          CurID := AlertLogPtr(CurID).SiblingID ;\n        end loop ;\n      end if ;\n    end procedure DeQueueID ;\n\n    ------------------------------------------------------------\n    -- PT Local\n    procedure EnQueueID(AlertLogID, ParentID : AlertLogIDType ; ParentIDSet : boolean := TRUE) is\n    ------------------------------------------------------------\n      variable CurID : AlertLogIDType ;\n    begin\n      AlertLogPtr(AlertLogID).ParentIDSet := ParentIDSet ;\n      AlertLogPtr(AlertLogID).ParentID    := ParentID ;\n      AlertLogPtr(AlertLogID).SiblingID   := ALERTLOG_ID_NOT_ASSIGNED ;\n\n      if AlertLogPtr(ParentID).ChildID < ALERTLOG_BASE_ID then\n        AlertLogPtr(ParentID).ChildID     := AlertLogID ;\n      else\n        CurID := AlertLogPtr(ParentID).ChildIDLast ;\n        AlertLogPtr(CurID).SiblingID := AlertLogID ;\n      end if ;\n      AlertLogPtr(ParentID).ChildIDLast := AlertLogID ;\n    end procedure EnQueueID ;\n\n    ------------------------------------------------------------\n    -- PT Local\n    procedure NewAlertLogRec(AlertLogID : AlertLogIDType ; iName : string ; ParentID : AlertLogIDType; ReportMode : AlertLogReportModeType := ENABLED; PrintParent : AlertLogPrintParentType := PRINT_NAME_AND_PARENT) is\n    ------------------------------------------------------------\n      variable AlertEnabled   : AlertEnableType ;\n      variable AlertStopCount : AlertCountType ;\n      variable LogEnabled     : LogEnableType ;\n    begin\n      AlertLogPtr(AlertLogID) := new AlertLogRecType ;\n      if AlertLogID = ALERTLOG_BASE_ID then\n        AlertEnabled := (TRUE, TRUE, TRUE) ;\n        LogEnabled   := (others => FALSE) ;\n        AlertStopCount := (FAILURE => 0, ERROR => integer'right, WARNING => integer'right) ;\n        EnQueueID(AlertLogID, ALERTLOG_BASE_ID, TRUE) ;\n      else\n        if ParentID < ALERTLOG_BASE_ID then\n          AlertEnabled := AlertLogPtr(ALERTLOG_BASE_ID).AlertEnabled ;\n          LogEnabled   := AlertLogPtr(ALERTLOG_BASE_ID).LogEnabled ;\n          EnQueueID(AlertLogID, ALERTLOG_BASE_ID, FALSE) ;\n        else\n          AlertEnabled := AlertLogPtr(ParentID).AlertEnabled ;\n          LogEnabled   := AlertLogPtr(ParentID).LogEnabled ;\n          EnQueueID(AlertLogID, ParentID, TRUE) ;\n        end if ;\n        AlertStopCount := (FAILURE | ERROR | WARNING => integer'right) ;\n      end if ;\n      AlertLogPtr(AlertLogID).Name                := new string'(iName) ;\n      AlertLogPtr(AlertLogID).NameLower           := new string'(to_lower(iName)) ;\n      AlertLogPtr(AlertLogID).AlertCount          := (0, 0, 0) ;\n      AlertLogPtr(AlertLogID).DisabledAlertCount  := (0, 0, 0) ;\n      AlertLogPtr(AlertLogID).AffirmCount         := 0 ;\n      AlertLogPtr(AlertLogID).PassedCount         := 0 ;\n      AlertLogPtr(AlertLogID).PassedGoal          := 0 ;\n      AlertLogPtr(AlertLogID).AlertEnabled        := AlertEnabled ;\n      AlertLogPtr(AlertLogID).AlertStopCount      := AlertStopCount ;\n      AlertLogPtr(AlertLogID).AlertPrintCount     := (FAILURE | ERROR | WARNING => integer'right) ;\n      AlertLogPtr(AlertLogID).LogEnabled          := LogEnabled ;\n      AlertLogPtr(AlertLogID).ReportMode          := ReportMode ;\n      -- Update PrintParent\n      if ParentID > ALERTLOG_BASE_ID then\n        AlertLogPtr(AlertLogID).PrintParent := PrintParent ;\n      else\n        AlertLogPtr(AlertLogID).PrintParent := PRINT_NAME ;\n      end if ;\n\n      -- Set ChildID, ChildIDLast, SiblingID to ALERTLOG_ID_NOT_ASSIGNED\n      AlertLogPtr(AlertLogID).SiblingID           := ALERTLOG_ID_NOT_ASSIGNED ;\n      AlertLogPtr(AlertLogID).ChildID             := ALERTLOG_ID_NOT_ASSIGNED ;\n      AlertLogPtr(AlertLogID).ChildIDLast         := ALERTLOG_ID_NOT_ASSIGNED ;\n      AlertLogPtr(AlertLogID).TotalErrors         := 0 ;\n      AlertLogPtr(AlertLogID).AffirmPassedCount   := 0 ;\n    end procedure NewAlertLogRec ;\n\n    ------------------------------------------------------------\n    -- PT Local\n    -- Construct initial data structure\n    procedure LocalInitialize(NewNumAlertLogIDs : AlertLogIDType := MIN_NUM_AL_IDS) is\n    ------------------------------------------------------------\n    begin\n      if NumAllocatedAlertLogIDsVar /= 0 then\n        Alert(ALERT_DEFAULT_ID, \"AlertLogPkg: Initialize, data structure already initialized\", FAILURE) ;\n        return ;\n      end if ;\n      -- Initialize Pointer\n      AlertLogPtr := new AlertLogArrayType(ALERTLOG_BASE_ID to ALERTLOG_BASE_ID + NewNumAlertLogIDs) ;\n      NumAllocatedAlertLogIDsVar := NewNumAlertLogIDs ;\n      -- Create BASE AlertLogID (if it differs from DEFAULT\n      NewAlertLogRec(ALERTLOG_BASE_ID, \"AlertLogTop\", ALERTLOG_BASE_ID) ;\n      -- Create DEFAULT AlertLogID\n      NewAlertLogRec(ALERT_DEFAULT_ID, \"Default\", ALERTLOG_BASE_ID) ;\n      NumAlertLogIDsVar := ALERT_DEFAULT_ID ;\n      -- Create OSVVM AlertLogID (if it differs from DEFAULT\n      if OSVVM_ALERTLOG_ID /= ALERT_DEFAULT_ID then\n        NewAlertLogRec(OSVVM_ALERTLOG_ID, \"OSVVM\", ALERTLOG_BASE_ID) ;\n        NumAlertLogIDsVar := NumAlertLogIDsVar + 1 ;\n      end if ;\n      if REQUIREMENT_ALERTLOG_ID /= ALERT_DEFAULT_ID then\n        NewAlertLogRec(REQUIREMENT_ALERTLOG_ID, \"Requirements\", ALERTLOG_BASE_ID) ;\n        NumAlertLogIDsVar := NumAlertLogIDsVar + 1 ;\n      end if ;\n      if OSVVM_SCOREBOARD_ALERTLOG_ID /= OSVVM_ALERTLOG_ID then\n        NewAlertLogRec(OSVVM_SCOREBOARD_ALERTLOG_ID, \"OSVVM Scoreboard\", ALERTLOG_BASE_ID) ;\n        NumAlertLogIDsVar := NumAlertLogIDsVar + 1 ;\n      end if ;\n    end procedure LocalInitialize ;\n\n    ------------------------------------------------------------\n    -- Construct initial data structure\n    procedure Initialize(NewNumAlertLogIDs : AlertLogIDType := MIN_NUM_AL_IDS) is\n    ------------------------------------------------------------\n    begin\n      LocalInitialize(NewNumAlertLogIDs) ;\n    end procedure Initialize ;\n\n    ------------------------------------------------------------\n    -- PT Local\n    -- Constructs initial data structure using constant below\n    impure function LocalInitialize return boolean is\n    ------------------------------------------------------------\n    begin\n      LocalInitialize(MIN_NUM_AL_IDS) ;\n      return TRUE ;\n    end function LocalInitialize ;\n\n    constant CONSTRUCT_ALERT_DATA_STRUCTURE : boolean := LocalInitialize ;\n\n    ------------------------------------------------------------\n    procedure DeallocateAlertLogStruct is\n    ------------------------------------------------------------\n    begin\n      for i in ALERTLOG_BASE_ID to NumAlertLogIDsVar loop\n        Deallocate(AlertLogPtr(i).Name) ;\n        Deallocate(AlertLogPtr(i)) ;\n      end loop ;\n      deallocate(AlertLogPtr) ;\n      -- Free up space used by protected types within AlertLogPkg\n      AlertPrefixVar.Deallocate ;\n      LogPrefixVar.Deallocate ;\n      ReportPrefixVar.Deallocate ;\n      DoneNameVar.Deallocate ;\n      PassNameVar.Deallocate ;\n      FailNameVar.Deallocate ;\n      -- Restore variables to their initial state\n      PrintPassedVar              := TRUE ;\n      PrintAffirmationsVar        := FALSE ;\n      PrintDisabledAlertsVar      := FALSE ;\n      PrintRequirementsVar        := FALSE ;\n      PrintIfHaveRequirementsVar  := TRUE ;\n      DefaultPassedGoalVar        := 1 ;\n      NumAlertLogIDsVar           := 0 ;\n      NumAllocatedAlertLogIDsVar  := 0 ;\n      GlobalAlertEnabledVar       := TRUE ; -- Allows turn off and on\n      AffirmCheckCountVar         := 0 ;\n      PassedCountVar              := 0 ;\n      FailOnWarningVar            := TRUE ;\n      FailOnDisabledErrorsVar     := TRUE ;\n      FailOnRequirementErrorsVar  := TRUE ;\n      ReportHierarchyVar          := TRUE ;\n      FoundReportHierVar          := FALSE ;\n      FoundAlertHierVar           := FALSE ;\n      WriteAlertErrorCountVar     := FALSE ;\n      WriteAlertLevelVar          := TRUE ;\n      WriteAlertNameVar           := TRUE ;\n      WriteAlertTimeVar           := TRUE ;\n      WriteLogErrorCountVar       := FALSE ;\n      WriteLogLevelVar            := TRUE ;\n      WriteLogNameVar             := TRUE ;\n      WriteLogTimeVar             := TRUE ;\n      WriteTimeLastVar            := TRUE ;\n      AlertLogJustifyAmountVar    := 0 ;\n      ReportJustifyAmountVar      := 0 ;\n      TimeJustifyAmountVar        := 0 ;\n    end procedure DeallocateAlertLogStruct ;\n\n    ------------------------------------------------------------\n    -- PT Local.\n    procedure GrowAlertStructure (NewNumAlertLogIDs : AlertLogIDType) is\n    ------------------------------------------------------------\n      variable oldAlertLogPtr : AlertLogArrayPtrType ;\n    begin\n      if NumAllocatedAlertLogIDsVar = 0 then\n        Initialize (NewNumAlertLogIDs) ;   -- Construct initial structure\n      else\n        oldAlertLogPtr := AlertLogPtr ;\n        AlertLogPtr := new AlertLogArrayType(ALERTLOG_BASE_ID to NewNumAlertLogIDs) ;\n        AlertLogPtr(ALERTLOG_BASE_ID to NumAlertLogIDsVar) := oldAlertLogPtr(ALERTLOG_BASE_ID to NumAlertLogIDsVar) ;\n        deallocate(oldAlertLogPtr) ;\n      end if ;\n      NumAllocatedAlertLogIDsVar := NewNumAlertLogIDs ;\n    end procedure GrowAlertStructure ;\n\n    ------------------------------------------------------------\n    -- Sets a AlertLogPtr to a particular size\n    -- Use for small bins to save space or large bins to\n    -- suppress the resize and copy in autosizes.\n    procedure SetNumAlertLogIDs (NewNumAlertLogIDs : AlertLogIDType) is\n    ------------------------------------------------------------\n      variable oldAlertLogPtr : AlertLogArrayPtrType ;\n    begin\n      if NewNumAlertLogIDs > NumAllocatedAlertLogIDsVar then\n        GrowAlertStructure(NewNumAlertLogIDs) ;\n      end if;\n    end procedure SetNumAlertLogIDs ;\n\n    ------------------------------------------------------------\n    -- PT Local\n    impure function GetNextAlertLogID return AlertLogIDType is\n    ------------------------------------------------------------\n      variable NewNumAlertLogIDs : AlertLogIDType ;\n    begin\n      NewNumAlertLogIDs := NumAlertLogIDsVar + 1 ;\n      if NewNumAlertLogIDs > NumAllocatedAlertLogIDsVar then\n        GrowAlertStructure(NumAllocatedAlertLogIDsVar + MIN_NUM_AL_IDS) ;\n      end if ;\n      NumAlertLogIDsVar := NewNumAlertLogIDs ;\n      return NumAlertLogIDsVar ;\n    end function GetNextAlertLogID ;\n\n    ------------------------------------------------------------\n    impure function FindAlertLogID(Name : string ) return AlertLogIDType is\n    ------------------------------------------------------------\n      constant NameLower : string := to_lower(Name) ;\n    begin\n      for i in ALERTLOG_BASE_ID+1 to NumAlertLogIDsVar loop\n        if NameLower = AlertLogPtr(i).NameLower.all then\n          return i ;\n        end if ;\n      end loop ;\n      return ALERTLOG_ID_NOT_FOUND ; -- not found\n    end function FindAlertLogID ;\n\n    ------------------------------------------------------------\n    -- PT Local\n    impure function LocalFindAlertLogID(Name : string ; ParentID : AlertLogIDType) return AlertLogIDType is\n    ------------------------------------------------------------\n      constant NameLower : string := to_lower(Name) ;\n    begin\n      if ParentID = ALERTLOG_ID_NOT_ASSIGNED then\n        return FindAlertLogID(Name) ;\n      else\n        for i in ALERTLOG_BASE_ID+1 to NumAlertLogIDsVar loop\n          if NameLower = AlertLogPtr(i).NameLower.all and\n            (AlertLogPtr(i).ParentID = ParentID or AlertLogPtr(i).ParentIDSet = FALSE)\n          then\n            return i ;\n          end if ;\n        end loop ;\n        return ALERTLOG_ID_NOT_FOUND ; -- not found\n      end if ;\n    end function LocalFindAlertLogID ;\n\n    ------------------------------------------------------------\n    impure function FindAlertLogID(Name : string ; ParentID : AlertLogIDType) return AlertLogIDType is\n    ------------------------------------------------------------\n      variable localParentID : AlertLogIDType ;\n    begin\n      localParentID := VerifyID(ParentID, ALERTLOG_ID_NOT_ASSIGNED) ;\n      return LocalFindAlertLogID(Name, localParentID) ;\n    end function FindAlertLogID ;\n\n    ------------------------------------------------------------\n    -- PT Local\n    procedure AdjustID(AlertLogID, ParentID : AlertLogIDType ; ParentIDSet : boolean := TRUE) is\n    ------------------------------------------------------------\n    begin\n      if IsRequirement(AlertLogID) and not IsRequirement(ParentID) then\n        Alert(AlertLogID, \"GetAlertLogID/GetReqID: Parent of a Requirement must be a Requirement\") ;\n      else\n        if ParentID /= AlertLogPtr(AlertLogID).ParentID then\n          DeQueueID(AlertLogID) ;\n          EnQueueID(AlertLogID, ParentID, ParentIDSet) ;\n        else\n          AlertLogPtr(AlertLogID).ParentIDSet := ParentIDSet ;\n        end if ;\n      end if ;\n    end procedure AdjustID ;\n\n    ------------------------------------------------------------\n    impure function NewID(\n      Name            : string ;\n      ParentID        : AlertLogIDType ;\n      ReportMode      : AlertLogReportModeType ;\n      PrintParent     : AlertLogPrintParentType ;\n      CreateHierarchy : boolean\n    ) return AlertLogIDType is\n    -- impure function GetAlertLogID(Name : string; ParentID : AlertLogIDType; CreateHierarchy : Boolean; DoNotReport : Boolean) return AlertLogIDType is\n    ------------------------------------------------------------\n      variable ResultID : AlertLogIDType ;\n      variable localParentID : AlertLogIDType ;\n    begin\n      localParentID := VerifyID(ParentID, ALERTLOG_ID_NOT_ASSIGNED, ALERTLOG_ID_NOT_ASSIGNED) ;\n      ResultID      := LocalFindAlertLogID(Name, localParentID) ;\n      if ResultID = ALERTLOG_ID_NOT_FOUND then\n        -- Create a new ID\n        ResultID := GetNextAlertLogID ;\n        NewAlertLogRec(ResultID, Name, localParentID, ReportMode, PrintParent) ;\n        FoundAlertHierVar := TRUE ;\n        if CreateHierarchy and ReportMode /= DISABLED then\n          FoundReportHierVar := TRUE ;\n        end if ;\n        AlertLogPtr(ResultID).PassedGoal := 0 ;\n        AlertLogPtr(ResultID).PassedGoalSet := FALSE ;\n      else\n        -- Found existing ID.  Update it.\n        if AlertLogPtr(ResultID).ParentIDSet = FALSE then\n          if localParentID /= ALERTLOG_ID_NOT_ASSIGNED then\n            -- Update ParentID and potentially relocate in the structure\n            AdjustID(ResultID, localParentID, TRUE) ;\n            -- Update PrintParent\n            if localParentID /= ALERTLOG_BASE_ID then\n              AlertLogPtr(ResultID).PrintParent := PrintParent ;\n            else\n              AlertLogPtr(ResultID).PrintParent := PRINT_NAME ;\n            end if ;\n          -- else -- do not update as ParentIDs are either same or input localParentID = ALERTLOG_ID_NOT_ASSIGNED\n          end if ;\n        end if ;\n      end if ;\n      return ResultID ;\n    end function NewID ;\n\n    ------------------------------------------------------------\n    impure function GetReqID(Name : string ; PassedGoal : integer ; ParentID : AlertLogIDType ; CreateHierarchy : Boolean) return AlertLogIDType is\n    ------------------------------------------------------------\n      variable ResultID : AlertLogIDType ;\n      variable localParentID : AlertLogIDType ;\n    begin\n      HasRequirementsVar := TRUE ;\n      localParentID := VerifyID(ParentID, ALERTLOG_ID_NOT_ASSIGNED, ALERTLOG_ID_NOT_ASSIGNED) ;\n      ResultID := LocalFindAlertLogID(Name, localParentID) ;\n      if ResultID = ALERTLOG_ID_NOT_FOUND then\n        -- Create a new ID\n        ResultID := GetNextAlertLogID ;\n        if localParentID = ALERTLOG_ID_NOT_ASSIGNED then\n          NewAlertLogRec(ResultID, Name, REQUIREMENT_ALERTLOG_ID, ENABLED, PRINT_NAME) ;\n          AlertLogPtr(ResultID).ParentIDSet := FALSE ;\n        else\n          -- May want just PRINT_NAME here as PRINT_NAME_AND_PARENT is not backward compatible\n--          NewAlertLogRec(ResultID, Name, localParentID, ENABLED, PRINT_NAME_AND_PARENT) ;\n          NewAlertLogRec(ResultID, Name, localParentID, ENABLED, PRINT_NAME) ;\n        end if ;\n        FoundAlertHierVar := TRUE ;\n        if CreateHierarchy then\n          FoundReportHierVar := TRUE ;\n        end if ;\n        if PassedGoal >= 0 then\n          AlertLogPtr(ResultID).PassedGoal := PassedGoal ;\n          AlertLogPtr(ResultID).PassedGoalSet := TRUE ;\n        else\n          AlertLogPtr(ResultID).PassedGoal := DefaultPassedGoalVar ;\n          AlertLogPtr(ResultID).PassedGoalSet := FALSE ;\n        end if ;\n      else\n        -- Found existing ID.  Update it.\n        if AlertLogPtr(ResultID).ParentIDSet = FALSE then\n          if localParentID /= ALERTLOG_ID_NOT_ASSIGNED then\n            AdjustID(ResultID, localParentID, TRUE) ;\n            if localParentID /= REQUIREMENT_ALERTLOG_ID then\n              -- May want just PRINT_NAME here as PRINT_NAME_AND_PARENT is not backward compatible\n--              AlertLogPtr(ResultID).PrintParent := PRINT_NAME_AND_PARENT ;\n              AlertLogPtr(ResultID).PrintParent := PRINT_NAME ;\n            else\n              AlertLogPtr(ResultID).PrintParent := PRINT_NAME ;\n            end if ;\n          else\n            -- Update if originally set by NewID/GetAlertLogID\n            AdjustID(ResultID, REQUIREMENT_ALERTLOG_ID, FALSE) ;\n          end if ;\n        end if ;\n        if AlertLogPtr(ResultID).PassedGoalSet = FALSE then\n          if PassedGoal >= 0 then\n            AlertLogPtr(ResultID).PassedGoal    := PassedGoal ;\n            AlertLogPtr(ResultID).PassedGoalSet := TRUE ;\n          else\n            AlertLogPtr(ResultID).PassedGoal    := DefaultPassedGoalVar ;\n            AlertLogPtr(ResultID).PassedGoalSet := FALSE ;\n          end if ;\n        end if ;\n      end if ;\n      return ResultID ;\n    end function GetReqID ;\n\n    ------------------------------------------------------------\n    procedure SetPassedGoal(AlertLogID : AlertLogIDType ; PassedGoal : integer ) is\n    ------------------------------------------------------------\n      variable localAlertLogID : AlertLogIDType ;\n    begin\n      HasRequirementsVar := TRUE ;\n      localAlertLogID := VerifyID(AlertLogID) ;\n      if PassedGoal >= 0 then\n        AlertLogPtr(localAlertLogID).PassedGoal := PassedGoal ;\n      else\n        AlertLogPtr(localAlertLogID).PassedGoal := DefaultPassedGoalVar ;\n      end if ;\n    end procedure SetPassedGoal ;\n\n    ------------------------------------------------------------\n    impure function GetAlertLogParentID(AlertLogID : AlertLogIDType) return AlertLogIDType is\n    ------------------------------------------------------------\n      variable localAlertLogID : AlertLogIDType ;\n    begin\n      localAlertLogID := VerifyID(AlertLogID) ;\n      return AlertLogPtr(localAlertLogID).ParentID ;\n    end function GetAlertLogParentID ;\n\n    ------------------------------------------------------------\n    procedure SetAlertLogPrefix(AlertLogID : AlertLogIDType; Name : string ) is\n    ------------------------------------------------------------\n      variable localAlertLogID : AlertLogIDType ;\n    begin\n      localAlertLogID := VerifyID(AlertLogID) ;\n      Deallocate(AlertLogPtr(localAlertLogID).Prefix) ;\n      if Name'length > 0 then\n        AlertLogPtr(localAlertLogID).Prefix := new string'(Name) ;\n      end if ;\n    end procedure SetAlertLogPrefix ;\n\n    ------------------------------------------------------------\n    procedure UnSetAlertLogPrefix(AlertLogID : AlertLogIDType) is\n    ------------------------------------------------------------\n      variable localAlertLogID : AlertLogIDType ;\n    begin\n      localAlertLogID := VerifyID(AlertLogID) ;\n      Deallocate(AlertLogPtr(localAlertLogID).Prefix) ;\n    end procedure UnSetAlertLogPrefix ;\n\n    ------------------------------------------------------------\n    impure function GetAlertLogPrefix(AlertLogID : AlertLogIDType) return string is\n    ------------------------------------------------------------\n      variable localAlertLogID : AlertLogIDType ;\n    begin\n      localAlertLogID := VerifyID(AlertLogID) ;\n      return AlertLogPtr(localAlertLogID).Prefix.all ;\n    end function GetAlertLogPrefix ;\n\n    ------------------------------------------------------------\n    procedure SetAlertLogSuffix(AlertLogID : AlertLogIDType; Name : string ) is\n    ------------------------------------------------------------\n      variable localAlertLogID : AlertLogIDType ;\n    begin\n      localAlertLogID := VerifyID(AlertLogID) ;\n      Deallocate(AlertLogPtr(localAlertLogID).Suffix) ;\n      if Name'length > 0 then\n        AlertLogPtr(localAlertLogID).Suffix := new string'(Name) ;\n      end if ;\n    end procedure SetAlertLogSuffix ;\n\n    ------------------------------------------------------------\n    procedure UnSetAlertLogSuffix(AlertLogID : AlertLogIDType) is\n    ------------------------------------------------------------\n      variable localAlertLogID : AlertLogIDType ;\n    begin\n      localAlertLogID := VerifyID(AlertLogID) ;\n      Deallocate(AlertLogPtr(localAlertLogID).Suffix) ;\n    end procedure UnSetAlertLogSuffix ;\n\n    ------------------------------------------------------------\n    impure function GetAlertLogSuffix(AlertLogID : AlertLogIDType) return string is\n    ------------------------------------------------------------\n      variable localAlertLogID : AlertLogIDType ;\n    begin\n      localAlertLogID := VerifyID(AlertLogID) ;\n      return AlertLogPtr(localAlertLogID).Suffix.all ;\n    end function GetAlertLogSuffix ;\n\n    ------------------------------------------------------------\n    ------------------------------------------------------------\n    -- Accessor Methods\n    ------------------------------------------------------------\n\n    ------------------------------------------------------------\n    procedure SetGlobalAlertEnable (A : boolean := TRUE) is\n    ------------------------------------------------------------\n    begin\n      GlobalAlertEnabledVar := A ;\n    end procedure SetGlobalAlertEnable ;\n\n    ------------------------------------------------------------\n    impure function GetGlobalAlertEnable return boolean is\n    ------------------------------------------------------------\n    begin\n      return GlobalAlertEnabledVar ;\n    end function GetGlobalAlertEnable ;\n\n    ------------------------------------------------------------\n    -- PT LOCAL\n    procedure SetOneStopCount(\n    ------------------------------------------------------------\n      AlertLogID   : AlertLogIDType ;\n      Level        : AlertType ;\n      Count        : integer\n    ) is\n    begin\n      if AlertLogPtr(AlertLogID).AlertStopCount(Level) = integer'right then\n        AlertLogPtr(AlertLogID).AlertStopCount(Level) := Count ;\n      else\n        AlertLogPtr(AlertLogID).AlertStopCount(Level) :=\n          AlertLogPtr(AlertLogID).AlertStopCount(Level) + Count ;\n      end if ;\n    end procedure SetOneStopCount ;\n\n    ------------------------------------------------------------\n    -- PT Local\n    procedure LocalSetAlertStopCount(AlertLogID : AlertLogIDType ;  Level : AlertType ;  Count : integer) is\n    ------------------------------------------------------------\n    begin\n      SetOneStopCount(AlertLogID, Level, Count) ;\n      if AlertLogID /= ALERTLOG_BASE_ID then\n        LocalSetAlertStopCount(AlertLogPtr(AlertLogID).ParentID, Level, Count) ;\n      end if ;\n    end procedure LocalSetAlertStopCount ;\n\n    ------------------------------------------------------------\n    procedure SetAlertStopCount(AlertLogID : AlertLogIDType ;  Level : AlertType ;  Count : integer) is\n    ------------------------------------------------------------\n      variable localAlertLogID : AlertLogIDType ;\n    begin\n      localAlertLogID := VerifyID(AlertLogID) ;\n      LocalSetAlertStopCount(localAlertLogID, Level, Count) ;\n    end procedure SetAlertStopCount ;\n\n    ------------------------------------------------------------\n    impure function GetAlertStopCount(AlertLogID : AlertLogIDType ;  Level : AlertType) return integer is\n    ------------------------------------------------------------\n      variable localAlertLogID : AlertLogIDType ;\n    begin\n      localAlertLogID := VerifyID(AlertLogID) ;\n      return AlertLogPtr(localAlertLogID).AlertStopCount(Level) ;\n    end function GetAlertStopCount ;\n\n    ------------------------------------------------------------\n    procedure SetAlertPrintCount(AlertLogID : AlertLogIDType ;  Level : AlertType ;  Count : integer) is\n    ------------------------------------------------------------\n      variable localAlertLogID : AlertLogIDType ;\n    begin\n      localAlertLogID := VerifyID(AlertLogID) ;\n      AlertLogPtr(localAlertLogID).AlertPrintCount(Level) := Count ;\n    end procedure SetAlertPrintCount ;\n\n    ------------------------------------------------------------\n    impure function GetAlertPrintCount(AlertLogID : AlertLogIDType ;  Level : AlertType) return integer is\n    ------------------------------------------------------------\n      variable localAlertLogID : AlertLogIDType ;\n    begin\n      localAlertLogID := VerifyID(AlertLogID) ;\n      return AlertLogPtr(localAlertLogID).AlertPrintCount(Level) ;\n    end function GetAlertPrintCount ;\n\n    ------------------------------------------------------------\n    procedure SetAlertPrintCount(AlertLogID : AlertLogIDType ;  Count : AlertCountType) is\n    ------------------------------------------------------------\n      variable localAlertLogID : AlertLogIDType ;\n    begin\n      localAlertLogID := VerifyID(AlertLogID) ;\n      AlertLogPtr(localAlertLogID).AlertPrintCount(FAILURE) := Count(FAILURE) ;\n      AlertLogPtr(localAlertLogID).AlertPrintCount(ERROR)   := Count(ERROR) ;\n      AlertLogPtr(localAlertLogID).AlertPrintCount(WARNING) := Count(WARNING) ;\n    end procedure SetAlertPrintCount ;\n\n    ------------------------------------------------------------\n    impure function GetAlertPrintCount(AlertLogID : AlertLogIDType) return AlertCountType is\n    ------------------------------------------------------------\n      variable localAlertLogID : AlertLogIDType ;\n    begin\n      localAlertLogID := VerifyID(AlertLogID) ;\n      return AlertLogPtr(localAlertLogID).AlertPrintCount ;\n    end function GetAlertPrintCount ;\n\n    ------------------------------------------------------------\n    procedure SetAlertLogPrintParent(AlertLogID : AlertLogIDType ;  PrintParent : AlertLogPrintParentType) is\n    ------------------------------------------------------------\n      variable localAlertLogID, ParentID : AlertLogIDType ;\n    begin\n      localAlertLogID := VerifyID(AlertLogID) ;\n      ParentID := AlertLogPtr(localAlertLogID).ParentID ;\n      if (ParentID = ALERTLOG_BASE_ID or ParentID = REQUIREMENT_ALERTLOG_ID) then\n        AlertLogPtr(localAlertLogID).PrintParent := PRINT_NAME ;\n      else\n        AlertLogPtr(localAlertLogID).PrintParent := PrintParent ;\n      end if ;\n    end procedure SetAlertLogPrintParent ;\n\n    ------------------------------------------------------------\n    impure function GetAlertLogPrintParent(AlertLogID : AlertLogIDType) return AlertLogPrintParentType is\n    ------------------------------------------------------------\n      variable localAlertLogID : AlertLogIDType ;\n    begin\n      localAlertLogID := VerifyID(AlertLogID) ;\n      return AlertLogPtr(localAlertLogID).PrintParent ;\n    end function GetAlertLogPrintParent ;\n\n    ------------------------------------------------------------\n    procedure SetAlertLogReportMode(AlertLogID : AlertLogIDType ;  ReportMode : AlertLogReportModeType) is\n    ------------------------------------------------------------\n      variable localAlertLogID : AlertLogIDType ;\n    begin\n      localAlertLogID := VerifyID(AlertLogID) ;\n      AlertLogPtr(localAlertLogID).ReportMode := ReportMode ;\n    end procedure SetAlertLogReportMode ;\n\n    ------------------------------------------------------------\n    impure function GetAlertLogReportMode(AlertLogID : AlertLogIDType) return AlertLogReportModeType is\n    ------------------------------------------------------------\n      variable localAlertLogID : AlertLogIDType ;\n    begin\n      localAlertLogID := VerifyID(AlertLogID) ;\n      return AlertLogPtr(localAlertLogID).ReportMode ;\n    end function GetAlertLogReportMode ;\n\n    ------------------------------------------------------------\n    procedure SetAlertEnable(Level : AlertType ;  Enable : boolean) is\n    ------------------------------------------------------------\n    begin\n      for i in ALERTLOG_BASE_ID to NumAlertLogIDsVar loop\n        AlertLogPtr(i).AlertEnabled(Level) := Enable ;\n      end loop ;\n    end procedure SetAlertEnable ;\n\n    ------------------------------------------------------------\n    -- PT Local\n    procedure LocalSetAlertEnable(AlertLogID : AlertLogIDType ;  Level : AlertType ;  Enable : boolean ; DescendHierarchy : boolean := TRUE) is\n    ------------------------------------------------------------\n      variable CurID : AlertLogIDType ;\n    begin\n      AlertLogPtr(AlertLogID).AlertEnabled(Level) := Enable ;\n      if DescendHierarchy then\n        CurID := AlertLogPtr(AlertLogID).ChildID ;\n        while CurID > ALERTLOG_BASE_ID loop\n          LocalSetAlertEnable(CurID, Level, Enable, DescendHierarchy) ;\n          CurID := AlertLogPtr(CurID).SiblingID ;\n        end loop ;\n      end if ;\n    end procedure LocalSetAlertEnable ;\n\n    ------------------------------------------------------------\n    procedure SetAlertEnable(AlertLogID : AlertLogIDType ;  Level : AlertType ;  Enable : boolean ; DescendHierarchy : boolean := TRUE) is\n    ------------------------------------------------------------\n      variable localAlertLogID : AlertLogIDType ;\n    begin\n      localAlertLogID := VerifyID(AlertLogID) ;\n      LocalSetAlertEnable(localAlertLogID, Level, Enable, DescendHierarchy) ;\n    end procedure SetAlertEnable ;\n\n    ------------------------------------------------------------\n    impure function GetAlertEnable(AlertLogID : AlertLogIDType ;  Level : AlertType) return boolean is\n    ------------------------------------------------------------\n      variable localAlertLogID : AlertLogIDType ;\n    begin\n      localAlertLogID := VerifyID(AlertLogID) ;\n      return AlertLogPtr(localAlertLogID).AlertEnabled(Level) ;\n    end function GetAlertEnable ;\n\n    ------------------------------------------------------------\n    procedure SetLogEnable(Level : LogType ;  Enable : boolean) is\n    ------------------------------------------------------------\n    begin\n      for i in ALERTLOG_BASE_ID to NumAlertLogIDsVar loop\n        AlertLogPtr(i).LogEnabled(Level) := Enable ;\n      end loop ;\n    end procedure SetLogEnable ;\n\n    ------------------------------------------------------------\n    -- PT Local\n    procedure LocalSetLogEnable(AlertLogID : AlertLogIDType ;  Level : LogType ;  Enable : boolean ; DescendHierarchy : boolean := TRUE) is\n    ------------------------------------------------------------\n      variable CurID : AlertLogIDType ;\n    begin\n      AlertLogPtr(AlertLogID).LogEnabled(Level) := Enable ;\n      if DescendHierarchy then\n        CurID := AlertLogPtr(AlertLogID).ChildID ;\n        while CurID > ALERTLOG_BASE_ID loop\n          LocalSetLogEnable(CurID, Level, Enable, DescendHierarchy) ;\n          CurID := AlertLogPtr(CurID).SiblingID ;\n        end loop ;\n      end if ;\n    end procedure LocalSetLogEnable ;\n\n    ------------------------------------------------------------\n    procedure SetLogEnable(AlertLogID : AlertLogIDType ;  Level : LogType ;  Enable : boolean ; DescendHierarchy : boolean := TRUE) is\n    ------------------------------------------------------------\n      variable localAlertLogID : AlertLogIDType ;\n    begin\n      localAlertLogID := VerifyID(AlertLogID) ;\n      LocalSetLogEnable(localAlertLogID, Level, Enable, DescendHierarchy) ;\n    end procedure SetLogEnable ;\n\n    ------------------------------------------------------------\n    impure function GetLogEnable(AlertLogID : AlertLogIDType ;  Level : LogType) return boolean is\n    ------------------------------------------------------------\n      variable localAlertLogID : AlertLogIDType ;\n    begin\n      localAlertLogID := VerifyID(AlertLogID) ;\n      if Level = ALWAYS then\n        return TRUE ;\n      else\n        return AlertLogPtr(localAlertLogID).LogEnabled(Level) ;\n      end if ;\n    end function GetLogEnable ;\n\n    ------------------------------------------------------------\n    -- PT Local\n    procedure PrintLogLevels(\n    ------------------------------------------------------------\n      AlertLogID   : AlertLogIDType ;\n      Prefix       : string ;\n      IndentAmount : integer\n    ) is\n      variable buf : line ;\n      variable CurID : AlertLogIDType ;\n    begin\n      write(buf, Prefix &  \" \"   & LeftJustify(AlertLogPtr(AlertLogID).Name.all, ReportJustifyAmountVar - IndentAmount)) ;\n      for i in LogIndexType loop\n        if AlertLogPtr(AlertLogID).LogEnabled(i) then\n--          write(buf, \" \"  & to_string(AlertLogPtr(AlertLogID).LogEnabled(i)) ) ;\n          write(buf, \" \"  & to_string(i)) ;\n        end if ;\n      end loop ;\n      WriteLine(buf) ;\n      CurID := AlertLogPtr(AlertLogID).ChildID ;\n      while CurID > ALERTLOG_BASE_ID loop\n-- Always print requirements\n--        if CurID = REQUIREMENT_ALERTLOG_ID and HasRequirementsVar = FALSE then\n--          CurID := AlertLogPtr(CurID).SiblingID ;\n--          next ;\n--        end if ;\n        PrintLogLevels(\n          AlertLogID    => CurID,\n          Prefix        => Prefix & \"  \",\n          IndentAmount  => IndentAmount + 2\n        ) ;\n        CurID := AlertLogPtr(CurID).SiblingID ;\n      end loop ;\n    end procedure PrintLogLevels ;\n\n    ------------------------------------------------------------\n    procedure ReportLogEnables is\n    ------------------------------------------------------------\n      variable TurnedOnJustify : boolean := FALSE ;\n    begin\n      if ReportJustifyAmountVar <= 0 then\n        TurnedOnJustify := TRUE ;\n        SetJustify ;\n      end if ;\n      PrintLogLevels(ALERTLOG_BASE_ID, \"\", 0) ;\n      if TurnedOnJustify then\n        -- Turn it back off\n        SetJustify(FALSE) ;\n      end if ;\n    end procedure ReportLogEnables ;\n\n    ------------------------------------------------------------\n    procedure SetAlertLogOptions (\n    ------------------------------------------------------------\n      FailOnWarning            : OsvvmOptionsType ;\n      FailOnDisabledErrors     : OsvvmOptionsType ;\n      FailOnRequirementErrors  : OsvvmOptionsType ;\n      ReportHierarchy          : OsvvmOptionsType ;\n      WriteAlertErrorCount     : OsvvmOptionsType ;\n      WriteAlertLevel          : OsvvmOptionsType ;\n      WriteAlertName           : OsvvmOptionsType ;\n      WriteAlertTime           : OsvvmOptionsType ;\n      WriteLogErrorCount       : OsvvmOptionsType ;\n      WriteLogLevel            : OsvvmOptionsType ;\n      WriteLogName             : OsvvmOptionsType ;\n      WriteLogTime             : OsvvmOptionsType ;\n      PrintPassed              : OsvvmOptionsType ;\n      PrintAffirmations        : OsvvmOptionsType ;\n      PrintDisabledAlerts      : OsvvmOptionsType ;\n      PrintRequirements        : OsvvmOptionsType ;\n      PrintIfHaveRequirements  : OsvvmOptionsType ;\n      DefaultPassedGoal        : integer ;\n      AlertPrefix              : string ;\n      LogPrefix                : string ;\n      ReportPrefix             : string ;\n      DoneName                 : string ;\n      PassName                 : string ;\n      FailName                 : string ;\n      IdSeparator              : string ;\n      WriteTimeLast            : OsvvmOptionsType ;\n      TimeJustifyAmount        : integer \n    ) is\n    begin\n      if FailOnWarning /= OPT_INIT_PARM_DETECT then\n        FailOnWarningVar := IsEnabled(FailOnWarning) ;\n      end if ;\n      if FailOnDisabledErrors /= OPT_INIT_PARM_DETECT then\n        FailOnDisabledErrorsVar := IsEnabled(FailOnDisabledErrors) ;\n      end if ;\n      if FailOnRequirementErrors /= OPT_INIT_PARM_DETECT then\n        FailOnRequirementErrorsVar := IsEnabled(FailOnRequirementErrors) ;\n      end if ;\n      if ReportHierarchy /= OPT_INIT_PARM_DETECT then\n        ReportHierarchyVar := IsEnabled(ReportHierarchy) ;\n      end if ;\n      if WriteAlertErrorCount /= OPT_INIT_PARM_DETECT then\n        WriteAlertErrorCountVar := IsEnabled(WriteAlertErrorCount) ;\n      end if ;\n      if WriteAlertLevel /= OPT_INIT_PARM_DETECT then\n        WriteAlertLevelVar := IsEnabled(WriteAlertLevel) ;\n      end if ;\n      if WriteAlertName /= OPT_INIT_PARM_DETECT then\n        WriteAlertNameVar := IsEnabled(WriteAlertName) ;\n      end if ;\n      if WriteAlertTime /= OPT_INIT_PARM_DETECT then\n        WriteAlertTimeVar := IsEnabled(WriteAlertTime) ;\n      end if ;\n      if WriteLogErrorCount /= OPT_INIT_PARM_DETECT then\n        WriteLogErrorCountVar := IsEnabled(WriteLogErrorCount) ;\n      end if ;\n      if WriteLogLevel /= OPT_INIT_PARM_DETECT then\n        WriteLogLevelVar := IsEnabled(WriteLogLevel) ;\n      end if ;\n      if WriteLogName /= OPT_INIT_PARM_DETECT then\n        WriteLogNameVar := IsEnabled(WriteLogName) ;\n      end if ;\n      if WriteLogTime /= OPT_INIT_PARM_DETECT then\n        WriteLogTimeVar := IsEnabled(WriteLogTime) ;\n      end if ;\n      if PrintPassed /= OPT_INIT_PARM_DETECT then\n        PrintPassedVar := IsEnabled(PrintPassed) ;\n      end if ;\n      if PrintAffirmations /= OPT_INIT_PARM_DETECT then\n        PrintAffirmationsVar := IsEnabled(PrintAffirmations) ;\n      end if ;\n      if PrintDisabledAlerts /= OPT_INIT_PARM_DETECT then\n        PrintDisabledAlertsVar := IsEnabled(PrintDisabledAlerts) ;\n      end if ;\n      if PrintRequirements /= OPT_INIT_PARM_DETECT then\n        PrintRequirementsVar := IsEnabled(PrintRequirements) ;\n      end if ;\n      if PrintIfHaveRequirements /= OPT_INIT_PARM_DETECT then\n        PrintIfHaveRequirementsVar := IsEnabled(PrintIfHaveRequirements) ;\n      end if ;\n      if DefaultPassedGoal > 0 then\n        DefaultPassedGoalVar := DefaultPassedGoal ;\n      end if ;\n      if AlertPrefix /= OSVVM_STRING_INIT_PARM_DETECT then\n        AlertPrefixVar.Set(AlertPrefix) ;\n      end if ;\n      if LogPrefix /= OSVVM_STRING_INIT_PARM_DETECT then\n        LogPrefixVar.Set(LogPrefix) ;\n      end if ;\n      if ReportPrefix /= OSVVM_STRING_INIT_PARM_DETECT then\n        ReportPrefixVar.Set(ReportPrefix) ;\n      end if ;\n      if DoneName /= OSVVM_STRING_INIT_PARM_DETECT then\n        DoneNameVar.Set(DoneName) ;\n      end if ;\n      if PassName /= OSVVM_STRING_INIT_PARM_DETECT then\n        PassNameVar.Set(PassName) ;\n      end if ;\n      if FailName /= OSVVM_STRING_INIT_PARM_DETECT then\n        FailNameVar.Set(FailName) ;\n      end if ;\n      if IdSeparator /= OSVVM_STRING_INIT_PARM_DETECT then\n        IdSeparatorVar.Set(IdSeparator) ;\n      end if ;\n      if WriteTimeLast /= OPT_INIT_PARM_DETECT then\n        WriteTimeLastVar := IsEnabled(WriteTimeLast) ;\n      end if ;\n      if TimeJustifyAmount >= 0 then\n        TimeJustifyAmountVar := TimeJustifyAmount ;\n      end if ;\n    end procedure SetAlertLogOptions ;\n\n    ------------------------------------------------------------\n    procedure ReportAlertLogOptions is\n    ------------------------------------------------------------\n      variable buf : line ;\n    begin\n      -- Boolean Values\n      swrite(buf, \"ReportAlertLogOptions\" & LF ) ;\n      swrite(buf, \"---------------------\" & LF ) ;\n      swrite(buf, \"FailOnWarningVar:           \" & to_string(FailOnWarningVar        ) & LF ) ;\n      swrite(buf, \"FailOnDisabledErrorsVar:    \" & to_string(FailOnDisabledErrorsVar ) & LF ) ;\n      swrite(buf, \"FailOnRequirementErrorsVar: \" & to_string(FailOnRequirementErrorsVar ) & LF ) ;\n\n      swrite(buf, \"ReportHierarchyVar:         \" & to_string(ReportHierarchyVar      ) & LF ) ;\n      swrite(buf, \"FoundReportHierVar:         \" & to_string(FoundReportHierVar      ) & LF ) ; -- Not set by user\n      swrite(buf, \"FoundAlertHierVar:          \" & to_string(FoundAlertHierVar       ) & LF ) ; -- Not set by user\n      swrite(buf, \"WriteAlertErrorCountVar:    \" & to_string(WriteAlertErrorCountVar ) & LF ) ;\n      swrite(buf, \"WriteAlertLevelVar:         \" & to_string(WriteAlertLevelVar      ) & LF ) ;\n      swrite(buf, \"WriteAlertNameVar:          \" & to_string(WriteAlertNameVar       ) & LF ) ;\n      swrite(buf, \"WriteAlertTimeVar:          \" & to_string(WriteAlertTimeVar       ) & LF ) ;\n      swrite(buf, \"WriteLogErrorCountVar:      \" & to_string(WriteLogErrorCountVar   ) & LF ) ;\n      swrite(buf, \"WriteLogLevelVar:           \" & to_string(WriteLogLevelVar        ) & LF ) ;\n      swrite(buf, \"WriteLogNameVar:            \" & to_string(WriteLogNameVar         ) & LF ) ;\n      swrite(buf, \"WriteLogTimeVar:            \" & to_string(WriteLogTimeVar         ) & LF ) ;\n      swrite(buf, \"PrintPassedVar:             \" & to_string(PrintPassedVar    ) & LF ) ;\n      swrite(buf, \"PrintAffirmationsVar:       \" & to_string(PrintAffirmationsVar    ) & LF ) ;\n      swrite(buf, \"PrintDisabledAlertsVar:     \" & to_string(PrintDisabledAlertsVar  ) & LF ) ;\n      swrite(buf, \"PrintRequirementsVar:       \" & to_string(PrintRequirementsVar    ) & LF ) ;\n      swrite(buf, \"PrintIfHaveRequirementsVar: \" & to_string(PrintIfHaveRequirementsVar  ) & LF ) ;\n\n      -- String\n      swrite(buf, \"AlertPrefixVar:             \" & string'(AlertPrefixVar.Get(OSVVM_DEFAULT_ALERT_PREFIX))  & LF ) ;\n      swrite(buf, \"LogPrefixVar:               \" & string'(LogPrefixVar.Get(OSVVM_DEFAULT_LOG_PREFIX))      & LF ) ;\n      swrite(buf, \"ReportPrefixVar:            \" & ResolveOsvvmWritePrefix(ReportPrefixVar.GetOpt) & LF ) ;\n      swrite(buf, \"DoneNameVar:                \" & ResolveOsvvmDoneName(DoneNameVar.GetOpt)        & LF ) ;\n      swrite(buf, \"PassNameVar:                \" & ResolveOsvvmPassName(PassNameVar.GetOpt)        & LF ) ;\n      swrite(buf, \"FailNameVar:                \" & ResolveOsvvmFailName(FailNameVar.GetOpt)        & LF ) ;\n      swrite(buf, \"WriteTimeLastVar:           \" & to_string(WriteTimeLastVar         ) & LF ) ;\n      swrite(buf, \"TimeJustifyAmountVar:       \" & to_string(TimeJustifyAmountVar     ) & LF ) ;\n      writeline(buf) ;\n    end procedure ReportAlertLogOptions ;\n\n    ------------------------------------------------------------\n    impure function GetAlertLogFailOnWarning        return OsvvmOptionsType is\n    ------------------------------------------------------------\n    begin\n      return to_OsvvmOptionsType(FailOnWarningVar) ;\n    end function GetAlertLogFailOnWarning ;\n\n    ------------------------------------------------------------\n    impure function GetAlertLogFailOnDisabledErrors return OsvvmOptionsType is\n    ------------------------------------------------------------\n    begin\n      return to_OsvvmOptionsType(FailOnDisabledErrorsVar) ;\n    end function GetAlertLogFailOnDisabledErrors ;\n\n    ------------------------------------------------------------\n    impure function GetAlertLogFailOnRequirementErrors return OsvvmOptionsType is\n    ------------------------------------------------------------\n    begin\n      return to_OsvvmOptionsType(FailOnRequirementErrorsVar) ;\n    end function GetAlertLogFailOnRequirementErrors ;\n\n    ------------------------------------------------------------\n    impure function GetAlertLogReportHierarchy      return OsvvmOptionsType is\n    ------------------------------------------------------------\n    begin\n      return to_OsvvmOptionsType(ReportHierarchyVar) ;\n    end function GetAlertLogReportHierarchy ;\n\n    ------------------------------------------------------------\n    impure function GetAlertLogFoundReportHier       return boolean is\n    ------------------------------------------------------------\n    begin\n      return FoundReportHierVar ;\n    end function GetAlertLogFoundReportHier ;\n\n    ------------------------------------------------------------\n    impure function GetAlertLogFoundAlertHier       return boolean is\n    ------------------------------------------------------------\n    begin\n      return FoundAlertHierVar ;\n    end function GetAlertLogFoundAlertHier ;\n\n    ------------------------------------------------------------\n    impure function GetAlertLogWriteAlertErrorCount return OsvvmOptionsType is\n    ------------------------------------------------------------\n    begin\n      return to_OsvvmOptionsType(WriteAlertErrorCountVar) ;\n    end function GetAlertLogWriteAlertErrorCount ;\n\n    ------------------------------------------------------------\n    impure function GetAlertLogWriteAlertLevel      return OsvvmOptionsType is\n    ------------------------------------------------------------\n    begin\n      return to_OsvvmOptionsType(WriteAlertLevelVar) ;\n    end function GetAlertLogWriteAlertLevel ;\n\n    ------------------------------------------------------------\n    impure function GetAlertLogWriteAlertName       return OsvvmOptionsType is\n    ------------------------------------------------------------\n    begin\n      return to_OsvvmOptionsType(WriteAlertNameVar) ;\n    end function GetAlertLogWriteAlertName ;\n\n    ------------------------------------------------------------\n    impure function GetAlertLogWriteAlertTime       return OsvvmOptionsType is\n    ------------------------------------------------------------\n    begin\n      return to_OsvvmOptionsType(WriteAlertTimeVar) ;\n    end function GetAlertLogWriteAlertTime ;\n\n    ------------------------------------------------------------\n    impure function GetAlertLogWriteLogErrorCount return OsvvmOptionsType is\n    ------------------------------------------------------------\n    begin\n      return to_OsvvmOptionsType(WriteLogErrorCountVar) ;\n    end function GetAlertLogWriteLogErrorCount ;\n\n    ------------------------------------------------------------\n    impure function GetAlertLogWriteLogLevel        return OsvvmOptionsType is\n    ------------------------------------------------------------\n    begin\n      return to_OsvvmOptionsType(WriteLogLevelVar) ;\n    end function GetAlertLogWriteLogLevel ;\n\n    ------------------------------------------------------------\n    impure function GetAlertLogWriteLogName         return OsvvmOptionsType is\n    ------------------------------------------------------------\n    begin\n      return to_OsvvmOptionsType(WriteLogNameVar) ;\n    end function GetAlertLogWriteLogName ;\n\n    ------------------------------------------------------------\n    impure function GetAlertLogWriteLogTime         return OsvvmOptionsType is\n    ------------------------------------------------------------\n    begin\n      return to_OsvvmOptionsType(WriteLogTimeVar) ;\n    end function GetAlertLogWriteLogTime ;\n\n    ------------------------------------------------------------\n    impure function GetAlertLogPrintPassed    return OsvvmOptionsType is\n    ------------------------------------------------------------\n    begin\n      return to_OsvvmOptionsType(PrintPassedVar) ;\n    end function GetAlertLogPrintPassed ;\n\n    ------------------------------------------------------------\n    impure function GetAlertLogPrintAffirmations    return OsvvmOptionsType is\n    ------------------------------------------------------------\n    begin\n      return to_OsvvmOptionsType(PrintAffirmationsVar) ;\n    end function GetAlertLogPrintAffirmations ;\n\n    ------------------------------------------------------------\n    impure function GetAlertLogPrintDisabledAlerts  return OsvvmOptionsType is\n    ------------------------------------------------------------\n    begin\n      return to_OsvvmOptionsType(PrintDisabledAlertsVar) ;\n    end function GetAlertLogPrintDisabledAlerts ;\n\n    ------------------------------------------------------------\n    impure function GetAlertLogPrintRequirements    return OsvvmOptionsType is\n    ------------------------------------------------------------\n    begin\n      return to_OsvvmOptionsType(PrintRequirementsVar) ;\n    end function GetAlertLogPrintRequirements ;\n\n    ------------------------------------------------------------\n    impure function GetAlertLogPrintIfHaveRequirements    return OsvvmOptionsType is\n    ------------------------------------------------------------\n    begin\n      return to_OsvvmOptionsType(PrintIfHaveRequirementsVar) ;\n    end function GetAlertLogPrintIfHaveRequirements ;\n\n    ------------------------------------------------------------\n    impure function GetAlertLogDefaultPassedGoal    return integer is\n    ------------------------------------------------------------\n    begin\n      return DefaultPassedGoalVar ;\n    end function GetAlertLogDefaultPassedGoal ;\n\n    ------------------------------------------------------------\n    impure function GetAlertLogAlertPrefix          return string is\n    ------------------------------------------------------------\n    begin\n      return AlertPrefixVar.Get(OSVVM_DEFAULT_ALERT_PREFIX) ;\n    end function GetAlertLogAlertPrefix ;\n\n    ------------------------------------------------------------\n    impure function GetAlertLogLogPrefix            return string is\n    ------------------------------------------------------------\n    begin\n      return LogPrefixVar.Get(OSVVM_DEFAULT_LOG_PREFIX) ;\n    end function GetAlertLogLogPrefix ;\n\n    ------------------------------------------------------------\n    impure function GetAlertLogReportPrefix return string is\n    ------------------------------------------------------------\n    begin\n      return ResolveOsvvmWritePrefix(ReportPrefixVar.GetOpt) ;\n    end function GetAlertLogReportPrefix ;\n\n    ------------------------------------------------------------\n    impure function GetAlertLogDoneName return string is\n    ------------------------------------------------------------\n    begin\n      return ResolveOsvvmDoneName(DoneNameVar.GetOpt) ;\n    end function GetAlertLogDoneName ;\n\n    ------------------------------------------------------------\n    impure function GetAlertLogPassName return string is\n    ------------------------------------------------------------\n    begin\n      return ResolveOsvvmPassName(PassNameVar.GetOpt) ;\n    end function GetAlertLogPassName ;\n\n    ------------------------------------------------------------\n    impure function GetAlertLogFailName return string is\n    ------------------------------------------------------------\n    begin\n      return ResolveOsvvmFailName(FailNameVar.GetOpt) ;\n    end function GetAlertLogFailName ;\n\n    ------------------------------------------------------------\n    impure function GetAlertLogWriteTimeLast        return OsvvmOptionsType is\n    ------------------------------------------------------------\n    begin\n      return to_OsvvmOptionsType(WriteTimeLastVar) ;\n    end function GetAlertLogWriteTimeLast ;\n\n\n  end protected body AlertLogStructPType ;\n\n\n\n  shared variable AlertLogStruct : AlertLogStructPType ;\n\n-- synthesis translate_on\n\n--- ///////////////////////////////////////////////////////////////////////////\n--- ///////////////////////////////////////////////////////////////////////////\n--- ///////////////////////////////////////////////////////////////////////////\n\n  ------------------------------------------------------------\n  procedure Alert(\n  ------------------------------------------------------------\n    AlertLogID   : AlertLogIDType ;\n    Message      : string  ;\n    Level        : AlertType := ERROR\n  ) is\n  begin\n    -- synthesis translate_off\n    AlertLogStruct.Alert(AlertLogID, Message, Level) ;\n    -- synthesis translate_on\n  end procedure alert ;\n\n  ------------------------------------------------------------\n  procedure Alert( Message : string ; Level : AlertType := ERROR ) is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    AlertLogStruct.Alert(ALERT_DEFAULT_ID, Message, Level) ;\n    -- synthesis translate_on\n  end procedure alert ;\n\n  ------------------------------------------------------------\n  procedure IncAlertCount(\n  ------------------------------------------------------------\n    AlertLogID   : AlertLogIDType ;\n    Level        : AlertType := ERROR\n  ) is\n  begin\n    -- synthesis translate_off\n    AlertLogStruct.IncAlertCount(AlertLogID, Level) ;\n    -- synthesis translate_on\n  end procedure IncAlertCount ;\n\n  ------------------------------------------------------------\n  procedure IncAlertCount( Level : AlertType := ERROR ) is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    AlertLogStruct.IncAlertCount(ALERT_DEFAULT_ID, Level) ;\n    -- synthesis translate_on\n  end procedure IncAlertCount ;\n\n\n  ------------------------------------------------------------\n  procedure AlertIf( AlertLogID  : AlertLogIDType ; condition : boolean ; Message : string ; Level : AlertType := ERROR ) is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    if condition then\n      AlertLogStruct.Alert(AlertLogID , Message, Level) ;\n    end if ;\n    -- synthesis translate_on\n  end procedure AlertIf ;\n\n  ------------------------------------------------------------\n  procedure AlertIf( condition : boolean ; Message : string ; Level : AlertType := ERROR ) is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    if condition then\n      AlertLogStruct.Alert(ALERT_DEFAULT_ID , Message, Level) ;\n    end if ;\n    -- synthesis translate_on\n  end procedure AlertIf ;\n\n  ------------------------------------------------------------\n  -- useful in a loop:  exit when AlertIf( not ReadValid, failure, \"Read Failed\") ;\n  impure function  AlertIf( AlertLogID  : AlertLogIDType ; condition : boolean ; Message : string ; Level : AlertType := ERROR ) return boolean is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    if condition then\n      AlertLogStruct.Alert(AlertLogID , Message, Level) ;\n    end if ;\n    -- synthesis translate_on\n    return condition ;\n  end function AlertIf ;\n\n  ------------------------------------------------------------\n  impure function  AlertIf( condition : boolean ; Message : string ; Level : AlertType := ERROR ) return boolean is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    if condition then\n      AlertLogStruct.Alert(ALERT_DEFAULT_ID, Message, Level) ;\n    end if ;\n    -- synthesis translate_on\n    return condition ;\n  end function AlertIf ;\n\n  ------------------------------------------------------------\n  procedure AlertIfNot( AlertLogID  : AlertLogIDType ; condition : boolean ; Message : string ; Level : AlertType := ERROR ) is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    if not condition then\n      AlertLogStruct.Alert(AlertLogID, Message, Level) ;\n    end if ;\n    -- synthesis translate_on\n  end procedure AlertIfNot ;\n\n  ------------------------------------------------------------\n  procedure AlertIfNot( condition : boolean ; Message : string ; Level : AlertType := ERROR ) is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    if not condition then\n      AlertLogStruct.Alert(ALERT_DEFAULT_ID, Message, Level) ;\n    end if ;\n    -- synthesis translate_on\n  end procedure AlertIfNot ;\n\n  ------------------------------------------------------------\n  -- useful in a loop:  exit when AlertIfNot( not ReadValid, failure, \"Read Failed\") ;\n  impure function  AlertIfNot( AlertLogID  : AlertLogIDType ; condition : boolean ; Message : string ; Level : AlertType := ERROR ) return boolean is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    if not condition then\n      AlertLogStruct.Alert(AlertLogID, Message, Level) ;\n    end if ;\n    -- synthesis translate_on\n    return not condition ;\n  end function AlertIfNot ;\n\n  ------------------------------------------------------------\n  impure function  AlertIfNot( condition : boolean ; Message : string ; Level : AlertType := ERROR ) return boolean is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    if not condition then\n      AlertLogStruct.Alert(ALERT_DEFAULT_ID, Message, Level) ;\n    end if ;\n    -- synthesis translate_on\n    return not condition ;\n  end function AlertIfNot ;\n\n\n  ------------------------------------------------------------\n  -- AlertIfEqual with AlertLogID\n  ------------------------------------------------------------\n  procedure AlertIfEqual( AlertLogID : AlertLogIDType ; L, R : std_logic ;        Message : string ; Level : AlertType := ERROR )  is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    if MetaMatch(L, R) then\n      AlertLogStruct.Alert(AlertLogID, Message & \" L = R,  L = \" & to_string(L) & \"   R = \" & to_string(R), Level) ;\n    end if ;\n    -- synthesis translate_on\n  end procedure AlertIfEqual ;\n\n  ------------------------------------------------------------\n  procedure AlertIfEqual( AlertLogID : AlertLogIDType ; L, R : std_logic_vector ; Message : string ; Level : AlertType := ERROR )  is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    if MetaMatch(L, R) then\n      AlertLogStruct.Alert(AlertLogID, Message & \" L = R,  L = \" & to_hxstring(L) & \"   R = \" & to_hxstring(R), Level) ;\n    end if ;\n    -- synthesis translate_on\n  end procedure AlertIfEqual ;\n\n  ------------------------------------------------------------\n  procedure AlertIfEqual( AlertLogID : AlertLogIDType ; L, R : unsigned ;         Message : string ; Level : AlertType := ERROR )  is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    if MetaMatch(L, R) then\n      AlertLogStruct.Alert(AlertLogID, Message & \" L = R,  L = \" & to_hxstring(L) & \"   R = \" & to_hxstring(R), Level) ;\n    end if ;\n    -- synthesis translate_on\n  end procedure AlertIfEqual ;\n\n  ------------------------------------------------------------\n  procedure AlertIfEqual( AlertLogID : AlertLogIDType ; L, R : signed ;           Message : string ; Level : AlertType := ERROR )  is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    if MetaMatch(L, R) then\n      AlertLogStruct.Alert(AlertLogID, Message & \" L = R,  L = \" & to_hxstring(L) & \"   R = \" & to_hxstring(R), Level) ;\n    end if ;\n    -- synthesis translate_on\n  end procedure AlertIfEqual ;\n\n  ------------------------------------------------------------\n  procedure AlertIfEqual( AlertLogID : AlertLogIDType ; L, R : integer ;          Message : string ; Level : AlertType := ERROR )  is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    if L = R then\n      AlertLogStruct.Alert(AlertLogID, Message & \" L = R,  L = \" & to_string(L) & \"   R = \" & to_string(R), Level) ;\n    end if ;\n    -- synthesis translate_on\n  end procedure AlertIfEqual ;\n\n  ------------------------------------------------------------\n  procedure AlertIfEqual( AlertLogID : AlertLogIDType ; L, R : real ;             Message : string ; Level : AlertType := ERROR )  is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    if L = R then\n      AlertLogStruct.Alert(AlertLogID, Message & \" L = R,  L = \" & to_string(L, 4) & \"   R = \" & to_string(R, 4), Level) ;\n    end if ;\n    -- synthesis translate_on\n  end procedure AlertIfEqual ;\n\n  ------------------------------------------------------------\n  procedure AlertIfEqual( AlertLogID : AlertLogIDType ; L, R : character ;        Message : string ; Level : AlertType := ERROR )  is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    if L = R then\n      AlertLogStruct.Alert(AlertLogID, Message & \" L = R,  L = \" & L & \"   R = \" & R, Level) ;\n    end if ;\n    -- synthesis translate_on\n  end procedure AlertIfEqual ;\n\n  ------------------------------------------------------------\n  procedure AlertIfEqual( AlertLogID : AlertLogIDType ; L, R : string ;           Message : string ; Level : AlertType := ERROR )  is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    if L = R then\n      AlertLogStruct.Alert(AlertLogID, Message & \" L = R,  L = \" & L & \"   R = \" & R, Level) ;\n    end if ;\n    -- synthesis translate_on\n  end procedure AlertIfEqual ;\n\n  ------------------------------------------------------------\n  procedure AlertIfEqual( AlertLogID : AlertLogIDType ; L, R : time ;             Message : string ; Level : AlertType := ERROR )  is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    if L = R then\n      AlertLogStruct.Alert(AlertLogID, Message & \" L = R,  L = \" & to_string(L, GetOsvvmDefaultTimeUnits)\n                                                     & \"   R = \" & to_string(R, GetOsvvmDefaultTimeUnits), Level) ;\n    end if ;\n    -- synthesis translate_on\n  end procedure AlertIfEqual ;\n\n\n  ------------------------------------------------------------\n  -- AlertIfEqual without AlertLogID\n  ------------------------------------------------------------\n  procedure AlertIfEqual( L, R : std_logic ;        Message : string ; Level : AlertType := ERROR )  is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    if MetaMatch(L, R) then\n      AlertLogStruct.Alert(ALERT_DEFAULT_ID, Message & \" L = R,  L = \" & to_string(L) & \"   R = \" & to_string(R), Level) ;\n    end if ;\n    -- synthesis translate_on\n  end procedure AlertIfEqual ;\n\n  ------------------------------------------------------------\n  procedure AlertIfEqual( L, R : std_logic_vector ; Message : string ; Level : AlertType := ERROR )  is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    if MetaMatch(L, R) then\n      AlertLogStruct.Alert(ALERT_DEFAULT_ID, Message & \" L = R,  L = \" & to_hxstring(L) & \"   R = \" & to_hxstring(R), Level) ;\n    end if ;\n    -- synthesis translate_on\n  end procedure AlertIfEqual ;\n\n  ------------------------------------------------------------\n  procedure AlertIfEqual( L, R : unsigned ;         Message : string ; Level : AlertType := ERROR )  is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    if MetaMatch(L, R) then\n      AlertLogStruct.Alert(ALERT_DEFAULT_ID, Message & \" L = R,  L = \" & to_hxstring(L) & \"   R = \" & to_hxstring(R), Level) ;\n    end if ;\n    -- synthesis translate_on\n  end procedure AlertIfEqual ;\n\n  ------------------------------------------------------------\n  procedure AlertIfEqual( L, R : signed ;           Message : string ; Level : AlertType := ERROR )  is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    if MetaMatch(L, R) then\n      AlertLogStruct.Alert(ALERT_DEFAULT_ID, Message & \" L = R,  L = \" & to_hxstring(L) & \"   R = \" & to_hxstring(R), Level) ;\n    end if ;\n    -- synthesis translate_on\n  end procedure AlertIfEqual ;\n\n  ------------------------------------------------------------\n  procedure AlertIfEqual( L, R : integer ;          Message : string ; Level : AlertType := ERROR )  is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    if L = R then\n      AlertLogStruct.Alert(ALERT_DEFAULT_ID, Message & \" L = R,  L = \" & to_string(L) & \"   R = \" & to_string(R), Level) ;\n    end if ;\n    -- synthesis translate_on\n  end procedure AlertIfEqual ;\n\n  ------------------------------------------------------------\n  procedure AlertIfEqual( L, R : real ;             Message : string ; Level : AlertType := ERROR )  is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    if L = R then\n      AlertLogStruct.Alert(ALERT_DEFAULT_ID, Message & \" L = R,  L = \" & to_string(L, 4) & \"   R = \" & to_string(R, 4), Level) ;\n    end if ;\n    -- synthesis translate_on\n  end procedure AlertIfEqual ;\n\n  ------------------------------------------------------------\n  procedure AlertIfEqual( L, R : character ;        Message : string ; Level : AlertType := ERROR )  is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    if L = R then\n      AlertLogStruct.Alert(ALERT_DEFAULT_ID, Message & \" L = R,  L = \" & L & \"   R = \" & R, Level) ;\n    end if ;\n    -- synthesis translate_on\n  end procedure AlertIfEqual ;\n\n  ------------------------------------------------------------\n  procedure AlertIfEqual( L, R : string ;           Message : string ; Level : AlertType := ERROR )  is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    if L = R then\n      AlertLogStruct.Alert(ALERT_DEFAULT_ID, Message & \" L = R,  L = \" & L & \"   R = \" & R, Level) ;\n    end if ;\n    -- synthesis translate_on\n  end procedure AlertIfEqual ;\n\n  ------------------------------------------------------------\n  procedure AlertIfEqual( L, R : time ;             Message : string ; Level : AlertType := ERROR )  is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    if L = R then\n      AlertLogStruct.Alert(ALERT_DEFAULT_ID, Message & \" L = R,  L = \" & to_string(L, GetOsvvmDefaultTimeUnits)\n                                                           & \"   R = \" & to_string(R, GetOsvvmDefaultTimeUnits), Level) ;\n    end if ;\n    -- synthesis translate_on\n  end procedure AlertIfEqual ;\n\n\n  ------------------------------------------------------------\n  -- AlertIfNotEqual with AlertLogID\n  ------------------------------------------------------------\n  procedure AlertIfNotEqual( AlertLogID : AlertLogIDType ; L, R : std_logic ;        Message : string ; Level : AlertType := ERROR )  is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    if not MetaMatch(L, R) then\n      AlertLogStruct.Alert(AlertLogID, Message & \" L /= R,  L = \" & to_string(L) & \"   R = \" & to_string(R), Level) ;\n    end if ;\n    -- synthesis translate_on\n  end procedure AlertIfNotEqual ;\n\n  ------------------------------------------------------------\n  procedure AlertIfNotEqual( AlertLogID : AlertLogIDType ; L, R : std_logic_vector ; Message : string ; Level : AlertType := ERROR )  is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    if not MetaMatch(L, R) then\n      AlertLogStruct.Alert(AlertLogID, Message & \" L /= R,  L = \" & to_hxstring(L) & \"   R = \" & to_hxstring(R), Level) ;\n    end if ;\n    -- synthesis translate_on\n  end procedure AlertIfNotEqual ;\n\n  ------------------------------------------------------------\n  procedure AlertIfNotEqual( AlertLogID : AlertLogIDType ; L, R : unsigned ;         Message : string ; Level : AlertType := ERROR )  is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    if  not MetaMatch(L, R) then\n      AlertLogStruct.Alert(AlertLogID, Message & \" L /= R,  L = \" & to_hxstring(L) & \"   R = \" & to_hxstring(R), Level) ;\n    end if ;\n    -- synthesis translate_on\n  end procedure AlertIfNotEqual ;\n\n  ------------------------------------------------------------\n  procedure AlertIfNotEqual( AlertLogID : AlertLogIDType ; L, R : signed ;           Message : string ; Level : AlertType := ERROR )  is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    if not MetaMatch(L, R) then\n      AlertLogStruct.Alert(AlertLogID, Message & \" L /= R,  L = \" & to_hxstring(L) & \"   R = \" & to_hxstring(R), Level) ;\n    end if ;\n    -- synthesis translate_on\n  end procedure AlertIfNotEqual ;\n\n  ------------------------------------------------------------\n  procedure AlertIfNotEqual( AlertLogID : AlertLogIDType ; L, R : integer ;          Message : string ; Level : AlertType := ERROR )  is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    if L /= R then\n      AlertLogStruct.Alert(AlertLogID, Message & \" L /= R,  L = \" & to_string(L) & \"   R = \" & to_string(R), Level) ;\n    end if ;\n    -- synthesis translate_on\n  end procedure AlertIfNotEqual ;\n\n  ------------------------------------------------------------\n  procedure AlertIfNotEqual( AlertLogID : AlertLogIDType ; L, R : real ;             Message : string ; Level : AlertType := ERROR )  is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    if L /= R then\n      AlertLogStruct.Alert(AlertLogID, Message & \" L /= R,  L = \" & to_string(L, 4) & \"   R = \" & to_string(R, 4), Level) ;\n    end if ;\n    -- synthesis translate_on\n  end procedure AlertIfNotEqual ;\n\n  ------------------------------------------------------------\n  procedure AlertIfNotEqual( AlertLogID : AlertLogIDType ; L, R : character ;        Message : string ; Level : AlertType := ERROR )  is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    if L /= R then\n      AlertLogStruct.Alert(AlertLogID, Message & \" L /= R,  L = \" & L & \"   R = \" & R, Level) ;\n    end if ;\n    -- synthesis translate_on\n  end procedure AlertIfNotEqual ;\n\n  ------------------------------------------------------------\n  procedure AlertIfNotEqual( AlertLogID : AlertLogIDType ; L, R : string ;           Message : string ; Level : AlertType := ERROR )  is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    if L /= R then\n      AlertLogStruct.Alert(AlertLogID, Message & \" L /= R,  L = \" & L & \"   R = \" & R, Level) ;\n    end if ;\n    -- synthesis translate_on\n  end procedure AlertIfNotEqual ;\n\n  ------------------------------------------------------------\n  procedure AlertIfNotEqual( AlertLogID : AlertLogIDType ; L, R : time ;             Message : string ; Level : AlertType := ERROR )  is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    if L /= R then\n      AlertLogStruct.Alert(AlertLogID, Message & \" L /= R,  L = \" & to_string(L, GetOsvvmDefaultTimeUnits) &\n                                                        \"   R = \" & to_string(R, GetOsvvmDefaultTimeUnits), Level) ;\n    end if ;\n    -- synthesis translate_on\n  end procedure AlertIfNotEqual ;\n\n\n  ------------------------------------------------------------\n  -- AlertIfNotEqual without AlertLogID\n  ------------------------------------------------------------\n  procedure AlertIfNotEqual( L, R : std_logic ;        Message : string ; Level : AlertType := ERROR )  is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    if not MetaMatch(L, R) then\n      AlertLogStruct.Alert(ALERT_DEFAULT_ID, Message & \" L /= R,  L = \" & to_string(L) & \"   R = \" & to_string(R), Level) ;\n    end if ;\n    -- synthesis translate_on\n  end procedure AlertIfNotEqual ;\n\n  ------------------------------------------------------------\n  procedure AlertIfNotEqual( L, R : std_logic_vector ; Message : string ; Level : AlertType := ERROR )  is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    if not MetaMatch(L, R) then\n      AlertLogStruct.Alert(ALERT_DEFAULT_ID, Message & \" L /= R,  L = \" & to_hxstring(L) & \"   R = \" & to_hxstring(R), Level) ;\n    end if ;\n    -- synthesis translate_on\n  end procedure AlertIfNotEqual ;\n\n  ------------------------------------------------------------\n  procedure AlertIfNotEqual( L, R : unsigned ;         Message : string ; Level : AlertType := ERROR )  is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    if not MetaMatch(L, R) then\n      AlertLogStruct.Alert(ALERT_DEFAULT_ID, Message & \" L /= R,  L = \" & to_hxstring(L) & \"   R = \" & to_hxstring(R), Level) ;\n    end if ;\n    -- synthesis translate_on\n  end procedure AlertIfNotEqual ;\n\n  ------------------------------------------------------------\n  procedure AlertIfNotEqual( L, R : signed ;           Message : string ; Level : AlertType := ERROR )  is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    if not MetaMatch(L, R) then\n      AlertLogStruct.Alert(ALERT_DEFAULT_ID, Message & \" L /= R,  L = \" & to_hxstring(L) & \"   R = \" & to_hxstring(R), Level) ;\n    end if ;\n    -- synthesis translate_on\n  end procedure AlertIfNotEqual ;\n\n  ------------------------------------------------------------\n  procedure AlertIfNotEqual( L, R : integer ;          Message : string ; Level : AlertType := ERROR )  is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    if L /= R then\n      AlertLogStruct.Alert(ALERT_DEFAULT_ID, Message & \" L /= R,  L = \" & to_string(L) & \"   R = \" & to_string(R), Level) ;\n    end if ;\n    -- synthesis translate_on\n  end procedure AlertIfNotEqual ;\n\n  ------------------------------------------------------------\n  procedure AlertIfNotEqual( L, R : real ;             Message : string ; Level : AlertType := ERROR )  is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    if L /= R then\n      AlertLogStruct.Alert(ALERT_DEFAULT_ID, Message & \" L /= R,  L = \" & to_string(L, 4) & \"   R = \" & to_string(R, 4), Level) ;\n    end if ;\n    -- synthesis translate_on\n  end procedure AlertIfNotEqual ;\n\n  ------------------------------------------------------------\n  procedure AlertIfNotEqual( L, R : character ;        Message : string ; Level : AlertType := ERROR )  is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    if L /= R then\n      AlertLogStruct.Alert(ALERT_DEFAULT_ID, Message & \" L /= R,  L = \" & L & \"   R = \" & R, Level) ;\n    end if ;\n    -- synthesis translate_on\n  end procedure AlertIfNotEqual ;\n\n  ------------------------------------------------------------\n  procedure AlertIfNotEqual( L, R : string ;           Message : string ; Level : AlertType := ERROR )  is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    if L /= R then\n      AlertLogStruct.Alert(ALERT_DEFAULT_ID, Message & \" L /= R,  L = \" & L & \"   R = \" & R, Level) ;\n    end if ;\n    -- synthesis translate_on\n  end procedure AlertIfNotEqual ;\n\n  ------------------------------------------------------------\n  procedure AlertIfNotEqual( L, R : time ;           Message : string ; Level : AlertType := ERROR )  is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    if L /= R then\n      AlertLogStruct.Alert(ALERT_DEFAULT_ID, Message & \" L /= R,  L = \" & to_string(L, GetOsvvmDefaultTimeUnits) &\n                                                              \"   R = \" & to_string(R, GetOsvvmDefaultTimeUnits), Level) ;\n    end if ;\n    -- synthesis translate_on\n  end procedure AlertIfNotEqual ;\n\n  ------------------------------------------------------------\n  -- Local\n  function LocalDiff (Line1, Line2 : string) return boolean is\n  -- Simple diff.  Move to string handling functions?\n  ------------------------------------------------------------\n    alias aLine1 : string (1 to Line1'length) is Line1 ;\n    alias aLine2 : string (1 to Line2'length) is Line2 ;\n    variable EndLine1 : integer := Line1'length;\n    variable EndLine2 : integer := Line2'length;\n  begin\n    -- Strip off any windows or unix end of line characters\n    for i in Line1'length downto 1 loop\n      exit when aLine1(i) /= LF and aLine1(i) /= CR ;\n      EndLine1 := i - 1;\n    end loop ;\n    for i in Line2'length downto 1 loop\n      exit when aLine2(i) /= LF and aLine2(i) /= CR ;\n      EndLine2 := i - 1;\n    end loop ;\n\n    return aLine1(1 to EndLine1) /= aLine2(1 to EndLine2) ;\n  end function LocalDiff ;\n\n  ------------------------------------------------------------\n  -- Local\n  procedure LocalAlertIfDiff (AlertLogID : AlertLogIDType ; file File1, File2 : text; Message : string ; Level : AlertType ; Valid : out boolean ) is\n  ------------------------------------------------------------\n    variable Buf1, Buf2 : line ;\n    variable File1Done, File2Done : boolean ;\n    variable LineCount : integer := 0 ;\n  begin\n    -- synthesis translate_off\n    ReadLoop : loop\n      File1Done := EndFile(File1) ;\n      File2Done := EndFile(File2) ;\n      exit ReadLoop when File1Done or File2Done ;\n\n      ReadLine(File1, Buf1) ;\n      ReadLine(File2, Buf2) ;\n      LineCount := LineCount + 1 ;\n\n--      if Buf1.all /= Buf2.all then  -- fails when use Windows file in Unix\n      if LocalDiff(Buf1.all, Buf2.all) then\n        AlertLogStruct.Alert(AlertLogID , Message & \" File miscompare on line \" & to_string(LineCount), Level) ;\n        exit ReadLoop ;\n      end if ;\n    end loop ReadLoop ;\n    if File1Done /= File2Done then\n      if not File1Done then\n        AlertLogStruct.Alert(AlertLogID , Message & \" File1 longer than File2 \" & to_string(LineCount), Level) ;\n      end if ;\n      if not File2Done then\n        AlertLogStruct.Alert(AlertLogID , Message & \" File2 longer than File1 \" & to_string(LineCount), Level) ;\n      end if ;\n    end if;\n    if File1Done and File2Done then\n      Valid := TRUE ;\n    else\n      Valid := FALSE ;\n    end if ;\n    -- synthesis translate_on\n  end procedure LocalAlertIfDiff ;\n\n  ------------------------------------------------------------\n  -- Local\n  procedure LocalAlertIfDiff (AlertLogID : AlertLogIDType ; Name1, Name2 : string; Message : string ; Level : AlertType ; Valid : out boolean ) is\n  -- Open files and call AlertIfDiff[text, ...]\n  ------------------------------------------------------------\n    file FileID1, FileID2 : text ;\n    variable status1, status2 : file_open_status ;\n    constant RESOLVED_MESSAGE : string := IfElse(Message = \"\", \"\", Message & \" \") ;\n  begin\n    -- synthesis translate_off\n    Valid := FALSE ;\n    file_open(status1, FileID1, Name1, READ_MODE) ;\n    file_open(status2, FileID2, Name2, READ_MODE) ;\n    if status1 = OPEN_OK and status2 = OPEN_OK then\n      LocalAlertIfDiff (AlertLogID, FileID1, FileID2, RESOLVED_MESSAGE & \"diff \" & Name1 & \"  \" & Name2 & \", \", Level, Valid) ;\n\n    else\n      if status1 /= OPEN_OK then\n        AlertLogStruct.Alert(AlertLogID , RESOLVED_MESSAGE & \"File, \" & Name1 & \", did not open\", Level) ;\n      end if ;\n      if status2 /= OPEN_OK then\n        AlertLogStruct.Alert(AlertLogID , RESOLVED_MESSAGE & \"File, \" & Name2 & \", did not open\", Level) ;\n      end if ;\n    end if;\n    -- synthesis translate_on\n  end procedure LocalAlertIfDiff ;\n\n  ------------------------------------------------------------\n  procedure AlertIfDiff (AlertLogID : AlertLogIDType ; Name1, Name2 : string; Message : string := \"\" ; Level : AlertType := ERROR ) is\n  -- Open files and call AlertIfDiff[text, ...]\n  ------------------------------------------------------------\n    variable Valid : boolean ;\n  begin\n    -- synthesis translate_off\n    LocalAlertIfDiff (AlertLogID, Name1, Name2, Message, Level, Valid) ;\n    -- synthesis translate_on\n  end procedure AlertIfDiff ;\n\n  ------------------------------------------------------------\n  procedure AlertIfDiff (Name1, Name2 : string; Message : string := \"\" ; Level : AlertType := ERROR ) is\n  ------------------------------------------------------------\n    variable Valid : boolean ;\n  begin\n    -- synthesis translate_off\n    LocalAlertIfDiff (ALERT_DEFAULT_ID, Name1, Name2, Message, Level, Valid) ;\n    -- synthesis translate_on\n  end procedure AlertIfDiff ;\n\n  ------------------------------------------------------------\n  procedure AlertIfDiff (AlertLogID : AlertLogIDType ; file File1, File2 : text; Message : string := \"\" ; Level : AlertType := ERROR ) is\n  -- Simple diff.\n  ------------------------------------------------------------\n    variable Valid : boolean ;\n  begin\n    -- synthesis translate_off\n    LocalAlertIfDiff (AlertLogID, File1, File2, Message, Level, Valid ) ;\n    -- synthesis translate_on\n  end procedure AlertIfDiff ;\n\n  ------------------------------------------------------------\n  procedure AlertIfDiff (file File1, File2 : text; Message : string := \"\" ; Level : AlertType := ERROR ) is\n  ------------------------------------------------------------\n    variable Valid : boolean ;\n  begin\n    -- synthesis translate_off\n    LocalAlertIfDiff (ALERT_DEFAULT_ID, File1, File2, Message, Level, Valid ) ;\n    -- synthesis translate_on\n  end procedure AlertIfDiff ;\n\n  ------------------------------------------------------------\n  procedure AffirmIf(\n  ------------------------------------------------------------\n    AlertLogID       : AlertLogIDType ;\n    condition        : boolean ;\n    ReceivedMessage  : string ;\n    ExpectedMessage  : string ;\n    Enable           : boolean  := FALSE   -- override internal enable\n  ) is\n  begin\n    -- synthesis translate_off\n    if condition then\n      -- PASSED.  Count affirmations and PASSED internal to LOG to catch all of them\n      AlertLogStruct.Log(AlertLogID, ReceivedMessage, PASSED, Enable) ;\n    else\n      AlertLogStruct.IncAffirmCount(AlertLogID) ;  -- count the affirmation\n      AlertLogStruct.Alert(AlertLogID, ReceivedMessage & ' ' & ExpectedMessage, ERROR) ;\n    end if ;\n    -- synthesis translate_on\n  end procedure AffirmIf ;\n\n  ------------------------------------------------------------\n  procedure AffirmIf( condition : boolean ; ReceivedMessage, ExpectedMessage : string ; Enable : boolean := FALSE ) is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    AffirmIf(ALERT_DEFAULT_ID, condition, ReceivedMessage, ExpectedMessage, Enable) ;\n    -- synthesis translate_on\n  end procedure AffirmIf ;\n\n  ------------------------------------------------------------\n  impure function AffirmIf( AlertLogID : AlertLogIDType ; condition : boolean ; ReceivedMessage, ExpectedMessage : string ; Enable : boolean := FALSE ) return boolean is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    AffirmIf(AlertLogID, condition, ReceivedMessage, ExpectedMessage, Enable) ;\n    -- synthesis translate_on\n    return condition ;\n  end function AffirmIf ;\n\n  ------------------------------------------------------------\n  impure function AffirmIf( condition : boolean ; ReceivedMessage, ExpectedMessage : string ; Enable : boolean := FALSE ) return boolean is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    AffirmIf(ALERT_DEFAULT_ID, condition, ReceivedMessage, ExpectedMessage, Enable) ;\n    -- synthesis translate_on\n    return condition ;\n  end function AffirmIf ;\n\n\n  ------------------------------------------------------------\n  procedure AffirmIf(\n  ------------------------------------------------------------\n    AlertLogID   : AlertLogIDType ;\n    condition    : boolean ;\n    Message      : string ;\n    Enable       : boolean  := FALSE   -- override internal enable\n  ) is\n  begin\n    -- synthesis translate_off\n    if condition then\n      -- PASSED.  Count affirmations and PASSED internal to LOG to catch all of them\n      AlertLogStruct.Log(AlertLogID, Message, PASSED, Enable) ;\n    else\n      AlertLogStruct.IncAffirmCount(AlertLogID) ;  -- count the affirmation\n      AlertLogStruct.Alert(AlertLogID, Message, ERROR) ;\n    end if ;\n    -- synthesis translate_on\n  end procedure AffirmIf ;\n\n  ------------------------------------------------------------\n  procedure AffirmIf(condition : boolean ; Message : string ;  Enable : boolean := FALSE) is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    AffirmIf(ALERT_DEFAULT_ID, condition, Message, Enable) ;\n    -- synthesis translate_on\n  end procedure AffirmIf;\n\n  ------------------------------------------------------------\n  -- useful in a loop:  exit when AffirmIf( ID, not ReadValid, \"Read Failed\") ;\n  impure function  AffirmIf( AlertLogID  : AlertLogIDType ; condition : boolean ; Message : string ; Enable : boolean := FALSE ) return boolean is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    AffirmIf(AlertLogID, condition, Message, Enable) ;\n    -- synthesis translate_on\n    return condition ;\n  end function AffirmIf ;\n\n  ------------------------------------------------------------\n  impure function  AffirmIf( condition : boolean ; Message : string ; Enable : boolean := FALSE ) return boolean is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    AffirmIf(ALERT_DEFAULT_ID, condition, Message, Enable) ;\n    -- synthesis translate_on\n    return condition ;\n  end function AffirmIf ;\n\n  ------------------------------------------------------------\n  ------------------------------------------------------------\n  procedure AffirmIfNot( AlertLogID : AlertLogIDType ; condition : boolean ; ReceivedMessage, ExpectedMessage : string ; Enable : boolean := FALSE ) is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    AffirmIf(AlertLogID, not condition, ReceivedMessage, ExpectedMessage, Enable) ;\n    -- synthesis translate_on\n  end procedure AffirmIfNot ;\n\n  ------------------------------------------------------------\n  procedure AffirmIfNot( condition : boolean ; ReceivedMessage, ExpectedMessage : string ; Enable : boolean := FALSE ) is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    AffirmIf(ALERT_DEFAULT_ID, not condition, ReceivedMessage, ExpectedMessage, Enable) ;\n    -- synthesis translate_on\n  end procedure AffirmIfNot ;\n\n  ------------------------------------------------------------\n  -- useful in a loop:  exit when AffirmIfNot( not ReadValid, failure, \"Read Failed\") ;\n  impure function  AffirmIfNot( AlertLogID  : AlertLogIDType ; condition : boolean ; ReceivedMessage, ExpectedMessage : string ; Enable : boolean := FALSE ) return boolean is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    AffirmIf(AlertLogID, not condition, ReceivedMessage, ExpectedMessage, Enable) ;\n    -- synthesis translate_on\n    return not condition ;\n  end function AffirmIfNot ;\n\n  ------------------------------------------------------------\n  impure function  AffirmIfNot( condition : boolean ; ReceivedMessage, ExpectedMessage : string ; Enable : boolean := FALSE ) return boolean is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    AffirmIf(ALERT_DEFAULT_ID, not condition, ReceivedMessage, ExpectedMessage, Enable) ;\n    -- synthesis translate_on\n    return not condition ;\n  end function AffirmIfNot ;\n\n  ------------------------------------------------------------\n  procedure AffirmIfNot( AlertLogID : AlertLogIDType ; condition : boolean ; Message : string ; Enable : boolean := FALSE ) is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    AffirmIf(AlertLogID, not condition, Message, Enable) ;\n    -- synthesis translate_on\n  end procedure AffirmIfNot ;\n\n  ------------------------------------------------------------\n  procedure AffirmIfNot( condition : boolean ; Message : string ; Enable : boolean := FALSE ) is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    AffirmIf(ALERT_DEFAULT_ID, not condition, Message, Enable) ;\n    -- synthesis translate_on\n  end procedure AffirmIfNot ;\n\n  ------------------------------------------------------------\n  -- useful in a loop:  exit when AffirmIfNot( not ReadValid, failure, \"Read Failed\") ;\n  impure function  AffirmIfNot( AlertLogID  : AlertLogIDType ; condition : boolean ; Message : string ; Enable : boolean := FALSE ) return boolean is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    AffirmIf(AlertLogID, not condition, Message, Enable) ;\n    -- synthesis translate_on\n    return not condition ;\n  end function AffirmIfNot ;\n\n  ------------------------------------------------------------\n  impure function  AffirmIfNot( condition : boolean ; Message : string ; Enable : boolean := FALSE ) return boolean is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    AffirmIf(ALERT_DEFAULT_ID, not condition, Message, Enable) ;\n    -- synthesis translate_on\n    return not condition ;\n  end function AffirmIfNot ;\n\n\n  ------------------------------------------------------------\n  ------------------------------------------------------------\n  procedure AffirmPassed( AlertLogID : AlertLogIDType ; Message : string ; Enable : boolean := FALSE ) is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    AffirmIf(AlertLogID, TRUE, Message, Enable) ;\n    -- synthesis translate_on\n  end procedure AffirmPassed ;\n\n  ------------------------------------------------------------\n  procedure AffirmPassed( Message : string ; Enable : boolean := FALSE ) is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    AffirmIf(ALERT_DEFAULT_ID, TRUE, Message, Enable) ;\n    -- synthesis translate_on\n  end procedure AffirmPassed ;\n\n  ------------------------------------------------------------\n  procedure AffirmError( AlertLogID : AlertLogIDType ; Message : string ) is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    AffirmIf(AlertLogID, FALSE, Message, FALSE) ;\n    -- synthesis translate_on\n  end procedure AffirmError ;\n\n  ------------------------------------------------------------\n  procedure AffirmError( Message : string ) is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    AffirmIf(ALERT_DEFAULT_ID, FALSE, Message, FALSE) ;\n    -- synthesis translate_on\n  end procedure AffirmError ;\n\n  -- With AlertLogID\n  ------------------------------------------------------------\n  procedure AffirmIfEqual( AlertLogID : AlertLogIDType ; Received, Expected : boolean ;  Message : string := \"\" ; Enable : boolean := FALSE )  is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    AffirmIf(AlertLogID, Received = Expected,\n      Message & \" Received : \" & to_string(Received),\n      \"?= Expected : \" & to_string(Expected),\n      Enable) ;\n    -- synthesis translate_on\n  end procedure AffirmIfEqual ;\n\n  ------------------------------------------------------------\n  procedure AffirmIfEqual( AlertLogID : AlertLogIDType ; Received, Expected : std_logic ;  Message : string := \"\" ; Enable : boolean := FALSE )  is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    AffirmIf(AlertLogID, MetaMatch(Received, Expected),\n      Message & \" Received : \" & to_string(Received),\n      \"?= Expected : \" & to_string(Expected),\n      Enable) ;\n    -- synthesis translate_on\n  end procedure AffirmIfEqual ;\n\n  ------------------------------------------------------------\n  procedure AffirmIfEqual( AlertLogID : AlertLogIDType ; Received, Expected : std_logic_vector ; Message : string := \"\" ; Enable : boolean := FALSE )  is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    AffirmIf(AlertLogID, MetaMatch(Received, Expected),\n      Message & \" Received : \" & to_hxstring(Received),\n      \"?= Expected : \" & to_hxstring(Expected),\n      Enable) ;\n    -- synthesis translate_on\n  end procedure AffirmIfEqual ;\n\n  ------------------------------------------------------------\n  procedure AffirmIfEqual( AlertLogID : AlertLogIDType ; Received, Expected : unsigned ; Message : string := \"\" ; Enable : boolean := FALSE )  is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    AffirmIf(AlertLogID, MetaMatch(Received, Expected),\n      Message & \" Received : \" & to_hxstring(Received),\n      \"?= Expected : \" & to_hxstring(Expected),\n      Enable) ;\n    -- synthesis translate_on\n  end procedure AffirmIfEqual ;\n\n  ------------------------------------------------------------\n  procedure AffirmIfEqual( AlertLogID : AlertLogIDType ; Received, Expected : signed ; Message : string := \"\" ; Enable : boolean := FALSE )  is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    AffirmIf(AlertLogID, MetaMatch(Received, Expected),\n      Message & \" Received : \" & to_hxstring(Received),\n      \"?= Expected : \" & to_hxstring(Expected),\n      Enable) ;\n    -- synthesis translate_on\n  end procedure AffirmIfEqual ;\n\n  ------------------------------------------------------------\n  procedure AffirmIfEqual( AlertLogID : AlertLogIDType ; Received, Expected : integer ; Message : string := \"\" ; Enable : boolean := FALSE )  is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    AffirmIf(AlertLogID, Received = Expected,\n      Message & \" Received : \" & to_string(Received),\n      \"= Expected : \" & to_string(Expected),\n      Enable) ;\n    -- synthesis translate_on\n  end procedure AffirmIfEqual ;\n\n  ------------------------------------------------------------\n  procedure AffirmIfEqual( AlertLogID : AlertLogIDType ; Received, Expected : real ; Message : string := \"\" ; Enable : boolean := FALSE )  is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    AffirmIf(AlertLogID, Received = Expected,\n      Message & \" Received : \" & to_string(Received, 4),\n      \"= Expected : \" & to_string(Expected, 4),\n      Enable) ;\n    -- synthesis translate_on\n  end procedure AffirmIfEqual ;\n\n  ------------------------------------------------------------\n  procedure AffirmIfEqual( AlertLogID : AlertLogIDType ; Received, Expected : character ; Message : string := \"\" ; Enable : boolean := FALSE )  is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    AffirmIf(AlertLogID, Received = Expected,\n      Message & \" Received : \" & to_string(Received),\n      \"= Expected : \" & to_string(Expected),\n      Enable) ;\n    -- synthesis translate_on\n  end procedure AffirmIfEqual ;\n\n  ------------------------------------------------------------\n  procedure AffirmIfEqual( AlertLogID : AlertLogIDType ; Received, Expected : string ; Message : string := \"\" ; Enable : boolean := FALSE )  is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    AffirmIf(AlertLogID, Received = Expected,\n      Message & \" Received : \" & Received,\n      \"= Expected : \" & Expected,\n      Enable) ;\n    -- synthesis translate_on\n  end procedure AffirmIfEqual ;\n\n  ------------------------------------------------------------\n  procedure AffirmIfEqual( AlertLogID : AlertLogIDType ; Received, Expected : time ; Message : string := \"\" ; Enable : boolean := FALSE )  is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    AffirmIf(AlertLogID, Received = Expected,\n      Message & \" Received : \" & to_string(Received, GetOsvvmDefaultTimeUnits),\n               \"= Expected : \" & to_string(Expected, GetOsvvmDefaultTimeUnits),\n      Enable) ;\n    -- synthesis translate_on\n  end procedure AffirmIfEqual ;\n\n  -- Without AlertLogID\n  ------------------------------------------------------------\n  procedure AffirmIfEqual( Received, Expected : boolean ;  Message : string := \"\" ; Enable : boolean := FALSE )  is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    AffirmIf(ALERT_DEFAULT_ID, Received = Expected,\n      Message & \" Received : \" & to_string(Received),\n      \"?= Expected : \" & to_string(Expected),\n      Enable) ;\n    -- synthesis translate_on\n  end procedure AffirmIfEqual ;\n\n  ------------------------------------------------------------\n  procedure AffirmIfEqual( Received, Expected : std_logic ;  Message : string := \"\" ; Enable : boolean := FALSE )  is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    AffirmIf(ALERT_DEFAULT_ID, MetaMatch(Received, Expected),\n      Message & \" Received : \" & to_string(Received),\n      \"?= Expected : \" & to_string(Expected),\n      Enable) ;\n    -- synthesis translate_on\n  end procedure AffirmIfEqual ;\n\n  ------------------------------------------------------------\n  procedure AffirmIfEqual( Received, Expected : std_logic_vector ; Message : string := \"\" ; Enable : boolean := FALSE )  is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    AffirmIf(ALERT_DEFAULT_ID, MetaMatch(Received, Expected),\n      Message & \" Received : \" & to_hxstring(Received),\n      \"?= Expected : \" & to_hxstring(Expected),\n      Enable) ;\n    -- synthesis translate_on\n  end procedure AffirmIfEqual ;\n\n  ------------------------------------------------------------\n  procedure AffirmIfEqual( Received, Expected : unsigned ; Message : string := \"\" ; Enable : boolean := FALSE )  is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    AffirmIf(ALERT_DEFAULT_ID, MetaMatch(Received, Expected),\n      Message & \" Received : \" & to_hxstring(Received),\n      \"?= Expected : \" & to_hxstring(Expected),\n      Enable) ;\n    -- synthesis translate_on\n  end procedure AffirmIfEqual ;\n\n  ------------------------------------------------------------\n  procedure AffirmIfEqual( Received, Expected : signed ; Message : string := \"\" ; Enable : boolean := FALSE )  is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    AffirmIf(ALERT_DEFAULT_ID, MetaMatch(Received, Expected),\n      Message & \" Received : \" & to_hxstring(Received),\n      \"?= Expected : \" & to_hxstring(Expected),\n      Enable) ;\n    -- synthesis translate_on\n  end procedure AffirmIfEqual ;\n\n  ------------------------------------------------------------\n  procedure AffirmIfEqual( Received, Expected : integer ; Message : string := \"\" ; Enable : boolean := FALSE )  is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    AffirmIf(ALERT_DEFAULT_ID, Received = Expected,\n      Message & \" Received : \" & to_string(Received),\n      \"= Expected : \" & to_string(Expected),\n      Enable) ;\n    -- synthesis translate_on\n  end procedure AffirmIfEqual ;\n\n  ------------------------------------------------------------\n  procedure AffirmIfEqual( Received, Expected : real ; Message : string := \"\" ; Enable : boolean := FALSE )  is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    AffirmIf(ALERT_DEFAULT_ID, Received = Expected,\n      Message & \" Received : \" & to_string(Received, 4),\n      \"= Expected : \" & to_string(Expected, 4),\n      Enable) ;\n    -- synthesis translate_on\n  end procedure AffirmIfEqual ;\n\n  ------------------------------------------------------------\n  procedure AffirmIfEqual( Received, Expected : character ; Message : string := \"\" ; Enable : boolean := FALSE )  is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    AffirmIf(ALERT_DEFAULT_ID, Received = Expected,\n      Message & \" Received : \" & to_string(Received),\n      \"= Expected : \" & to_string(Expected),\n      Enable) ;\n    -- synthesis translate_on\n  end procedure AffirmIfEqual ;\n\n  ------------------------------------------------------------\n  procedure AffirmIfEqual( Received, Expected : string ; Message : string := \"\" ; Enable : boolean := FALSE )  is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    AffirmIf(ALERT_DEFAULT_ID, Received = Expected,\n      Message & \" Received : \" & Received,\n      \"= Expected : \" & Expected,\n      Enable) ;\n    -- synthesis translate_on\n  end procedure AffirmIfEqual ;\n\n  ------------------------------------------------------------\n  procedure AffirmIfEqual( Received, Expected : time ; Message : string := \"\" ; Enable : boolean := FALSE )  is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    AffirmIf(ALERT_DEFAULT_ID, Received = Expected,\n      Message & \" Received : \"  & to_string(Received, GetOsvvmDefaultTimeUnits),\n                \"= Expected : \" & to_string(Expected, GetOsvvmDefaultTimeUnits),\n      Enable) ;\n    -- synthesis translate_on\n  end procedure AffirmIfEqual ;\n\n  ------------------------------------------------------------\n  procedure AffirmIfNotDiff (AlertLogID : AlertLogIDType ; Name1, Name2 : string; Message : string := \"\" ; Enable : boolean := FALSE ) is\n  -- Open files and call AffirmIfNotDiff[text, ...]\n  ------------------------------------------------------------\n    variable Valid : boolean ;\n  begin\n    -- synthesis translate_off\n    LocalAlertIfDiff (AlertLogID, Name1, Name2, Message, ERROR, Valid) ;\n    if Valid then\n      AlertLogStruct.Log(AlertLogID, Message & \" \" & Name1 & \"  \" & Name2, PASSED, Enable) ;\n    else\n      AlertLogStruct.IncAffirmCount(AlertLogID) ;  -- count the affirmation\n      -- Alert already signaled by LocalAlertIfDiff\n    end if ;\n    -- synthesis translate_on\n  end procedure AffirmIfNotDiff ;\n\n  ------------------------------------------------------------\n  procedure AffirmIfNotDiff (Name1, Name2 : string; Message : string := \"\" ; Enable : boolean := FALSE ) is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    AffirmIfNotDiff(ALERT_DEFAULT_ID, Name1, Name2, Message, Enable) ;\n    -- synthesis translate_on\n  end procedure AffirmIfNotDiff ;\n\n  ------------------------------------------------------------\n  procedure AffirmIfNotDiff (AlertLogID : AlertLogIDType ; file File1, File2 : text; Message : string := \"\" ; Enable : boolean := FALSE ) is\n  -- Simple diff.\n  ------------------------------------------------------------\n    variable Valid : boolean ;\n  begin\n    -- synthesis translate_off\n    LocalAlertIfDiff (AlertLogID, File1, File2, Message, ERROR, Valid ) ;\n    if Valid then\n      AlertLogStruct.Log(AlertLogID, Message, PASSED, Enable) ;\n    else\n      AlertLogStruct.IncAffirmCount(AlertLogID) ;  -- count the affirmation\n      -- Alert already signaled by LocalAlertIfDiff\n    end if ;\n    -- synthesis translate_on\n  end procedure AffirmIfNotDiff ;\n\n  ------------------------------------------------------------\n  procedure AffirmIfNotDiff (file File1, File2 : text; Message : string := \"\" ; Enable : boolean := FALSE ) is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    AffirmIfNotDiff(ALERT_DEFAULT_ID, File1, File2, Message, Enable) ;\n    -- synthesis translate_on\n  end procedure AffirmIfNotDiff ;\n\n  ------------------------------------------------------------\n-- DEPRECATED - naming polarity is incorrect.   Should be AffirmIfNotDiff\n  procedure AffirmIfDiff (AlertLogID : AlertLogIDType ; Name1, Name2 : string; Message : string := \"\" ; Enable : boolean := FALSE ) is\n  -- Open files and call AffirmIfDiff[text, ...]\n  ------------------------------------------------------------\n    variable Valid : boolean ;\n  begin\n    -- synthesis translate_off\n    LocalAlertIfDiff (AlertLogID, Name1, Name2, Message, ERROR, Valid) ;\n    if Valid then\n      AlertLogStruct.Log(AlertLogID, Message & \" \" & Name1 & \" = \" & Name2, PASSED, Enable) ;\n    else\n      AlertLogStruct.IncAffirmCount(AlertLogID) ;  -- count the affirmation\n      -- Alert already signaled by LocalAlertIfDiff\n    end if ;\n    -- synthesis translate_on\n  end procedure AffirmIfDiff ;\n\n  ------------------------------------------------------------\n-- DEPRECATED - naming polarity is incorrect.   Should be AffirmIfNotDiff\n  procedure AffirmIfDiff (Name1, Name2 : string; Message : string := \"\" ; Enable : boolean := FALSE ) is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    AffirmIfDiff(ALERT_DEFAULT_ID, Name1, Name2, Message, Enable) ;\n    -- synthesis translate_on\n  end procedure AffirmIfDiff ;\n\n  ------------------------------------------------------------\n-- DEPRECATED - naming polarity is incorrect.   Should be AffirmIfNotDiff\n  procedure AffirmIfDiff (AlertLogID : AlertLogIDType ; file File1, File2 : text; Message : string := \"\" ; Enable : boolean := FALSE ) is\n  -- Simple diff.\n  ------------------------------------------------------------\n    variable Valid : boolean ;\n  begin\n    -- synthesis translate_off\n    LocalAlertIfDiff (AlertLogID, File1, File2, Message, ERROR, Valid ) ;\n    if Valid then\n      AlertLogStruct.Log(AlertLogID, Message, PASSED, Enable) ;\n    else\n      AlertLogStruct.IncAffirmCount(AlertLogID) ;  -- count the affirmation\n      -- Alert already signaled by LocalAlertIfDiff\n    end if ;\n    -- synthesis translate_on\n  end procedure AffirmIfDiff ;\n\n  ------------------------------------------------------------\n-- DEPRECATED - naming polarity is incorrect.   Should be AffirmIfNotDiff\n  procedure AffirmIfDiff (file File1, File2 : text; Message : string := \"\" ; Enable : boolean := FALSE ) is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    AffirmIfDiff(ALERT_DEFAULT_ID, File1, File2, Message, Enable) ;\n    -- synthesis translate_on\n  end procedure AffirmIfDiff ;\n\n\n  -- Support for Specification / Requirements Tracking\n  ------------------------------------------------------------\n  procedure AffirmIf( RequirementsIDName : string ; condition : boolean ; ReceivedMessage, ExpectedMessage : string ; Enable : boolean := FALSE ) is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n--?? Set Goal to 1?  Should the ID already exist?\n    AffirmIf(GetReqID(RequirementsIDName), condition, ReceivedMessage, ExpectedMessage, Enable) ;\n    -- synthesis translate_on\n  end procedure AffirmIf ;\n\n  ------------------------------------------------------------\n  procedure AffirmIf( RequirementsIDName : string ; condition : boolean ; Message : string ; Enable : boolean := FALSE ) is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n--?? Set Goal to 1?  Should the ID already exist?\n    AffirmIf(GetReqID(RequirementsIDName), condition, Message, Enable) ;\n    -- synthesis translate_on\n  end procedure AffirmIf ;\n\n  ------------------------------------------------------------\n  procedure SetAlertLogJustify (Enable : boolean := TRUE) is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    AlertLogStruct.SetJustify(Enable) ;\n    -- synthesis translate_on\n  end procedure SetAlertLogJustify ;\n\n  ------------------------------------------------------------\n  procedure ReportAlerts ( Name : String ; AlertCount : AlertCountType ) is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    AlertLogStruct.ReportAlerts(Name, AlertCount) ;\n    -- synthesis translate_on\n  end procedure ReportAlerts ;\n\n  ------------------------------------------------------------\n  procedure ReportRequirements is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    AlertLogStruct.ReportRequirements ;\n    -- synthesis translate_on\n  end procedure ReportRequirements ;\n\n  ------------------------------------------------------------\n  procedure ReportAlerts (\n  ------------------------------------------------------------\n    Name           : string          := OSVVM_STRING_INIT_PARM_DETECT ;\n    AlertLogID     : AlertLogIDType  := ALERTLOG_BASE_ID ;\n    ExternalErrors : AlertCountType  := (others => 0) ;\n    ReportAll      : Boolean         := FALSE\n  ) is\n  begin\n    -- synthesis translate_off\n    AlertLogStruct.ReportAlerts(Name, AlertLogID, ExternalErrors, ReportAll, TRUE) ;\n    -- synthesis translate_on\n  end procedure ReportAlerts ;\n\n  ------------------------------------------------------------\n  procedure ReportNonZeroAlerts (\n  ------------------------------------------------------------\n    Name           : string          := OSVVM_STRING_INIT_PARM_DETECT ;\n    AlertLogID     : AlertLogIDType  := ALERTLOG_BASE_ID ;\n    ExternalErrors : AlertCountType  := (others => 0)\n  ) is\n  begin\n    -- synthesis translate_off\n    AlertLogStruct.ReportAlerts(Name, AlertLogID, ExternalErrors, FALSE, FALSE) ;\n    -- synthesis translate_on\n  end procedure ReportNonZeroAlerts ;\n\n  ------------------------------------------------------------\n  procedure WriteAlertYaml (\n  ------------------------------------------------------------\n    FileName       : string ;\n    ExternalErrors : AlertCountType := (0,0,0) ;\n    Prefix         : string := \"\" ;\n    PrintSettings  : boolean := TRUE ;\n    PrintChildren  : boolean := TRUE ;\n    OpenKind       : File_Open_Kind := WRITE_MODE\n  ) is\n  begin\n    -- synthesis translate_off\n    AlertLogStruct.WriteAlertYaml(FileName, ExternalErrors, Prefix, PrintSettings, PrintChildren, OpenKind) ;\n    -- synthesis translate_on\n  end procedure WriteAlertYaml ;\n\n  ------------------------------------------------------------\n  procedure WriteAlertSummaryYaml (FileName : string := \"\" ; ExternalErrors : AlertCountType := (0,0,0)) is\n  ------------------------------------------------------------\n    constant RESOLVED_FILE_NAME : string := IfElse(FileName'length = 0, OSVVM_BUILD_YAML_FILE, FileName) ;\n  begin\n    -- synthesis translate_off\n    WriteAlertYaml(FileName => RESOLVED_FILE_NAME, ExternalErrors => ExternalErrors, Prefix => \"        \", PrintSettings => FALSE, PrintChildren => FALSE, OpenKind => APPEND_MODE) ;\n    -- WriteTestSummary(FileName => OSVVM_BUILD_YAML_FILE, OpenKind => APPEND_MODE, Prefix => \"      \", Suffix => \"\", ExternalErrors => ExternalErrors, WriteFieldName => TRUE) ;\n    -- synthesis translate_on\n  end procedure WriteAlertSummaryYaml ;\n\n  ------------------------------------------------------------\n  procedure WriteRequirementsYaml (\n  ------------------------------------------------------------\n    FileName    : string ;\n    AlertLogID  : AlertLogIDType := REQUIREMENT_ALERTLOG_ID ;\n    OpenKind    : File_Open_Kind := WRITE_MODE\n  ) is\n  begin\n    -- synthesis translate_off\n    AlertLogStruct.WriteRequirementsYaml(FileName, AlertLogID, OpenKind) ;\n    -- synthesis translate_on\n  end procedure WriteRequirementsYaml ;\n\n  ------------------------------------------------------------\n  impure function GotRequirements return boolean is\n  ------------------------------------------------------------\n    variable result : boolean ; \n  begin\n    -- synthesis translate_off\n    result := AlertLogStruct.GotRequirements ;\n    -- synthesis translate_on\n    return result ; \n  end function GotRequirements ;\n\n  ------------------------------------------------------------\n  -- Deprecated.  Use WriteAlertSummaryYaml Instead.\n  procedure CreateYamlReport (ExternalErrors : AlertCountType := (0,0,0)) is\n  begin\n    -- synthesis translate_off\n    WriteAlertSummaryYaml(ExternalErrors => ExternalErrors) ;\n    -- synthesis translate_on\n  end procedure CreateYamlReport ;\n\n  ------------------------------------------------------------\n  procedure WriteTestSummary (\n  ------------------------------------------------------------\n    FileName       : string ;\n    OpenKind       : File_Open_Kind := APPEND_MODE ;\n    Prefix         : string := \"\" ;\n    Suffix         : string := \"\" ;\n    ExternalErrors : AlertCountType := (0,0,0) ;\n    WriteFieldName : boolean := FALSE\n  ) is\n  begin\n    -- synthesis translate_off\n    AlertLogStruct.WriteTestSummary(FileName, OpenKind, Prefix, Suffix, ExternalErrors, WriteFieldName) ;\n    -- synthesis translate_on\n  end procedure WriteTestSummary ;\n\n  ------------------------------------------------------------\n  procedure WriteTestSummaries (\n  ------------------------------------------------------------\n    FileName    : string ;\n    OpenKind    : File_Open_Kind := WRITE_MODE\n  ) is\n  begin\n    -- synthesis translate_off\n    AlertLogStruct.WriteTestSummaries(FileName, OpenKind) ;\n    -- synthesis translate_on\n  end procedure WriteTestSummaries ;\n\n  ------------------------------------------------------------\n  procedure ReportTestSummaries is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    AlertLogStruct.ReportTestSummaries ;\n    -- synthesis translate_on\n  end procedure ReportTestSummaries ;\n\n  ------------------------------------------------------------\n  procedure WriteAlerts (\n  ------------------------------------------------------------\n    FileName    : string ;\n    AlertLogID  : AlertLogIDType := ALERTLOG_BASE_ID ;\n    OpenKind    : File_Open_Kind := WRITE_MODE\n  ) is\n  begin\n    -- synthesis translate_off\n    AlertLogStruct.WriteAlerts(FileName, AlertLogID, OpenKind) ;\n    -- synthesis translate_on\n  end procedure WriteAlerts ;\n\n  ------------------------------------------------------------\n  procedure WriteRequirements (\n  ------------------------------------------------------------\n    FileName        : string ;\n    AlertLogID      : AlertLogIDType := REQUIREMENT_ALERTLOG_ID ;\n    OpenKind        : File_Open_Kind := WRITE_MODE\n  ) is\n  begin\n    -- synthesis translate_off\n    AlertLogStruct.WriteRequirements(FileName, AlertLogID, OpenKind) ;\n    -- synthesis translate_on\n  end procedure WriteRequirements ;\n\n  ------------------------------------------------------------\n  procedure ReadSpecification (FileName : string ; PassedGoal : integer := -1 ) is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    AlertLogStruct.ReadSpecification(FileName, PassedGoal) ;\n    -- synthesis translate_on\n  end procedure ReadSpecification ;\n\n  ------------------------------------------------------------\n  procedure ReadRequirements (\n  ------------------------------------------------------------\n    FileName        : string ;\n    ThresholdPassed : boolean := FALSE\n  ) is\n  begin\n    -- synthesis translate_off\n    AlertLogStruct.ReadRequirements(FileName, ThresholdPassed, TestSummary => FALSE) ;\n    -- synthesis translate_on\n  end procedure ReadRequirements ;\n\n  ------------------------------------------------------------\n  procedure ReadTestSummaries (FileName : string) is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    AlertLogStruct.ReadRequirements(FileName, ThresholdPassed => FALSE, TestSummary => TRUE) ;\n    -- synthesis translate_on\n  end procedure ReadTestSummaries ;\n\n--  ------------------------------------------------------------\n--  procedure ReportTestSummaries (FileName : string) is\n--  ------------------------------------------------------------\n--  begin\n--    -- synthesis translate_off\n--    AlertLogStruct.ReadRequirements(FileName, ThresholdPassed => FALSE, TestSummary => TRUE) ;\n--    -- synthesis translate_on\n--  end procedure ReportTestSummaries ;\n\n  ------------------------------------------------------------\n  procedure ClearAlerts is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    AlertLogStruct.ClearAlerts ;\n    -- synthesis translate_on\n  end procedure ClearAlerts ;\n\n  ------------------------------------------------------------\n  procedure ClearAlertStopCounts is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    AlertLogStruct.ClearAlertStopCounts ;\n    -- synthesis translate_on\n  end procedure ClearAlertStopCounts ;\n\n  ------------------------------------------------------------\n  procedure ClearAlertCounts is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    AlertLogStruct.ClearAlerts ;\n    AlertLogStruct.ClearAlertStopCounts ;\n    -- synthesis translate_on\n  end procedure ClearAlertCounts ;\n\n  ------------------------------------------------------------\n  function \"ABS\" (L : AlertCountType) return AlertCountType is\n  ------------------------------------------------------------\n    variable Result : AlertCountType ;\n  begin\n    -- synthesis translate_off\n    Result(FAILURE) := ABS( L(FAILURE) ) ;\n    Result(ERROR)   := ABS( L(ERROR) ) ;\n    Result(WARNING) := ABS( L(WARNING) );\n    -- synthesis translate_on\n    return Result ;\n  end function \"ABS\" ;\n\n  ------------------------------------------------------------\n  function \"+\" (L, R : AlertCountType) return AlertCountType is\n  ------------------------------------------------------------\n    variable Result : AlertCountType ;\n  begin\n    -- synthesis translate_off\n    Result(FAILURE) := L(FAILURE) + R(FAILURE) ;\n    Result(ERROR)   := L(ERROR)   + R(ERROR) ;\n    Result(WARNING) := L(WARNING) + R(WARNING) ;\n    -- synthesis translate_on\n    return Result ;\n  end function \"+\" ;\n\n  ------------------------------------------------------------\n  function \"-\" (L, R : AlertCountType) return AlertCountType is\n  ------------------------------------------------------------\n    variable Result : AlertCountType ;\n  begin\n    -- synthesis translate_off\n    Result(FAILURE) := L(FAILURE) - R(FAILURE) ;\n    Result(ERROR)   := L(ERROR)   - R(ERROR) ;\n    Result(WARNING) := L(WARNING) - R(WARNING) ;\n    -- synthesis translate_on\n    return Result ;\n  end function \"-\" ;\n\n  ------------------------------------------------------------\n  function \"-\" (R : AlertCountType) return AlertCountType is\n  ------------------------------------------------------------\n    variable Result : AlertCountType ;\n  begin\n    -- synthesis translate_off\n    Result(FAILURE) := - R(FAILURE) ;\n    Result(ERROR)   := - R(ERROR) ;\n    Result(WARNING) := - R(WARNING) ;\n    -- synthesis translate_on\n    return Result ;\n  end function \"-\" ;\n\n  ------------------------------------------------------------\n  impure function SumAlertCount(AlertCount: AlertCountType) return integer is\n  ------------------------------------------------------------\n    variable result : integer ;\n  begin\n    -- synthesis translate_off\n    -- Using ABS ensures correct expected error handling.\n    result := abs(AlertCount(FAILURE)) + abs(AlertCount(ERROR)) + abs(AlertCount(WARNING)) ;\n    -- synthesis translate_on\n    return result ;\n  end function SumAlertCount ;\n\n  ------------------------------------------------------------\n  impure function GetAlertCount(AlertLogID : AlertLogIDType := ALERTLOG_BASE_ID) return AlertCountType is\n  ------------------------------------------------------------\n    variable result : AlertCountType ;\n  begin\n    -- synthesis translate_off\n    result := AlertLogStruct.GetAlertCount(AlertLogID) ;\n    -- synthesis translate_on\n    return result ;\n  end function GetAlertCount ;\n\n  ------------------------------------------------------------\n  impure function GetAlertCount(AlertLogID : AlertLogIDType := ALERTLOG_BASE_ID) return integer is\n  ------------------------------------------------------------\n    variable result : integer ;\n  begin\n    -- synthesis translate_off\n    result := SumAlertCount(AlertLogStruct.GetAlertCount(AlertLogID)) ;\n    -- synthesis translate_on\n    return result ;\n  end function GetAlertCount ;\n\n  ------------------------------------------------------------\n  impure function GetEnabledAlertCount(AlertLogID : AlertLogIDType := ALERTLOG_BASE_ID) return AlertCountType is\n  ------------------------------------------------------------\n    variable result : AlertCountType ;\n  begin\n    -- synthesis translate_off\n    result := AlertLogStruct.GetEnabledAlertCount(AlertLogID) ;\n    -- synthesis translate_on\n    return result ;\n  end function GetEnabledAlertCount ;\n\n  ------------------------------------------------------------\n  impure function GetEnabledAlertCount(AlertLogID : AlertLogIDType := ALERTLOG_BASE_ID) return integer is\n  ------------------------------------------------------------\n    variable result : integer ;\n  begin\n    -- synthesis translate_off\n    result := SumAlertCount(AlertLogStruct.GetEnabledAlertCount(AlertLogID)) ;\n    -- synthesis translate_on\n    return result ;\n  end function GetEnabledAlertCount ;\n\n  ------------------------------------------------------------\n  impure function GetDisabledAlertCount return AlertCountType is\n  ------------------------------------------------------------\n    variable result : AlertCountType ;\n  begin\n    -- synthesis translate_off\n    result := AlertLogStruct.GetDisabledAlertCount ;\n    -- synthesis translate_on\n    return result ;\n  end function GetDisabledAlertCount ;\n\n  ------------------------------------------------------------\n  impure function GetDisabledAlertCount return integer is\n  ------------------------------------------------------------\n    variable result : integer ;\n  begin\n    -- synthesis translate_off\n    result := SumAlertCount(AlertLogStruct.GetDisabledAlertCount) ;\n    -- synthesis translate_on\n    return result ;\n  end function GetDisabledAlertCount ;\n\n  ------------------------------------------------------------\n  impure function GetDisabledAlertCount(AlertLogID: AlertLogIDType) return AlertCountType is\n  ------------------------------------------------------------\n    variable result : AlertCountType ;\n  begin\n    -- synthesis translate_off\n    result := AlertLogStruct.GetDisabledAlertCount(AlertLogID) ;\n    -- synthesis translate_on\n    return result ;\n  end function GetDisabledAlertCount ;\n\n  ------------------------------------------------------------\n  impure function GetDisabledAlertCount(AlertLogID: AlertLogIDType) return integer is\n  ------------------------------------------------------------\n    variable result : integer ;\n  begin\n    -- synthesis translate_off\n    result := SumAlertCount(AlertLogStruct.GetDisabledAlertCount(AlertLogID)) ;\n    -- synthesis translate_on\n    return result ;\n  end function GetDisabledAlertCount ;\n\n  ------------------------------------------------------------\n  procedure Log(\n  ------------------------------------------------------------\n    AlertLogID   : AlertLogIDType ;\n    Message      : string ;\n    Level        : LogType := ALWAYS ;\n    Enable       : boolean := FALSE    -- override internal enable\n  ) is\n  begin\n    -- synthesis translate_off\n    AlertLogStruct.Log(AlertLogID, Message, Level, Enable) ;\n    -- synthesis translate_on\n  end procedure log ;\n\n  ------------------------------------------------------------\n  procedure Log( Message : string ; Level : LogType := ALWAYS ; Enable : boolean := FALSE) is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    AlertLogStruct.Log(LOG_DEFAULT_ID, Message, Level, Enable) ;\n    -- synthesis translate_on\n  end procedure log ;\n\n  ------------------------------------------------------------\n  procedure SetAlertEnable(Level : AlertType ;  Enable : boolean) is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    AlertLogStruct.SetAlertEnable(Level, Enable) ;\n    -- synthesis translate_on\n  end procedure SetAlertEnable ;\n\n  ------------------------------------------------------------\n  procedure SetAlertEnable(AlertLogID : AlertLogIDType ;  Level : AlertType ;  Enable : boolean ; DescendHierarchy : boolean := TRUE) is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    AlertLogStruct.SetAlertEnable(AlertLogID, Level, Enable, DescendHierarchy) ;\n    -- synthesis translate_on\n  end procedure SetAlertEnable ;\n\n  ------------------------------------------------------------\n  impure function GetAlertEnable(AlertLogID : AlertLogIDType ;  Level : AlertType) return boolean is\n  ------------------------------------------------------------\n    variable result : boolean ;\n  begin\n    -- synthesis translate_off\n    result := AlertLogStruct.GetAlertEnable(AlertLogID, Level) ;\n    -- synthesis translate_on\n    return result ;\n  end function GetAlertEnable ;\n\n  ------------------------------------------------------------\n  impure function GetAlertEnable(Level : AlertType) return boolean is\n  ------------------------------------------------------------\n    variable result : boolean ;\n  begin\n    -- synthesis translate_off\n    result := AlertLogStruct.GetAlertEnable(ALERT_DEFAULT_ID, Level) ;\n    -- synthesis translate_on\n    return result ;\n  end function GetAlertEnable ;\n\n  ------------------------------------------------------------\n  procedure SetLogEnable(Level : LogType ;  Enable : boolean) is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    AlertLogStruct.SetLogEnable(Level, Enable) ;\n    -- synthesis translate_on\n  end procedure SetLogEnable ;\n\n  ------------------------------------------------------------\n  procedure SetLogEnable(AlertLogID : AlertLogIDType ;  Level : LogType ;  Enable : boolean ; DescendHierarchy : boolean := TRUE) is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    AlertLogStruct.SetLogEnable(AlertLogID, Level, Enable, DescendHierarchy) ;\n    -- synthesis translate_on\n  end procedure SetLogEnable ;\n\n  ------------------------------------------------------------\n  impure function GetLogEnable(AlertLogID : AlertLogIDType ;  Level : LogType) return boolean is\n  ------------------------------------------------------------\n    variable result : boolean ;\n  begin\n    -- synthesis translate_off\n    result := AlertLogStruct.GetLogEnable(AlertLogID, Level) ;\n    -- synthesis translate_on\n    return result ;\n  end function GetLogEnable ;\n\n  ------------------------------------------------------------\n  impure function GetLogEnable(Level : LogType) return boolean is\n  ------------------------------------------------------------\n    variable result : boolean ;\n  begin\n    -- synthesis translate_off\n    result := AlertLogStruct.GetLogEnable(LOG_DEFAULT_ID, Level) ;\n    -- synthesis translate_on\n    return result ;\n  end function GetLogEnable ;\n\n  ------------------------------------------------------------\n  procedure ReportLogEnables is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    AlertLogStruct.ReportLogEnables ;\n    -- synthesis translate_on\n  end ReportLogEnables ;\n\n ------------------------------------------------------------\n  procedure SetTestName(Name : string ) is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    AlertLogStruct.SetTestName(Name) ;\n    -- synthesis translate_on\n  end procedure SetTestName ;\n\n  -- synthesis translate_off\n  ------------------------------------------------------------\n  impure function GetTestName return string is\n  ------------------------------------------------------------\n  begin\n    return AlertLogStruct.GetAlertLogName(ALERTLOG_BASE_ID) ;\n  end function GetTestName ;\n\n  ------------------------------------------------------------\n  impure function GetTranscriptName return string is\n  ------------------------------------------------------------\n  begin\n    return GetTestName & \".log\" ;\n  end function GetTranscriptName ;\n\n  ------------------------------------------------------------\n  impure function GetAlertLogName(AlertLogID : AlertLogIDType := ALERTLOG_BASE_ID) return string is\n  ------------------------------------------------------------\n  begin\n    return AlertLogStruct.GetAlertLogName(AlertLogID) ;\n  end GetAlertLogName ;\n  -- synthesis translate_on\n\n  ------------------------------------------------------------\n  procedure DeallocateAlertLogStruct is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    AlertLogStruct.DeallocateAlertLogStruct ;\n    -- synthesis translate_on\n  end procedure DeallocateAlertLogStruct ;\n\n  ------------------------------------------------------------\n  procedure InitializeAlertLogStruct is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    AlertLogStruct.Initialize ;\n    -- synthesis translate_on\n  end procedure InitializeAlertLogStruct ;\n\n  ------------------------------------------------------------\n  impure function FindAlertLogID(Name : string ) return AlertLogIDType is\n  ------------------------------------------------------------\n    variable result : AlertLogIDType ;\n  begin\n    -- synthesis translate_off\n    result := AlertLogStruct.FindAlertLogID(Name) ;\n    -- synthesis translate_on\n    return result ;\n  end function FindAlertLogID ;\n\n  ------------------------------------------------------------\n  impure function FindAlertLogID(Name : string ; ParentID : AlertLogIDType) return AlertLogIDType is\n  ------------------------------------------------------------\n    variable result : AlertLogIDType ;\n  begin\n    -- synthesis translate_off\n    result := AlertLogStruct.FindAlertLogID(Name, ParentID) ;\n    -- synthesis translate_on\n    return result ;\n  end function FindAlertLogID ;\n\n  ------------------------------------------------------------\n  impure function NewID(\n  ------------------------------------------------------------\n    Name            : string ;\n    ParentID        : AlertLogIDType          := ALERTLOG_ID_NOT_ASSIGNED;\n    ReportMode      : AlertLogReportModeType  := ENABLED ;\n    PrintParent     : AlertLogPrintParentType := PRINT_NAME_AND_PARENT ;\n    CreateHierarchy : boolean                 := TRUE\n  ) return AlertLogIDType is\n    variable result : AlertLogIDType ;\n	begin\n    -- synthesis translate_off\n    result := AlertLogStruct.NewID(Name, ParentID, ReportMode, PrintParent, CreateHierarchy) ;\n    -- synthesis translate_on\n    return result ;\n  end function NewID ;\n\n  ------------------------------------------------------------\n  impure function GetAlertLogID(Name : string; ParentID : AlertLogIDType := ALERTLOG_ID_NOT_ASSIGNED; CreateHierarchy : Boolean := TRUE; DoNotReport : Boolean := FALSE) return AlertLogIDType is\n  ------------------------------------------------------------\n    variable result : AlertLogIDType ;\n		variable ReportMode  : AlertLogReportModeType := ENABLED ;\n	begin\n    -- synthesis translate_off\n    if DoNotReport then\n        ReportMode := DISABLED ;\n    end if;\n    -- PrintParent PRINT_NAME_AND_PARENT is not backward compatible with PRINT_NAME of the past\n    result := AlertLogStruct.NewID(Name, ParentID, ReportMode => ReportMode, PrintParent => PRINT_NAME, CreateHierarchy => CreateHierarchy) ;\n--    result := AlertLogStruct.GetAlertLogID(Name, ParentID, CreateHierarchy, DoNotReport) ;\n    -- synthesis translate_on\n    return result ;\n  end function GetAlertLogID ;\n\n  ------------------------------------------------------------\n  impure function GetReqID(Name : string ; PassedGoal : integer := -1 ; ParentID : AlertLogIDType := ALERTLOG_ID_NOT_ASSIGNED ; CreateHierarchy : Boolean := TRUE) return AlertLogIDType is\n  ------------------------------------------------------------\n    variable result : AlertLogIDType ;\n  begin\n    -- synthesis translate_off\n    result := AlertLogStruct.GetReqID(Name, PassedGoal, ParentID, CreateHierarchy) ;\n    -- synthesis translate_on\n    return result ;\n  end function GetReqID ;\n\n  ------------------------------------------------------------\n  procedure SetPassedGoal(AlertLogID : AlertLogIDType ; PassedGoal : integer ) is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    AlertLogStruct.SetPassedGoal(AlertLogID, PassedGoal) ;\n    -- synthesis translate_on\n  end procedure SetPassedGoal ;\n\n  ------------------------------------------------------------\n  impure function GetAlertLogParentID(AlertLogID : AlertLogIDType) return AlertLogIDType is\n  ------------------------------------------------------------\n    variable result : AlertLogIDType ;\n  begin\n    -- synthesis translate_off\n    result := AlertLogStruct.GetAlertLogParentID(AlertLogID) ;\n    -- synthesis translate_on\n    return result ;\n  end function GetAlertLogParentID ;\n\n  ------------------------------------------------------------\n  procedure SetAlertLogPrefix(AlertLogID : AlertLogIDType; Name : string ) is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    AlertLogStruct.SetAlertLogPrefix(AlertLogID, Name) ;\n    -- synthesis translate_on\n  end procedure SetAlertLogPrefix ;\n\n  ------------------------------------------------------------\n  procedure UnSetAlertLogPrefix(AlertLogID : AlertLogIDType ) is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    AlertLogStruct.UnSetAlertLogPrefix(AlertLogID) ;\n    -- synthesis translate_on\n  end procedure UnSetAlertLogPrefix ;\n\n  -- synthesis translate_off\n  ------------------------------------------------------------\n  impure function GetAlertLogPrefix(AlertLogID : AlertLogIDType) return string is\n  ------------------------------------------------------------\n  begin\n    return AlertLogStruct.GetAlertLogPrefix(AlertLogID) ;\n  end function GetAlertLogPrefix ;\n  -- synthesis translate_on\n\n  ------------------------------------------------------------\n  procedure SetAlertLogSuffix(AlertLogID : AlertLogIDType; Name : string ) is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    AlertLogStruct.SetAlertLogSuffix(AlertLogID, Name) ;\n    -- synthesis translate_on\n  end procedure SetAlertLogSuffix ;\n\n  ------------------------------------------------------------\n  procedure UnSetAlertLogSuffix(AlertLogID : AlertLogIDType ) is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    AlertLogStruct.UnSetAlertLogSuffix(AlertLogID) ;\n    -- synthesis translate_on\n  end procedure UnSetAlertLogSuffix ;\n\n  -- synthesis translate_off\n  ------------------------------------------------------------\n  impure function GetAlertLogSuffix(AlertLogID : AlertLogIDType) return string is\n  ------------------------------------------------------------\n  begin\n    return AlertLogStruct.GetAlertLogSuffix(AlertLogID) ;\n  end function GetAlertLogSuffix ;\n  -- synthesis translate_on\n\n  ------------------------------------------------------------\n  procedure SetGlobalAlertEnable (A : boolean := TRUE) is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    AlertLogStruct.SetGlobalAlertEnable(A) ;\n    -- synthesis translate_on\n  end procedure SetGlobalAlertEnable ;\n\n  ------------------------------------------------------------\n  -- Set using constant.  Set before code runs.\n  impure function SetGlobalAlertEnable (A : boolean := TRUE) return boolean is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    AlertLogStruct.SetGlobalAlertEnable(A) ;\n    -- synthesis translate_on\n    return A ;\n  end function SetGlobalAlertEnable ;\n\n  ------------------------------------------------------------\n  impure function GetGlobalAlertEnable return boolean is\n  ------------------------------------------------------------\n    variable result : boolean ;\n  begin\n    -- synthesis translate_off\n    result := AlertLogStruct.GetGlobalAlertEnable ;\n    -- synthesis translate_on\n    return result ;\n  end function GetGlobalAlertEnable ;\n\n  ------------------------------------------------------------\n  procedure IncAffirmCount(AlertLogID : AlertLogIDType := ALERTLOG_BASE_ID) is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    AlertLogStruct.IncAffirmCount(AlertLogID) ;\n    -- synthesis translate_on\n  end procedure IncAffirmCount ;\n\n  ------------------------------------------------------------\n  impure function GetAffirmCount return natural is\n  ------------------------------------------------------------\n    variable result : natural ;\n  begin\n    -- synthesis translate_off\n    result := AlertLogStruct.GetAffirmCount ;\n    -- synthesis translate_on\n    return result ;\n  end function GetAffirmCount ;\n\n  ------------------------------------------------------------\n  procedure IncAffirmPassedCount(AlertLogID : AlertLogIDType := ALERTLOG_BASE_ID) is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    AlertLogStruct.IncAffirmPassedCount(AlertLogID) ;\n    -- synthesis translate_on\n  end procedure IncAffirmPassedCount ;\n\n  ------------------------------------------------------------\n  impure function GetAffirmPassedCount return natural is\n  ------------------------------------------------------------\n    variable result : natural ;\n  begin\n    -- synthesis translate_off\n    result := AlertLogStruct.GetAffirmPassedCount ;\n    -- synthesis translate_on\n    return result ;\n  end function GetAffirmPassedCount ;\n\n  ------------------------------------------------------------\n  procedure SetAlertStopCount(AlertLogID : AlertLogIDType ;  Level : AlertType ;  Count : integer) is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    AlertLogStruct.SetAlertStopCount(AlertLogID, Level, Count) ;\n    -- synthesis translate_on\n  end procedure SetAlertStopCount ;\n\n  ------------------------------------------------------------\n  procedure SetAlertStopCount(Level : AlertType ;  Count : integer) is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    AlertLogStruct.SetAlertStopCount(ALERTLOG_BASE_ID, Level, Count) ;\n    -- synthesis translate_on\n  end procedure SetAlertStopCount ;\n\n  ------------------------------------------------------------\n  impure function GetAlertStopCount(AlertLogID : AlertLogIDType ;  Level : AlertType) return integer is\n  ------------------------------------------------------------\n    variable result : integer ;\n  begin\n    -- synthesis translate_off\n    result := AlertLogStruct.GetAlertStopCount(AlertLogID, Level) ;\n    -- synthesis translate_on\n    return result ;\n  end function GetAlertStopCount ;\n\n  ------------------------------------------------------------\n  impure function GetAlertStopCount(Level : AlertType) return integer is\n  ------------------------------------------------------------\n    variable result : integer ;\n  begin\n    -- synthesis translate_off\n    result := AlertLogStruct.GetAlertStopCount(ALERTLOG_BASE_ID, Level) ;\n    -- synthesis translate_on\n    return result ;\n  end function GetAlertStopCount ;\n\n  ------------------------------------------------------------\n  procedure SetAlertPrintCount(AlertLogID : AlertLogIDType ;  Level : AlertType ;  Count : integer) is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    AlertLogStruct.SetAlertPrintCount(AlertLogID, Level, Count) ;\n    -- synthesis translate_on\n  end procedure SetAlertPrintCount ;\n\n  ------------------------------------------------------------\n  procedure SetAlertPrintCount(Level : AlertType ;  Count : integer) is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    AlertLogStruct.SetAlertPrintCount(ALERTLOG_DEFAULT_ID, Level, Count) ;\n    -- synthesis translate_on\n  end procedure SetAlertPrintCount ;\n\n  ------------------------------------------------------------\n  impure function GetAlertPrintCount(AlertLogID : AlertLogIDType ;  Level : AlertType) return integer is\n  ------------------------------------------------------------\n    variable result : integer ;\n  begin\n    -- synthesis translate_off\n    result := AlertLogStruct.GetAlertPrintCount(AlertLogID, Level) ;\n    -- synthesis translate_on\n    return result ;\n  end function GetAlertPrintCount ;\n\n  ------------------------------------------------------------\n  impure function GetAlertPrintCount(Level : AlertType) return integer is\n  ------------------------------------------------------------\n    variable result : integer ;\n  begin\n    -- synthesis translate_off\n    result := AlertLogStruct.GetAlertPrintCount(ALERTLOG_DEFAULT_ID, Level) ;\n    -- synthesis translate_on\n    return result ;\n  end function GetAlertPrintCount ;\n\n  ------------------------------------------------------------\n  procedure SetAlertPrintCount(AlertLogID : AlertLogIDType ;  Count : AlertCountType) is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    AlertLogStruct.SetAlertPrintCount(AlertLogID, Count) ;\n    -- synthesis translate_on\n  end procedure SetAlertPrintCount ;\n\n  ------------------------------------------------------------\n  procedure SetAlertPrintCount(Count : AlertCountType) is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    AlertLogStruct.SetAlertPrintCount(ALERTLOG_DEFAULT_ID, Count) ;\n    -- synthesis translate_on\n  end procedure SetAlertPrintCount ;\n\n  ------------------------------------------------------------\n  impure function GetAlertPrintCount(AlertLogID : AlertLogIDType) return AlertCountType is\n  ------------------------------------------------------------\n    variable result : AlertCountType ;\n  begin\n    -- synthesis translate_off\n    result := AlertLogStruct.GetAlertPrintCount(AlertLogID) ;\n    -- synthesis translate_on\n    return result ;\n  end function GetAlertPrintCount ;\n\n  ------------------------------------------------------------\n  impure function GetAlertPrintCount return AlertCountType is\n  ------------------------------------------------------------\n    variable result : AlertCountType ;\n  begin\n    -- synthesis translate_off\n    result := AlertLogStruct.GetAlertPrintCount(ALERTLOG_DEFAULT_ID) ;\n    -- synthesis translate_on\n    return result ;\n  end function GetAlertPrintCount ;\n\n  ------------------------------------------------------------\n  procedure SetAlertLogPrintParent(AlertLogID : AlertLogIDType ;  PrintParent : AlertLogPrintParentType) is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    AlertLogStruct.SetAlertLogPrintParent(AlertLogID, PrintParent) ;\n    -- synthesis translate_on\n  end procedure SetAlertLogPrintParent ;\n\n  ------------------------------------------------------------\n  procedure SetAlertLogPrintParent(                                PrintParent : AlertLogPrintParentType) is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    AlertLogStruct.SetAlertLogPrintParent(ALERTLOG_DEFAULT_ID, PrintParent) ;\n    -- synthesis translate_on\n  end procedure SetAlertLogPrintParent ;\n\n  ------------------------------------------------------------\n  impure function GetAlertLogPrintParent(AlertLogID : AlertLogIDType) return AlertLogPrintParentType is\n  ------------------------------------------------------------\n    variable result : AlertLogPrintParentType ;\n  begin\n    -- synthesis translate_off\n    result := AlertLogStruct.GetAlertLogPrintParent(AlertLogID) ;\n    -- synthesis translate_on\n    return result ;\n  end function GetAlertLogPrintParent ;\n\n  ------------------------------------------------------------\n  impure function GetAlertLogPrintParent                              return AlertLogPrintParentType is\n  ------------------------------------------------------------\n    variable result : AlertLogPrintParentType ;\n  begin\n    -- synthesis translate_off\n    result := AlertLogStruct.GetAlertLogPrintParent(ALERTLOG_DEFAULT_ID) ;\n    -- synthesis translate_on\n    return result ;\n  end function GetAlertLogPrintParent ;\n\n  ------------------------------------------------------------\n  procedure SetAlertLogReportMode(AlertLogID : AlertLogIDType ;  ReportMode : AlertLogReportModeType) is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    AlertLogStruct.SetAlertLogReportMode(AlertLogID, ReportMode) ;\n    -- synthesis translate_on\n  end procedure SetAlertLogReportMode ;\n\n  ------------------------------------------------------------\n  procedure SetAlertLogReportMode(                                ReportMode : AlertLogReportModeType) is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    AlertLogStruct.SetAlertLogReportMode(ALERTLOG_DEFAULT_ID, ReportMode) ;\n    -- synthesis translate_on\n  end procedure SetAlertLogReportMode ;\n\n  ------------------------------------------------------------\n  impure function GetAlertLogReportMode(AlertLogID : AlertLogIDType) return AlertLogReportModeType is\n  ------------------------------------------------------------\n    variable result : AlertLogReportModeType ;\n  begin\n    -- synthesis translate_off\n    result := AlertLogStruct.GetAlertLogReportMode(AlertLogID) ;\n    -- synthesis translate_on\n    return result ;\n  end function GetAlertLogReportMode ;\n\n  ------------------------------------------------------------\n  impure function GetAlertLogReportMode                              return AlertLogReportModeType is\n  ------------------------------------------------------------\n    variable result : AlertLogReportModeType ;\n  begin\n    -- synthesis translate_off\n    result := AlertLogStruct.GetAlertLogReportMode(ALERTLOG_DEFAULT_ID) ;\n    -- synthesis translate_on\n    return result ;\n  end function GetAlertLogReportMode ;\n\n  ------------------------------------------------------------\n  procedure SetAlertLogOptions (\n  ------------------------------------------------------------\n    FailOnWarning            : OsvvmOptionsType := OPT_INIT_PARM_DETECT ;\n    FailOnDisabledErrors     : OsvvmOptionsType := OPT_INIT_PARM_DETECT ;\n    FailOnRequirementErrors  : OsvvmOptionsType := OPT_INIT_PARM_DETECT ;\n    ReportHierarchy          : OsvvmOptionsType := OPT_INIT_PARM_DETECT ;\n    WriteAlertErrorCount     : OsvvmOptionsType := OPT_INIT_PARM_DETECT ;\n    WriteAlertLevel          : OsvvmOptionsType := OPT_INIT_PARM_DETECT ;\n    WriteAlertName           : OsvvmOptionsType := OPT_INIT_PARM_DETECT ;\n    WriteAlertTime           : OsvvmOptionsType := OPT_INIT_PARM_DETECT ;\n    WriteLogErrorCount       : OsvvmOptionsType := OPT_INIT_PARM_DETECT ;\n    WriteLogLevel            : OsvvmOptionsType := OPT_INIT_PARM_DETECT ;\n    WriteLogName             : OsvvmOptionsType := OPT_INIT_PARM_DETECT ;\n    WriteLogTime             : OsvvmOptionsType := OPT_INIT_PARM_DETECT ;\n    PrintPassed              : OsvvmOptionsType := OPT_INIT_PARM_DETECT ;\n    PrintAffirmations        : OsvvmOptionsType := OPT_INIT_PARM_DETECT ;\n    PrintDisabledAlerts      : OsvvmOptionsType := OPT_INIT_PARM_DETECT ;\n    PrintRequirements        : OsvvmOptionsType := OPT_INIT_PARM_DETECT ;\n    PrintIfHaveRequirements  : OsvvmOptionsType := OPT_INIT_PARM_DETECT ;\n    DefaultPassedGoal        : integer          := integer'left ;\n    AlertPrefix              : string := OSVVM_STRING_INIT_PARM_DETECT ;\n    LogPrefix                : string := OSVVM_STRING_INIT_PARM_DETECT ;\n    ReportPrefix             : string := OSVVM_STRING_INIT_PARM_DETECT ;\n    DoneName                 : string := OSVVM_STRING_INIT_PARM_DETECT ;\n    PassName                 : string := OSVVM_STRING_INIT_PARM_DETECT ;\n    FailName                 : string := OSVVM_STRING_INIT_PARM_DETECT ;\n    IdSeparator              : string := OSVVM_STRING_INIT_PARM_DETECT ;\n    WriteTimeLast            : OsvvmOptionsType := OPT_INIT_PARM_DETECT ;\n    TimeJustifyAmount        : integer          := integer'left \n  ) is\n  begin\n    -- synthesis translate_off\n    AlertLogStruct.SetAlertLogOptions (\n      FailOnWarning            => FailOnWarning,\n      FailOnDisabledErrors     => FailOnDisabledErrors,\n      FailOnRequirementErrors  => FailOnRequirementErrors,\n      ReportHierarchy          => ReportHierarchy,\n      WriteAlertErrorCount     => WriteAlertErrorCount,\n      WriteAlertLevel          => WriteAlertLevel,\n      WriteAlertName           => WriteAlertName,\n      WriteAlertTime           => WriteAlertTime,\n      WriteLogErrorCount       => WriteLogErrorCount,\n      WriteLogLevel            => WriteLogLevel,\n      WriteLogName             => WriteLogName,\n      WriteLogTime             => WriteLogTime,\n      PrintPassed              => PrintPassed,\n      PrintAffirmations        => PrintAffirmations,\n      PrintDisabledAlerts      => PrintDisabledAlerts,\n      PrintRequirements        => PrintRequirements,\n      PrintIfHaveRequirements  => PrintIfHaveRequirements,\n      DefaultPassedGoal        => DefaultPassedGoal,\n      AlertPrefix              => AlertPrefix,\n      LogPrefix                => LogPrefix,\n      ReportPrefix             => ReportPrefix,\n      DoneName                 => DoneName,\n      PassName                 => PassName,\n      FailName                 => FailName,\n      IdSeparator              => IdSeparator,\n      WriteTimeLast            => WriteTimeLast, \n      TimeJustifyAmount        => TimeJustifyAmount \n    );\n    -- synthesis translate_on\n  end procedure SetAlertLogOptions ;\n\n  ------------------------------------------------------------\n  procedure ReportAlertLogOptions is\n  ------------------------------------------------------------\n  begin\n    -- synthesis translate_off\n    AlertLogStruct.ReportAlertLogOptions ;\n    -- synthesis translate_on\n  end procedure ReportAlertLogOptions ;\n\n\n\n  -- synthesis translate_off\n\n  ------------------------------------------------------------\n  impure function GetAlertLogFailOnWarning        return OsvvmOptionsType is\n  ------------------------------------------------------------\n  begin\n    return AlertLogStruct.GetAlertLogFailOnWarning ;\n  end function GetAlertLogFailOnWarning ;\n\n  ------------------------------------------------------------\n  impure function GetAlertLogFailOnDisabledErrors return OsvvmOptionsType is\n  ------------------------------------------------------------\n  begin\n    return AlertLogStruct.GetAlertLogFailOnDisabledErrors ;\n  end function GetAlertLogFailOnDisabledErrors ;\n\n  ------------------------------------------------------------\n  impure function GetAlertLogFailOnRequirementErrors return OsvvmOptionsType is\n  ------------------------------------------------------------\n  begin\n    return AlertLogStruct.GetAlertLogFailOnRequirementErrors ;\n  end function GetAlertLogFailOnRequirementErrors ;\n\n  ------------------------------------------------------------\n  impure function GetAlertLogReportHierarchy      return OsvvmOptionsType is\n  ------------------------------------------------------------\n  begin\n    return AlertLogStruct.GetAlertLogReportHierarchy ;\n  end function GetAlertLogReportHierarchy ;\n\n  ------------------------------------------------------------\n  impure function GetAlertLogFoundReportHier       return boolean is\n  ------------------------------------------------------------\n  begin\n    return AlertLogStruct.GetAlertLogFoundReportHier ;\n  end function GetAlertLogFoundReportHier ;\n\n  ------------------------------------------------------------\n  impure function GetAlertLogFoundAlertHier       return boolean is\n  ------------------------------------------------------------\n  begin\n    return AlertLogStruct.GetAlertLogFoundAlertHier ;\n  end function GetAlertLogFoundAlertHier ;\n\n  ------------------------------------------------------------\n  impure function GetAlertLogWriteAlertErrorCount return OsvvmOptionsType is\n  ------------------------------------------------------------\n  begin\n    return AlertLogStruct.GetAlertLogWriteAlertErrorCount ;\n  end function GetAlertLogWriteAlertErrorCount ;\n\n  ------------------------------------------------------------\n  impure function GetAlertLogWriteAlertLevel      return OsvvmOptionsType is\n  ------------------------------------------------------------\n  begin\n    return AlertLogStruct.GetAlertLogWriteAlertLevel ;\n  end function GetAlertLogWriteAlertLevel ;\n\n  ------------------------------------------------------------\n  impure function GetAlertLogWriteAlertName       return OsvvmOptionsType is\n  ------------------------------------------------------------\n  begin\n    return AlertLogStruct.GetAlertLogWriteAlertName ;\n  end function GetAlertLogWriteAlertName ;\n\n  ------------------------------------------------------------\n  impure function GetAlertLogWriteAlertTime       return OsvvmOptionsType is\n  ------------------------------------------------------------\n  begin\n    return AlertLogStruct.GetAlertLogWriteAlertTime ;\n  end function GetAlertLogWriteAlertTime ;\n\n  ------------------------------------------------------------\n  impure function GetAlertLogWriteLogErrorCount return OsvvmOptionsType is\n  ------------------------------------------------------------\n  begin\n    return AlertLogStruct.GetAlertLogWriteLogErrorCount ;\n  end function GetAlertLogWriteLogErrorCount ;\n\n  ------------------------------------------------------------\n  impure function GetAlertLogWriteLogLevel        return OsvvmOptionsType is\n  ------------------------------------------------------------\n  begin\n    return AlertLogStruct.GetAlertLogWriteLogLevel ;\n  end function GetAlertLogWriteLogLevel ;\n\n  ------------------------------------------------------------\n  impure function GetAlertLogWriteLogName         return OsvvmOptionsType is\n  ------------------------------------------------------------\n  begin\n    return AlertLogStruct.GetAlertLogWriteLogName ;\n  end function GetAlertLogWriteLogName ;\n\n  ------------------------------------------------------------\n  impure function GetAlertLogWriteLogTime         return OsvvmOptionsType is\n  ------------------------------------------------------------\n  begin\n    return AlertLogStruct.GetAlertLogWriteLogTime ;\n  end function GetAlertLogWriteLogTime ;\n\n  ------------------------------------------------------------\n  impure function GetAlertLogPrintPassed    return OsvvmOptionsType is\n  ------------------------------------------------------------\n  begin\n    return AlertLogStruct.GetAlertLogPrintPassed ;\n  end function GetAlertLogPrintPassed ;\n\n  ------------------------------------------------------------\n  impure function GetAlertLogPrintAffirmations    return OsvvmOptionsType is\n  ------------------------------------------------------------\n  begin\n    return AlertLogStruct.GetAlertLogPrintAffirmations ;\n  end function GetAlertLogPrintAffirmations ;\n\n  ------------------------------------------------------------\n  impure function GetAlertLogPrintDisabledAlerts  return OsvvmOptionsType is\n  ------------------------------------------------------------\n  begin\n    return AlertLogStruct.GetAlertLogPrintDisabledAlerts ;\n  end function GetAlertLogPrintDisabledAlerts ;\n\n  ------------------------------------------------------------\n  impure function GetAlertLogPrintRequirements    return OsvvmOptionsType is\n  ------------------------------------------------------------\n  begin\n  return AlertLogStruct.GetAlertLogPrintRequirements ;\n  end function GetAlertLogPrintRequirements ;\n\n  ------------------------------------------------------------\n  impure function GetAlertLogPrintIfHaveRequirements    return OsvvmOptionsType is\n  ------------------------------------------------------------\n  begin\n  return AlertLogStruct.GetAlertLogPrintIfHaveRequirements ;\n  end function GetAlertLogPrintIfHaveRequirements ;\n\n  ------------------------------------------------------------\n  impure function GetAlertLogDefaultPassedGoal    return integer is\n  ------------------------------------------------------------\n  begin\n  return AlertLogStruct.GetAlertLogDefaultPassedGoal ;\n  end function GetAlertLogDefaultPassedGoal ;\n\n  ------------------------------------------------------------\n  impure function GetAlertLogAlertPrefix          return string is\n  ------------------------------------------------------------\n  begin\n    return AlertLogStruct.GetAlertLogAlertPrefix ;\n  end function GetAlertLogAlertPrefix ;\n\n  ------------------------------------------------------------\n  impure function GetAlertLogLogPrefix            return string is\n  ------------------------------------------------------------\n  begin\n    return AlertLogStruct.GetAlertLogLogPrefix ;\n  end function GetAlertLogLogPrefix ;\n\n  ------------------------------------------------------------\n  impure function GetAlertLogReportPrefix return string is\n  ------------------------------------------------------------\n  begin\n    return AlertLogStruct.GetAlertLogReportPrefix ;\n  end function GetAlertLogReportPrefix ;\n\n  ------------------------------------------------------------\n  impure function GetAlertLogDoneName return string is\n  ------------------------------------------------------------\n  begin\n    return AlertLogStruct.GetAlertLogDoneName ;\n  end function GetAlertLogDoneName ;\n\n  ------------------------------------------------------------\n  impure function GetAlertLogPassName return string is\n  ------------------------------------------------------------\n  begin\n    return AlertLogStruct.GetAlertLogPassName ;\n  end function GetAlertLogPassName ;\n\n  ------------------------------------------------------------\n  impure function GetAlertLogFailName return string is\n  ------------------------------------------------------------\n  begin\n    return AlertLogStruct.GetAlertLogFailName ;\n  end function GetAlertLogFailName ;\n\n  ------------------------------------------------------------\n  impure function GetAlertLogWriteTimeLast        return OsvvmOptionsType is\n  ------------------------------------------------------------\n  begin\n    return AlertLogStruct.GetAlertLogWriteTimeLast ;\n  end function GetAlertLogWriteTimeLast ;\n\n\n  ------------------------------------------------------------\n  -- Package Local\n  procedure ToLogLevel(LogLevel : out LogType; Name : in String; LogValid : out boolean) is\n  ------------------------------------------------------------\n  -- type LogType is (ALWAYS, DEBUG, FINAL, INFO, PASSED) ;  -- NEVER\n  begin\n    if    Name = \"PASSED\" then\n      LogLevel := PASSED ;\n      LogValid := TRUE ;\n    elsif Name = \"DEBUG\" then\n      LogLevel := DEBUG ;\n      LogValid := TRUE ;\n    elsif Name = \"FINAL\" then\n      LogLevel := FINAL ;\n      LogValid := TRUE ;\n    elsif Name = \"INFO\"  then\n      LogLevel := INFO ;\n      LogValid := TRUE ;\n    else\n      LogLevel := ALWAYS ;\n      LogValid := FALSE ;\n    end if ;\n  end procedure ToLogLevel ;\n\n  ------------------------------------------------------------\n  function IsLogEnableType (Name : String) return boolean is\n  ------------------------------------------------------------\n  -- type LogType is (ALWAYS, DEBUG, FINAL, INFO, PASSED) ;  -- NEVER\n  begin\n    if    Name = \"PASSED\" then return TRUE ;\n    elsif Name = \"DEBUG\" then return TRUE ;\n    elsif Name = \"FINAL\" then return TRUE ;\n    elsif Name = \"INFO\"  then return TRUE ;\n    end if ;\n    return FALSE ;\n  end function IsLogEnableType ;\n\n  ------------------------------------------------------------\n  procedure ReadLogEnables (file AlertLogInitFile : text) is\n  --  Preferred Read format\n  --  Line 1:  instance1_name log_enable log_enable log_enable\n  --  Line 2:  instance2_name log_enable log_enable log_enable\n  --  when reading multiple log_enables on a line, they must be separated by a space\n  --\n  --- Also supports alternate format from Lyle/....\n  --  Line 1:  instance1_name\n  --  Line 2:  log enable\n  --  Line 3:  instance2_name\n  --  Line 4:  log enable\n  --\n  ------------------------------------------------------------\n    type     ReadStateType is (GET_ID, GET_ENABLE) ;\n    variable ReadState        : ReadStateType := GET_ID ;\n    variable buf              : line ;\n    variable Empty            : boolean ;\n    variable MultiLineComment : boolean := FALSE ;\n    variable Name             : string(1 to 80) ;\n    variable NameLen          : integer ;\n    variable AlertLogID       : AlertLogIDType ;\n    variable ReadAnEnable     : boolean ;\n    variable LogValid         : boolean ;\n    variable LogLevel         : LogType ;\n  begin\n    ReadState := GET_ID ;\n    ReadLineLoop : while not EndFile(AlertLogInitFile) loop\n      ReadLine(AlertLogInitFile, buf) ;\n      if ReadAnEnable then\n        -- Read one or more enable values, next line read AlertLog name\n        -- Note that any newline with ReadAnEnable TRUE will result in\n        -- searching for another AlertLogID name - this includes multi-line comments.\n        ReadState := GET_ID ;\n      end if ;\n\n      ReadNameLoop : loop\n        EmptyOrCommentLine(buf, Empty, MultiLineComment) ;\n        next ReadLineLoop when Empty ;\n\n        case ReadState is\n          when GET_ID =>\n            sread(buf, Name, NameLen) ;\n            exit ReadNameLoop when NameLen = 0 ;\n            AlertLogID := GetAlertLogID(Name(1 to NameLen), ALERTLOG_ID_NOT_ASSIGNED) ;\n            ReadState := GET_ENABLE ;\n            ReadAnEnable := FALSE ;\n\n          when GET_ENABLE =>\n            sread(buf, Name, NameLen) ;\n            exit ReadNameLoop when NameLen = 0 ;\n            ReadAnEnable := TRUE ;\n--            if not IsLogEnableType(Name(1 to NameLen)) then\n--              Alert(OSVVM_ALERTLOG_ID, \"AlertLogPkg.ReadLogEnables: Found Invalid LogEnable: \" & Name(1 to NameLen)) ;\n--              exit ReadNameLoop ;\n--            end if ;\n----            Log(OSVVM_ALERTLOG_ID, \"SetLogEnable(OSVVM_ALERTLOG_ID, \" & Name(1 to NameLen) & \", TRUE) ;\", DEBUG) ;\n--            LogLevel := LogType'value(\"\" & Name(1 to NameLen)) ;  -- \"\" & added for RivieraPro 2020.10\n            ToLogLevel(LogLevel, Name(1 to NameLen), LogValid) ;\n            exit ReadNameLoop when not LogValid ;\n            SetLogEnable(AlertLogID, LogLevel, TRUE) ;\n        end case ;\n      end loop ReadNameLoop ;\n    end loop ReadLineLoop ;\n  end procedure ReadLogEnables ;\n\n  ------------------------------------------------------------\n  procedure ReadLogEnables (FileName : string) is\n  ------------------------------------------------------------\n    file AlertLogInitFile : text open READ_MODE is FileName ;\n  begin\n    ReadLogEnables(AlertLogInitFile) ;\n  end procedure ReadLogEnables ;\n\n  ------------------------------------------------------------\n  function PathTail (A : string) return string is\n  ------------------------------------------------------------\n    alias aA : string(1 to A'length) is A ;\n    variable LenA : integer := A'length ;\n    variable Result : string(1 to A'length) ;\n  begin\n    if aA(LenA) = ':' then\n      LenA := LenA - 1 ;\n    end if ;\n    for i in LenA downto 1 loop\n      if aA(i) = ':' then\n--!! GHDL Issue\n--         return (1 to LenA - i => aA(i+1 to LenA)) ;\n        Result(1 to LenA - i) := aA(i+1 to LenA) ;\n        return Result(1 to LenA - i) ;\n      end if ;\n    end loop ;\n    return aA(1 to LenA) ;\n  end function PathTail ;\n\n\n  ------------------------------------------------------------\n  -- MetaMatch\n  --   Similar to STD_MATCH, except\n  --   it returns TRUE for U=U, X=X, Z=Z, and W=W\n  --   All other values are consistent with STD_MATCH\n  --   MetaMatch, BooleanTableType, and MetaMatchTable are derivatives\n  --   of STD_MATCH from IEEE.Numeric_Std copyright by IEEE.\n  --   Numeric_Std is also released under the Apache License, Version 2.0.\n  --   Coding Styles were updated to match OSVVM\n  ------------------------------------------------------------\n\n  type BooleanTableType is array(std_ulogic, std_ulogic) of boolean;\n\n  constant MetaMatchTable : BooleanTableType := (\n    --------------------------------------------------------------------------\n    -- U      X      0      1      Z      W      L      H      -\n    --------------------------------------------------------------------------\n    (TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, TRUE),  -- | U |\n    (FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, TRUE),  -- | X |\n    (FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, TRUE,  FALSE, TRUE),  -- | 0 |\n    (FALSE, FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, TRUE,  TRUE),  -- | 1 |\n    (FALSE, FALSE, FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, TRUE),  -- | Z |\n    (FALSE, FALSE, FALSE, FALSE, FALSE, TRUE,  FALSE, FALSE, TRUE),  -- | W |\n    (FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, TRUE,  FALSE, TRUE),  -- | L |\n    (FALSE, FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE, TRUE,  TRUE),  -- | H |\n    (TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE,  TRUE)   -- | - |\n    );\n\n  function MetaMatch (l, r : std_ulogic) return boolean is\n  begin\n    return MetaMatchTable(l, r);\n  end function MetaMatch;\n\n  function MetaMatch (L, R : std_ulogic_vector) return boolean is\n    alias aL : std_ulogic_vector(1 to L'length) is L;\n    alias aR : std_ulogic_vector(1 to R'length) is R;\n  begin\n    if aL'length /= aR'length then\n      --! log(OSVVM_ALERTLOG_ID, \"AlertLogPkg.MetaMatch: Length Mismatch\", DEBUG) ;\n      return FALSE;\n    else\n      for i in aL'range loop\n        if not (MetaMatchTable(aL(i), aR(i))) then\n          return FALSE;\n        end if;\n      end loop;\n      return TRUE;\n    end if;\n  end function MetaMatch;\n\n  function MetaMatch (L, R : unresolved_unsigned) return boolean is\n  begin\n    return MetaMatch( std_ulogic_vector(L), std_ulogic_vector(R)) ;\n  end function MetaMatch;\n\n  function MetaMatch (L, R : unresolved_signed) return boolean is\n  begin\n    return MetaMatch( std_ulogic_vector(L), std_ulogic_vector(R)) ;\n  end function MetaMatch;\n\n  ------------------------------------------------------------\n  -- Helper function for NewID in data structures\n  function ResolvePrintParent (\n  ------------------------------------------------------------\n    UniqueParent : boolean ;\n    PrintParent  : AlertLogPrintParentType\n  ) return AlertLogPrintParentType is\n    variable result : AlertLogPrintParentType ;\n  begin\n    if (not UniqueParent) and PrintParent = PRINT_NAME_AND_PARENT then\n      result := PRINT_NAME ;\n    else\n      result := PrintParent ;\n    end if ;\n    return result ;\n  end function ResolvePrintParent ;\n\n  -- synthesis translate_on\n\n  --  ------------------------------------------------------------\n  -- Deprecated\n  --\n\n  ------------------------------------------------------------\n  -- deprecated\n  procedure AlertIf( condition : boolean ; AlertLogID  : AlertLogIDType ; Message : string ; Level : AlertType := ERROR ) is\n  begin\n    -- synthesis translate_off\n    AlertIf( AlertLogID, condition, Message, Level) ;\n    -- synthesis translate_on\n  end procedure AlertIf ;\n\n  ------------------------------------------------------------\n  -- deprecated\n  impure function  AlertIf( condition : boolean ; AlertLogID  : AlertLogIDType ; Message : string ; Level : AlertType := ERROR ) return boolean is\n    variable result : boolean ;\n  begin\n    -- synthesis translate_off\n    result := AlertIf( AlertLogID, condition, Message, Level) ;\n    -- synthesis translate_on\n    return result ;\n  end function AlertIf ;\n\n  ------------------------------------------------------------\n  -- deprecated\n  procedure AlertIfNot( condition : boolean ; AlertLogID  : AlertLogIDType ; Message : string ; Level : AlertType := ERROR ) is\n  begin\n    -- synthesis translate_off\n    AlertIfNot( AlertLogID, condition, Message, Level) ;\n    -- synthesis translate_on\n  end procedure AlertIfNot ;\n\n  ------------------------------------------------------------\n  -- deprecated\n  impure function  AlertIfNot( condition : boolean ; AlertLogID  : AlertLogIDType ; Message : string ; Level : AlertType := ERROR ) return boolean is\n    variable result : boolean ;\n  begin\n    -- synthesis translate_off\n    result := AlertIfNot( AlertLogID, condition, Message, Level) ;\n    -- synthesis translate_on\n    return result ;\n  end function AlertIfNot ;\n\n  ------------------------------------------------------------\n  -- deprecated\n  procedure AffirmIf(\n    AlertLogID   : AlertLogIDType ;\n    condition    : boolean ;\n    Message      : string ;\n    LogLevel     : LogType  ;  -- := PASSED\n    AlertLevel   : AlertType := ERROR\n  ) is\n  begin\n    -- synthesis translate_off\n    if condition then\n      -- PASSED.  Count affirmations and PASSED internal to LOG to catch all of them\n      AlertLogStruct.Log(AlertLogID, Message, LogLevel) ; -- call log\n    else\n      AlertLogStruct.IncAffirmCount(AlertLogID) ;  -- count the affirmation\n      AlertLogStruct.Alert(AlertLogID, Message, AlertLevel) ; -- signal failure\n    end if ;\n    -- synthesis translate_on\n  end procedure AffirmIf ;\n\n  ------------------------------------------------------------\n  -- deprecated\n  procedure AffirmIf( AlertLogID : AlertLogIDType ; condition : boolean ; Message : string ; AlertLevel : AlertType ) is\n  begin\n    -- synthesis translate_off\n    AffirmIf(AlertLogID, condition, Message, PASSED, AlertLevel) ;\n    -- synthesis translate_on\n  end procedure AffirmIf ;\n\n  ------------------------------------------------------------\n  -- deprecated\n  procedure AffirmIf(condition : boolean ; Message : string ;  LogLevel : LogType  ; AlertLevel : AlertType := ERROR) is\n  begin\n    -- synthesis translate_off\n    AffirmIf(ALERT_DEFAULT_ID, condition, Message, LogLevel, AlertLevel) ;\n    -- synthesis translate_on\n  end procedure AffirmIf;\n\n  ------------------------------------------------------------\n  -- deprecated\n  procedure AffirmIf(condition : boolean ; Message : string ;  AlertLevel : AlertType ) is\n  begin\n    -- synthesis translate_off\n    AffirmIf(ALERT_DEFAULT_ID, condition, Message, PASSED, AlertLevel) ;\n    -- synthesis translate_on\n  end procedure AffirmIf;\n\nend package body AlertLogPkg ;","lang":"vhdl"};
processSrcData(g_data);