var g_data = {"name":"C:/SynthWorks/Dev/_osvvm/OsvvmLibraries/osvvm/TbUtilPkg.vhd","src":"--\n--  File Name:         TbUtilPkg.vhd\n--  Design Unit Name:  TbUtilPkg\n--  Revision:          STANDARD VERSION\n--\n--  Maintainer:        Jim Lewis      email:  jim@SynthWorks.com\n--  Contributor(s):\n--     Jim Lewis      email:  jim@SynthWorks.com\n--\n--  Package Defines\n--\n--  Developed for:\n--        SynthWorks Design Inc.\n--        VHDL Training Classes\n--        11898 SW 128th Ave.  Tigard, Or  97223\n--        http://www.SynthWorks.com\n--\n--  Revision History:\n--    Date      Version    Description\n--    09/2022   2022.09    Added WaitForTransactionOrIrq, FinishTransaction, and TransactionPending for AckType/RdyType\n--    03/2022   2022.03    Added EdgeRose, EdgeFell, FindRisingEdge, FindFallingEdge.\n--    01/2022   2022.01    Added MetaTo01.  Added WaitForTransaction without clock for RdyType/AckType and bit.\n--    02/2021   2021.02    Added AckType, RdyType, RequestTransaction, WaitForTransaction for AckType/RdyType\n--    12/2020   2020.12    Added IfElse functions for string and integer.\n--                         Added Increment function for integer\n--    01/2020   2020.01    Updated Licenses to Apache\n--    08/2018   2018.08    Updated WaitForTransaction to allow 0 time transactions\n--    04/2018   2018.04    Added RequestTransaction, WaitForTransaction, Toggle, WaitForToggle for bit.\n--                         Added Increment and WaitForToggle for integer.\n--    11/2016   2016.11    First Public Release Version\n--                         Updated naming for consistency.\n--    10/2013   2013.10    Split out Text Utilities\n--    11/1999:  0.1        Initial revision\n--                         Numerous revisions for VHDL Testbenches and Verification\n--\n--\n--  This file is part of OSVVM.\n--\n--  Copyright (c) 1999 - 2021 by SynthWorks Design Inc.\n--\n--  Licensed under the Apache License, Version 2.0 (the \"License\");\n--  you may not use this file except in compliance with the License.\n--  You may obtain a copy of the License at\n--\n--      https://www.apache.org/licenses/LICENSE-2.0\n--\n--  Unless required by applicable law or agreed to in writing, software\n--  distributed under the License is distributed on an \"AS IS\" BASIS,\n--  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n--  See the License for the specific language governing permissions and\n--  limitations under the License.\n--\n\nlibrary ieee ;\n  use ieee.std_logic_1164.all ;\n\n  use work.AlertLogPkg.all ;\n  use work.TranscriptPkg.all ;\n  use work.ResolutionPkg.all ;\n  use work.OsvvmGlobalPkg.all ;\n\npackage TbUtilPkg is\n\n  constant CLK_ACTIVE : std_logic := '1' ;\n\n  constant t_sim_resolution : time := std.env.resolution_limit ;  -- VHDL-2008\n  -- constant t_sim_resolution : time := 1 ns ;  -- for non VHDL-2008 simulators\n\n  ------------------------------------------------------------\n  -- ZeroOneHot, OneHot\n  --   OneHot:      return true if exactly one value is 1\n  --   ZeroOneHot:  return false when more than one value is a 1\n  ------------------------------------------------------------\n  function OneHot ( constant A : in std_logic_vector ) return boolean ;\n  function ZeroOneHot ( constant A : in std_logic_vector ) return boolean ;\n\n  ------------------------------------------------------------\n  -- EdgeRose, EdgeFell, FindRisingEdge, FindFallingEdge\n  ------------------------------------------------------------\n  function  EdgeRose ( signal C : in std_logic ) return boolean ;\n  function  EdgeFell ( signal C : in std_logic ) return boolean ;\n  function  EdgeActive ( signal C : in std_logic; A : std_logic ) return boolean ;\n  procedure FindRisingEdge ( signal C : in std_logic) ;\n  procedure FindFallingEdge ( signal C : in std_logic ) ;\n  procedure FindActiveEdge ( signal C : in std_logic; A : std_logic ) ;\n\n  ------------------------------------------------------------\n  -- MetaTo01\n  --   Convert Meta values to 0\n  ------------------------------------------------------------\n  function MetaTo01 ( constant A : in std_ulogic ) return std_ulogic ;\n  function MetaTo01 ( constant A : in std_ulogic_vector ) return std_ulogic_vector ;\n\n  ------------------------------------------------------------\n  -- IfElse\n  --   Crutch until VHDL-2019 conditional initialization\n  --   If condition is true return first parameter otherwise return second\n  ------------------------------------------------------------\n  function IfElse(Expr : boolean ; A, B : std_logic_vector) return std_logic_vector ;\n  function IfElse(Expr : boolean ; A, B : integer) return integer ;\n\n  ------------------------------------------------------------\n  -- RequestTransaction - WaitForTransaction\n  --   RequestTransaction - Transaction initiation in transaction procedure\n  --   WaitForTransaction - Transaction execution control in VC\n  ------------------------------------------------------------\n  ------------------------------------------------------------\n  -- RequestTransaction - WaitForTransaction\n  --   std_logic\n  ------------------------------------------------------------\n  procedure RequestTransaction (\n    signal Rdy  : Out std_logic ;\n    signal Ack  : In  std_logic\n  ) ;\n\n  procedure WaitForTransaction (\n    signal Clk  : In  std_logic ;\n    signal Rdy  : In  std_logic ;\n    signal Ack  : Out std_logic\n  ) ;\n\n  -- Only for clockless models\n  procedure WaitForTransaction (\n    signal Rdy : In  std_logic ;\n    signal Ack : Out std_logic\n  ) ;\n\n  ------------------------------------------------------------\n  -- RequestTransaction - WaitForTransaction\n  --   bit\n  ------------------------------------------------------------\n  procedure RequestTransaction (\n    signal Rdy  : Out bit ;\n    signal Ack  : In  bit\n  ) ;\n\n  procedure WaitForTransaction (\n    signal Clk  : In  std_logic ;\n    signal Rdy  : In  bit ;\n    signal Ack  : Out bit\n  ) ;\n  \n  -- Only for clockless models\n  procedure WaitForTransaction (\n    signal Rdy : in  bit ;\n    signal Ack : out bit\n  ) ;\n\n  ------------------------------------------------------------\n  -- RequestTransaction - WaitForTransaction\n  --   integer\n  ------------------------------------------------------------\n  subtype RdyType is resolved_max integer range  0 to integer'high ;\n  subtype AckType is resolved_max integer range -1 to integer'high ;\n\n  procedure RequestTransaction (\n    signal Rdy     : InOut RdyType ;\n    signal Ack     : In    AckType\n  ) ;\n\n  procedure WaitForTransaction (\n    signal Clk      : In    std_logic ;\n    signal Rdy      : In    RdyType ;\n    signal Ack      : InOut AckType\n  ) ;\n\n  -- Only for clockless models\n  procedure WaitForTransaction (\n    signal Rdy      : In    RdyType ;\n    signal Ack      : InOut AckType\n  );\n\n\n  ------------------------------------------------------------\n  -- Interrupt handling variations of WaitForTransaction \n  --   std_logic / std_logic \n  ------------------------------------------------------------\n  procedure WaitForTransaction (\n    signal   Clk       : In  std_logic ;\n    signal   Rdy       : In  std_logic ;\n    signal   Ack       : Out std_logic ;\n    signal   TimeOut   : In  std_logic ;\n    constant Polarity  : In  std_logic := '1'\n  ) ;\n\n  -- Intended for models that need to switch between instruction streams\n  -- such as a CPU when interrupt is pending\n  procedure WaitForTransactionOrIrq (\n    signal Clk     : In  std_logic ;\n    signal Rdy     : In  std_logic ;\n    signal IntReq  : In  std_logic\n  ) ;\n\n  -- Set Ack to Model starting value\n  procedure StartTransaction  ( signal Ack : Out std_logic ) ;\n  -- Set Ack to Model finishing value\n  procedure FinishTransaction ( signal Ack : Out std_logic ) ;\n  -- If a transaction is pending, return true\n  function TransactionPending ( signal Rdy : In  std_logic ) return boolean ;\n\n  ------------------------------------------------------------\n  -- Interrupt handling variations of WaitForTransaction \n  --   RdyType/AckType \n  ------------------------------------------------------------\n  -- Intended for models that need to switch between instruction streams\n  -- such as a CPU when interrupt is pending\n  procedure WaitForTransactionOrIrq (\n    signal   Clk      : In  std_logic ;\n    signal   Rdy      : In  RdyType ;\n    signal   Ack      : In  AckType ;\n    signal   IntReq   : In  std_logic ;\n    constant POLARITY : In  std_logic := '1' \n  ) ;\n\n  -- StartTransaction not used, Ack is incremented at transaction completion\n--  procedure StartTransaction  ( signal Ack : Out AckType ) ; \n\n  -- Increment Ack\n  procedure FinishTransaction ( signal Ack : InOut AckType ) ;\n\n  -- If a transaction is pending, return true\n  --   Used to detect presence of transaction stream,\n  --   such as an interrupt handler\n  function TransactionPending (\n    signal Rdy     : In  RdyType ;\n    signal Ack     : In  AckType\n  ) return boolean ;\n\n\n  ------------------------------------------------------------\n  -- Toggle, WaitForToggle\n  --   Used for communicating between processes\n  ------------------------------------------------------------\n  procedure Toggle (\n    signal Sig        : InOut std_logic ;\n    constant DelayVal : time\n  ) ;\n  procedure Toggle ( signal Sig : InOut std_logic ) ;\n  procedure ToggleHS ( signal Sig : InOut std_logic ) ;\n  function  IsToggle ( signal Sig : In std_logic ) return boolean ;\n  procedure WaitForToggle ( signal Sig : In std_logic ) ;\n\n  -- Bit type versions\n  procedure Toggle ( signal Sig : InOut bit ; constant DelayVal : time ) ;\n  procedure Toggle ( signal Sig : InOut bit ) ;\n  procedure ToggleHS ( signal Sig : InOut bit ) ;\n  function  IsToggle ( signal Sig : In bit ) return boolean ;\n  procedure WaitForToggle ( signal Sig : In bit ) ;\n\n  -- Integer type versions\n  procedure Increment ( signal Sig : InOut integer ; constant RollOverValue : in integer := 0) ;\n  function  Increment (constant Sig : in integer ; constant Amount : in integer := 1) return integer ;\n  procedure WaitForToggle ( signal Sig : In integer ) ;\n\n\n  ------------------------------------------------------------\n  -- WaitForBarrier\n  --   Barrier Synchronization\n  --   Multiple processes call it, it finishes when all have called it\n  ------------------------------------------------------------\n  procedure WaitForBarrier ( signal Sig : InOut std_logic ) ;\n  procedure WaitForBarrier ( signal Sig : InOut std_logic ; signal TimeOut : std_logic ; constant Polarity : in std_logic := '1') ;\n  procedure WaitForBarrier ( signal Sig : InOut std_logic ; constant TimeOut : time ) ;\n  -- resolved_barrier : summing resolution used in conjunction with integer based barriers\n  function resolved_barrier ( s : integer_vector ) return integer ;\n  subtype  integer_barrier is resolved_barrier integer ;\n  -- Usage of integer barriers requires resolved_barrier. Initialization to 1 recommended, but not required\n  --   signal barrier1 : resolved_barrier integer := 1 ;     -- using the resolution function\n  --   signal barrier2 : integer_barrier := 1 ;              -- using the subtype that already applies the resolution function\n  procedure WaitForBarrier ( signal Sig : InOut integer ) ;\n  procedure WaitForBarrier ( signal Sig : InOut integer ; signal TimeOut : std_logic ; constant Polarity : in std_logic := '1') ;\n  procedure WaitForBarrier ( signal Sig : InOut integer ; constant TimeOut : time ) ;\n  -- Using separate signals\n  procedure WaitForBarrier2 ( signal SyncOut : out std_logic ; signal SyncIn : in  std_logic ) ;\n  procedure WaitForBarrier2 ( signal SyncOut : out std_logic ; signal SyncInV : in  std_logic_vector ) ;\n\n\n  ------------------------------------------------------------\n  -- WaitForClock\n  --   Sync to Clock - after a delay, after a number of clocks\n  ------------------------------------------------------------\n  procedure WaitForClock ( signal Clk : in std_logic ;  constant Delay : in time ) ;\n  procedure WaitForClock ( signal Clk : in std_logic ;  constant NumberOfClocks : in integer := 1) ;\n  procedure WaitForClock ( signal Clk : in std_logic ;  signal Enable : in boolean ) ;\n  procedure WaitForClock ( signal Clk : in std_logic ;  signal Enable : in std_logic ; constant Polarity : std_logic := '1' ) ;\n\n\n  ------------------------------------------------------------\n  -- WaitForLevel\n  --   Find a signal at a level\n  ------------------------------------------------------------\n  procedure WaitForLevel ( signal A : in boolean ) ;\n  procedure WaitForLevel ( signal A : in std_logic ; Polarity : std_logic := '1' ) ;\n\n  ------------------------------------------------------------\n  -- CreateClock,  CreateReset\n  --   Note these do not exit\n  ------------------------------------------------------------\n  procedure CreateClock (\n    signal   Clk        : inout std_logic ;\n    constant Period     : time ;\n    constant DutyCycle  : real := 0.5\n  )  ;\n\n  procedure CheckClockPeriod (\n    constant AlertLogID : AlertLogIDType ;\n    signal   Clk        : in  std_logic ;\n    constant Period     : time ;\n    constant ClkName    : string := \"Clock\" ;\n    constant HowMany    : integer := 5\n  ) ;\n\n  procedure CheckClockPeriod (\n    signal   Clk        : in  std_logic ;\n    constant Period     : time ;\n    constant ClkName    : string := \"Clock\" ;\n    constant HowMany    : integer := 5\n  ) ;\n\n  procedure CreateReset (\n    signal   Reset       : out std_logic ;\n    constant ResetActive : in  std_logic ;\n    signal   Clk         : in  std_logic ;\n    constant Period      :     time ;\n    constant tpd         :     time := 0 ns\n  ) ;\n\n  procedure LogReset (\n    constant AlertLogID  : AlertLogIDType ;\n    signal   Reset       : in  std_logic ;\n    constant ResetActive : in  std_logic ;\n    constant ResetName   : in  string := \"Reset\" ;\n    constant LogLevel    : in  LogType := ALWAYS\n  ) ;\n\n  procedure LogReset (\n    signal   Reset       : in  std_logic ;\n    constant ResetActive : in  std_logic ;\n    constant ResetName   : in  string := \"Reset\" ;\n    constant LogLevel    : in  LogType := ALWAYS\n  ) ;\n\n  ------------------------------------------------------------\n  --  Deprecated subprogram names\n  --    Maintaining backward compatibility using aliases\n  ------------------------------------------------------------\n  -- History of RequestTransaction / WaitForTransaction\n  alias RequestAction is RequestTransaction [std_logic, std_logic] ;\n  alias WaitForRequest is WaitForTransaction [std_logic, std_logic, std_logic] ;\n  -- History of WaitForToggle\n  alias WaitOnToggle is WaitForToggle [std_logic] ;\n  -- History of WaitForBarrier\n  alias WayPointBlock is WaitForBarrier [std_logic] ;\n  alias SyncTo is WaitForBarrier2[std_logic, std_logic] ;\n  alias SyncTo is WaitForBarrier2[std_logic, std_logic_vector] ;\n  -- Backward compatible name\n  alias SyncToClk is WaitForClock [std_logic, time] ;\n\n  ------------------------------------------------------------\n  -- Deprecated\n  -- WaitForAck, StrobeAck\n  --   Replaced by WaitForToggle and Toggle\n  ------------------------------------------------------------\n  procedure WaitForAck ( signal Ack : In  std_logic ) ;\n  procedure StrobeAck  ( signal Ack : Out std_logic ) ;\n\nend TbUtilPkg ;\n\n-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\npackage body TbUtilPkg is\n  type stdulogic_indexby_stdulogic is array (std_ulogic) of std_ulogic;\n\n  ------------------------------------------------------------\n  -- ZeroOneHot, OneHot\n  --   OneHot:      return true if exactly one value is 1\n  --   ZeroOneHot:  return false when more than one value is a 1\n  ------------------------------------------------------------\n  function OneHot ( constant A : in std_logic_vector ) return boolean is\n    variable found_one : boolean := FALSE ;\n  begin\n    for i in A'range loop\n      if A(i) = '1' or A(i) = 'H' then\n        if found_one then\n          return FALSE ;\n        end if ;\n        found_one := TRUE ;\n      end if ;\n    end loop ;\n    return found_one ; -- found a one\n  end function OneHot ;\n\n  function ZeroOneHot ( constant A : in std_logic_vector ) return boolean is\n    variable found_one : boolean := FALSE ;\n  begin\n    for i in A'range loop\n      if A(i) = '1' or A(i) = 'H' then\n        if found_one then\n          return FALSE ;\n        end if ;\n        found_one := TRUE ;\n      end if ;\n    end loop ;\n    return TRUE ;  -- all zero or found a one\n  end function ZeroOneHot ;\n\n  ------------------------------------------------------------\n  -- EdgeRose, EdgeFell, FindRisingEdge, FindFallingEdge\n  ------------------------------------------------------------\n  function EdgeRose ( signal C : in std_logic ) return boolean is\n  begin\n    return  to_x01(C)='1' and to_x01(C'last_value)='0' and C'last_event= 0 sec ;\n  end function EdgeRose ;\n\n  function EdgeFell ( signal C : in std_logic ) return boolean is\n  begin\n    return  to_x01(C)='0' and to_x01(C'last_value)='1' and C'last_event= 0 sec ;\n  end function EdgeFell ;\n\n  function EdgeActive ( signal C : in std_logic; A : std_logic ) return boolean is\n  begin\n    return  to_x01(C)=A and to_x01(C'last_value)=not A and C'last_event= 0 sec ;\n  end function EdgeActive ;\n\n  procedure FindRisingEdge ( signal C : in std_logic) is\n  begin\n    if not EdgeRose(C) then\n      wait until rising_edge(C) ;\n    end if ;\n  end procedure FindRisingEdge ;\n\n--!!  Rejected as the semantic is confusing\n--!!  procedure FindRisingEdge ( signal C : in std_logic; Count : integer) is\n--!!    variable Start : integer := 1 ;\n--!!  begin\n--!!    if EdgeRose(C) then\n--!!      Start := 2 ;\n--!!    end if\n--!!    for i in Start to Count loop\n--!!      wait until rising_edge(C) ;\n--!!    end loop ;\n--!!  end procedure FindRisingEdge ;\n\n  procedure FindFallingEdge ( signal C : in std_logic ) is\n  begin\n    if not EdgeFell(C) then\n      wait until falling_edge(C) ;\n    end if ;\n  end procedure FindFallingEdge ;\n\n  procedure FindActiveEdge ( signal C : in std_logic; A : std_logic ) is\n  begin\n    if A = '1' then\n      FindRisingEdge(C) ;\n    else\n      FindFallingEdge(C) ;\n    end if ;\n  end procedure FindActiveEdge ;\n\n\n  ------------------------------------------------------------\n  -- MetaTo01\n  --   Convert Meta values to 0\n  ------------------------------------------------------------\n  constant MetaTo01Table : stdulogic_indexby_stdulogic := (\n      '1'     => '1',\n      'H'     => '1',\n      others  => '0'\n  );\n\n  function MetaTo01 ( constant A : in std_ulogic ) return std_ulogic is\n  begin\n    return MetaTo01Table(A) ;\n  end function MetaTo01 ;\n\n  function MetaTo01 ( constant A : in std_ulogic_vector ) return std_ulogic_vector is\n    variable result : std_logic_vector(A'range) ;\n  begin\n    for i in A'range loop\n      result(i) := MetaTo01Table(A(i)) ;\n    end loop ;\n    return result ;\n  end function MetaTo01 ;\n\n  ------------------------------------------------------------\n  -- IfElse\n  --   Crutch until VHDL-2019 conditional initialization\n  --   If condition is true return first parameter otherwise return second\n  ------------------------------------------------------------\n  function IfElse(Expr : boolean ; A, B : std_logic_vector) return std_logic_vector is\n  begin\n    if Expr then\n      return A ;\n    else\n      return B ;\n    end if ;\n  end function IfElse ;\n\n  function IfElse(Expr : boolean ; A, B : integer) return integer is\n  begin\n    if Expr then\n      return A ;\n    else\n      return B ;\n    end if ;\n  end function IfElse ;\n\n  ------------------------------------------------------------\n  -- RequestTransaction - WaitForTransaction\n  --   RequestTransaction - Transaction initiation in transaction procedure\n  --   WaitForTransaction - Transaction execution control in VC\n  ------------------------------------------------------------\n  ------------------------------------------------------------\n  -- RequestTransaction - WaitForTransaction\n  --   std_logic\n  ------------------------------------------------------------\n  procedure RequestTransaction (\n    signal Rdy  : Out std_logic ;\n    signal Ack  : In  std_logic\n  ) is\n  begin\n    -- Record contains new transaction\n    Rdy        <= '1' ;\n    -- Find Ack low = '0'\n    wait until Ack = '0' ;\n    -- Prepare for Next Transaction\n    Rdy        <= '0' ;\n    -- Transaction Done\n    wait until Ack = '1' ;\n  end procedure RequestTransaction ;\n\n  procedure WaitForTransaction (\n    signal Clk  : In  std_logic ;\n    signal Rdy  : In  std_logic ;\n    signal Ack  : Out std_logic\n  ) is\n    variable AckTime : time ;\n  begin\n    -- End of Previous Cycle.  Signal Done\n    Ack        <= '1' ;               --  #6\n    AckTime    := NOW ;\n    -- Find Start of Transaction\n    wait for 0 ns ; -- Allow Rdy from previous cycle to clear\n    if Rdy /= '1' then                --   #2\n      wait until Rdy = '1' ;\n    else\n      wait for 0 ns ; -- allow Ack to update\n    end if ;\n    -- align to clock if needed (not back-to-back transactions)\n    if NOW /= AckTime then\n      wait until Clk = CLK_ACTIVE ;\n    end if ;\n    -- Model active and owns the record\n    Ack        <= '0' ;               --  #3\n    wait for 0 ns ; -- Allow transactions without time passing\n  end procedure WaitForTransaction ;\n\n  -- Only for clockless models \n  procedure WaitForTransaction (\n    signal Rdy  : In  std_logic ;\n    signal Ack  : Out std_logic\n  ) is\n  begin\n    -- End of Previous Cycle.  Signal Done\n    Ack        <= '1' ;               --  #6\n    -- Find Start of Transaction\n    wait for 0 ns ; -- Allow Rdy from previous cycle to clear\n    if Rdy /= '1' then                --   #2\n      wait until Rdy = '1' ;\n    end if ;\n    -- Model active and owns the record\n    Ack        <= '0' ;               --  #3\n    wait for 0 ns ; -- allow 0 time transactions\n  end procedure WaitForTransaction ;\n\n  ------------------------------------------------------------\n  -- RequestTransaction - WaitForTransaction\n  --   bit\n  ------------------------------------------------------------\n  procedure RequestTransaction (\n    signal Rdy  : Out bit ;\n    signal Ack  : In  bit\n  ) is\n  begin\n    -- Record contains new transaction\n    Rdy        <= '1' ;\n    -- Find Ack low = '0'\n    wait until Ack = '0' ;\n    -- Prepare for Next Transaction\n    Rdy        <= '0' ;\n    -- Transaction Done\n    wait until Ack = '1' ;\n  end procedure RequestTransaction ;\n\n  procedure WaitForTransaction (\n    signal Clk  : In  std_logic ;\n    signal Rdy  : In  bit ;\n    signal Ack  : Out bit\n  ) is\n    variable AckTime : time ;\n  begin\n    -- End of Previous Cycle.  Signal Done\n    Ack        <= '1' ;               --  #6\n    AckTime    := NOW ;\n    -- Find Start of Transaction\n    wait for 0 ns ; -- Allow Rdy from previous cycle to clear\n    if Rdy /= '1' then                --   #2\n      wait until Rdy = '1' ;\n    else\n      wait for 0 ns ; -- allow Ack to update\n    end if ;\n    -- align to clock if needed (not back-to-back transactions)\n    if NOW /= AckTime then\n      wait until Clk = CLK_ACTIVE ;\n    end if ;\n    -- Model active and owns the record\n    Ack        <= '0' ;               --  #3\n    wait for 0 ns ; -- Allow transactions without time passing\n  end procedure WaitForTransaction ;\n\n  -- Only for clockless models \n  procedure WaitForTransaction (\n    signal Rdy  : in  bit ;\n    signal Ack  : out bit\n  ) is\n  begin\n    -- End of Previous Cycle.  Signal Done\n    Ack        <= '1' ;               --  #6\n    -- Find Start of Transaction\n    wait for 0 ns ; -- Allow Rdy from previous cycle to clear\n    if Rdy /= '1' then                --   #2\n      wait until Rdy = '1' ;\n    end if ;\n    -- Model active and owns the record\n    Ack        <= '0' ;               --  #3\n    wait for 0 ns ; -- allow 0 time transactions\n  end procedure WaitForTransaction ;\n\n  ------------------------------------------------------------\n  -- RequestTransaction - WaitForTransaction\n  --   integer\n  ------------------------------------------------------------\n  procedure RequestTransaction (\n    signal Rdy     : InOut RdyType ;\n    signal Ack     : In    AckType\n  ) is\n  begin\n    -- Initiate Transaction Request\n    Rdy <= Increment(Rdy) ;\n    wait for 0 ns ;\n\n    -- Wait for Transaction Completion\n    wait until Rdy = Ack ;\n  end procedure RequestTransaction ;\n\n  procedure WaitForTransaction (\n    signal Clk      : In    std_logic ;\n    signal Rdy      : In    RdyType ;\n    signal Ack      : InOut AckType\n  ) is\n  begin\n    -- End of Previous Cycle.  Signal Done\n    Ack <= Increment(Ack) ;\n\n    -- Find Start of Transaction\n    wait until Ack /= Rdy ;\n\n    -- Align to clock if needed (not back-to-back transactions)\n    if not EdgeActive(Clk, CLK_ACTIVE) then\n      wait until Clk = CLK_ACTIVE ;\n    end if ;\n  end procedure WaitForTransaction ;\n\n  -- Only for clockless models \n  procedure WaitForTransaction (\n    signal Rdy      : In    RdyType ;\n    signal Ack      : InOut AckType\n  ) is\n  begin\n    -- End of Previous Cycle.  Signal Done\n    Ack <= Increment(Ack) ;\n\n    -- Find Start of Transaction\n    wait until Ack /= Rdy ;\n  end procedure WaitForTransaction ;\n\n  ------------------------------------------------------------\n  -- WaitForTransaction \n  --   Specializations for interrupt handling\n  ------------------------------------------------------------\n  procedure WaitForTransaction (\n    signal   Clk       : In  std_logic ;\n    signal   Rdy       : In  std_logic ;\n    signal   Ack       : Out std_logic ;\n    signal   TimeOut   : In  std_logic ;\n    constant Polarity  : In  std_logic := '1'\n  ) is\n    variable AckTime : time ;\n    variable FoundRdy : boolean ;\n  begin\n    -- End of Previous Cycle.  Signal Done\n    Ack        <= '1' ;               --  #6\n    AckTime    := NOW ;\n    -- Find Ready or Time out\n    wait for 0 ns ; -- Allow Rdy from previous cycle to clear\n    if (Rdy /= '1' and TimeOut /= Polarity) then\n      wait until Rdy = '1' or TimeOut = Polarity ;\n    end if ;\n    FoundRdy := Rdy = '1' ;\n    -- align to clock if Rdy or TimeOut does not happen within delta cycles from Ack\n    if NOW /= AckTime then\n      wait until Clk = CLK_ACTIVE ;\n    end if ;\n    if FoundRdy then\n      -- Model active and owns the record\n      Ack        <= '0' ;             --  #3\n      wait for 0 ns ; -- Allow transactions without time passing\n    end if ;\n  end procedure WaitForTransaction ;\n\n  -- Variation for model that stops waiting when IntReq is asserted\n  -- Intended for models that need to switch between instruction streams\n  -- such as a CPU when interrupt is pending\n  procedure WaitForTransactionOrIrq (\n    signal Clk     : In  std_logic ;\n    signal Rdy     : In  std_logic ;\n    signal IntReq  : In  std_logic\n  ) is\n    variable AckTime : time ;\n    constant POLARITY : std_logic := '1' ;\n  begin\n    AckTime    := NOW ;\n    -- Find Ready or Time out\n    wait for 0 ns ; -- allow Rdy from previous cycle to clear\n    if (Rdy /= '1' and IntReq /= POLARITY) then\n      wait until Rdy = '1' or IntReq = POLARITY ;\n    else\n      wait for 0 ns ; -- allow Ack to update\n   end if ;\n    -- align to clock if Rdy or IntReq does not happen within delta cycles from Ack\n    if NOW /= AckTime then\n      wait until Clk = CLK_ACTIVE ;\n    end if ;\n  end procedure ;\n\n  -- Set Ack to Model starting value\n  -- Pairs with WaitForTransactionOrIrq above\n  procedure StartTransaction  ( signal Ack : Out std_logic ) is\n  begin\n    Ack        <= '0' ;\n    wait for 0 ns ; -- Allow transactions without time passing\n  end procedure StartTransaction ;\n\n  -- Set Ack to Model finishing value\n  -- Pairs with WaitForTransactionOrIrq above\n  procedure FinishTransaction ( signal Ack : Out std_logic ) is\n  begin\n    -- End of Cycle\n    Ack        <= '1' ;\n    wait for 0 ns ; -- Allow Ack to update\n  end procedure FinishTransaction ;\n\n  -- If a transaction is pending, return true\n  --   Used to detect presence of transaction stream,\n  --   such as an interrupt handler\n  function TransactionPending (\n    signal Rdy     : In  std_logic\n  ) return boolean is\n  begin\n    return Rdy = '1' ;\n  end function TransactionPending ;\n\n  ------------------------------------------------------------\n  -- WaitForTransaction - RdyType/AckType \n  --   Specializations for interrupt handling\n  ------------------------------------------------------------\n  -- Intended for models that need to switch between instruction streams\n  -- such as a CPU when interrupt is pending\n  procedure WaitForTransactionOrIrq (\n    signal   Clk      : In  std_logic ;\n    signal   Rdy      : In  RdyType ;\n    signal   Ack      : In  AckType ;\n    signal   IntReq   : In  std_logic ;\n    constant POLARITY : In  std_logic := '1' \n  ) is\n  begin\n    if (Ack = Rdy and IntReq /= POLARITY) then\n      wait until Ack /= Rdy or IntReq = POLARITY ;\n   end if ;\n    -- Align to clock if needed (not back-to-back transactions)\n    if not EdgeActive(Clk, CLK_ACTIVE) then\n      wait until Clk = CLK_ACTIVE ;\n    end if ;\n  end procedure ;\n\n  -- Set Ack to Model starting value\n  -- Pairs with WaitForTransactionOrIrq above\n--  procedure StartTransaction  ( signal Ack : Out AckType ) is\n--  begin\n--    Null ; -- Do nothing\n--  end procedure StartTransaction ;\n\n  -- Set Ack to Model finishing value\n  -- Pairs with WaitForTransactionOrIrq above\n  procedure FinishTransaction ( signal Ack : InOut AckType ) is\n  begin\n    -- End of Cycle\n    Ack <= Increment(Ack) ;\n    wait for 0 ns ; -- allow Ack to update - required for WaitForTransactionOrIrq\n  end procedure FinishTransaction ;\n\n  -- If a transaction is pending, return true\n  --   Used to detect presence of transaction stream,\n  --   such as an interrupt handler\n  function TransactionPending (\n    signal Rdy     : In  RdyType ;\n    signal Ack     : In  AckType\n  ) return boolean is\n  begin\n    return Rdy /= Ack ;\n  end function TransactionPending ;\n\n\n  ------------------------------------------------------------\n  -- Toggle, WaitForToggle\n  --   Used for communicating between processes\n  ------------------------------------------------------------\n  constant toggle_sl_table : stdulogic_indexby_stdulogic := (\n      '0'     => '1',\n      'L'     => '1',\n      others  => '0'\n  );\n\n  procedure Toggle (\n    signal Sig        : InOut std_logic ;\n    constant DelayVal : time\n  ) is\n    variable iDelayVal : time ;\n  begin\n    if DelayVal > t_sim_resolution then\n      iDelayVal := DelayVal - t_sim_resolution ;\n    else\n      iDelayVal := 0 sec ;\n      AlertIf(OSVVM_ALERTLOG_ID, DelayVal < 0 sec, \"osvvm.TbUtilPkg.Toggle: Delay value < 0 ns\") ;\n    end if ;\n    Sig <= toggle_sl_table(Sig) after iDelayVal ;\n  end procedure Toggle ;\n\n  procedure Toggle ( signal Sig : InOut std_logic ) is\n  begin\n    Sig <= toggle_sl_table(Sig) ;\n  end procedure Toggle ;\n\n  procedure ToggleHS ( signal Sig : InOut std_logic ) is\n  begin\n    Sig    <= toggle_sl_table(Sig) ;\n    wait for 0 ns ;  -- Sig toggles\n    wait for 0 ns ;  -- new values updated into record\n  end procedure ToggleHS ;\n\n  function IsToggle ( signal Sig : In std_logic ) return boolean is\n  begin\n    return Sig'event ;\n  end function IsToggle ;\n\n  procedure WaitForToggle ( signal Sig : In std_logic ) is\n  begin\n    wait on Sig ;\n  end procedure WaitForToggle ;\n\n  -- Bit type versions\n  procedure Toggle ( signal Sig : InOut bit ; constant DelayVal : time ) is\n    variable iDelayVal : time ;\n  begin\n    if DelayVal > t_sim_resolution then\n      iDelayVal := DelayVal - t_sim_resolution ;\n    else\n      iDelayVal := 0 sec ;\n      AlertIf(OSVVM_ALERTLOG_ID, DelayVal < 0 sec,\n         \"osvvm.TbUtilPkg.Toggle: Delay value < 0 ns\", WARNING) ;\n    end if ;\n    Sig <= not Sig after iDelayVal ;\n  end procedure Toggle ;\n\n  procedure Toggle ( signal Sig : InOut bit ) is\n  begin\n    Sig <= not Sig ;\n  end procedure Toggle ;\n\n  procedure ToggleHS ( signal Sig : InOut bit ) is\n  begin\n    Sig    <= not Sig ;\n    wait for 0 ns ;  -- Sig toggles\n    wait for 0 ns ;  -- new values updated into record\n  end procedure ToggleHS ;\n\n  function IsToggle ( signal Sig : In bit ) return boolean is\n  begin\n    return Sig'event ;\n  end function IsToggle ;\n\n  procedure WaitForToggle ( signal Sig : In bit ) is\n  begin\n    wait on Sig ;\n  end procedure WaitForToggle ;\n\n  -- Integer type versions\n  procedure Increment (signal Sig : InOut integer ; constant RollOverValue : in integer := 0) is\n  begin\n--!!    if Sig = integer'high then\n    if Sig = 2**30-1 then -- for consistency with function increment\n      Sig <= RollOverValue ;\n    else\n      Sig <= Sig + 1 ;\n    end if ;\n  end procedure Increment ;\n\n  function Increment (constant Sig : in integer ; constant Amount : in integer := 1) return integer is\n  begin\n--! Sig = integer'high - Amount + 1 ;\n    return (Sig + Amount) mod 2**30 ;\n  end function Increment ;\n\n  procedure WaitForToggle ( signal Sig : In integer ) is\n  begin\n    wait on Sig ;\n  end procedure WaitForToggle ;\n\n  ------------------------------------------------------------\n  -- WaitForBarrier\n  --   Barrier Synchronization\n  --   Multiple processes call it, it finishes when all have called it\n  ------------------------------------------------------------\n  procedure WaitForBarrier ( signal Sig : InOut std_logic ) is\n  begin\n    Sig <= 'H' ;\n    -- Wait until all processes set Sig to H\n    -- Level check not necessary since last value /= H yet\n    wait until Sig = 'H' ;\n    -- Deactivate and propagate to allow back to back calls\n    Sig <= '0' ;\n    wait for 0 ns ;\n  end procedure WaitForBarrier ;\n\n  procedure WaitForBarrier ( signal Sig : InOut std_logic ; signal TimeOut : std_logic ; constant Polarity : in std_logic := '1') is\n  begin\n    Sig <= 'H' ;\n    -- Wait until all processes set Sig to H\n    -- Level check not necessary since last value /= H yet\n    wait until Sig = 'H' or TimeOut = Polarity ;\n    -- Deactivate and propagate to allow back to back calls\n    Sig <= '0' ;\n    wait for 0 ns ;\n  end procedure WaitForBarrier ;\n\n  procedure WaitForBarrier ( signal Sig : InOut std_logic ; constant TimeOut : time ) is\n  begin\n    Sig <= 'H' ;\n    -- Wait until all processes set Sig to H\n    -- Level check not necessary since last value /= H yet\n    wait until Sig = 'H' for TimeOut ;\n    -- Deactivate and propagate to allow back to back calls\n    Sig <= '0' ;\n    wait for 0 ns ;\n  end procedure WaitForBarrier ;\n\n  ------------------------------------------------------------\n  -- resolved_barrier\n  -- summing resolution used in conjunction with integer based barriers\n  function resolved_barrier ( s : integer_vector ) return integer is\n    variable result : integer := 0 ;\n  begin\n    for i in s'RANGE loop\n--      if s(i) /= integer'left then\n--        result := result + s(i);\n--      else\n      if s(i) /= 0 then\n        result := result + 1;  -- removes the initialization requirement\n      end if ;\n    end loop ;\n    return result ;\n  end function resolved_barrier ;\n\n  -- Usage of integer barriers requires resolved_barrier. Initialization to 1 recommended, but not required\n  --   signal barrier1 : resolved_barrier integer := 1 ;     -- using the resolution function\n  --   signal barrier2 : integer_barrier := 1 ;              -- using the subtype that already applies the resolution function\n  procedure WaitForBarrier ( signal Sig : InOut integer ) is\n  begin\n    Sig <= 0 ;\n    -- Wait until all processes set Sig to 0\n    -- Level check not necessary since last value /= 0 yet\n    wait until Sig = 0  ;\n    -- Deactivate and propagate to allow back to back calls\n    Sig <= 1 ;\n    wait for 0 ns ;\n  end procedure WaitForBarrier ;\n\n  procedure WaitForBarrier ( signal Sig : InOut integer ; signal TimeOut : std_logic ; constant Polarity : in std_logic := '1') is\n  begin\n    Sig <= 0 ;\n    -- Wait until all processes set Sig to 0\n    -- Level check not necessary since last value /= 0 yet\n    wait until Sig = 0 or TimeOut = Polarity ;\n    -- Deactivate and propagate to allow back to back calls\n    Sig <= 1 ;\n    wait for 0 ns ;\n  end procedure WaitForBarrier ;\n\n  procedure WaitForBarrier ( signal Sig : InOut integer ; constant TimeOut : time ) is\n  begin\n    Sig <= 0 ;\n    -- Wait until all processes set Sig to 0\n    -- Level check not necessary since last value /= 0 yet\n    wait until Sig = 0 for TimeOut ;\n    -- Deactivate and propagate to allow back to back calls\n    Sig <= 1 ;\n    wait for 0 ns ;\n  end procedure WaitForBarrier ;\n\n  -- Using separate signals\n  procedure WaitForBarrier2 ( signal SyncOut : out std_logic ; signal SyncIn : in  std_logic ) is\n  begin\n    -- Activate Rdy\n    SyncOut <= '1' ;\n    -- Make sure our Rdy is seen\n    wait for 0 ns ;\n    -- Wait until other process' Rdy is at level 1\n    if SyncIn /= '1' then\n       wait until SyncIn = '1' ;\n    end if ;\n    -- Deactivate Rdy\n    SyncOut <= '0' ;\n  end procedure WaitForBarrier2 ;\n\n  procedure WaitForBarrier2 ( signal SyncOut : out std_logic ; signal SyncInV : in  std_logic_vector ) is\n    constant ALL_ONE : std_logic_vector(SyncInV'Range) := (others => '1');\n  begin\n    -- Activate Rdy\n    SyncOut <= '1' ;\n    -- Make sure our Rdy is seen\n    wait for 0 ns ;\n    -- Wait until all other process' Rdy is at level 1\n    if SyncInV /= ALL_ONE then\n       wait until SyncInV = ALL_ONE ;\n    end if ;\n    -- Deactivate Rdy\n    SyncOut <= '0' ;\n  end procedure WaitForBarrier2 ;\n\n\n  ------------------------------------------------------------\n  -- WaitForClock\n  --   Sync to Clock - after a delay, after a number of clocks\n  ------------------------------------------------------------\n  procedure WaitForClock ( signal Clk : in std_logic ;  constant Delay : in time ) is\n  begin\n    if delay > t_sim_resolution then\n      wait for delay - t_sim_resolution ;\n    end if ;\n    wait until Clk = CLK_ACTIVE ;\n  end procedure WaitForClock ;\n\n  procedure WaitForClock ( signal Clk : in std_logic ;  constant NumberOfClocks : in integer := 1) is\n  begin\n    for i in 1 to NumberOfClocks loop\n      wait until Clk = CLK_ACTIVE ;\n    end loop ;\n  end procedure WaitForClock ;\n\n  procedure WaitForClock ( signal Clk : in std_logic ;  signal Enable : in boolean ) is\n  begin\n    wait on Clk until Clk = CLK_ACTIVE and Enable ;\n  end procedure WaitForClock ;\n\n  procedure WaitForClock ( signal Clk : in std_logic ;  signal Enable : in std_logic ; constant Polarity : std_logic := '1' ) is\n  begin\n    wait on Clk until Clk = CLK_ACTIVE and Enable = Polarity ;\n  end procedure WaitForClock ;\n\n\n  ------------------------------------------------------------\n  -- WaitForLevel\n  --   Find a signal at a level\n  ------------------------------------------------------------\n  procedure WaitForLevel ( signal A : in boolean ) is\n  begin\n    if not A then\n      wait until A ;\n    end if ;\n  end procedure WaitForLevel ;\n\n  procedure WaitForLevel ( signal A : in std_logic ; Polarity : std_logic := '1' ) is\n  begin\n    if A /= Polarity then\n      -- wait on A until A = Polarity ;\n      if Polarity = '1' then\n        wait until A = '1' ;\n      else\n        wait until A = '0' ;\n      end if ;\n    end if ;\n  end procedure WaitForLevel ;\n\n\n  ------------------------------------------------------------\n  -- CreateClock,  CreateReset\n  --   Note these do not exit\n  ------------------------------------------------------------\n  procedure CreateClock (\n    signal   Clk        : inout std_logic ;\n    constant Period     : time ;\n    constant DutyCycle  : real := 0.5\n  ) is\n    constant HIGH_TIME : time := Period * DutyCycle ;\n    constant LOW_TIME  : time := Period - HIGH_TIME ;\n  begin\n    if HIGH_TIME = LOW_TIME then\n --     -- Set a 1 if not initialized, otherwise use initialized value.\n --     if Clk = 'U' then \n --       Clk <= '1' ; \n --       wait for 0 ns ; \n --     end if  ;\n      loop\n        Clk <= toggle_sl_table(Clk) after HIGH_TIME ;\n        wait on Clk ;\n      end loop ;\n    else\n      -- Schedule s.t. all assignments after the first occur on delta cycle 0\n      Clk <= '0', '1' after LOW_TIME ;\n      wait for period - t_sim_resolution ; -- allows after on future Clk <= '0'\n      loop\n        Clk <= '0' after t_sim_resolution, '1' after LOW_TIME + t_sim_resolution ;\n        wait for period ;\n      end loop ;\n    end if ;\n  end procedure CreateClock ;\n\n  procedure CheckClockPeriod (\n    constant AlertLogID : AlertLogIDType ;\n    signal   Clk        : in  std_logic ;\n    constant Period     : time ;\n    constant ClkName    : string := \"Clock\" ;\n    constant HowMany    : integer := 5\n  ) is\n    variable LastLogTime, ObservedPeriod : time ;\n  begin\n    wait until EdgeActive(Clk, CLK_ACTIVE) ;\n    LastLogTime := now ;\n    -- Check First HowMany clocks\n    for i in 1 to HowMany loop\n      wait until Clk = CLK_ACTIVE ;\n      ObservedPeriod := now - LastLogTime ;\n      AffirmIf(AlertLogID, ObservedPeriod = Period,\n         \"CheckClockPeriod: \" & ClkName & \" Period: \" & to_string(ObservedPeriod, GetOsvvmDefaultTimeUnits) &\n         \" = Expected \" & to_string(Period, GetOsvvmDefaultTimeUnits)) ;\n      LastLogTime := now ;\n     end loop ;\n     wait ;\n  end procedure CheckClockPeriod ;\n\n  procedure CheckClockPeriod (\n    signal   Clk        : in  std_logic ;\n    constant Period     : time ;\n    constant ClkName    : string := \"Clock\" ;\n    constant HowMany    : integer := 5\n  ) is\n  begin\n    CheckClockPeriod (\n      AlertLogID => ALERTLOG_DEFAULT_ID,\n      Clk        => Clk,\n      Period     => Period,\n      ClkName    => ClkName,\n      HowMany    => HowMany\n    ) ;\n  end procedure CheckClockPeriod ;\n\n  procedure CreateReset (\n    signal   Reset       : out std_logic ;\n    constant ResetActive : in  std_logic ;\n    signal   Clk         : in  std_logic ;\n    constant Period      :     time ;\n    constant tpd         :     time := 0 ns\n  ) is\n  begin\n    wait until EdgeActive(Clk, CLK_ACTIVE) ;\n    Reset <= ResetActive after tpd ;\n    wait for Period - t_sim_resolution ;\n    wait until Clk = CLK_ACTIVE ;\n    Reset <= not ResetActive after tpd ;\n    wait ;\n  end procedure CreateReset ;\n\n  procedure LogReset (\n    constant AlertLogID  : AlertLogIDType ;\n    signal   Reset       : in  std_logic ;\n    constant ResetActive : in  std_logic ;\n    constant ResetName   : in  string := \"Reset\" ;\n    constant LogLevel    : in  LogType := ALWAYS\n  ) is\n  begin\n    -- Does not log the value of Reset at time 0.\n    for_ever : loop\n      wait on Reset ;\n      if Reset = ResetActive then\n        LOG(AlertLogID, ResetName & \" now active\", INFO) ;\n        print(\"\") ;\n      elsif Reset = not ResetActive then\n        LOG(AlertLogID, ResetName & \" now inactive\", INFO) ;\n        print(\"\") ;\n      else\n        LOG(AlertLogID, ResetName & \" = \" & to_string(Reset), INFO) ;\n        print(\"\") ;\n      end if ;\n    end loop for_ever ;\n  end procedure LogReset ;\n\n  procedure LogReset (\n    signal   Reset       : in  std_logic ;\n    constant ResetActive : in  std_logic ;\n    constant ResetName   : in  string := \"Reset\" ;\n    constant LogLevel    : in  LogType := ALWAYS\n  ) is\n  begin\n    LogReset (\n      AlertLogID  => ALERTLOG_DEFAULT_ID,\n      Reset       => Reset,\n      ResetActive => ResetActive,\n      ResetName   => ResetName,\n      LogLevel    => LogLevel\n    ) ;\n  end procedure LogReset ;\n\n  ------------------------------------------------------------\n  -- Deprecated\n  -- WaitForAck, StrobeAck\n  --   Replaced by WaitForToggle and Toggle\n  ------------------------------------------------------------\n  procedure WaitForAck ( signal Ack : In  std_logic ) is\n  begin\n    -- Wait for Model to be done\n    wait until Ack = '1' ;\n    wait for 0 ns ;\n  end procedure ;\n\n  procedure StrobeAck  ( signal Ack  : Out std_logic ) is\n  begin\n    -- Model done, drive rising edge on Ack\n    Ack        <= '0' ;\n    wait for 0 ns ;\n    Ack        <= '1' ;\n    wait for 0 ns ;\n  end procedure ;\n\n\nend TbUtilPkg ;\n","lang":"vhdl"};
processSrcData(g_data);