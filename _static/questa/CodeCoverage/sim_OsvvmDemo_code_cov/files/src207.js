var g_data = {"name":"C:/SynthWorks/Dev/_osvvm/OsvvmLibraries/Ethernet/src/xMiiMacTransmitter.vhd","src":"--\n--  File Name:         xMiiMacTransmitter.vhd\n--  Design Unit Name:  xMiiMacTransmitter\n--  Revision:          OSVVM MODELS STANDARD VERSION\n--\n--  Maintainer:        Jim Lewis      email:  jim@synthworks.com\n--  Contributor(s):\n--     Jim Lewis      jim@synthworks.com\n--\n--\n--  Description:\n--      Ethernet GMII/RGMII/MII/RMII VC\n--      First target is to support PHY\n--      Later on need basis consider supporting MAC\n--\n--\n--  Developed by:\n--        SynthWorks Design Inc.\n--        VHDL Training Classes\n--        http://www.SynthWorks.com\n--\n--  Revision History:\n--    Date      Version    Description\n--    10/2022   2022.10    Initial Release\n--\n--\n--  This file is part of OSVVM.\n--\n--  Copyright (c) 2022 by SynthWorks Design Inc.\n--\n--  Licensed under the Apache License, Version 2.0 (the \"License\");\n--  you may not use this file except in compliance with the License.\n--  You may obtain a copy of the License at\n--\n--      https://www.apache.org/licenses/LICENSE-2.0\n--\n--  Unless required by applicable law or agreed to in writing, software\n--  distributed under the License is distributed on an \"AS IS\" BASIS,\n--  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n--  See the License for the specific language governing permissions and\n--  limitations under the License.\n--\n\nlibrary ieee ;\n  use ieee.std_logic_1164.all ;\n  use ieee.numeric_std.all ;\n  use ieee.numeric_std_unsigned.all ;\n  use ieee.math_real.all ;\n\nlibrary osvvm ;\n  context osvvm.OsvvmContext ;\n  use osvvm.ScoreboardPkg_slv.all ;\n  use osvvm.ScoreboardPkg_int.all ;\n\nlibrary osvvm_common ;\n  context osvvm_common.OsvvmCommonContext ;\n\n  use work.xMiiTbPkg.all ;\n\nentity xMiiMacTransmitter is\n  generic (\n    MODEL_ID_NAME  : string := \"\" ;\n    DEFAULT_DELAY  : time := 1 ns ;\n    tpd            : time := DEFAULT_DELAY \n  ) ;\n  port (\n    -- Configured by MDIO - it can change during operation based on PHY negotiation\n    xMiiInterface : in xMiiInterfaceType := GMII ;\n    xMiiBps       : in xMiiBpsType       := BPS_1G ;\n    \n    -- xMiiMacReceiver Transmitter Functional Interface\n    Gtx_Clk   : out std_logic ;  -- out for GMII/RGMII, in for MII\n    Tx_Clk    : in  std_logic ;  -- out for GMII/RGMII, in for MII\n    TxD       : out std_logic_vector(0 to 7) ; \n    Tx_En     : out std_logic ; \n    Tx_Er     : out std_logic ; \n    Tx_Ctl    : out std_logic ; \n    \n    -- Testbench Transaction Interface\n    TransRec   : inout StreamRecType   -- Information outbound of this VC\n  ) ;\n\n  -- Use MODEL_ID_NAME Generic if set, otherwise,\n  -- use model instance label (preferred if set as entityname_1)\n  constant MODEL_INSTANCE_NAME : string :=\n    IfElse(MODEL_ID_NAME'length > 0, MODEL_ID_NAME, \n      to_lower(PathTail(xMiiMacTransmitter'PATH_NAME))) ;\n\nend entity xMiiMacTransmitter ;\narchitecture behavioral of xMiiMacTransmitter is\n\n  signal tperiod_xClk : time := CalcPeriod(BPS_1G, GMII) ; \n  signal RefGtxClk    : std_logic := '0' ; \n  signal iTxClk       : std_logic := '0' ; \n    \n  signal ModelID      : AlertLogIDType ;\n\n  signal DataFifo     : osvvm.ScoreboardPkg_slv.ScoreboardIDType ;\n  signal MetaFifo     : osvvm.ScoreboardPkg_int.ScoreboardIDType ;\n\n  signal TransmitRequestCount, TransmitDoneCount      : integer := 0 ;\n\n--!! TODO - NumGapLength should be a function of frequency\n  signal NumGapLength : integer := 7 ;\n\nbegin\n\n  ------------------------------------------------------------\n  --  Initialize alerts\n  ------------------------------------------------------------\n  Initialize : process\n    variable ID : AlertLogIDType ;\n  begin\n    -- Alerts\n    ID           := NewID(MODEL_INSTANCE_NAME) ;\n    ModelID      <= ID ;\n    DataFifo     <= NewID(\"DataFifo\",  ID, ReportMode => DISABLED, Search => PRIVATE_NAME) ; \n    MetaFifo     <= NewID(\"MetaFifo\",  ID, ReportMode => DISABLED, Search => PRIVATE_NAME) ; \n    wait ;\n  end process Initialize ;\n\n  ------------------------------------------------------------\n  ClkProc : process\n  ------------------------------------------------------------\n  begin\n    wait for 0 ns ;  -- calc init value on tperiod_xClk\n    loop \n      RefGtxClk <= not RefGtxClk after tperiod_xClk ; \n      wait on RefGtxClk ; \n    end loop ; \n  end process ; \n\n  tperiod_xClk <= CalcPeriod(xMiiBps, xMiiInterface) ; \n  \n  -- Internal timing reference - caution:  shifted by delta cycle\n  iTxClk <= RefGtxClk when xMiiInterface = GMII or xMiiInterface = RGMII \n            else Tx_Clk when xMiiInterface = MII else\n--!!TODO resolve source of RMII Clk\n            Tx_Clk ; -- Source of RMII\n  \n  -- source synchronous clock delay.  Typically done by board traces.\n  Gtx_Clk <= RefGtxClk after tpd ; \n\n\n  ------------------------------------------------------------\n  TransactionDispatcher : process\n  ------------------------------------------------------------\n    variable NumberTransfers : integer ;\n  begin\n    wait for 0 ns ;  -- Wait for ModelId\n    TransRec.BurstFifo <= NewID(\"BurstFifo\", ModelId, ReportMode => DISABLED, Search => PRIVATE_NAME) ;\n    \n    DispatchLoop : loop \n      WaitForTransaction(\n         Clk      => iTxClk,\n         Rdy      => TransRec.Rdy,\n         Ack      => TransRec.Ack\n      ) ;\n\n      case TransRec.Operation is\n        when WAIT_FOR_CLOCK =>\n          WaitForClock(iTxClk, TransRec.IntToModel) ;\n\n        when WAIT_FOR_TRANSACTION =>\n          if TransmitRequestCount /= TransmitDoneCount then\n            wait until TransmitRequestCount = TransmitDoneCount ;\n          end if ;\n\n        when GET_TRANSACTION_COUNT =>\n          TransRec.IntFromModel <= TransmitDoneCount ;\n          wait for 0 ns ;\n\n        when GET_ALERTLOG_ID =>\n          TransRec.IntFromModel <= integer(ModelId) ;\n          wait for 0 ns ;\n\n        when SEND_BURST | SEND_BURST_ASYNC =>\n          NumberTransfers := TransRec.IntToModel ;\n          Push(MetaFifo, NumberTransfers) ;\n          Increment(TransmitRequestCount) ; \n-- Any reason not to just use the BurstFifo directly?\n-- Limits BurstFifo editing capability when ASYNC and \n          for i in 1 to NumberTransfers loop\n            Push(DataFifo, Pop(TransRec.BurstFifo)) ;\n          end loop ; \n          \n          wait for 0 ns ;\n          if IsBlocking(TransRec.Operation) then\n            wait until TransmitRequestCount = TransmitDoneCount ;\n          end if ;\n          Log(ModelId,\n            \"Sent Packet# \" & to_string (TransmitRequestCount),\n            INFO, TransRec.BoolToModel or IsLogEnabled(ModelId, PASSED)\n          ) ;\n\n        when SET_MODEL_OPTIONS | GET_MODEL_OPTIONS =>\n          Alert(ModelId, \"Configuration done via MDIO Interface.\" & \n                         \"  Transaction # \" & to_string(TransRec.Rdy), FAILURE) ;\n\n        when MULTIPLE_DRIVER_DETECT =>\n          Alert(ModelId, \"Multiple Drivers on Transaction Record.\" & \n                         \"  Transaction # \" & to_string(TransRec.Rdy), FAILURE) ;\n\n        -- The End -- Done\n        when others =>\n          Alert(ModelId, \"Unimplemented Transaction: \" & to_string(TransRec.Operation), FAILURE) ;\n      end case ;\n\n      -- Wait for 1 delta cycle, required if a wait is not in all case branches above\n      wait for 0 ns ;\n    end loop DispatchLoop ;\n  end process TransactionDispatcher ;\n\n\n\n  ------------------------------------------------------------\n  MacTxHandler : process\n  --  MAC sends data on Transmitter Interface\n  ------------------------------------------------------------\n    variable PreambleLength : integer := 7 ; -- requirement to send 7\n    variable PacketLength   : integer ;\n    \n    ------------------------------------------------------------\n    procedure SendByte (\n      iData : std_logic_vector(0 to 7);  \n      iEn   : std_logic := '1'; \n      iEr   : std_logic := '0' \n    ) is\n    ------------------------------------------------------------\n    begin\n      SendByte(\n        Clk           => iTxClk,\n        iData         => iData, \n        iEnDv         => iEn,\n        iEr           => iEr,\n        Tpd           => tpd, \n        xMiiInterface => xMiiInterface,\n        oData         => TxD,\n        oEnDv         => Tx_En,\n        oEr           => Tx_Er,\n        oCtl          => Tx_Ctl\n      ) ; \n    end procedure SendByte ; \n\n  begin\n  \n    TxD       <= (others => '0') ;\n    Tx_En     <= '0' ;\n    Tx_Er     <= '0' ;\n    Tx_Ctl    <= '0' ;\n\n    wait for 0 ns ; -- Allow DataFifo and MetaFifo to initialize \n\n    SendLoop : loop\n      if Empty(MetaFifo) then\n         WaitForToggle(TransmitRequestCount) ;\n      end if ;\n      FindRisingEdge(iTxClk) ;\n      PacketLength := Pop(MetaFifo) ; \n\n      -- Send Preamble Bytes \n      for i in 1 to PreambleLength loop\n        SendByte(X\"AA\") ; \n      end loop ;\n\n      -- Send SFD\n      SendByte(X\"AB\") ; \n\n      for i in 1 to PacketLength loop  \n        SendByte(Pop(DataFifo)) ; \n      end loop ; \n\n      -- Send Inter-frame gap\n      for i in 1 to NumGapLength loop \n        SendByte(X\"0F\", '0', '0') ; \n      end loop ;\n\n      -- Signal completion\n      Increment(TransmitDoneCount) ;\n      wait for 0 ns ;\n    end loop SendLoop ;\n  end process MacTxHandler ;\n    \nend architecture behavioral ;\n","lang":"vhdl"};
processSrcData(g_data);