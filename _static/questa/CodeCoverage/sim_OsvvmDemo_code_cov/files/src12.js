var g_data = {"name":"C:/SynthWorks/Dev/_osvvm/OsvvmLibraries/Common/src/StreamTransactionArrayPkg.vhd","src":"--\n--  File Name:         StreamTransactionArrayPkg.vhd\n--  Design Unit Name:  StreamTransactionArrayPkg\n--  Revision:          OSVVM MODELS STANDARD VERSION\n--\n--  Maintainer:        Jim Lewis      email:  jim@synthworks.com\n--  Contributor(s):\n--     Jim Lewis      jim@synthworks.com\n--\n--\n--  Description:\n--    Defines Stream transaction initiation procedures (Send, Get, ...)\n--    for arrays of Stream Interfaces (StreamRecArrayType).\n--    Companion to StreamTransactionPkg.vhd\n--    \n--    This works around a VHDL issue documented in \n--    https://gitlab.com/IEEE-P1076/VHDL-Issues/-/issues/275\n--    When this issue is fixed and implemented, this package will\n--    no longer be needed\n--\n--\n--  Developed by:\n--        SynthWorks Design Inc.\n--        VHDL Training Classes\n--        http://www.SynthWorks.com\n--\n--  Revision History:\n--    Date      Version    Description\n--    11/2022   2022.11    initial\n--\n--\n--  This file is part of OSVVM.\n--  \n--  Copyright (c) 2022 by SynthWorks Design Inc.  \n--  \n--  Licensed under the Apache License, Version 2.0 (the \"License\");\n--  you may not use this file except in compliance with the License.\n--  You may obtain a copy of the License at\n--  \n--      https://www.apache.org/licenses/LICENSE-2.0\n--  \n--  Unless required by applicable law or agreed to in writing, software\n--  distributed under the License is distributed on an \"AS IS\" BASIS,\n--  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n--  See the License for the specific language governing permissions and\n--  limitations under the License.\n--  \n\nlibrary ieee ;\n  use ieee.std_logic_1164.all ;\n  use ieee.numeric_std.all ;\n  use ieee.numeric_std_unsigned.all ;\n\n  use std.textio.all ;\n\nlibrary osvvm ; \n  context osvvm.OsvvmContext ;  \n  use osvvm.ScoreboardPkg_slv.all ; \n  \n  use work.FifoFillPkg_slv.all ; \n  use work.StreamTransactionPkg.all ; \n\npackage StreamTransactionArrayPkg is \n\n  -- ========================================================\n  --  Directive Transactions  \n  --  Directive transactions interact with the verification component \n  --  without generating any transactions or interface waveforms.\n  --  Supported by all verification components\n  -- ========================================================\n  ------------------------------------------------------------\n  procedure WaitForTransaction (\n  --  Wait until pending (transmit) or next (receive) transaction(s) complete\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer \n  ) ; \n\n  ------------------------------------------------------------\n  procedure WaitForClock (\n  -- Wait for NumberOfClocks number of clocks \n  -- relative to the verification component clock\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  WaitCycles       : in    natural := 1\n  ) ; \n  \n  ------------------------------------------------------------\n  procedure GetTransactionCount (\n  -- Get the number of transactions handled by the model.  \n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    variable  TransactionCount : out   integer \n  ) ; \n\n  ------------------------------------------------------------\n  procedure GetAlertLogID (\n  -- Get the AlertLogID from the verification component.\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    variable  AlertLogID       : out   AlertLogIDType \n  ) ; \n  \n  ------------------------------------------------------------\n  procedure GetErrorCount (\n  -- Error reporting for testbenches that do not use OSVVM AlertLogPkg\n  -- Returns error count.  If an error count /= 0, also print errors\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    variable  ErrorCount       : out   natural\n  ) ; \n  \n  ------------------------------------------------------------\n  --  SetBurstMode and GetBurstMode\n  --  are directive transactions that configure the burst mode \n  --  into one of the modes defined for StreamFifoBurstModeType\n  ------------------------------------------------------------\n  ------------------------------------------------------------\n  procedure SetBurstMode (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  OptVal           : in    StreamFifoBurstModeType\n  ) ;\n\n  ------------------------------------------------------------\n  procedure GetBurstMode (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    variable  OptVal           : out   StreamFifoBurstModeType\n  ) ;\n\n  ------------------------------------------------------------\n  --  GotBurst   \n  --  Check to see if Read Burst is available\n  --  Primarily used internally\n  ------------------------------------------------------------\n  ------------------------------------------------------------\n  procedure GotBurst (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  NumFifoWords     : in    integer ;\n    variable  Available        : out   boolean\n  ) ;\n\n  -- ========================================================\n  --  Set and Get Model Options  \n  --  Model operations are directive transactions that are  \n  --  used to configure the verification component.  \n  --  They can either be used directly or with a model specific\n  --  wrapper around them - see AXI models for examples.\n  -- ========================================================\n  ------------------------------------------------------------\n  procedure SetModelOptions (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  Option           : in    integer ;\n    constant  OptVal           : in    boolean\n  ) ;\n\n  ------------------------------------------------------------\n  procedure SetModelOptions (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  Option           : in    integer ;\n    constant  OptVal           : in    integer\n  ) ;\n\n  ------------------------------------------------------------\n  procedure SetModelOptions (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  Option           : in    integer ;\n    constant  OptVal           : in    std_logic_vector\n  ) ;\n  \n  ------------------------------------------------------------\n  procedure SetModelOptions (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  Option           : in    integer ;\n    constant  OptVal           : in    time\n  ) ;\n  \n  ------------------------------------------------------------\n  procedure SetModelOptions (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  Option           : in    integer \n  ) ;\n  \n  ------------------------------------------------------------\n  procedure GetModelOptions (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  Option           : in    integer ;\n    variable  OptVal           : out   boolean\n  ) ;\n\n  ------------------------------------------------------------\n  procedure GetModelOptions (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  Option           : in    integer ;\n    variable  OptVal           : out   integer\n  ) ;\n\n  ------------------------------------------------------------\n  procedure GetModelOptions (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  Option           : in    integer ;\n    variable  OptVal           : out   std_logic_vector\n  ) ;\n  \n  ------------------------------------------------------------\n  procedure GetModelOptions (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  Option           : in    integer ;\n    variable  OptVal           : out   time\n  ) ;\n  \n  ------------------------------------------------------------\n  procedure GetModelOptions (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  Option           : in    integer \n  ) ;\n\n\n  -- ========================================================\n  --  Transmitter Transactions\n  -- ========================================================\n\n  -- ========================================================\n  -- Send\n  -- Blocking Send Transaction. \n  -- Param, when present, is an extra parameter used by the verification component\n  -- The UART verification component uses Param for error injection.\n  -- ========================================================\n  \n  ------------------------------------------------------------\n  procedure Send (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  Data             : in    std_logic_vector ;\n    constant  Param            : in    std_logic_vector ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) ; \n\n  ------------------------------------------------------------\n  procedure Send (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  Data             : in    std_logic_vector ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) ; \n  \n\n  -- ========================================================\n  -- SendAsync\n  -- Asynchronous / Non-Blocking Send Transaction\n  -- Param, when present, is an extra parameter used by the verification component\n  -- The UART verification component uses Param for error injection. \n  -- ========================================================\n\n  ------------------------------------------------------------\n  procedure SendAsync (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  Data             : in    std_logic_vector ;\n    constant  Param            : in    std_logic_vector ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) ; \n\n  ------------------------------------------------------------\n  procedure SendAsync (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  Data             : in    std_logic_vector ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) ; \n\n\n  -- ========================================================\n  -- SendBurst\n  -- Blocking Send Burst Transaction. \n  -- Param, when present, is an extra parameter used by the verification component\n  -- The UART verification component uses Param for error injection.\n  -- ========================================================\n\n  ------------------------------------------------------------\n  procedure SendBurst (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  NumFifoWords     : in    integer ;\n    constant  Param            : in    std_logic_vector ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) ; \n\n  ------------------------------------------------------------\n  procedure SendBurst (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  NumFifoWords     : in    integer ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) ; \n  \n  ------------------------------------------------------------\n  procedure SendBurstVector (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  VectorOfWords    : in    slv_vector ;\n    constant  Param            : in    std_logic_vector ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) ;\n  \n  ------------------------------------------------------------\n  procedure SendBurstVector (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  VectorOfWords    : in    slv_vector ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) ;\n  \n--  alias SendBurst is SendBurstVector[StreamRecArrayType, slv_vector, std_logic_vector, boolean] ; \n--  alias SendBurst is SendBurstVector[StreamRecArrayType, slv_vector, boolean] ; \n\n  ------------------------------------------------------------\n  procedure SendBurstIncrement (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  FirstWord        : in    std_logic_vector ;\n    constant  NumFifoWords     : in    integer ;\n    constant  Param            : in    std_logic_vector ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) ;\n\n  ------------------------------------------------------------\n  procedure SendBurstIncrement (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  FirstWord        : in    std_logic_vector ;\n    constant  NumFifoWords     : in    integer ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) ;\n\n  ------------------------------------------------------------\n  procedure SendBurstRandom (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  FirstWord        : in    std_logic_vector ;\n    constant  NumFifoWords     : in    integer ;\n    constant  Param            : in    std_logic_vector ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) ;\n\n  ------------------------------------------------------------\n  procedure SendBurstRandom (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  FirstWord        : in    std_logic_vector ;\n    constant  NumFifoWords     : in    integer ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) ;\n\n  ------------------------------------------------------------\n  procedure SendBurstRandom (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  CoverID          : in    CoverageIDType ;\n    constant  NumFifoWords     : in    integer ;\n    constant  FifoWidth        : in    integer ;\n    constant  Param            : in    std_logic_vector ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) ;\n\n  ------------------------------------------------------------\n  procedure SendBurstRandom (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  CoverID          : in    CoverageIDType ;\n    constant  NumFifoWords     : in    integer ;\n    constant  FifoWidth        : in    integer ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) ;\n\n  -- ========================================================\n  -- SendBurstAsync\n  -- Asynchronous / Non-Blocking Send Transaction\n  -- Param, when present, is an extra parameter used by the verification component\n  -- The UART verification component uses Param for error injection. \n  -- ========================================================\n\n  ------------------------------------------------------------\n  procedure SendBurstAsync (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  NumFifoWords     : in    integer ;\n    constant  Param            : in    std_logic_vector ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) ; \n\n  ------------------------------------------------------------\n  procedure SendBurstAsync (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  NumFifoWords     : in    integer ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) ; \n  \n  ------------------------------------------------------------\n  procedure SendBurstVectorAsync (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  VectorOfWords    : in    slv_vector ;\n    constant  Param            : in    std_logic_vector ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) ;\n  \n  ------------------------------------------------------------\n  procedure SendBurstVectorAsync (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  VectorOfWords    : in    slv_vector ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) ;\n  \n--  alias SendBurstAsync is SendBurstVectorAsync[StreamRecArrayType, slv_vector, std_logic_vector, boolean] ; \n--  alias SendBurstAsync is SendBurstVectorAsync[StreamRecArrayType, slv_vector, boolean] ; \n\n  ------------------------------------------------------------\n  procedure SendBurstIncrementAsync (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  FirstWord        : in    std_logic_vector ;\n    constant  NumFifoWords     : in    integer ;\n    constant  Param            : in    std_logic_vector ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) ;\n\n  ------------------------------------------------------------\n  procedure SendBurstIncrementAsync (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  FirstWord        : in    std_logic_vector ;\n    constant  NumFifoWords     : in    integer ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) ;\n\n  ------------------------------------------------------------\n  procedure SendBurstRandomAsync (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  FirstWord        : in    std_logic_vector ;\n    constant  NumFifoWords     : in    integer ;\n    constant  Param            : in    std_logic_vector ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) ;\n\n  ------------------------------------------------------------\n  procedure SendBurstRandomAsync (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  FirstWord        : in    std_logic_vector ;\n    constant  NumFifoWords     : in    integer ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) ;\n  \n  ------------------------------------------------------------\n  procedure SendBurstRandomAsync (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  CoverID          : in    CoverageIDType ;\n    constant  NumFifoWords     : in    integer ;\n    constant  FifoWidth        : in    integer ;\n    constant  Param            : in    std_logic_vector ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) ;\n\n  ------------------------------------------------------------\n  procedure SendBurstRandomAsync (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  CoverID          : in    CoverageIDType ;\n    constant  NumFifoWords     : in    integer ;\n    constant  FifoWidth        : in    integer ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) ;\n\n  -- ========================================================\n  --  Receiver Transactions\n  -- ========================================================\n\n  -- ========================================================\n  -- Get\n  -- Blocking Get Transaction. \n  -- Param, when present, is an extra parameter used by the verification component\n  -- The UART verification component uses Param for received error status.\n  -- ========================================================\n\n  ------------------------------------------------------------\n  procedure Get (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    variable  Data             : out   std_logic_vector ;\n    variable  Param            : out   std_logic_vector ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) ; \n\n  ------------------------------------------------------------\n  procedure Get (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    variable  Data             : out   std_logic_vector ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) ; \n\n\n  -- ========================================================\n  -- TryGet\n  -- Try Get Transaction\n  -- If Data is available, get it and return available TRUE,\n  -- otherwise Return Available FALSE.\n  -- Param, when present, is an extra parameter used by the verification component\n  -- The UART verification component uses Param for received error status.\n  -- ========================================================\n\n  ------------------------------------------------------------\n  procedure TryGet (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    variable  Data             : out   std_logic_vector ;\n    variable  Available        : out   boolean ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) ; \n  \n  ------------------------------------------------------------\n  procedure TryGet (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    variable  Data             : out   std_logic_vector ;\n    variable  Param            : out   std_logic_vector ;\n    variable  Available        : out   boolean ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) ;  \n\n\n  -- ========================================================\n  -- GetBurst\n  -- Blocking Get Burst Transaction. \n  -- Param, when present, is an extra parameter from the verification component\n  -- The UART verification component uses Param for received error status.\n  -- ========================================================\n\n  ------------------------------------------------------------\n  procedure GetBurst (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    variable  NumFifoWords     : inout integer ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) ; \n  \n  ------------------------------------------------------------\n  procedure GetBurst (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    variable  NumFifoWords     : inout integer ;\n    variable  Param            : out   std_logic_vector ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) ;  \n\n  -- ========================================================\n  -- TryGetBurst\n  -- Try Get Burst Transaction\n  -- If Data is available, get it and return available TRUE,\n  -- otherwise Return Available FALSE.\n  -- Param, when present, is an extra parameter used by the verification component\n  -- The UART verification component uses Param for received error status.\n  -- ========================================================\n\n  ------------------------------------------------------------\n  procedure TryGetBurst (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    variable  NumFifoWords     : inout integer ;\n    variable  Available        : out   boolean ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) ; \n  \n  ------------------------------------------------------------\n  procedure TryGetBurst (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    variable  NumFifoWords     : inout integer ;\n    variable  Param            : out   std_logic_vector ;\n    variable  Available        : out   boolean ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) ;  \n\n\n  -- ========================================================\n  -- Check\n  -- Blocking Check Transaction. \n  -- Data is the expected value to be received.\n  -- Param, when present, is an extra parameter used by the verification component\n  -- The UART verification component uses Param for received error status.\n  -- ========================================================\n\n  ------------------------------------------------------------\n  procedure Check (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  Data             : in    std_logic_vector ;\n    constant  Param            : in    std_logic_vector ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) ; \n\n  ------------------------------------------------------------\n  procedure Check (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  Data             : in    std_logic_vector ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) ; \n\n\n  -- ========================================================\n  -- TryCheck\n  -- Try Check Transaction\n  -- If Data is available, check it and return available TRUE,\n  -- otherwise Return Available FALSE.\n  -- Param, when present, is an extra parameter used by the verification component\n  -- The UART verification component uses Param for received error status.\n  -- ========================================================\n\n  ------------------------------------------------------------\n  procedure TryCheck (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  Data             : in    std_logic_vector ;\n    constant  Param            : in    std_logic_vector ;\n    variable  Available        : out   boolean ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) ; \n\n  ------------------------------------------------------------\n  procedure TryCheck (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  Data             : in    std_logic_vector ;\n    variable  Available        : out   boolean ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) ; \n\n  -- ========================================================\n  -- CheckBurst\n  -- Blocking Check Burst Transaction. \n  -- Param, when present, is an extra parameter used by the verification component\n  -- The UART verification component uses Param for checking error injection.\n  -- ========================================================\n  ------------------------------------------------------------\n  procedure CheckBurst (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  NumFifoWords     : in    integer ;\n    constant  Param            : in    std_logic_vector ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) ; \n\n  ------------------------------------------------------------\n  procedure CheckBurst (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  NumFifoWords     : in    integer ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) ; \n\n  ------------------------------------------------------------\n  procedure CheckBurstVector (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  VectorOfWords    : in    slv_vector ;\n    constant  Param            : in    std_logic_vector ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) ;\n  \n  ------------------------------------------------------------\n  procedure CheckBurstVector (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  VectorOfWords    : in    slv_vector ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) ;\n  \n--  alias CheckBurst is CheckBurstVector[StreamRecArrayType, slv_vector, std_logic_vector, boolean] ; \n--  alias CheckBurst is CheckBurstVector[StreamRecArrayType, slv_vector, boolean] ; \n\n  ------------------------------------------------------------\n  procedure CheckBurstIncrement (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  FirstWord        : in    std_logic_vector ;\n    constant  NumFifoWords     : in    integer ;\n    constant  Param            : in    std_logic_vector ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) ;\n\n  ------------------------------------------------------------\n  procedure CheckBurstIncrement (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  FirstWord        : in    std_logic_vector ;\n    constant  NumFifoWords     : in    integer ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) ;\n\n  ------------------------------------------------------------\n  procedure CheckBurstRandom (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  FirstWord        : in    std_logic_vector ;\n    constant  NumFifoWords     : in    integer ;\n    constant  Param            : in    std_logic_vector ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) ;\n\n  ------------------------------------------------------------\n  procedure CheckBurstRandom (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  FirstWord        : in    std_logic_vector ;\n    constant  NumFifoWords     : in    integer ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) ;\n\n  ------------------------------------------------------------\n  procedure CheckBurstRandom (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  CoverID          : in    CoverageIDType ;\n    constant  NumFifoWords     : in    integer ;\n    constant  FifoWidth        : in    integer ;\n    constant  Param            : in    std_logic_vector ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) ;  \n\n  ------------------------------------------------------------\n  procedure CheckBurstRandom (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  CoverID          : in    CoverageIDType ;\n    constant  NumFifoWords     : in    integer ;\n    constant  FifoWidth        : in    integer ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) ;  \n\n  -- ========================================================\n  -- TryCheckBurst\n  -- Try / Non-Blocking Check Burst Transaction\n  -- Param, when present, is an extra parameter used by the verification component\n  -- The UART verification component uses Param for error injection. \n  -- ========================================================\n\n  ------------------------------------------------------------\n  procedure TryCheckBurst (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  NumFifoWords     : in    integer ;\n    constant  Param            : in    std_logic_vector ;\n    variable  Available        : out   boolean ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) ; \n  \n  ------------------------------------------------------------\n  procedure TryCheckBurst (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  NumFifoWords     : in    integer ;\n    variable  Available        : out   boolean ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) ; \n  \n  ------------------------------------------------------------\n  procedure TryCheckBurstVector (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  VectorOfWords    : in    slv_vector ;\n    constant  Param            : in    std_logic_vector ;\n    variable  Available        : out   boolean ;\n    constant  StatusMsgOn      : in    boolean := false\n  )  ;\n  \n  ------------------------------------------------------------\n  procedure TryCheckBurstVector (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  VectorOfWords    : in    slv_vector ;\n    variable  Available        : out   boolean ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) ;\n\n--  alias TryCheckBurst is TryCheckBurstVector[StreamRecArrayType, slv_vector, std_logic_vector, boolean, boolean] ; \n--  alias TryCheckBurst is TryCheckBurstVector[StreamRecArrayType, slv_vector, boolean, boolean] ; \n  \n  ------------------------------------------------------------\n  procedure TryCheckBurstIncrement (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  FirstWord        : in    std_logic_vector ;\n    constant  NumFifoWords     : in    integer ;\n    constant  Param            : in    std_logic_vector ;\n    variable  Available        : out   boolean ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) ;\n\n  ------------------------------------------------------------\n  procedure TryCheckBurstIncrement (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  FirstWord        : in    std_logic_vector ;\n    constant  NumFifoWords     : in    integer ;\n    variable  Available        : out   boolean ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) ;\n\n  ------------------------------------------------------------\n  procedure TryCheckBurstRandom (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  FirstWord        : in    std_logic_vector ;\n    constant  NumFifoWords     : in    integer ;\n    constant  Param            : in    std_logic_vector ;\n    variable  Available        : out   boolean ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) ;\n\n  ------------------------------------------------------------\n  procedure TryCheckBurstRandom (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  FirstWord        : in    std_logic_vector ;\n    constant  NumFifoWords     : in    integer ;\n    variable  Available        : out   boolean ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) ;\n\n  ------------------------------------------------------------\n  procedure TryCheckBurstRandom (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  CoverID          : in    CoverageIDType ;\n    constant  NumFifoWords     : in    integer ;\n    constant  FifoWidth        : in    integer ;\n    constant  Param            : in    std_logic_vector ;\n    variable  Available        : out   boolean ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) ;  \n\n  ------------------------------------------------------------\n  procedure TryCheckBurstRandom (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  CoverID          : in    CoverageIDType ;\n    constant  NumFifoWords     : in    integer ;\n    constant  FifoWidth        : in    integer ;\n    variable  Available        : out   boolean ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) ;  \n\n\n  -- ========================================================\n  --  Pseudo Transactions\n  --  Interact with the record only.\n  -- ========================================================\n  ------------------------------------------------------------\n  procedure ReleaseTransactionRecord (\n  --  Must run on same delta cycle as AcquireTransactionRecord\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer \n  ) ; \n  \n  ------------------------------------------------------------\n  procedure AcquireTransactionRecord (\n  --  Must run on same delta cycle as ReleaseTransactionRecord\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer \n  ) ; \nend package StreamTransactionArrayPkg ;\n\npackage body StreamTransactionArrayPkg is \n\n  ------------------------------------------------------------\n  procedure StreamArrayRequestTransaction (\n  --  Package Local\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer \n  ) is\n  begin\n    case Index is \n      when  0 =>  RequestTransaction(Rdy => TransactionRec( 0).Rdy, Ack => TransactionRec( 0).Ack) ; \n      when  1 =>  RequestTransaction(Rdy => TransactionRec( 1).Rdy, Ack => TransactionRec( 1).Ack) ; \n      when  2 =>  RequestTransaction(Rdy => TransactionRec( 2).Rdy, Ack => TransactionRec( 2).Ack) ; \n      when  3 =>  RequestTransaction(Rdy => TransactionRec( 3).Rdy, Ack => TransactionRec( 3).Ack) ; \n      when  4 =>  RequestTransaction(Rdy => TransactionRec( 4).Rdy, Ack => TransactionRec( 4).Ack) ; \n      when  5 =>  RequestTransaction(Rdy => TransactionRec( 5).Rdy, Ack => TransactionRec( 5).Ack) ; \n      when  6 =>  RequestTransaction(Rdy => TransactionRec( 6).Rdy, Ack => TransactionRec( 6).Ack) ; \n      when  7 =>  RequestTransaction(Rdy => TransactionRec( 7).Rdy, Ack => TransactionRec( 7).Ack) ; \n      when  8 =>  RequestTransaction(Rdy => TransactionRec( 8).Rdy, Ack => TransactionRec( 8).Ack) ; \n      when  9 =>  RequestTransaction(Rdy => TransactionRec( 9).Rdy, Ack => TransactionRec( 9).Ack) ; \n      when 10 =>  RequestTransaction(Rdy => TransactionRec(10).Rdy, Ack => TransactionRec(10).Ack) ; \n      when 11 =>  RequestTransaction(Rdy => TransactionRec(11).Rdy, Ack => TransactionRec(11).Ack) ; \n      when 12 =>  RequestTransaction(Rdy => TransactionRec(12).Rdy, Ack => TransactionRec(12).Ack) ; \n      when 13 =>  RequestTransaction(Rdy => TransactionRec(13).Rdy, Ack => TransactionRec(13).Ack) ; \n      when 14 =>  RequestTransaction(Rdy => TransactionRec(14).Rdy, Ack => TransactionRec(14).Ack) ; \n      when 15 =>  RequestTransaction(Rdy => TransactionRec(15).Rdy, Ack => TransactionRec(15).Ack) ; \n      when 16 =>  RequestTransaction(Rdy => TransactionRec(16).Rdy, Ack => TransactionRec(16).Ack) ; \n      when 17 =>  RequestTransaction(Rdy => TransactionRec(17).Rdy, Ack => TransactionRec(17).Ack) ; \n      when 18 =>  RequestTransaction(Rdy => TransactionRec(18).Rdy, Ack => TransactionRec(18).Ack) ; \n      when 19 =>  RequestTransaction(Rdy => TransactionRec(19).Rdy, Ack => TransactionRec(19).Ack) ; \n      when 20 =>  RequestTransaction(Rdy => TransactionRec(20).Rdy, Ack => TransactionRec(20).Ack) ; \n      when 21 =>  RequestTransaction(Rdy => TransactionRec(21).Rdy, Ack => TransactionRec(21).Ack) ; \n      when 22 =>  RequestTransaction(Rdy => TransactionRec(22).Rdy, Ack => TransactionRec(22).Ack) ; \n      when 23 =>  RequestTransaction(Rdy => TransactionRec(23).Rdy, Ack => TransactionRec(23).Ack) ; \n      when 24 =>  RequestTransaction(Rdy => TransactionRec(24).Rdy, Ack => TransactionRec(24).Ack) ; \n      when 25 =>  RequestTransaction(Rdy => TransactionRec(25).Rdy, Ack => TransactionRec(25).Ack) ; \n      when 26 =>  RequestTransaction(Rdy => TransactionRec(26).Rdy, Ack => TransactionRec(26).Ack) ; \n      when 27 =>  RequestTransaction(Rdy => TransactionRec(27).Rdy, Ack => TransactionRec(27).Ack) ; \n      when 28 =>  RequestTransaction(Rdy => TransactionRec(28).Rdy, Ack => TransactionRec(28).Ack) ; \n      when 29 =>  RequestTransaction(Rdy => TransactionRec(29).Rdy, Ack => TransactionRec(29).Ack) ; \n      when 30 =>  RequestTransaction(Rdy => TransactionRec(30).Rdy, Ack => TransactionRec(30).Ack) ; \n      when 31 =>  RequestTransaction(Rdy => TransactionRec(31).Rdy, Ack => TransactionRec(31).Ack) ; \n      when 32 =>  RequestTransaction(Rdy => TransactionRec(32).Rdy, Ack => TransactionRec(32).Ack) ; \n      when 33 =>  RequestTransaction(Rdy => TransactionRec(33).Rdy, Ack => TransactionRec(33).Ack) ; \n      when 34 =>  RequestTransaction(Rdy => TransactionRec(34).Rdy, Ack => TransactionRec(34).Ack) ; \n      when 35 =>  RequestTransaction(Rdy => TransactionRec(35).Rdy, Ack => TransactionRec(35).Ack) ; \n      when 36 =>  RequestTransaction(Rdy => TransactionRec(36).Rdy, Ack => TransactionRec(36).Ack) ; \n      when 37 =>  RequestTransaction(Rdy => TransactionRec(37).Rdy, Ack => TransactionRec(37).Ack) ; \n      when 38 =>  RequestTransaction(Rdy => TransactionRec(38).Rdy, Ack => TransactionRec(38).Ack) ; \n      when 39 =>  RequestTransaction(Rdy => TransactionRec(39).Rdy, Ack => TransactionRec(39).Ack) ; \n      when 40 =>  RequestTransaction(Rdy => TransactionRec(40).Rdy, Ack => TransactionRec(40).Ack) ; \n      when 41 =>  RequestTransaction(Rdy => TransactionRec(41).Rdy, Ack => TransactionRec(41).Ack) ; \n      when 42 =>  RequestTransaction(Rdy => TransactionRec(42).Rdy, Ack => TransactionRec(42).Ack) ; \n      when 43 =>  RequestTransaction(Rdy => TransactionRec(43).Rdy, Ack => TransactionRec(43).Ack) ; \n      when 44 =>  RequestTransaction(Rdy => TransactionRec(44).Rdy, Ack => TransactionRec(44).Ack) ; \n      when 45 =>  RequestTransaction(Rdy => TransactionRec(45).Rdy, Ack => TransactionRec(45).Ack) ; \n      when 46 =>  RequestTransaction(Rdy => TransactionRec(46).Rdy, Ack => TransactionRec(46).Ack) ; \n      when 47 =>  RequestTransaction(Rdy => TransactionRec(47).Rdy, Ack => TransactionRec(47).Ack) ; \n      when 48 =>  RequestTransaction(Rdy => TransactionRec(48).Rdy, Ack => TransactionRec(48).Ack) ; \n      when 49 =>  RequestTransaction(Rdy => TransactionRec(49).Rdy, Ack => TransactionRec(49).Ack) ; \n      when 50 =>  RequestTransaction(Rdy => TransactionRec(50).Rdy, Ack => TransactionRec(50).Ack) ; \n      when 51 =>  RequestTransaction(Rdy => TransactionRec(51).Rdy, Ack => TransactionRec(51).Ack) ; \n      when 52 =>  RequestTransaction(Rdy => TransactionRec(52).Rdy, Ack => TransactionRec(52).Ack) ; \n      when 53 =>  RequestTransaction(Rdy => TransactionRec(53).Rdy, Ack => TransactionRec(53).Ack) ; \n      when 54 =>  RequestTransaction(Rdy => TransactionRec(54).Rdy, Ack => TransactionRec(54).Ack) ; \n      when 55 =>  RequestTransaction(Rdy => TransactionRec(55).Rdy, Ack => TransactionRec(55).Ack) ; \n      when 56 =>  RequestTransaction(Rdy => TransactionRec(56).Rdy, Ack => TransactionRec(56).Ack) ; \n      when 57 =>  RequestTransaction(Rdy => TransactionRec(57).Rdy, Ack => TransactionRec(57).Ack) ; \n      when 58 =>  RequestTransaction(Rdy => TransactionRec(58).Rdy, Ack => TransactionRec(58).Ack) ; \n      when 59 =>  RequestTransaction(Rdy => TransactionRec(59).Rdy, Ack => TransactionRec(59).Ack) ; \n      when 60 =>  RequestTransaction(Rdy => TransactionRec(60).Rdy, Ack => TransactionRec(60).Ack) ; \n      when 61 =>  RequestTransaction(Rdy => TransactionRec(61).Rdy, Ack => TransactionRec(61).Ack) ; \n      when 62 =>  RequestTransaction(Rdy => TransactionRec(62).Rdy, Ack => TransactionRec(62).Ack) ; \n      when 63 =>  RequestTransaction(Rdy => TransactionRec(63).Rdy, Ack => TransactionRec(63).Ack) ; \n      when 64 =>  RequestTransaction(Rdy => TransactionRec(64).Rdy, Ack => TransactionRec(64).Ack) ; \n      when 65 =>  RequestTransaction(Rdy => TransactionRec(65).Rdy, Ack => TransactionRec(65).Ack) ; \n      when 66 =>  RequestTransaction(Rdy => TransactionRec(66).Rdy, Ack => TransactionRec(66).Ack) ; \n      when 67 =>  RequestTransaction(Rdy => TransactionRec(67).Rdy, Ack => TransactionRec(67).Ack) ; \n      when 68 =>  RequestTransaction(Rdy => TransactionRec(68).Rdy, Ack => TransactionRec(68).Ack) ; \n      when 69 =>  RequestTransaction(Rdy => TransactionRec(69).Rdy, Ack => TransactionRec(69).Ack) ; \n      when 70 =>  RequestTransaction(Rdy => TransactionRec(70).Rdy, Ack => TransactionRec(70).Ack) ; \n      when 71 =>  RequestTransaction(Rdy => TransactionRec(71).Rdy, Ack => TransactionRec(71).Ack) ; \n      when 72 =>  RequestTransaction(Rdy => TransactionRec(72).Rdy, Ack => TransactionRec(72).Ack) ; \n      when 73 =>  RequestTransaction(Rdy => TransactionRec(73).Rdy, Ack => TransactionRec(73).Ack) ; \n      when 74 =>  RequestTransaction(Rdy => TransactionRec(74).Rdy, Ack => TransactionRec(74).Ack) ; \n      when 75 =>  RequestTransaction(Rdy => TransactionRec(75).Rdy, Ack => TransactionRec(75).Ack) ; \n      when 76 =>  RequestTransaction(Rdy => TransactionRec(76).Rdy, Ack => TransactionRec(76).Ack) ; \n      when 77 =>  RequestTransaction(Rdy => TransactionRec(77).Rdy, Ack => TransactionRec(77).Ack) ; \n      when 78 =>  RequestTransaction(Rdy => TransactionRec(78).Rdy, Ack => TransactionRec(78).Ack) ; \n      when 79 =>  RequestTransaction(Rdy => TransactionRec(79).Rdy, Ack => TransactionRec(79).Ack) ; \n      when 80 =>  RequestTransaction(Rdy => TransactionRec(80).Rdy, Ack => TransactionRec(80).Ack) ; \n      when 81 =>  RequestTransaction(Rdy => TransactionRec(81).Rdy, Ack => TransactionRec(81).Ack) ; \n      when 82 =>  RequestTransaction(Rdy => TransactionRec(82).Rdy, Ack => TransactionRec(82).Ack) ; \n      when 83 =>  RequestTransaction(Rdy => TransactionRec(83).Rdy, Ack => TransactionRec(83).Ack) ; \n      when 84 =>  RequestTransaction(Rdy => TransactionRec(84).Rdy, Ack => TransactionRec(84).Ack) ; \n      when 85 =>  RequestTransaction(Rdy => TransactionRec(85).Rdy, Ack => TransactionRec(85).Ack) ; \n      when 86 =>  RequestTransaction(Rdy => TransactionRec(86).Rdy, Ack => TransactionRec(86).Ack) ; \n      when 87 =>  RequestTransaction(Rdy => TransactionRec(87).Rdy, Ack => TransactionRec(87).Ack) ; \n      when 88 =>  RequestTransaction(Rdy => TransactionRec(88).Rdy, Ack => TransactionRec(88).Ack) ; \n      when 89 =>  RequestTransaction(Rdy => TransactionRec(89).Rdy, Ack => TransactionRec(89).Ack) ; \n      when 90 =>  RequestTransaction(Rdy => TransactionRec(90).Rdy, Ack => TransactionRec(90).Ack) ; \n      when 91 =>  RequestTransaction(Rdy => TransactionRec(91).Rdy, Ack => TransactionRec(91).Ack) ; \n      when 92 =>  RequestTransaction(Rdy => TransactionRec(92).Rdy, Ack => TransactionRec(92).Ack) ; \n      when 93 =>  RequestTransaction(Rdy => TransactionRec(93).Rdy, Ack => TransactionRec(93).Ack) ; \n      when 94 =>  RequestTransaction(Rdy => TransactionRec(94).Rdy, Ack => TransactionRec(94).Ack) ; \n      when 95 =>  RequestTransaction(Rdy => TransactionRec(95).Rdy, Ack => TransactionRec(95).Ack) ; \n      when 96 =>  RequestTransaction(Rdy => TransactionRec(96).Rdy, Ack => TransactionRec(96).Ack) ; \n      when 97 =>  RequestTransaction(Rdy => TransactionRec(97).Rdy, Ack => TransactionRec(97).Ack) ; \n      when 98 =>  RequestTransaction(Rdy => TransactionRec(98).Rdy, Ack => TransactionRec(98).Ack) ; \n      when 99 =>  RequestTransaction(Rdy => TransactionRec(99).Rdy, Ack => TransactionRec(99).Ack) ; \n      when 100 =>  RequestTransaction(Rdy => TransactionRec(100).Rdy, Ack => TransactionRec(100).Ack) ; \n      when 101 =>  RequestTransaction(Rdy => TransactionRec(101).Rdy, Ack => TransactionRec(101).Ack) ; \n      when 102 =>  RequestTransaction(Rdy => TransactionRec(102).Rdy, Ack => TransactionRec(102).Ack) ; \n      when 103 =>  RequestTransaction(Rdy => TransactionRec(103).Rdy, Ack => TransactionRec(103).Ack) ; \n      when 104 =>  RequestTransaction(Rdy => TransactionRec(104).Rdy, Ack => TransactionRec(104).Ack) ; \n      when 105 =>  RequestTransaction(Rdy => TransactionRec(105).Rdy, Ack => TransactionRec(105).Ack) ; \n      when 106 =>  RequestTransaction(Rdy => TransactionRec(106).Rdy, Ack => TransactionRec(106).Ack) ; \n      when 107 =>  RequestTransaction(Rdy => TransactionRec(107).Rdy, Ack => TransactionRec(107).Ack) ; \n      when 108 =>  RequestTransaction(Rdy => TransactionRec(108).Rdy, Ack => TransactionRec(108).Ack) ; \n      when 109 =>  RequestTransaction(Rdy => TransactionRec(109).Rdy, Ack => TransactionRec(109).Ack) ; \n      when 110 =>  RequestTransaction(Rdy => TransactionRec(110).Rdy, Ack => TransactionRec(110).Ack) ; \n      when 111 =>  RequestTransaction(Rdy => TransactionRec(111).Rdy, Ack => TransactionRec(111).Ack) ; \n      when 112 =>  RequestTransaction(Rdy => TransactionRec(112).Rdy, Ack => TransactionRec(112).Ack) ; \n      when 113 =>  RequestTransaction(Rdy => TransactionRec(113).Rdy, Ack => TransactionRec(113).Ack) ; \n      when 114 =>  RequestTransaction(Rdy => TransactionRec(114).Rdy, Ack => TransactionRec(114).Ack) ; \n      when 115 =>  RequestTransaction(Rdy => TransactionRec(115).Rdy, Ack => TransactionRec(115).Ack) ; \n      when 116 =>  RequestTransaction(Rdy => TransactionRec(116).Rdy, Ack => TransactionRec(116).Ack) ; \n      when 117 =>  RequestTransaction(Rdy => TransactionRec(117).Rdy, Ack => TransactionRec(117).Ack) ; \n      when 118 =>  RequestTransaction(Rdy => TransactionRec(118).Rdy, Ack => TransactionRec(118).Ack) ; \n      when 119 =>  RequestTransaction(Rdy => TransactionRec(119).Rdy, Ack => TransactionRec(119).Ack) ; \n      when 120 =>  RequestTransaction(Rdy => TransactionRec(120).Rdy, Ack => TransactionRec(120).Ack) ; \n      when 121 =>  RequestTransaction(Rdy => TransactionRec(121).Rdy, Ack => TransactionRec(121).Ack) ; \n      when 122 =>  RequestTransaction(Rdy => TransactionRec(122).Rdy, Ack => TransactionRec(122).Ack) ; \n      when 123 =>  RequestTransaction(Rdy => TransactionRec(123).Rdy, Ack => TransactionRec(123).Ack) ; \n      when 124 =>  RequestTransaction(Rdy => TransactionRec(124).Rdy, Ack => TransactionRec(124).Ack) ; \n      when 125 =>  RequestTransaction(Rdy => TransactionRec(125).Rdy, Ack => TransactionRec(125).Ack) ; \n      when 126 =>  RequestTransaction(Rdy => TransactionRec(126).Rdy, Ack => TransactionRec(126).Ack) ; \n      when 127 =>  RequestTransaction(Rdy => TransactionRec(127).Rdy, Ack => TransactionRec(127).Ack) ; \n      when 128 =>  RequestTransaction(Rdy => TransactionRec(128).Rdy, Ack => TransactionRec(128).Ack) ; \n      when 129 =>  RequestTransaction(Rdy => TransactionRec(129).Rdy, Ack => TransactionRec(129).Ack) ; \n      when others => Alert(\"StreamTransactionArrayPkg: Please extend StreamArrayRequestTransaction to handle \" & to_string(Index) & \" indices\") ; \n    end case ;  \n  end procedure StreamArrayRequestTransaction ; \n\n  -- ========================================================\n  --  Directive Transactions  \n  --  Directive transactions interact with the verification component \n  --  without generating any transactions or interface waveforms.\n  --  Supported by all verification components\n  -- ========================================================\n  ------------------------------------------------------------\n  procedure WaitForTransaction (\n  --  Wait until pending (transmit) or next (receive) transaction(s) complete\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer \n  ) is\n  begin\n    TransactionRec(Index).Operation   <= WAIT_FOR_TRANSACTION ;\n    StreamArrayRequestTransaction(TransactionRec => TransactionRec, Index => Index) ; \n  end procedure WaitForTransaction ; \n\n  ------------------------------------------------------------\n  procedure WaitForClock (\n  -- Wait for NumberOfClocks number of clocks \n  -- relative to the verification component clock\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  WaitCycles       : in    natural := 1\n  ) is\n  begin\n    TransactionRec(Index).Operation   <= WAIT_FOR_CLOCK ;\n    TransactionRec(Index).IntToModel  <= WaitCycles ; \n    StreamArrayRequestTransaction(TransactionRec => TransactionRec, Index => Index) ; \n  end procedure WaitForClock ; \n\n  ------------------------------------------------------------\n  procedure GetTransactionCount (\n  -- Get the number of transactions handled by the model.  \n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    variable  TransactionCount : out   integer \n  ) is\n  begin\n    TransactionRec(Index).Operation   <= GET_TRANSACTION_COUNT ;\n    StreamArrayRequestTransaction(TransactionRec => TransactionRec, Index => Index) ; \n    TransactionCount := TransactionRec(Index).IntFromModel ; \n  end procedure GetTransactionCount ; \n\n  ------------------------------------------------------------\n  procedure GetAlertLogID (\n  -- Get the AlertLogID from the verification component.\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    variable  AlertLogID       : out   AlertLogIDType \n  ) is\n  begin\n    TransactionRec(Index).Operation   <= GET_ALERTLOG_ID ;\n    StreamArrayRequestTransaction(TransactionRec => TransactionRec, Index => Index) ; \n    AlertLogID := AlertLogIDType(TransactionRec(Index).IntFromModel) ; \n  end procedure GetAlertLogID ; \n  \n  ------------------------------------------------------------\n  procedure GetErrorCount (\n  -- Error reporting for testbenches that do not use OSVVM AlertLogPkg\n  -- Returns error count.  If an error count /= 0, also print errors\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    variable  ErrorCount       : out   natural\n  ) is\n    variable  AlertLogID : AlertLogIDType ;\n  begin\n    GetAlertLogID(TransactionRec, Index, AlertLogID) ;\n--    ReportNonZeroAlerts(AlertLogID => AlertLogID) ;\n    ErrorCount := GetAlertCount(AlertLogID => AlertLogID) ;\n  end procedure GetErrorCount ; \n  \n  \n  -- ========================================================\n  --  Set and Get Burst Mode   \n  --  Set Burst Mode for models that do bursting.\n  -- ========================================================\n  ------------------------------------------------------------\n  procedure SetBurstMode (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  OptVal           : in    StreamFifoBurstModeType\n  ) is\n  begin\n    TransactionRec(Index).Operation     <= SET_BURST_MODE ;\n    TransactionRec(Index).IntToModel    <= OptVal ;\n    StreamArrayRequestTransaction(TransactionRec => TransactionRec, Index => Index) ;\n  end procedure SetBurstMode ;\n\n  ------------------------------------------------------------\n  procedure GetBurstMode (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    variable  OptVal           : out   StreamFifoBurstModeType\n  ) is\n  begin\n    TransactionRec(Index).Operation     <= GET_BURST_MODE ;\n    StreamArrayRequestTransaction(TransactionRec => TransactionRec, Index => Index) ;\n    OptVal := TransactionRec(Index).IntFromModel ; \n  end procedure GetBurstMode ;\n\n  ------------------------------------------------------------\n  --  GotBurst   \n  -- Check to see if Read Burst is available\n  ------------------------------------------------------------\n  ------------------------------------------------------------\n  procedure GotBurst (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  NumFifoWords     : in    integer ;\n    variable  Available        : out   boolean\n  ) is\n  begin\n    TransactionRec(Index).Operation   <= GOT_BURST ;\n    -- NumFifoWords not used in all implementations - needed when interface has no burst capability\n    TransactionRec(Index).IntToModel  <= NumFifoWords ; \n    StreamArrayRequestTransaction(TransactionRec => TransactionRec, Index => Index) ;\n    Available := TransactionRec(Index).BoolFromModel ; \n  end procedure GotBurst ;\n\n  -- ========================================================\n  --  Set and Get Model Options  \n  --  Model operations are directive transactions that are  \n  --  used to configure the verification component.  \n  --  They can either be used directly or with a model specific\n  --  wrapper around them - see AXI models for examples.\n  -- ========================================================\n  ------------------------------------------------------------\n  procedure SetModelOptions (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  Option           : in    integer ;\n    constant  OptVal           : in    boolean\n  ) is\n  begin\n    TransactionRec(Index).Operation     <= SET_MODEL_OPTIONS ;\n    TransactionRec(Index).Options       <= Option ;\n    TransactionRec(Index).BoolToModel   <= OptVal ;\n    StreamArrayRequestTransaction(TransactionRec => TransactionRec, Index => Index) ;\n  end procedure SetModelOptions ;\n\n  ------------------------------------------------------------\n  procedure SetModelOptions (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  Option           : in    integer ;\n    constant  OptVal           : in    integer\n  ) is\n  begin\n    TransactionRec(Index).Operation     <= SET_MODEL_OPTIONS ;\n    TransactionRec(Index).Options       <= Option ;\n    TransactionRec(Index).IntToModel    <= OptVal ;\n    StreamArrayRequestTransaction(TransactionRec => TransactionRec, Index => Index) ;\n  end procedure SetModelOptions ;\n\n  ------------------------------------------------------------\n  procedure SetModelOptions (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  Option           : in    integer ;\n    constant  OptVal           : in    std_logic_vector\n  ) is\n  begin\n    TransactionRec(Index).Operation     <= SET_MODEL_OPTIONS ;\n    TransactionRec(Index).Options       <= Option ;\n    TransactionRec(Index).IntToModel    <= to_integer(OptVal) ;\n    StreamArrayRequestTransaction(TransactionRec => TransactionRec, Index => Index) ;\n  end procedure SetModelOptions ;\n  \n  ------------------------------------------------------------\n  procedure SetModelOptions (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  Option           : in    integer ;\n    constant  OptVal           : in    time\n  ) is\n  begin\n    TransactionRec(Index).Operation     <= SET_MODEL_OPTIONS ;\n    TransactionRec(Index).Options       <= Option ;\n    TransactionRec(Index).TimeToModel   <= OptVal ;\n    StreamArrayRequestTransaction(TransactionRec => TransactionRec, Index => Index) ;\n  end procedure SetModelOptions ;\n\n  ------------------------------------------------------------\n  procedure SetModelOptions (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  Option           : in    integer \n  ) is\n  begin\n    TransactionRec(Index).Operation     <= SET_MODEL_OPTIONS ;\n    TransactionRec(Index).Options       <= Option ;\n    -- OptVal handled by Model Specific Package\n    -- TransactionRec(Index).IntToModel    <= to_integer(OptVal) ;\n    StreamArrayRequestTransaction(TransactionRec => TransactionRec, Index => Index) ;\n  end procedure SetModelOptions ;\n\n  ------------------------------------------------------------\n  procedure GetModelOptions (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  Option           : in    integer ;\n    variable  OptVal           : out   boolean\n  ) is\n  begin\n    TransactionRec(Index).Operation     <= GET_MODEL_OPTIONS ;\n    TransactionRec(Index).Options       <= Option ;\n    StreamArrayRequestTransaction(TransactionRec => TransactionRec, Index => Index) ;\n    OptVal := TransactionRec(Index).BoolFromModel    ;\n  end procedure GetModelOptions ;\n\n  ------------------------------------------------------------\n  procedure GetModelOptions (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  Option           : in    integer ;\n    variable  OptVal           : out   integer\n  ) is\n  begin\n    TransactionRec(Index).Operation     <= GET_MODEL_OPTIONS ;\n    TransactionRec(Index).Options       <= Option ;\n    StreamArrayRequestTransaction(TransactionRec => TransactionRec, Index => Index) ;\n    OptVal := TransactionRec(Index).IntFromModel ; \n  end procedure GetModelOptions ;\n\n  ------------------------------------------------------------\n  procedure GetModelOptions (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  Option           : in    integer ;\n    variable  OptVal           : out   std_logic_vector\n  ) is\n  begin\n    TransactionRec(Index).Operation     <= GET_MODEL_OPTIONS ;\n    TransactionRec(Index).Options       <= Option ;\n    StreamArrayRequestTransaction(TransactionRec => TransactionRec, Index => Index) ;\n    OptVal := to_slv(TransactionRec(Index).IntFromModel, OptVal'length) ; \n  end procedure GetModelOptions ;\n  \n  ------------------------------------------------------------\n  procedure GetModelOptions (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  Option           : in    integer ;\n    variable  OptVal           : out   time\n  ) is\n  begin\n    TransactionRec(Index).Operation     <= GET_MODEL_OPTIONS ;\n    TransactionRec(Index).Options       <= Option ;\n    StreamArrayRequestTransaction(TransactionRec => TransactionRec, Index => Index) ;\n    OptVal := TransactionRec(Index).TimeFromModel ; \n  end procedure GetModelOptions ;\n\n  ------------------------------------------------------------\n  procedure GetModelOptions (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  Option           : in    integer \n  ) is\n  begin\n    TransactionRec(Index).Operation     <= GET_MODEL_OPTIONS ;\n    TransactionRec(Index).Options       <= Option ;\n    StreamArrayRequestTransaction(TransactionRec => TransactionRec, Index => Index) ;\n    -- OptVal handled by Model Specific layer overloading\n    -- OptVal := TransactionRec(Index).TimeFromModel ; \n  end procedure GetModelOptions ;\n\n\n  -- ========================================================\n  --  Transmitter Transactions\n  -- ========================================================\n  \n  -- ========================================================\n  -- Send\n  -- Blocking Send Transaction. \n  -- Param, when present, is an extra parameter used by the verification component\n  -- The UART verification component uses Param for error injection.\n  -- ========================================================\n  ------------------------------------------------------------\n  procedure LocalSend (\n  -- Package Local - simplifies the other calls to Send\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  Operation        : in    StreamOperationType ;\n    constant  Data             : in    std_logic_vector ;\n    constant  Param            : in    std_logic_vector ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) is \n    variable LocalParam : std_logic_vector(TransactionRec(Index).ParamToModel'length -1 downto 0) := (others => '-') ;\n  begin\n    LocalParam(Param'length-1 downto 0) := Param ; \n    TransactionRec(Index).Operation     <= Operation ;\n    TransactionRec(Index).DataToModel   <= SafeResize(Data, TransactionRec(Index).DataToModel'length) ; \n    TransactionRec(Index).ParamToModel  <= SafeResize(LocalParam, TransactionRec(Index).ParamToModel'length) ; \n    TransactionRec(Index).IntToModel    <= Data'length ;\n    TransactionRec(Index).BoolToModel   <= StatusMsgOn ; \n    StreamArrayRequestTransaction(TransactionRec => TransactionRec, Index => Index) ; \n  end procedure LocalSend ; \n\n  ------------------------------------------------------------\n  procedure Send (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  Data             : in    std_logic_vector ;\n    constant  Param            : in    std_logic_vector ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) is \n  begin\n    LocalSend(TransactionRec, Index, SEND, Data, Param, StatusMsgOn) ;\n  end procedure Send ; \n\n  ------------------------------------------------------------\n  procedure Send (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  Data             : in    std_logic_vector ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) is \n  begin\n    LocalSend(TransactionRec, Index, SEND, Data, \"\", StatusMsgOn);\n  end procedure Send ; \n\n  -- ========================================================\n  -- SendAsync\n  -- Asynchronous / Non-Blocking Send Transaction\n  -- Param, when present, is an extra parameter used by the verification component\n  -- The UART verification component uses Param for error injection. \n  -- ========================================================\n\n  ------------------------------------------------------------\n  procedure SendAsync (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  Data             : in    std_logic_vector ;\n    constant  Param            : in    std_logic_vector ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) is \n  begin\n    LocalSend(TransactionRec, Index, SEND_ASYNC, Data, Param, StatusMsgOn) ;\n  end procedure SendAsync ; \n\n  ------------------------------------------------------------\n  procedure SendAsync (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  Data             : in    std_logic_vector ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) is \n  begin\n    LocalSend(TransactionRec, Index, SEND_ASYNC, Data, \"\", StatusMsgOn);\n  end procedure SendAsync ; \n\n\n  -- ========================================================\n  -- SendBurst\n  -- Blocking Send Burst Transaction. \n  -- Param, when present, is an extra parameter used by the verification component\n  -- The UART verification component uses Param for error injection.\n  -- ========================================================\n  ------------------------------------------------------------\n  procedure LocalSendBurst (\n  -- Package Local - simplifies the other calls to Send\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  Operation        : in    StreamOperationType ;\n    constant  NumFifoWords     : in    integer ;\n    constant  Param            : in    std_logic_vector ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) is \n    variable LocalParam : std_logic_vector(TransactionRec(Index).ParamToModel'length -1 downto 0) := (others => '-') ;\n  begin\n    LocalParam(Param'length-1 downto 0) := Param ; \n    TransactionRec(Index).Operation     <= Operation ;\n    TransactionRec(Index).IntToModel    <= NumFifoWords ; \n    TransactionRec(Index).ParamToModel  <= SafeResize(LocalParam, TransactionRec(Index).ParamToModel'length) ; \n    TransactionRec(Index).BoolToModel   <= StatusMsgOn ; \n    StreamArrayRequestTransaction(TransactionRec => TransactionRec, Index => Index) ; \n  end procedure LocalSendBurst ; \n\n  ------------------------------------------------------------\n  procedure SendBurst (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  NumFifoWords     : in    integer ;\n    constant  Param            : in    std_logic_vector ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) is \n  begin\n    LocalSendBurst(TransactionRec, Index, SEND_BURST, NumFifoWords, Param, StatusMsgOn) ;\n  end procedure SendBurst ; \n\n  ------------------------------------------------------------\n  procedure SendBurst (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  NumFifoWords     : in    integer ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) is \n  begin\n    LocalSendBurst(TransactionRec, Index, SEND_BURST, NumFifoWords, \"\", StatusMsgOn) ;\n  end procedure SendBurst ; \n\n  ------------------------------------------------------------\n  procedure SendBurstVector (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  VectorOfWords    : in    slv_vector ;\n    constant  Param            : in    std_logic_vector ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) is\n  begin\n    PushBurstVector(TransactionRec(Index).BurstFifo, VectorOfWords) ;\n    LocalSendBurst(TransactionRec, Index, SEND_BURST, VectorOfWords'length, Param, StatusMsgOn) ; \n  end procedure SendBurstVector ;\n  \n  ------------------------------------------------------------\n  procedure SendBurstVector (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  VectorOfWords    : in    slv_vector ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) is\n  begin\n    SendBurstVector(TransactionRec, Index, VectorOfWords, \"\", StatusMsgOn) ; \n  end procedure SendBurstVector ;\n  \n  ------------------------------------------------------------\n  procedure SendBurstIncrement (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  FirstWord        : in    std_logic_vector ;\n    constant  NumFifoWords     : in    integer ;\n    constant  Param            : in    std_logic_vector ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) is\n  begin\n    PushBurstIncrement(TransactionRec(Index).BurstFifo, FirstWord, NumFifoWords) ;\n    LocalSendBurst(TransactionRec, Index, SEND_BURST, NumFifoWords, Param, StatusMsgOn) ; \n  end procedure SendBurstIncrement ;\n  \n  ------------------------------------------------------------\n  procedure SendBurstIncrement (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  FirstWord        : in    std_logic_vector ;\n    constant  NumFifoWords     : in    integer ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) is\n  begin\n    SendBurstIncrement(TransactionRec, Index, FirstWord, NumFifoWords, \"\", StatusMsgOn) ; \n  end procedure SendBurstIncrement ;\n\n  ------------------------------------------------------------\n  procedure SendBurstRandom (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  FirstWord        : in    std_logic_vector ;\n    constant  NumFifoWords     : in    integer ;\n    constant  Param            : in    std_logic_vector ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) is\n  begin\n    PushBurstRandom(TransactionRec(Index).BurstFifo, FirstWord, NumFifoWords) ;\n    LocalSendBurst(TransactionRec, Index, SEND_BURST, NumFifoWords, Param, StatusMsgOn) ; \n  end procedure SendBurstRandom ;\n  \n  ------------------------------------------------------------\n  procedure SendBurstRandom (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  FirstWord        : in    std_logic_vector ;\n    constant  NumFifoWords     : in    integer ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) is\n  begin\n    SendBurstRandom(TransactionRec, Index, FirstWord, NumFifoWords, \"\", StatusMsgOn) ; \n  end procedure SendBurstRandom ;\n\n  ------------------------------------------------------------\n  procedure SendBurstRandom (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  CoverID          : in    CoverageIDType ;\n    constant  NumFifoWords     : in    integer ;\n    constant  FifoWidth        : in    integer ;\n    constant  Param            : in    std_logic_vector ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) is\n  begin\n    PushBurstRandom(TransactionRec(Index).BurstFifo, CoverID, NumFifoWords, FifoWidth) ;\n    LocalSendBurst(TransactionRec, Index, SEND_BURST, NumFifoWords, Param, StatusMsgOn) ; \n  end procedure SendBurstRandom ;  \n\n  ------------------------------------------------------------\n  procedure SendBurstRandom (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  CoverID          : in    CoverageIDType ;\n    constant  NumFifoWords     : in    integer ;\n    constant  FifoWidth        : in    integer ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) is\n  begin\n    SendBurstRandom(TransactionRec, Index, CoverID, NumFifoWords, FifoWidth, \"\", StatusMsgOn) ; \n  end procedure SendBurstRandom ;  \n\n\n  -- ========================================================\n  -- SendBurstAsync\n  -- Asynchronous / Non-Blocking Send Transaction\n  -- Param, when present, is an extra parameter used by the verification component\n  -- The UART verification component uses Param for error injection. \n  -- ========================================================\n\n  ------------------------------------------------------------\n  procedure SendBurstAsync (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  NumFifoWords     : in    integer ;\n    constant  Param            : in    std_logic_vector ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) is \n  begin\n    LocalSendBurst(TransactionRec, Index, SEND_BURST_ASYNC, NumFifoWords, Param, StatusMsgOn) ;\n  end procedure SendBurstAsync ; \n\n  ------------------------------------------------------------\n  procedure SendBurstAsync (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  NumFifoWords     : in    integer ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) is \n  begin\n    LocalSendBurst(TransactionRec, Index, SEND_BURST_ASYNC, NumFifoWords, \"\", StatusMsgOn) ;\n  end procedure SendBurstAsync ; \n\n  ------------------------------------------------------------\n  procedure SendBurstVectorAsync (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  VectorOfWords    : in    slv_vector ;\n    constant  Param            : in    std_logic_vector ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) is\n  begin\n    PushBurstVector(TransactionRec(Index).BurstFifo, VectorOfWords) ;\n    LocalSendBurst(TransactionRec, Index, SEND_BURST_ASYNC, VectorOfWords'length, Param, StatusMsgOn) ; \n  end procedure SendBurstVectorAsync ;\n  \n  ------------------------------------------------------------\n  procedure SendBurstVectorAsync (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  VectorOfWords    : in    slv_vector ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) is\n  begin\n    SendBurstVectorAsync(TransactionRec, Index, VectorOfWords, \"\", StatusMsgOn) ; \n  end procedure SendBurstVectorAsync ;\n  \n  ------------------------------------------------------------\n  procedure SendBurstIncrementAsync (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  FirstWord        : in    std_logic_vector ;\n    constant  NumFifoWords     : in    integer ;\n    constant  Param            : in    std_logic_vector ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) is\n  begin\n    PushBurstIncrement(TransactionRec(Index).BurstFifo, FirstWord, NumFifoWords) ;\n    LocalSendBurst(TransactionRec, Index, SEND_BURST_ASYNC, NumFifoWords, Param, StatusMsgOn) ; \n  end procedure SendBurstIncrementAsync ;\n\n  ------------------------------------------------------------\n  procedure SendBurstIncrementAsync (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  FirstWord        : in    std_logic_vector ;\n    constant  NumFifoWords     : in    integer ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) is\n  begin\n    SendBurstIncrementAsync(TransactionRec, Index, FirstWord, NumFifoWords, \"\", StatusMsgOn) ; \n  end procedure SendBurstIncrementAsync ;\n\n  ------------------------------------------------------------\n  procedure SendBurstRandomAsync (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  FirstWord        : in    std_logic_vector ;\n    constant  NumFifoWords     : in    integer ;\n    constant  Param            : in    std_logic_vector ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) is\n  begin\n    PushBurstRandom(TransactionRec(Index).BurstFifo, FirstWord, NumFifoWords) ;\n    LocalSendBurst(TransactionRec, Index, SEND_BURST_ASYNC, NumFifoWords, Param, StatusMsgOn) ; \n  end procedure SendBurstRandomAsync ;\n\n  ------------------------------------------------------------\n  procedure SendBurstRandomAsync (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  FirstWord        : in    std_logic_vector ;\n    constant  NumFifoWords     : in    integer ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) is\n    variable RV : RandomPType ; \n  begin\n    SendBurstRandomAsync(TransactionRec, Index, FirstWord, NumFifoWords, \"\", StatusMsgOn) ; \n  end procedure SendBurstRandomAsync ;\n\n  ------------------------------------------------------------\n  procedure SendBurstRandomAsync (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  CoverID          : in    CoverageIDType ;\n    constant  NumFifoWords     : in    integer ;\n    constant  FifoWidth        : in    integer ;\n    constant  Param            : in    std_logic_vector ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) is\n  begin\n    PushBurstRandom(TransactionRec(Index).BurstFifo, CoverID, NumFifoWords, FifoWidth) ;\n    LocalSendBurst(TransactionRec, Index, SEND_BURST_ASYNC, NumFifoWords, Param, StatusMsgOn) ; \n  end procedure SendBurstRandomAsync ;  \n\n  ------------------------------------------------------------\n  procedure SendBurstRandomAsync (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  CoverID          : in    CoverageIDType ;\n    constant  NumFifoWords     : in    integer ;\n    constant  FifoWidth        : in    integer ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) is\n  begin\n    SendBurstRandomAsync(TransactionRec, Index, CoverID, NumFifoWords, FifoWidth, \"\", StatusMsgOn) ; \n  end procedure SendBurstRandomAsync ;  \n\n\n  -- ========================================================\n  --  Receiver Transactions\n  -- ========================================================\n\n  -- ========================================================\n  -- Get\n  -- Blocking Get Transaction. \n  -- Param, when present, is an extra parameter used by the verification component\n  -- The UART verification component uses Param for received error status.\n  -- ========================================================\n\n  ------------------------------------------------------------\n  procedure Get (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    variable  Data             : out   std_logic_vector ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) is \n  begin\n    TransactionRec(Index).Operation   <= GET ;\n    TransactionRec(Index).IntToModel  <= Data'length ;\n    TransactionRec(Index).BoolToModel <= StatusMsgOn ;     \n    StreamArrayRequestTransaction(TransactionRec => TransactionRec, Index => Index) ; \n    Data  := SafeResize(TransactionRec(Index).DataFromModel, Data'length) ; \n  end procedure Get ; \n  \n  ------------------------------------------------------------\n  procedure Get (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    variable  Data             : out   std_logic_vector ;\n    variable  Param            : out   std_logic_vector ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) is \n  begin\n    Get(TransactionRec, Index, Data, StatusMsgOn) ;\n    Param := SafeResize(TransactionRec(Index).ParamFromModel, Param'length) ; \n  end procedure Get ;  \n\n  -- ========================================================\n  -- TryGet\n  -- Try Get Transaction\n  -- If Data is available, get it and return available TRUE,\n  -- otherwise Return Available FALSE.\n  -- Param, when present, is an extra parameter used by the verification component\n  -- The UART verification component uses Param for received error status.\n  -- ========================================================\n\n  ------------------------------------------------------------\n  procedure TryGet (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    variable  Data             : out   std_logic_vector ;\n    variable  Available        : out   boolean ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) is \n  begin\n    TransactionRec(Index).Operation   <= TRY_GET ;\n    TransactionRec(Index).IntToModel  <= Data'length ;\n    TransactionRec(Index).BoolToModel <= StatusMsgOn ;     \n    StreamArrayRequestTransaction(TransactionRec => TransactionRec, Index => Index) ; \n    Data      := SafeResize(TransactionRec(Index).DataFromModel, Data'length) ; \n    Available := TransactionRec(Index).BoolFromModel ;\n  end procedure TryGet ; \n  \n  ------------------------------------------------------------\n  procedure TryGet (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    variable  Data             : out   std_logic_vector ;\n    variable  Param            : out   std_logic_vector ;\n    variable  Available        : out   boolean ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) is \n  begin\n    TryGet(TransactionRec, Index, Data, Available, StatusMsgOn) ;\n    Param := SafeResize(TransactionRec(Index).ParamFromModel, Param'length) ; \n  end procedure TryGet ;  \n\n\n  -- ========================================================\n  -- GetBurst\n  -- Blocking Get Burst Transaction. \n  -- Param, when present, is an extra parameter from the verification component\n  -- The UART verification component uses Param for received error status.\n  -- ========================================================\n\n  ------------------------------------------------------------\n  procedure LocalGetBurst (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  NumFifoWords     : in    integer ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) is \n  begin\n    TransactionRec(Index).Operation   <= GET_BURST ;\n    TransactionRec(Index).IntToModel  <= NumFifoWords ;  -- For models without burst framing (like UART)\n    TransactionRec(Index).BoolToModel <= StatusMsgOn ;     \n    StreamArrayRequestTransaction(TransactionRec => TransactionRec, Index => Index) ; \n  end procedure LocalGetBurst ; \n  \n  ------------------------------------------------------------\n  procedure GetBurst (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    variable  NumFifoWords     : inout integer ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) is \n  begin\n    LocalGetBurst(TransactionRec, Index, NumFifoWords, StatusMsgOn) ; \n    NumFifoWords := TransactionRec(Index).IntFromModel ;\n  end procedure GetBurst ; \n  \n  ------------------------------------------------------------\n  procedure GetBurst (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    variable  NumFifoWords     : inout integer ;\n    variable  Param            : out   std_logic_vector ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) is \n  begin\n    LocalGetBurst(TransactionRec, Index, NumFifoWords, StatusMsgOn) ; \n    NumFifoWords := TransactionRec(Index).IntFromModel ;\n    Param := SafeResize(TransactionRec(Index).ParamFromModel, Param'length) ; \n  end procedure GetBurst ;  \n\n  -- ========================================================\n  -- TryGetBurst\n  -- Try Get Burst Transaction\n  -- If Data is available, get it and return available TRUE,\n  -- otherwise Return Available FALSE.\n  -- Param, when present, is an extra parameter used by the verification component\n  -- The UART verification component uses Param for received error status.\n  -- ========================================================\n\n  ------------------------------------------------------------\n  procedure LocalTryGetBurst (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  NumFifoWords     : in    integer ;\n    variable  Available        : out   boolean ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) is \n  begin\n    TransactionRec(Index).Operation   <= TRY_GET_BURST ;\n    TransactionRec(Index).IntToModel  <= NumFifoWords ;  -- For models without burst framing (like UART)\n    TransactionRec(Index).BoolToModel <= StatusMsgOn ;     \n    StreamArrayRequestTransaction(TransactionRec => TransactionRec, Index => Index) ; \n    Available := TransactionRec(Index).BoolFromModel ;\n  end procedure LocalTryGetBurst ; \n\n  ------------------------------------------------------------\n  procedure TryGetBurst (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    variable  NumFifoWords     : inout integer ;\n    variable  Available        : out   boolean ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) is \n  begin\n    LocalTryGetBurst(TransactionRec, Index, NumFifoWords, Available, StatusMsgOn) ;\n    NumFifoWords  := TransactionRec(Index).IntFromModel ;\n  end procedure TryGetBurst ; \n\n  ------------------------------------------------------------\n  procedure TryGetBurst (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    variable  NumFifoWords     : inout integer ;\n    variable  Param            : out   std_logic_vector ;\n    variable  Available        : out   boolean ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) is \n  begin\n    LocalTryGetBurst(TransactionRec, Index, NumFifoWords, Available, StatusMsgOn) ;\n    NumFifoWords  := TransactionRec(Index).IntFromModel ;\n    Param := SafeResize(TransactionRec(Index).ParamFromModel, Param'length) ; \n  end procedure TryGetBurst ;  \n\n\n  -- ========================================================\n  -- Check\n  -- Blocking Get Transaction. \n  -- Data is the expected value to be received.\n  -- Param, when present, is an extra parameter used by the verification component\n  -- The UART verification component uses Param for received error status.\n  -- ========================================================\n\n  ------------------------------------------------------------\n  procedure Check (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  Data             : in    std_logic_vector ;\n    constant  Param            : in    std_logic_vector ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) is \n    variable LocalParam : std_logic_vector(TransactionRec(Index).ParamToModel'length -1 downto 0) := (others => '-') ;\n  begin\n    LocalParam(Param'length-1 downto 0) := Param ; \n    TransactionRec(Index).Operation     <= CHECK ;\n    TransactionRec(Index).DataToModel   <= SafeResize(Data, TransactionRec(Index).DataToModel'length) ; \n    TransactionRec(Index).ParamToModel  <= SafeResize(LocalParam, TransactionRec(Index).ParamToModel'length) ; \n    TransactionRec(Index).IntToModel    <= Data'length ;\n    TransactionRec(Index).BoolToModel   <= StatusMsgOn ;     \n    StreamArrayRequestTransaction(TransactionRec => TransactionRec, Index => Index) ; \n  end procedure Check ; \n\n  ------------------------------------------------------------\n  procedure Check (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  Data             : in    std_logic_vector ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) is \n  begin\n    Check(TransactionRec, Index, Data, \"\", StatusMsgOn) ;\n  end procedure Check ; \n\n\n  -- ========================================================\n  -- TryCheck\n  -- Try Check Transaction\n  -- If Data is available, check it and return available TRUE,\n  -- otherwise Return Available FALSE.\n  -- Param, when present, is an extra parameter used by the verification component\n  -- The UART verification component uses Param for received error status.\n  -- ========================================================\n\n  ------------------------------------------------------------\n  procedure TryCheck (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  Data             : in    std_logic_vector ;\n    constant  Param            : in    std_logic_vector ;\n    variable  Available        : out   boolean ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) is \n    variable LocalParam : std_logic_vector(TransactionRec(Index).ParamToModel'length -1 downto 0) := (others => '-') ;\n  begin\n    LocalParam(Param'length-1 downto 0) := Param ; \n    TransactionRec(Index).Operation     <= TRY_CHECK ;\n    TransactionRec(Index).DataToModel   <= SafeResize(Data, TransactionRec(Index).DataToModel'length) ; \n    TransactionRec(Index).ParamToModel  <= SafeResize(LocalParam, TransactionRec(Index).ParamToModel'length) ; \n    TransactionRec(Index).IntToModel    <= Data'length ;\n    TransactionRec(Index).BoolToModel   <= StatusMsgOn ;     \n    StreamArrayRequestTransaction(TransactionRec => TransactionRec, Index => Index) ; \n    Available := TransactionRec(Index).BoolFromModel ;\n  end procedure TryCheck ; \n\n  ------------------------------------------------------------\n  procedure TryCheck (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  Data             : in    std_logic_vector ;\n    variable  Available        : out   boolean ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) is \n  begin\n    TryCheck(TransactionRec, Index, Data, \"\", Available, StatusMsgOn) ;\n  end procedure TryCheck ; \n\n\n  -- ========================================================\n  -- CheckBurst\n  -- Blocking Check Burst Transaction. \n  -- Param, when present, is an extra parameter used by the verification component\n  -- The UART verification component uses Param for checking error injection.\n  -- ========================================================\n  ------------------------------------------------------------\n  procedure LocalCheckBurst (\n  -- Package Local - simplifies the other calls to Check\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  Operation        : in    StreamOperationType ;\n    constant  NumFifoWords     : in    integer ;\n    constant  Param            : in    std_logic_vector ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) is \n    variable LocalParam : std_logic_vector(TransactionRec(Index).ParamToModel'length -1 downto 0) := (others => '-') ;\n  begin\n    LocalParam(Param'length-1 downto 0) := Param ; \n    TransactionRec(Index).Operation     <= Operation ;\n    TransactionRec(Index).IntToModel    <= NumFifoWords ; \n    TransactionRec(Index).ParamToModel  <= SafeResize(LocalParam, TransactionRec(Index).ParamToModel'length) ; \n    TransactionRec(Index).BoolToModel   <= StatusMsgOn ; \n    StreamArrayRequestTransaction(TransactionRec => TransactionRec, Index => Index) ; \n  end procedure LocalCheckBurst ; \n\n  ------------------------------------------------------------\n  procedure CheckBurst (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  NumFifoWords     : in    integer ;\n    constant  Param            : in    std_logic_vector ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) is \n  begin\n    LocalCheckBurst(TransactionRec, Index, CHECK_BURST, NumFifoWords, Param, StatusMsgOn) ;\n  end procedure CheckBurst ; \n  \n  ------------------------------------------------------------\n  procedure CheckBurst (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  NumFifoWords     : in    integer ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) is \n  begin\n    LocalCheckBurst(TransactionRec, Index, CHECK_BURST, NumFifoWords, \"\", StatusMsgOn) ;\n  end procedure CheckBurst ; \n\n  ------------------------------------------------------------\n  procedure CheckBurstVector (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  VectorOfWords    : in    slv_vector ;\n    constant  Param            : in    std_logic_vector ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) is\n  begin\n    PushBurstVector(TransactionRec(Index).BurstFifo, VectorOfWords) ;\n    LocalCheckBurst(TransactionRec, Index, CHECK_BURST, VectorOfWords'length, Param, StatusMsgOn) ;\n  end procedure CheckBurstVector ;\n  \n  ------------------------------------------------------------\n  procedure CheckBurstVector (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  VectorOfWords    : in    slv_vector ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) is\n  begin\n    CheckBurstVector(TransactionRec, Index, VectorOfWords, \"\", StatusMsgOn) ; \n  end procedure CheckBurstVector ;\n  \n  ------------------------------------------------------------\n  procedure CheckBurstIncrement (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  FirstWord        : in    std_logic_vector ;\n    constant  NumFifoWords     : in    integer ;\n    constant  Param            : in    std_logic_vector ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) is\n  begin\n    PushBurstIncrement(TransactionRec(Index).BurstFifo, FirstWord, NumFifoWords) ;\n    LocalCheckBurst(TransactionRec, Index, CHECK_BURST, NumFifoWords, Param, StatusMsgOn) ;\n  end procedure CheckBurstIncrement ;\n\n  ------------------------------------------------------------\n  procedure CheckBurstIncrement (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  FirstWord        : in    std_logic_vector ;\n    constant  NumFifoWords     : in    integer ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) is\n  begin\n    CheckBurstIncrement(TransactionRec, Index, FirstWord, NumFifoWords, \"\", StatusMsgOn) ; \n  end procedure CheckBurstIncrement ;\n\n  ------------------------------------------------------------\n  procedure CheckBurstRandom (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  FirstWord        : in    std_logic_vector ;\n    constant  NumFifoWords     : in    integer ;\n    constant  Param            : in    std_logic_vector ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) is\n  begin\n    PushBurstRandom(TransactionRec(Index).BurstFifo, FirstWord, NumFifoWords) ;\n    LocalCheckBurst(TransactionRec, Index, CHECK_BURST, NumFifoWords, Param, StatusMsgOn) ;\n  end procedure CheckBurstRandom ;\n  \n  ------------------------------------------------------------\n  procedure CheckBurstRandom (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  FirstWord        : in    std_logic_vector ;\n    constant  NumFifoWords     : in    integer ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) is\n  begin\n    CheckBurstRandom(TransactionRec, Index, FirstWord, NumFifoWords, \"\", StatusMsgOn) ; \n  end procedure CheckBurstRandom ;\n\n  ------------------------------------------------------------\n  procedure CheckBurstRandom (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  CoverID          : in    CoverageIDType ;\n    constant  NumFifoWords     : in    integer ;\n    constant  FifoWidth        : in    integer ;\n    constant  Param            : in    std_logic_vector ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) is\n  begin\n    PushBurstRandom(TransactionRec(Index).BurstFifo, CoverID, NumFifoWords, FifoWidth) ;\n    LocalCheckBurst(TransactionRec, Index, CHECK_BURST, NumFifoWords, Param, StatusMsgOn) ;\n  end procedure CheckBurstRandom ;  \n\n  ------------------------------------------------------------\n  procedure CheckBurstRandom (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  CoverID          : in    CoverageIDType ;\n    constant  NumFifoWords     : in    integer ;\n    constant  FifoWidth        : in    integer ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) is\n  begin\n    CheckBurstRandom(TransactionRec, Index, CoverID, NumFifoWords, FifoWidth, \"\", StatusMsgOn) ;\n  end procedure CheckBurstRandom ;  \n\n  -- ========================================================\n  -- TryCheckBurst\n  -- Try / Non-Blocking Check Burst Transaction\n  -- Param, when present, is an extra parameter used by the verification component\n  -- The UART verification component uses Param for error injection. \n  -- ========================================================\n  ------------------------------------------------------------\n  procedure TryCheckBurst (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  NumFifoWords     : in    integer ;\n    constant  Param            : in    std_logic_vector ;\n    variable  Available        : out   boolean ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) is \n  begin\n    LocalCheckBurst(TransactionRec, Index, TRY_CHECK_BURST, NumFifoWords, Param, StatusMsgOn) ;\n    Available := TransactionRec(Index).BoolFromModel ;\n  end procedure TryCheckBurst ; \n\n  ------------------------------------------------------------\n  procedure TryCheckBurst (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  NumFifoWords     : in    integer ;\n    variable  Available        : out   boolean ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) is \n  begin\n    LocalCheckBurst(TransactionRec, Index, TRY_CHECK_BURST, NumFifoWords, \"\", StatusMsgOn) ;\n    Available := TransactionRec(Index).BoolFromModel ;\n  end procedure TryCheckBurst ; \n\n  ------------------------------------------------------------\n  procedure TryCheckBurstVector (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  VectorOfWords    : in    slv_vector ;\n    constant  Param            : in    std_logic_vector ;\n    variable  Available        : out   boolean ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) is\n  begin\n    GotBurst(TransactionRec, Index, VectorOfWords'length, Available) ; \n    if Available then \n      PushBurstVector(TransactionRec(Index).BurstFifo, VectorOfWords) ;\n      LocalCheckBurst(TransactionRec, Index, CHECK_BURST, VectorOfWords'length, Param, StatusMsgOn) ;\n    end if ; \n  end procedure TryCheckBurstVector ;\n    \n  ------------------------------------------------------------\n  procedure TryCheckBurstVector (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  VectorOfWords    : in    slv_vector ;\n    variable  Available        : out   boolean ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) is\n  begin\n    TryCheckBurstVector(TransactionRec, Index, VectorOfWords, \"\", Available, StatusMsgOn) ;\n  end procedure TryCheckBurstVector ;\n  \n  ------------------------------------------------------------\n  procedure TryCheckBurstIncrement (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  FirstWord        : in    std_logic_vector ;\n    constant  NumFifoWords     : in    integer ;\n    constant  Param            : in    std_logic_vector ;\n    variable  Available        : out   boolean ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) is\n  begin\n    GotBurst(TransactionRec, Index, NumFifoWords, Available) ; \n    if Available then\n      PushBurstIncrement(TransactionRec(Index).BurstFifo, FirstWord, NumFifoWords) ;\n      LocalCheckBurst(TransactionRec, Index, CHECK_BURST, NumFifoWords, Param, StatusMsgOn) ;\n    end if ; \n  end procedure TryCheckBurstIncrement ;\n\n  ------------------------------------------------------------\n  procedure TryCheckBurstIncrement (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  FirstWord        : in    std_logic_vector ;\n    constant  NumFifoWords     : in    integer ;\n    variable  Available        : out   boolean ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) is\n  begin\n    TryCheckBurstIncrement(TransactionRec, Index, FirstWord, NumFifoWords, \"\", Available, StatusMsgOn) ; \n  end procedure TryCheckBurstIncrement ;\n\n  ------------------------------------------------------------\n  procedure TryCheckBurstRandom (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  FirstWord        : in    std_logic_vector ;\n    constant  NumFifoWords     : in    integer ;\n    constant  Param            : in    std_logic_vector ;\n    variable  Available        : out   boolean ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) is\n  begin\n    GotBurst(TransactionRec, Index, NumFifoWords, Available) ; \n    if Available then\n      PushBurstRandom(TransactionRec(Index).BurstFifo, FirstWord, NumFifoWords) ;\n      LocalCheckBurst(TransactionRec, Index, CHECK_BURST, NumFifoWords, Param, StatusMsgOn) ;\n    end if ; \n  end procedure TryCheckBurstRandom ;\n\n  ------------------------------------------------------------\n  procedure TryCheckBurstRandom (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  FirstWord        : in    std_logic_vector ;\n    constant  NumFifoWords     : in    integer ;\n    variable  Available        : out   boolean ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) is\n  begin\n    TryCheckBurstRandom(TransactionRec, Index, FirstWord, NumFifoWords, \"\", Available, StatusMsgOn) ; \n  end procedure TryCheckBurstRandom ;\n\n  ------------------------------------------------------------\n  procedure TryCheckBurstRandom (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  CoverID          : in    CoverageIDType ;\n    constant  NumFifoWords     : in    integer ;\n    constant  FifoWidth        : in    integer ;\n    constant  Param            : in    std_logic_vector ;\n    variable  Available        : out   boolean ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) is\n  begin\n    GotBurst(TransactionRec, Index, NumFifoWords, Available) ; \n    if Available then\n      PushBurstRandom(TransactionRec(Index).BurstFifo, CoverID, NumFifoWords, FifoWidth) ;\n      LocalCheckBurst(TransactionRec, Index, CHECK_BURST, NumFifoWords, Param, StatusMsgOn) ;\n    end if ; \n  end procedure TryCheckBurstRandom ;  \n\n  ------------------------------------------------------------\n  procedure TryCheckBurstRandom (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer ;\n    constant  CoverID          : in    CoverageIDType ;\n    constant  NumFifoWords     : in    integer ;\n    constant  FifoWidth        : in    integer ;\n    variable  Available        : out   boolean ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) is\n  begin\n    TryCheckBurstRandom(TransactionRec, Index, CoverID, NumFifoWords, FifoWidth, \"\", Available, StatusMsgOn) ;\n  end procedure TryCheckBurstRandom ;  \n\n  -- ========================================================\n  --  Pseudo Transactions\n  --  Interact with the record only.\n  -- ========================================================\n  ------------------------------------------------------------\n  procedure ReleaseTransactionRecord (\n  --  Must run on same delta cycle as AcquireTransactionRecord\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer \n  ) is\n  begin\n    -- Set everything driven by TestCtrl to type'left (except Rdy)\n    TransactionRec(Index).Rdy           <= RdyType'left ;   \n    TransactionRec(Index).Operation     <= NOT_DRIVEN ;\n    TransactionRec(Index).DataToModel   <= (TransactionRec(Index).DataToModel'range => 'U') ;\n    TransactionRec(Index).ParamToModel  <= (TransactionRec(Index).ParamToModel'range => 'U') ;\n    TransactionRec(Index).IntToModel    <= integer'left ; \n    TransactionRec(Index).BoolToModel   <= boolean'left ; \n    TransactionRec(Index).TimeToModel   <= time'left ; \n    TransactionRec(Index).Options       <= integer'left ;    \n  end procedure ReleaseTransactionRecord ; \n  \n  ------------------------------------------------------------\n  procedure AcquireTransactionRecord (\n  --  Must run on same delta cycle as ReleaseTransactionRecord\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecArrayType ;\n    constant  Index            : in    integer \n  ) is\n  begin\n    -- Start Driving Rdy on next delta cycle with the current value.  \n    TransactionRec(Index).Rdy           <= TransactionRec(Index).Rdy ; \n  end procedure AcquireTransactionRecord ; \n\nend package body StreamTransactionArrayPkg ;","lang":"vhdl"};
processSrcData(g_data);