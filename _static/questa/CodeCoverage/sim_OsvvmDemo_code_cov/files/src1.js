var g_data = {"name":"C:/SynthWorks/Dev/_osvvm/OsvvmLibraries/AXI4/common/src/Axi4ModelPkg.vhd","src":"--\n--  File Name:         Axi4ModelPkg.vhd\n--  Design Unit Name:  Axi4ModelPkg\n--  Revision:          OSVVM MODELS STANDARD VERSION\n--\n--  Maintainer:        Jim Lewis      email:  jim@synthworks.com\n--  Contributor(s):\n--     Jim Lewis      jim@synthworks.com\n--\n--\n--  Description:\n--      Defines procedures to support Valid and Ready handshaking\n--      \n--\n--  Developed by:\n--        SynthWorks Design Inc.\n--        VHDL Training Classes\n--        http://www.SynthWorks.com\n--\n--  Revision History:\n--    Date      Version    Description\n--    03/2022   2022.03    Removed deprecated items\n--    01/2020   2020.01    Updated license notice\n--    09/2017   2017       Initial revision\n--\n--\n--  This file is part of OSVVM.\n--  \n--  Copyright (c) 2017 - 2020 by SynthWorks Design Inc.  \n--  \n--  Licensed under the Apache License, Version 2.0 (the \"License\");\n--  you may not use this file except in compliance with the License.\n--  You may obtain a copy of the License at\n--  \n--      https://www.apache.org/licenses/LICENSE-2.0\n--  \n--  Unless required by applicable law or agreed to in writing, software\n--  distributed under the License is distributed on an \"AS IS\" BASIS,\n--  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n--  See the License for the specific language governing permissions and\n--  limitations under the License.\n--  \nlibrary ieee ; \n  use ieee.std_logic_1164.all ;\n  use ieee.numeric_std.all ;\n  use ieee.numeric_std_unsigned.all ;\n  use ieee.math_real.all ;\n  \nlibrary osvvm ; \n  context osvvm.OsvvmContext ; \n  use osvvm.ScoreboardPkg_slv.all ;\n  \nlibrary osvvm_common ; \n  context osvvm_common.OsvvmCommonContext ;\n    \nuse work.Axi4InterfaceCommonPkg.all ;\nuse work.Axi4InterfacePkg.all ; \n  \npackage Axi4ModelPkg is \n\n  ------------------------------------------------------------\n  function CalculateByteAddress (\n  -- Fetch the address and data the slave sees for a write \n  ------------------------------------------------------------\n    constant Address         : In  std_logic_vector ;\n    constant AddrBitsPerWord : In  integer \n  ) return integer ; \n\n  ------------------------------------------------------------\n  function CalculateBurstLen(\n  ------------------------------------------------------------\n    constant NumBytes       : In  integer ; \n    constant ByteAddress    : In  integer ; \n    constant ByteWidth      : In  integer \n  ) return integer ;\n\n--!!  -- Keep for now\n--!!  ------------------------------------------------------------\n--!!  function CalculateWriteStrobe (\n--!!  ------------------------------------------------------------\n--!!    constant ByteAddr      : In  integer ;\n--!!    constant NumberOfBytes : In  integer ; \n--!!    constant MaxBytes      : In  integer \n--!!  ) return std_logic_vector ; \n\n  ------------------------------------------------------------\n  function CalculateWriteStrobe (\n  ------------------------------------------------------------\n    constant Data          : In  std_logic_vector \n  ) return std_logic_vector ;\n\n  ------------------------------------------------------------\n  function AlignBytesToDataBus (\n  -- Shift Data to Align it. \n  ------------------------------------------------------------\n    constant Data          : In    std_logic_vector ;\n    constant DataWidth     : In    integer ;\n    constant ByteAddr      : In    integer \n  ) return std_logic_vector ; \n\n  ------------------------------------------------------------\n  procedure FilterUndrivenData (\n  ------------------------------------------------------------\n    variable Data          : InOut std_logic_vector ;\n    variable Strb          : In    std_logic_vector ;\n    constant DefaultData   : In    std_logic \n  ) ;\n\n  ------------------------------------------------------------\n  procedure CheckDataIsBytes (\n  -- Check AXI Write Data Width - BYTE and < WordWidth adjusted for ByteAddr \n  ------------------------------------------------------------\n    constant ModelID         : In    AlertLogIDType ; \n    constant DataWidth       : In    integer ;\n    constant MessagePrefix   : In    string  := \"\" ; \n    constant TransferNumber  : In    integer := -1\n  ) ; \n  \n  ------------------------------------------------------------\n  procedure CheckDataWidth (\n  -- Check AXI Write Data Width - BYTE and < WordWidth adjusted for ByteAddr \n  ------------------------------------------------------------\n    constant ModelID         : In    AlertLogIDType ; \n    constant DataWidth       : In    integer ; \n    constant ByteAddr        : In    integer ;\n    constant MaxDataBits     : In    integer ;\n    constant MessagePrefix   : In    string  := \"\" ; \n    constant TransferNumber  : In    integer := -1\n  ) ;\n\n  ------------------------------------------------------------\n  procedure PopWriteBurstData (\n  ------------------------------------------------------------\n    constant WriteBurstFifo  : In    osvvm.ScoreboardPkg_slv.ScoreboardIdType ;\n    constant BurstFifoMode   : In    AddressBusFifoBurstModeType ;\n    variable WriteData       : InOut std_logic_vector ;\n    variable WriteStrb       : InOut std_logic_vector ;\n    variable BytesToSend     : InOut integer ; \n    constant ByteAddress     : In    integer := 0 \n  ) ;\n\n  ------------------------------------------------------------\n  procedure PushReadBurstData (\n  -- Push Burst Data into Byte Burst FIFO.   \n  ------------------------------------------------------------\n    constant ReadBurstFifo  : In    osvvm.ScoreboardPkg_slv.ScoreboardIdType ;\n    constant BurstFifoMode  : In    AddressBusFifoBurstModeType ;\n    variable ReadData       : InOut std_logic_vector ;\n    variable BytesToReceive : InOut integer ; \n    constant ByteAddress    : In    integer := 0 \n  ) ;\n\n-- ====  Older Version Directed FIFO intereaction\n\n  ------------------------------------------------------------\n  procedure PopWriteBurstData (\n  ------------------------------------------------------------\n    variable WriteBurstFifo  : InOut osvvm.ScoreboardPkg_slv.ScoreboardPType ;\n    constant BurstFifoMode   : In    AddressBusFifoBurstModeType ;\n    variable WriteData       : InOut std_logic_vector ;\n    variable WriteStrb       : InOut std_logic_vector ;\n    variable BytesToSend     : InOut integer ; \n    constant ByteAddress     : In    integer := 0 \n  ) ;\n\n  ------------------------------------------------------------\n  procedure PushReadBurstData (\n  -- Push Burst Data into Byte Burst FIFO.   \n  ------------------------------------------------------------\n    variable ReadBurstFifo  : InOut osvvm.ScoreboardPkg_slv.ScoreboardPType ;\n    constant BurstFifoMode  : In    AddressBusFifoBurstModeType ;\n    variable ReadData       : InOut std_logic_vector ;\n    variable BytesToReceive : InOut integer ; \n    constant ByteAddress    : In    integer := 0 \n  ) ;\n  \n  ------------------------------------------------------------\n  function AlignDataBusToBytes (\n  -- Shift Data Right and MASK unused bytes. \n  ------------------------------------------------------------\n    constant Data          : In    std_logic_vector ;\n    constant DataWidth     : In    integer ;\n    constant ByteAddr      : In    integer \n  ) return std_logic_vector ;\n  \nend package Axi4ModelPkg ;\n\n-- /////////////////////////////////////////////////////////////////////////////////////////\n-- /////////////////////////////////////////////////////////////////////////////////////////\n\npackage body Axi4ModelPkg is\n \n  ------------------------------------------------------------\n  function CalculateByteAddress (\n  ------------------------------------------------------------\n    constant Address         : In  std_logic_vector ;\n    constant AddrBitsPerWord : In  integer \n  ) return integer is\n    alias    aAddr         : std_logic_vector(Address'length downto 1) is Address ; \n  begin \n    return to_integer(aAddr(AddrBitsPerWord downto 1) ) ;\n  end function CalculateByteAddress ; \n  \n  ------------------------------------------------------------\n  function CalculateBurstLen(\n  ------------------------------------------------------------\n    constant NumBytes       : In  integer ; \n    constant ByteAddress    : In  integer ; \n    constant ByteWidth      : In  integer \n  ) return integer is\n    variable BytesInFirstTransfer : integer ; \n    variable BytesAfterFirstTransfer : integer ; \n  begin\n    BytesInFirstTransfer := ByteWidth - ByteAddress ; \n    if BytesInFirsttransfer  > NumBytes then\n      return 0 ; -- only one word in transfer\n    else\n      BytesAfterFirstTransfer := NumBytes - BytesInFirstTransfer ;\n      return 0 + integer(ceil(real(BytesAfterFirstTransfer)/real(ByteWidth))) ; \n    end if ; \n  end function CalculateBurstLen ; \n  \n--!! -- Keep for now.   Capability is in AlignBytesToDataBus as it fills RHS with U\n--!!  ------------------------------------------------------------\n--!!  function CalculateWriteStrobe (\n--!!  ------------------------------------------------------------\n--!!    constant ByteAddr      : In  integer ;\n--!!    constant NumberOfBytes : In  integer ; \n--!!    constant MaxBytes      : In  integer \n--!!  ) return std_logic_vector is\n--!!    variable WriteStrobe   : std_logic_vector(MaxBytes downto 1) := (others => '0') ; \n--!!  begin\n--!!    -- Calculate Initial WriteStrobe based on number of bytes\n--!!    WriteStrobe(NumberOfBytes downto 1) := (others => '1') ;\n--!!        \n--!!    -- Adjust WriteStrobe for Address\n--!!    -- replace by sll? WriteStrobe sll ByteAddr \n--!!    return WriteStrobe(MaxBytes - ByteAddr downto 1) & (ByteAddr downto 1 => '0') ;\n--!!  end function CalculateWriteStrobe ; \n  \n  ------------------------------------------------------------\n  function CalculateWriteStrobe (\n  ------------------------------------------------------------\n    constant Data          : In  std_logic_vector \n  ) return std_logic_vector is\n    variable WriteStrobe : std_logic_vector(Data'length/8-1 downto 0) := (others => '0') ; \n    alias aData : std_logic_vector(Data'length-1 downto 0) is Data ; \n  begin\n    for i in WriteStrobe'reverse_range loop\n      if aData(i*8) /= 'U' then \n        WriteStrobe(i) := '1' ;\n      end if ; \n    end loop ;\n    return WriteStrobe ;\n  end function CalculateWriteStrobe ; \n  \n  ------------------------------------------------------------\n  function AlignBytesToDataBus (\n  ------------------------------------------------------------\n    constant Data          : In    std_logic_vector ;\n    constant DataWidth     : In    integer ;\n    constant ByteAddr      : In    integer \n  ) return std_logic_vector is\n    constant DATA_LEFT : integer := Data'length-1 ; \n    alias    aData     : std_logic_vector(DATA_LEFT downto 0) is Data ; \n    variable result    : std_logic_vector(DATA_LEFT downto 0) := (others => 'U') ; \n  begin\n    if DataWidth < Data'length then   \n      Result(DataWidth + ByteAddr*8 - 1 downto ByteAddr*8) := aData(DataWidth-1 downto 0) ;\n      return Result ; \n    else \n      -- Make Bits to the Right of ByteAddr a U\n      Result(DATA_LEFT downto ByteAddr*8) := aData(DATA_LEFT downto ByteAddr*8) ; \n      return Result ; \n    end if ; \n  end function AlignBytesToDataBus ; \n  \n  ------------------------------------------------------------\n  function AlignDataBusToBytes (\n  -- Shift Data Right and MASK unused bytes. \n  ------------------------------------------------------------\n    constant Data          : In    std_logic_vector ;\n    constant DataWidth     : In    integer ;\n    constant ByteAddr      : In    integer \n  ) return std_logic_vector is\n    constant DATA_LEFT : integer := Data'length-1 ; \n    alias    aData         : std_logic_vector(DATA_LEFT downto 0) is Data ; \n    variable Result        : std_logic_vector(DATA_LEFT downto 0) := (others => '0') ; \n  begin\n    if DataWidth < Data'length then  \n      Result(DataWidth-1 downto 0) := aData(DataWidth + ByteAddr*8 - 1 downto ByteAddr*8) ;    \n      return Result ; \n    else\n      -- Make Bits to the Right of ByteAddr a 0\n      Result(DATA_LEFT downto ByteAddr*8) := aData(DATA_LEFT downto ByteAddr*8) ; \n      return Result ; \n    end if ; \n  end function AlignDataBusToBytes ; \n\n  ------------------------------------------------------------\n  procedure FilterUndrivenData (\n  ------------------------------------------------------------\n    variable Data          : InOut std_logic_vector ;\n    variable Strb          : In    std_logic_vector ;\n    constant DefaultData   : In    std_logic \n  ) is\n    alias aData : std_logic_vector(Data'length-1 downto 0) is Data ; \n    alias aStrb : std_logic_vector(Strb'length-1 downto 0) is Strb ; \n  begin\n    for i in aStrb'range loop\n      if aStrb(i) = '0' then \n        aData(i*8+7 downto i*8) := (others => DefaultData) ;\n      end if ; \n    end loop ; \n  end procedure FilterUndrivenData ; \n  \n  ------------------------------------------------------------\n  procedure CheckDataIsBytes (\n  -- Check that DataWidth is byte oriented\n  ------------------------------------------------------------\n    constant ModelID         : In    AlertLogIDType ; \n    constant DataWidth       : In    integer ;\n    constant MessagePrefix   : In    string  := \"\" ; \n    constant TransferNumber  : In    integer := -1\n  ) is\n  begin\n    if DataWidth mod 8 /= 0 then \n      if TransferNumber > 0 then \n        Alert(ModelID, \n          MessagePrefix  &\n          \"Data not on a byte boundary.\" & \n          \"  DataWidth: \" & to_string(DataWidth) & \n          \"  TransferNumber: \" & to_string(TransferNumber), \n          FAILURE) ;\n      else\n        Alert(ModelID, \n          MessagePrefix  &\n          \"Data not on a byte boundary.\" & \n          \"  DataWidth: \" & to_string(DataWidth) , \n          FAILURE) ;\n      end if ; \n    end if ; \n  end procedure CheckDataIsBytes ; \n  \n  ------------------------------------------------------------\n  procedure CheckDataWidth (\n  -- Check AXI Write Data Width - BYTE and < WordWidth adjusted for ByteAddr \n  ------------------------------------------------------------\n    constant ModelID         : In    AlertLogIDType ; \n    constant DataWidth       : In    integer ; \n    constant ByteAddr        : In    integer ;\n    constant MaxDataBits     : In    integer ;\n    constant MessagePrefix   : In    string  := \"\" ; \n    constant TransferNumber  : In    integer := -1\n  ) is\n  begin\n    if DataWidth + ByteAddr*8 > MaxDataBits and DataWidth /= MaxDataBits then\n        AlertIf(ModelID, DataWidth + ByteAddr*8 > MaxDataBits, \n          MessagePrefix  &\n          \"Data length too large.\" & \n          \"  ByteAddr: \" & to_string(ByteAddr) & \" * 8\" & \n          \"  + DataWidth: \" & to_string(DataWidth) & \n          \"  > MaxDataBits: \" & to_string(MaxDataBits) & \n          \"  TransferNumber: \" & to_string(TransferNumber),\n          FAILURE) ;\n      end if ; \n    end procedure CheckDataWidth ; \n\n  ------------------------------------------------------------\n  -- Local\n  procedure PopWriteBurstByteData (\n  ------------------------------------------------------------\n    constant WriteBurstFifo  : In    osvvm.ScoreboardPkg_slv.ScoreboardIdType ;\n    variable WriteData       : InOut std_logic_vector ;\n    variable WriteStrb       : InOut std_logic_vector ;\n    variable BytesToSend     : InOut integer ; \n    constant ByteAddress     : In    integer := 0 \n  ) is\n    constant DataLeft : integer := WriteData'length-1; \n    alias aWriteData : std_logic_vector(DataLeft downto 0) is WriteData ; \n    alias aWriteStrb : std_logic_vector(WriteStrb'length-1 downto 0) is WriteStrb ;\n    variable DataIndex    : integer := ByteAddress * 8 ; \n    variable StrbIndex    : integer := ByteAddress ; \n  begin\n    aWriteData := (others => 'U') ;\n    aWriteStrb := (others => '0') ;\n    -- First Byte is put in right side of word\n    PopByte : while DataIndex <= DataLeft loop  \n      aWriteData(DataIndex+7 downto DataIndex) := Pop(WriteBurstFifo) ; \n      if aWriteData(DataIndex) /= 'U' then \n        aWriteStrb(StrbIndex) := '1' ; \n      end if ; \n      BytesToSend := BytesToSend - 1 ; \n      exit when BytesToSend = 0 ; \n      DataIndex := DataIndex + 8 ; \n      StrbIndex := StrbIndex + 1 ; \n    end loop PopByte ;\n  end procedure PopWriteBurstByteData ; \n\n  ------------------------------------------------------------\n  -- Local\n  procedure PopWriteBurstWordData (\n  ------------------------------------------------------------\n    constant WriteBurstFifo  : In    osvvm.ScoreboardPkg_slv.ScoreboardIdType ;\n    variable WriteData       : InOut std_logic_vector ;\n    variable WriteStrb       : InOut std_logic_vector ;\n    constant ByteAddress     : In    integer := 0 \n  ) is\n    alias aWriteData : std_logic_vector(WriteData'length-1 downto 0) is WriteData ; \n    alias aWriteStrb : std_logic_vector(WriteStrb'length-1 downto 0) is WriteStrb ;\n    variable DataIndex    : integer := 0 ; \n  begin\n    aWriteData := Pop(WriteBurstFifo) ; \n    aWriteStrb := (others => '0') ; \n    \n    for i in 0 to ByteAddress-1 loop \n      aWriteData(DataIndex + 7 downto DataIndex) := (others => 'U') ; \n      DataIndex := DataIndex + 8 ; \n    end loop ; \n    \n    for i in ByteAddress to WriteStrb'length-1 loop \n      if aWriteData(DataIndex) /= 'U' then \n        aWriteStrb(i) := '1' ; \n      end if ; \n      DataIndex := DataIndex + 8 ;\n    end loop ;\n  end procedure PopWriteBurstWordData ; \n  \n  ------------------------------------------------------------\n  procedure PopWriteBurstData (\n  ------------------------------------------------------------\n    constant WriteBurstFifo  : In    osvvm.ScoreboardPkg_slv.ScoreboardIdType ;\n    constant BurstFifoMode   : In    AddressBusFifoBurstModeType ;\n    variable WriteData       : InOut std_logic_vector ;\n    variable WriteStrb       : InOut std_logic_vector ;\n    variable BytesToSend     : InOut integer ; \n    constant ByteAddress     : In    integer := 0 \n  ) is\n  begin\n    case BurstFifoMode is\n      when ADDRESS_BUS_BURST_BYTE_MODE => \n        PopWriteBurstByteData(WriteBurstFifo, WriteData, WriteStrb, BytesToSend, ByteAddress) ;\n        \n      when ADDRESS_BUS_BURST_WORD_MODE => \n        PopWriteBurstWordData(WriteBurstFifo, WriteData, WriteStrb, ByteAddress) ;\n\n      when others => \n        -- Already checked, this should never happen\n        Alert(\"PopWriteBurstData: BurstFifoMode Invalid Mode: \" & to_string(BurstFifoMode), FAILURE) ;\n        \n    end case ; \n  end procedure PopWriteBurstData ; \n\n  ------------------------------------------------------------\n  procedure PushReadBurstByteData (\n  -- Push Burst Data into Byte Burst FIFO.   \n  ------------------------------------------------------------\n    constant ReadBurstFifo  : In    osvvm.ScoreboardPkg_slv.ScoreboardIdType ;\n    variable ReadData       : InOut std_logic_vector ;\n    variable BytesToReceive : InOut integer ; \n    constant ByteAddress    : In    integer := 0 \n  ) is\n    constant DataLeft : integer := ReadData'length-1; \n    alias aReadData : std_logic_vector(DataLeft downto 0) is ReadData ; \n    variable DataIndex    : integer := ByteAddress * 8 ; \n    variable StrbIndex    : integer := ByteAddress ; \n  begin\n    -- First Byte is put in right side of word\n    PushByte : while DataIndex <= DataLeft loop  \n      Push(ReadBurstFifo, aReadData(DataIndex+7 downto DataIndex)) ;\n      BytesToReceive := BytesToReceive - 1 ; \n      exit when BytesToReceive = 0 ; \n      DataIndex := DataIndex + 8 ; \n    end loop PushByte ;\n  end procedure PushReadBurstByteData ; \n\n  ------------------------------------------------------------\n  procedure PushReadBurstData (\n  -- Push Burst Data into Byte Burst FIFO.   \n  ------------------------------------------------------------\n    constant ReadBurstFifo  : In    osvvm.ScoreboardPkg_slv.ScoreboardIdType ;\n    constant BurstFifoMode  : In    AddressBusFifoBurstModeType ;\n    variable ReadData       : InOut std_logic_vector ;\n    variable BytesToReceive : InOut integer ; \n    constant ByteAddress    : In    integer := 0 \n  ) is\n  begin\n    case BurstFifoMode is\n      when ADDRESS_BUS_BURST_BYTE_MODE => \n        PushReadBurstByteData(ReadBurstFifo, ReadData, BytesToReceive, ByteAddress) ;\n        \n      when ADDRESS_BUS_BURST_WORD_MODE => \n        Push(ReadBurstFifo, ReadData) ; \n\n      when others => \n        -- Already checked, this should never happen\n        Alert(\"PushReadBurstData: BurstFifoMode Invalid Mode: \" & to_string(BurstFifoMode), FAILURE) ;\n    end case ; \n  end procedure PushReadBurstData ; \n\n\n-- ====  Older Version Directed FIFO intereaction\n  \n  ------------------------------------------------------------\n  -- Local\n  procedure PopWriteBurstByteData (\n  ------------------------------------------------------------\n    variable WriteBurstFifo  : InOut osvvm.ScoreboardPkg_slv.ScoreboardPType ;\n    variable WriteData       : InOut std_logic_vector ;\n    variable WriteStrb       : InOut std_logic_vector ;\n    variable BytesToSend     : InOut integer ; \n    constant ByteAddress     : In    integer := 0 \n  ) is\n    constant DataLeft : integer := WriteData'length-1; \n    alias aWriteData : std_logic_vector(DataLeft downto 0) is WriteData ; \n    alias aWriteStrb : std_logic_vector(WriteStrb'length-1 downto 0) is WriteStrb ;\n    variable DataIndex    : integer := ByteAddress * 8 ; \n    variable StrbIndex    : integer := ByteAddress ; \n  begin\n    aWriteData := (others => 'U') ;\n    aWriteStrb := (others => '0') ;\n    -- First Byte is put in right side of word\n    PopByte : while DataIndex <= DataLeft loop  \n      aWriteData(DataIndex+7 downto DataIndex) := WriteBurstFifo.Pop ; \n      if aWriteData(DataIndex) /= 'U' then \n        aWriteStrb(StrbIndex) := '1' ; \n      end if ; \n      BytesToSend := BytesToSend - 1 ; \n      exit when BytesToSend = 0 ; \n      DataIndex := DataIndex + 8 ; \n      StrbIndex := StrbIndex + 1 ; \n    end loop PopByte ;\n  end procedure PopWriteBurstByteData ; \n\n  ------------------------------------------------------------\n  -- Local\n  procedure PopWriteBurstWordData (\n  ------------------------------------------------------------\n    variable WriteBurstFifo  : InOut osvvm.ScoreboardPkg_slv.ScoreboardPType ;\n    variable WriteData       : InOut std_logic_vector ;\n    variable WriteStrb       : InOut std_logic_vector ;\n    constant ByteAddress     : In    integer := 0 \n  ) is\n    alias aWriteData : std_logic_vector(WriteData'length-1 downto 0) is WriteData ; \n    alias aWriteStrb : std_logic_vector(WriteStrb'length-1 downto 0) is WriteStrb ;\n    variable DataIndex    : integer := 0 ; \n  begin\n    aWriteData := WriteBurstFifo.pop ; \n    aWriteStrb := (others => '0') ; \n    \n    for i in 0 to ByteAddress-1 loop \n      aWriteData(DataIndex + 7 downto DataIndex) := (others => 'U') ; \n      DataIndex := DataIndex + 8 ; \n    end loop ; \n    \n    for i in ByteAddress to WriteStrb'length-1 loop \n      if aWriteData(DataIndex) /= 'U' then \n        aWriteStrb(i) := '1' ; \n      end if ; \n      DataIndex := DataIndex + 8 ;\n    end loop ;\n  end procedure PopWriteBurstWordData ; \n  \n  ------------------------------------------------------------\n  procedure PopWriteBurstData (\n  ------------------------------------------------------------\n    variable WriteBurstFifo  : InOut osvvm.ScoreboardPkg_slv.ScoreboardPType ;\n    constant BurstFifoMode   : In    AddressBusFifoBurstModeType ;\n    variable WriteData       : InOut std_logic_vector ;\n    variable WriteStrb       : InOut std_logic_vector ;\n    variable BytesToSend     : InOut integer ; \n    constant ByteAddress     : In    integer := 0 \n  ) is\n  begin\n    case BurstFifoMode is\n      when ADDRESS_BUS_BURST_BYTE_MODE => \n        PopWriteBurstByteData(WriteBurstFifo, WriteData, WriteStrb, BytesToSend, ByteAddress) ;\n        \n      when ADDRESS_BUS_BURST_WORD_MODE => \n        PopWriteBurstWordData(WriteBurstFifo, WriteData, WriteStrb, ByteAddress) ;\n\n      when others => \n        -- Already checked, this should never happen\n        Alert(\"PopWriteBurstData: BurstFifoMode Invalid Mode: \" & to_string(BurstFifoMode), FAILURE) ;\n        \n    end case ; \n  end procedure PopWriteBurstData ; \n\n  ------------------------------------------------------------\n  procedure PushReadBurstByteData (\n  -- Push Burst Data into Byte Burst FIFO.   \n  ------------------------------------------------------------\n    variable ReadBurstFifo  : InOut osvvm.ScoreboardPkg_slv.ScoreboardPType ;\n    variable ReadData       : InOut std_logic_vector ;\n    variable BytesToReceive : InOut integer ; \n    constant ByteAddress    : In    integer := 0 \n  ) is\n    constant DataLeft : integer := ReadData'length-1; \n    alias aReadData : std_logic_vector(DataLeft downto 0) is ReadData ; \n    variable DataIndex    : integer := ByteAddress * 8 ; \n    variable StrbIndex    : integer := ByteAddress ; \n  begin\n    -- First Byte is put in right side of word\n    PushByte : while DataIndex <= DataLeft loop  \n      ReadBurstFifo.push(aReadData(DataIndex+7 downto DataIndex)) ;\n      BytesToReceive := BytesToReceive - 1 ; \n      exit when BytesToReceive = 0 ; \n      DataIndex := DataIndex + 8 ; \n    end loop PushByte ;\n  end procedure PushReadBurstByteData ; \n\n  ------------------------------------------------------------\n  procedure PushReadBurstData (\n  -- Push Burst Data into Byte Burst FIFO.   \n  ------------------------------------------------------------\n    variable ReadBurstFifo  : InOut osvvm.ScoreboardPkg_slv.ScoreboardPType ;\n    constant BurstFifoMode  : In    AddressBusFifoBurstModeType ;\n    variable ReadData       : InOut std_logic_vector ;\n    variable BytesToReceive : InOut integer ; \n    constant ByteAddress    : In    integer := 0 \n  ) is\n  begin\n    case BurstFifoMode is\n      when ADDRESS_BUS_BURST_BYTE_MODE => \n        PushReadBurstByteData(ReadBurstFifo, ReadData, BytesToReceive, ByteAddress) ;\n        \n      when ADDRESS_BUS_BURST_WORD_MODE => \n        ReadBurstFifo.Push(ReadData) ; \n\n      when others => \n        -- Already checked, this should never happen\n        Alert(\"PushReadBurstData: BurstFifoMode Invalid Mode: \" & to_string(BurstFifoMode), FAILURE) ;\n    end case ; \n  end procedure PushReadBurstData ; \n\nend package body Axi4ModelPkg ; ","lang":"vhdl"};
processSrcData(g_data);