var g_data = {"name":"C:/SynthWorks/Dev/_osvvm/OsvvmLibraries/osvvm/MemorySupportPkg.vhd","src":"--\n--  File Name:         MemorySupportPkg.vhd\n--  Design Unit Name:  MemorySupportPkg\n--  Revision:          STANDARD VERSION\n--\n--  Maintainer:        Jim Lewis      email:  jim@synthworks.com \n--  Contributor(s):            \n--    Jim Lewis      email:  jim@synthworks.com   \n--\n--  Description\n--    Defines the storage policies: X, NoX, and orig \n--    Supports MemoryGenericPkg\n--    Policies are implemented in instances in MemoryPkg\n--    \n--  Developed for: \n--        SynthWorks Design Inc. \n--        VHDL Training Classes\n--        11898 SW 128th Ave.  Tigard, Or  97223\n--        http://www.SynthWorks.com\n--\n--  Revision History:\n--    Date      Version    Description\n--    08/2022   2022.08    Initial revision\n--\n--\n--  This file is part of OSVVM.\n--  \n--  Copyright (c) 2022 by SynthWorks Design Inc.  \n--  \n--  Licensed under the Apache License, Version 2.0 (the \"License\");\n--  you may not use this file except in compliance with the License.\n--  You may obtain a copy of the License at\n--  \n--      https://www.apache.org/licenses/LICENSE-2.0\n--  \n--  Unless required by applicable law or agreed to in writing, software\n--  distributed under the License is distributed on an \"AS IS\" BASIS,\n--  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n--  See the License for the specific language governing permissions and\n--  limitations under the License.\n--  \n\nlibrary IEEE ; \n  use IEEE.std_logic_1164.all ; \n  use IEEE.numeric_std.all ; \n  use IEEE.numeric_std_unsigned.all ; \n  use IEEE.math_real.all ;\n\n  use work.AlertLogPkg.all ;\n  \npackage MemorySupportPkg is\n\n  subtype MemoryBaseType is integer_vector ; \n\n  -- -----------------------------------------------\n  -- Memory Policy X\n  --   Maintains fidelity of X and U\n  --   Each integer value stores 16 bits of data and 16 bits o X and U\n  --   Bit size unlimited\n  -- \n  subtype  MemoryBaseType_X is integer_vector ;\n  function SizeMemoryBaseType_X(Size : integer) return integer ;  \n  function ToMemoryBaseType_X  (Slv  : std_logic_vector ; Size : integer) return integer_vector ;\n  function FromMemoryBaseType_X(Mem  : integer_vector   ; Size : integer) return std_logic_vector ;\n  function InitMemoryBaseType_X(Size : integer) return integer_vector ; \n\n  -- -----------------------------------------------\n  -- Memory Policy NoX\n  --   X and U are stored as a 0\n  --   Each integer value stores 32 bits of data\n  --   Bit size unlimited\n  --   For larger word widths, uses half storage as X\n  -- \n  subtype  MemoryBaseType_NoX is integer_vector ;\n  function SizeMemoryBaseType_NoX(Size : integer) return integer ;  \n  function ToMemoryBaseType_NoX  (Slv  : std_logic_vector ; Size : integer) return integer_vector ;\n  function FromMemoryBaseType_NoX(Mem  : integer_vector   ; Size : integer) return std_logic_vector ;\n  function InitMemoryBaseType_NoX(Size : integer) return integer_vector ; \n\n  -- -----------------------------------------------\n  -- Memory policy orig \n  --   For backward compatibility only\n  --   upto 31 bits of data\n  --   X or U in any bit and the word becomes X\n  -- \n  subtype  MemoryBaseType_orig is integer_vector ; \n  function SizeMemoryBaseType_orig(Size : integer) return integer ;  \n  function ToMemoryBaseType_orig  (Slv  : std_logic_vector ; Size : integer) return integer_vector ;\n  function FromMemoryBaseType_orig(Mem  : integer_vector   ; Size : integer) return std_logic_vector ;\n  function InitMemoryBaseType_orig(Size : integer) return integer_vector ; \n\nend MemorySupportPkg ;\n\npackage body MemorySupportPkg is \n\n  ------------------------------------------------------------\n  -- Memory Policy X\n  --   Maintains fidelity of X and U\n  --   Each integer value stores 16 bits of data and 16 bits o X and U\n  ------------------------------------------------------------\n  ------------------------------------------------------------\n  function SizeMemoryBaseType_X(Size : integer) return integer is  \n  ------------------------------------------------------------\n  begin\n    return integer(Ceil(real(Size)/16.0)) ; \n  end function SizeMemoryBaseType_X ; \n  \n  ------------------------------------------------------------\n  function ToMemoryBaseType_X(Slv : std_logic_vector ; Size : integer) return integer_vector is \n  ------------------------------------------------------------\n    variable NormalizedSlv : std_logic_vector(Size*16-1 downto 0) ;\n    variable Bits16        : std_logic_vector(15 downto 0) ;\n    variable BitIsX        : std_logic_vector(15 downto 0) ; \n    variable BitVal        : std_logic_vector(15 downto 0) ;\n    variable result        : integer_vector (Size-1 downto 0) ; \n  begin\n    NormalizedSlv := Resize(Slv, Size*16) ; \n    for MemIndex in result'reverse_range loop \n      Bits16 := NormalizedSlv(16*MemIndex+15 downto 16*MemIndex) ;\n      for BitIndex in 0 to 15 loop\n        if Is_X(Bits16(BitIndex)) then \n          BitIsX(BitIndex) := '1' ; \n          BitVal(BitIndex) := '1' when Bits16(BitIndex) = 'U' else '0' ;\n        else \n          BitIsX(BitIndex) := '0' ; \n          BitVal(BitIndex) := Bits16(BitIndex) ;\n        end if ; \n      end loop ; \n      result(MemIndex) := to_integer(signed(BitIsX & BitVal)) ; \n    end loop ;\n    return result ; \n  end function ToMemoryBaseType_X ; \n  \n  ------------------------------------------------------------\n  function FromMemoryBaseType_X(Mem : integer_vector ; Size : integer) return std_logic_vector is \n  ------------------------------------------------------------\n    constant NumIntegers   : integer := Mem'length ; \n    alias    NormalizedMem : integer_vector(NumIntegers-1 downto 0) is Mem ; \n    variable NormalizedSlv : std_logic_vector(NumIntegers*16-1 downto 0) ;\n    variable Bits16        : std_logic_vector(15 downto 0) ;\n    variable BitIsX        : std_logic_vector(15 downto 0) ; \n    variable BitVal        : std_logic_vector(15 downto 0) ;\n  begin\n    for MemIndex in NormalizedMem'reverse_range loop \n      (BitIsX, BitVal) := std_logic_vector(to_signed(NormalizedMem(MemIndex), 32)) ;\n      for BitIndex in 0 to 15 loop\n        if BitIsX(BitIndex) = '1' then \n          Bits16(BitIndex) := 'U' when BitVal(BitIndex) = '1' else 'X' ;\n        else\n          Bits16(BitIndex) := BitVal(BitIndex) ; \n        end if ;      \n      end loop ;\n      NormalizedSlv(16*MemIndex+15 downto 16*MemIndex) := Bits16 ;\n    end loop ; \n    return NormalizedSlv(Size-1 downto 0) ; \n  end function FromMemoryBaseType_X ; \n  \n  ------------------------------------------------------------\n  function InitMemoryBaseType_X(Size : integer) return integer_vector is  \n  ------------------------------------------------------------\n    constant BaseU : integer_vector(0 to Size-1)  := (others => -1) ;\n  begin\n    return BaseU ; \n  end function InitMemoryBaseType_X ; \n  \n\n  ------------------------------------------------------------\n  -- Memory Policy NoX\n  --   X and U are stored as a 0\n  --   Each integer value stores 32 bits of data\n  ------------------------------------------------------------\n  ------------------------------------------------------------\n  function SizeMemoryBaseType_NoX(Size : integer) return integer is  \n  ------------------------------------------------------------\n  begin\n    return integer(Ceil(real(Size)/32.0)) ; \n  end function SizeMemoryBaseType_NoX ; \n  \n  ------------------------------------------------------------\n  function ToMemoryBaseType_NoX(Slv : std_logic_vector ; Size : integer) return integer_vector is \n  ------------------------------------------------------------\n    variable NormalizedSlv : std_logic_vector(Size*32-1 downto 0) ;\n    variable Bits32        : std_logic_vector(31 downto 0) ;\n    variable BitVal        : std_logic_vector(31 downto 0) ;\n    variable result        : integer_vector (Size-1 downto 0) ; \n  begin\n    NormalizedSlv := Resize(Slv, Size*32) ; \n    for MemIndex in result'reverse_range loop \n      Bits32 := NormalizedSlv(32*MemIndex+31 downto 32*MemIndex) ;\n      for BitIndex in 0 to 31 loop\n        if Is_X(Bits32(BitIndex)) then \n          BitVal(BitIndex) := '0' ;\n        else \n          BitVal(BitIndex) := Bits32(BitIndex) ;\n        end if ; \n      end loop ; \n      result(MemIndex) := to_integer(signed(BitVal)) ; \n    end loop ;\n    return result ; \n  end function ToMemoryBaseType_NoX ; \n  \n  ------------------------------------------------------------\n  function FromMemoryBaseType_NoX(Mem : integer_vector ; Size : integer) return std_logic_vector is \n  ------------------------------------------------------------\n    constant NumIntegers   : integer := Mem'length ; \n    alias    NormalizedMem : integer_vector(NumIntegers-1 downto 0) is Mem ; \n    variable NormalizedSlv : std_logic_vector(NumIntegers*32-1 downto 0) ;\n    variable Bits32        : std_logic_vector(31 downto 0) ;\n    variable BitVal        : std_logic_vector(31 downto 0) ;\n  begin\n    for MemIndex in NormalizedMem'reverse_range loop \n      Bits32 := std_logic_vector(to_signed(NormalizedMem(MemIndex), 32)) ;\n      NormalizedSlv(32*MemIndex+31 downto 32*MemIndex) := Bits32 ;\n    end loop ; \n    return NormalizedSlv(Size-1 downto 0) ; \n  end function FromMemoryBaseType_NoX ; \n  \n  ------------------------------------------------------------\n  function InitMemoryBaseType_NoX(Size : integer) return integer_vector is  \n  ------------------------------------------------------------\n    constant BaseU : integer_vector(0 to Size-1)  := (others => 0) ;\n  begin\n    return BaseU ; \n  end function InitMemoryBaseType_NoX ; \n\n\n  ------------------------------------------------------------\n  -- Memory policy orig \n  --   For backward compatibility only\n  --   upto 31 bits of data\n  --   X or U in any bit and the word becomes X\n  ------------------------------------------------------------\n  ------------------------------------------------------------\n  function SizeMemoryBaseType_orig(Size : integer) return integer is  \n  ------------------------------------------------------------\n  begin\n    -- would be better as an alert, but not worth the pain since this is deprecated\n    assert Size < 32 report \"MemoryPkg.MemInit/NewID.  DataWidth = \" & to_string(Size) & \" must be < 32 \" severity FAILURE ; \n    return 1 ; \n  end function SizeMemoryBaseType_orig ; \n\n  ------------------------------------------------------------\n  function ToMemoryBaseType_orig(Slv : std_logic_vector ; Size : integer) return integer_vector is \n  ------------------------------------------------------------\n    variable result : integer ; \n  begin\n    if (Is_X(Slv)) then \n      result := -1 ;\n    else\n      result := to_integer( Slv ) ;\n    end if ;\n    return (1 => result) ; \n  end function ToMemoryBaseType_orig ; \n  \n  ------------------------------------------------------------\n  function FromMemoryBaseType_orig(Mem : integer_vector ; Size : integer) return std_logic_vector is \n  ------------------------------------------------------------\n    variable Data : std_logic_vector(Size-1 downto 0) ; \n  begin\n    if Mem(Mem'left) >= 0 then \n      -- Get the Word from the Array\n      Data := to_slv(Mem(Mem'left), Size) ;\n    elsif Mem(Mem'left) = -1 then \n     -- X in Word, return all X\n      Data := (Data'range => 'X') ;\n    else \n     -- Location Uninitialized, return all X\n      Data := (Data'range => 'U') ;\n    end if ;\n    return Data ; \n  end function FromMemoryBaseType_orig ; \n  \n  ------------------------------------------------------------\n  function InitMemoryBaseType_orig(Size : integer) return integer_vector is  \n  ------------------------------------------------------------\n  begin\n    return (1 => integer'left) ; \n  end function InitMemoryBaseType_orig ; \n \nend MemorySupportPkg ;","lang":"vhdl"};
processSrcData(g_data);