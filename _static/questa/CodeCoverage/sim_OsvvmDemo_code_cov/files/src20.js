var g_data = {"name":"C:/SynthWorks/Dev/_osvvm/OsvvmLibraries/osvvm/MemoryGenericPkg.vhd","src":"--\n--  File Name:         MemoryGenericPkg.vhd\n--  Design Unit Name:  MemoryGenericPkg\n--  Revision:          STANDARD VERSION\n--\n--  Maintainer:        Jim Lewis      email:  jim@synthworks.com \n--  Contributor(s):            \n--     Jim Lewis      email:  jim@synthworks.com   \n--\n--  Description\n--      Package defines a protected type, MemoryPType, and methods  \n--      for efficiently implementing memory data structures\n--    \n--  Developed for: \n--        SynthWorks Design Inc. \n--        VHDL Training Classes\n--        11898 SW 128th Ave.  Tigard, Or  97223\n--        http://www.SynthWorks.com\n--\n--  Revision History:\n--    Date      Version    Description\n--    01/2023   2023.01    Updated address checks in MemRead and MemWrite\n--    11/2022   2022.11    Updated default search to PRIVATE_NAME\n--    08/2022   2022.08    Refactored and added generics for base type\n--    02/2022   2022.02    Updated NewID with ReportMode, Search, PrintParent.   Supports searching for Memory models.\n--    06/2021   2021.06    Updated Data Structure, IDs for new use model, and Wrapper Subprograms\n--    01/2020   2020.01    Updated Licenses to Apache\n--    11/2016   2016.11    Refinement to MemRead to return value, X (if X), U (if not initialized)\n--    01/2016   2016.01    Update for buf.all(buf'left)\n--    06/2015   2015.06    Updated for Alerts, ...\n--    ...       ...        Numerous revisions for VHDL Testbenches and Verification\n--    05/2005   0.1        Initial revision\n--\n--\n--  This file is part of OSVVM.\n--  \n--  Copyright (c) 2005 - 2022 by SynthWorks Design Inc.  \n--  \n--  Licensed under the Apache License, Version 2.0 (the \"License\");\n--  you may not use this file except in compliance with the License.\n--  You may obtain a copy of the License at\n--  \n--      https://www.apache.org/licenses/LICENSE-2.0\n--  \n--  Unless required by applicable law or agreed to in writing, software\n--  distributed under the License is distributed on an \"AS IS\" BASIS,\n--  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n--  See the License for the specific language governing permissions and\n--  limitations under the License.\n--  \n\nuse std.textio.all ;\nlibrary IEEE ; \n  use IEEE.std_logic_1164.all ; \n  use IEEE.numeric_std.all ; \n  use IEEE.numeric_std_unsigned.all ; \n  use IEEE.math_real.all ;\n  \n  use work.TextUtilPkg.all ;\n  use work.TranscriptPkg.all ;  \n  use work.AlertLogPkg.all ;\n  use work.NameStorePkg.all ;\n  use work.ResolutionPkg.all ; \n  \n-- Temporary workaround for MemoryBaseType \n  use work.MemorySupportPkg.MemoryBaseType ;\n\npackage MemoryGenericPkg is\n  generic (\n--    type MemoryBaseType ;\n    function SizeMemoryBaseType(Size : integer) return integer ; -- is <> ;\n    function ToMemoryBaseType  (A : std_logic_vector ; Size : integer) return MemoryBaseType ; -- is <> ;\n    function FromMemoryBaseType(A : MemoryBaseType   ; Size : integer) return std_logic_vector ; -- is <> ;\n    function InitMemoryBaseType(Size : integer) return MemoryBaseType -- is <> \n  ) ;\n  \n  type MemoryIDType is record\n    ID : integer_max ;\n  end record MemoryIDType ; \n  type MemoryIDArrayType is array (integer range <>) of MemoryIDType ;\n\n  constant OSVVM_MEMORY_ALERTLOG_ID : AlertLogIDType := OSVVM_ALERTLOG_ID ;\n  ------------------------------------------------------------\n  impure function NewID (\n    Name                : String ; \n    AddrWidth           : integer ; \n    DataWidth           : integer ; \n    ParentID            : AlertLogIDType          := OSVVM_MEMORY_ALERTLOG_ID ;\n    ReportMode          : AlertLogReportModeType  := ENABLED ; \n    Search              : NameSearchType          := PRIVATE_NAME ;\n    PrintParent         : AlertLogPrintParentType := PRINT_NAME_AND_PARENT\n  ) return MemoryIDType ;\n\n  ------------------------------------------------------------\n  procedure MemWrite ( \n    ID    : MemoryIDType ; \n    Addr  : std_logic_vector ;\n    Data  : std_logic_vector \n  ) ; \n  procedure MemRead (  \n    ID    : in MemoryIDType ;\n    Addr  : in  std_logic_vector ;\n    Data  : out std_logic_vector \n  ) ; \n  impure function MemRead ( \n    ID    : MemoryIDType ; \n    Addr  : std_logic_vector \n  ) return std_logic_vector ; \n\n  ------------------------------------------------------------\n  procedure MemErase (ID : in MemoryIDType); \n  \n  ------------------------------------------------------------\n  impure function GetAlertLogID (ID : in MemoryIDType) return AlertLogIDType ;\n  \n  ------------------------------------------------------------\n  procedure FileReadH (    -- Hexadecimal File Read \n    ID           : MemoryIDType ;\n    FileName     : string ; \n    StartAddr    : std_logic_vector ; \n    EndAddr      : std_logic_vector\n  ) ;\n  procedure FileReadH (\n    ID           : MemoryIDType ;\n    FileName     : string ;  \n    StartAddr    : std_logic_vector\n  ) ;\n  procedure FileReadH (\n    ID           : MemoryIDType ;\n    FileName     : string \n  ) ;\n\n  ------------------------------------------------------------\n  procedure FileReadB (    -- Binary File Read \n    ID           : MemoryIDType ;\n    FileName     : string ; \n    StartAddr    : std_logic_vector ; \n    EndAddr      : std_logic_vector\n  ) ;\n  procedure FileReadB (\n    ID           : MemoryIDType ;\n    FileName     : string ;  \n    StartAddr    : std_logic_vector\n  ) ;\n  procedure FileReadB (\n    ID           : MemoryIDType ;\n    FileName     : string \n  ) ;\n\n  ------------------------------------------------------------\n  procedure FileWriteH (    -- Hexadecimal File Write \n    ID           : MemoryIDType ;\n    FileName     : string ; \n    StartAddr    : std_logic_vector ; \n    EndAddr      : std_logic_vector\n  ) ;\n  procedure FileWriteH (\n    ID           : MemoryIDType ;\n    FileName     : string ;  \n    StartAddr    : std_logic_vector\n  ) ;\n  procedure FileWriteH (\n    ID           : MemoryIDType ;\n    FileName     : string \n  ) ;\n\n  ------------------------------------------------------------\n  procedure FileWriteB (    -- Binary File Write \n    ID           : MemoryIDType ;\n    FileName     : string ; \n    StartAddr    : std_logic_vector ; \n    EndAddr      : std_logic_vector\n  ) ;\n  procedure FileWriteB (\n    ID           : MemoryIDType ;\n    FileName     : string ;  \n    StartAddr    : std_logic_vector\n  ) ;\n  procedure FileWriteB (\n    ID           : MemoryIDType ;\n    FileName     : string \n  ) ;\n\n  type MemoryPType is protected \n  \n    ------------------------------------------------------------\n    impure function NewID (\n      Name                : String ; \n      AddrWidth           : integer ; \n      DataWidth           : integer ; \n      ParentID            : AlertLogIDType          := OSVVM_MEMORY_ALERTLOG_ID ;\n      ReportMode          : AlertLogReportModeType  := ENABLED ; \n      Search              : NameSearchType          := PRIVATE_NAME ;\n      PrintParent         : AlertLogPrintParentType := PRINT_NAME_AND_PARENT\n    ) return integer ;\n\n    ------------------------------------------------------------\n    procedure MemWrite ( \n      ID    : integer ; \n      Addr  : std_logic_vector ;\n      Data  : std_logic_vector \n    ) ; \n    procedure MemRead (  \n      ID    : in integer ;\n      Addr  : in  std_logic_vector ;\n      Data  : out std_logic_vector \n    ) ; \n    impure function MemRead ( \n      ID    : integer ; \n      Addr  : std_logic_vector \n    ) return std_logic_vector ; \n\n    ------------------------------------------------------------\n    procedure MemErase (ID : integer) ; \n    \n    impure function GetAlertLogID (ID : integer) return AlertLogIDType ;\n    \n    ------------------------------------------------------------\n    procedure FileReadH (    -- Hexadecimal File Read \n      ID           : integer ;\n      FileName     : string ; \n      StartAddr    : std_logic_vector ; \n      EndAddr      : std_logic_vector\n    ) ;\n    procedure FileReadH (\n      ID           : integer ;\n      FileName     : string ;  \n      StartAddr    : std_logic_vector\n    ) ;\n    procedure FileReadH (\n      ID           : integer ;\n      FileName     : string \n    ) ;\n\n    ------------------------------------------------------------\n    procedure FileReadB (    -- Binary File Read \n      ID           : integer ;\n      FileName     : string ; \n      StartAddr    : std_logic_vector ; \n      EndAddr      : std_logic_vector\n    ) ;\n    procedure FileReadB (\n      ID           : integer ;\n      FileName     : string ;  \n      StartAddr    : std_logic_vector\n    ) ;\n    procedure FileReadB (\n      ID           : integer ;\n      FileName     : string \n    ) ;\n\n    ------------------------------------------------------------\n    procedure FileWriteH (    -- Hexadecimal File Write \n      ID           : integer ;\n      FileName     : string ; \n      StartAddr    : std_logic_vector ; \n      EndAddr      : std_logic_vector\n    ) ;\n    procedure FileWriteH (\n      ID           : integer ;\n      FileName     : string ;  \n      StartAddr    : std_logic_vector\n    ) ;\n    procedure FileWriteH (\n      ID           : integer ;\n      FileName     : string \n    ) ;\n\n    ------------------------------------------------------------\n    procedure FileWriteB (    -- Binary File Write \n      ID           : integer ;\n      FileName     : string ; \n      StartAddr    : std_logic_vector ; \n      EndAddr      : std_logic_vector\n    ) ;\n    procedure FileWriteB (\n      ID           : integer ;\n      FileName     : string ;  \n      StartAddr    : std_logic_vector\n    ) ;\n    procedure FileWriteB (\n      ID           : integer ;\n      FileName     : string \n    ) ;\n\n    ------------------------------------------------------------\n    -- Destroys the entire data structure\n    -- Usage:  At the end of the simulation to remove all \n    -- memory used by data structure.  \n    -- Note, a normal simulator does this for you.  \n    -- You only need this if the simulator is broken.\n    procedure deallocate ; \n\n    ------------------------------------------------------------\n    -- /////////////////////////////////////////\n    -- Historical Interface\n    --   In the new implementation, these use index 1. \n    --   These are for backward compatibility support\n    -- \n    -- /////////////////////////////////////////\n    ------------------------------------------------------------\n    procedure MemInit ( AddrWidth, DataWidth  : in  integer ) ;\n    \n    ------------------------------------------------------------\n    procedure MemWrite ( Addr, Data  : in  std_logic_vector ) ; \n\n    ------------------------------------------------------------\n    procedure MemRead (  \n      Addr  : in  std_logic_vector ;\n      Data  : out std_logic_vector \n    ) ; \n    impure function MemRead ( Addr  : std_logic_vector ) return std_logic_vector ; \n\n    ------------------------------------------------------------\n    procedure MemErase ; \n    \n    ------------------------------------------------------------\n    procedure SetAlertLogID (A : AlertLogIDType) ;\n    procedure SetAlertLogID (Name : string ; ParentID : AlertLogIDType := OSVVM_MEMORY_ALERTLOG_ID ; CreateHierarchy : Boolean := TRUE) ;    \n    impure function GetAlertLogID return AlertLogIDType ;\n    \n    ------------------------------------------------------------\n    procedure FileReadH (    -- Hexadecimal File Read \n      FileName     : string ; \n      StartAddr    : std_logic_vector ; \n      EndAddr      : std_logic_vector\n    ) ;\n    procedure FileReadH (FileName : string ;  StartAddr : std_logic_vector) ;\n    procedure FileReadH (FileName : string) ; \n\n    ------------------------------------------------------------\n    procedure FileReadB (    -- Binary File Read \n      FileName     : string ; \n      StartAddr    : std_logic_vector ; \n      EndAddr      : std_logic_vector\n    ) ;\n    procedure FileReadB (FileName : string ;  StartAddr : std_logic_vector) ;\n    procedure FileReadB (FileName : string) ; \n\n    ------------------------------------------------------------\n    procedure FileWriteH (    -- Hexadecimal File Write \n      FileName     : string ; \n      StartAddr    : std_logic_vector ; \n      EndAddr      : std_logic_vector\n    ) ;\n    procedure FileWriteH (FileName : string ;  StartAddr : std_logic_vector) ;\n    procedure FileWriteH (FileName : string) ; \n\n    ------------------------------------------------------------\n    procedure FileWriteB (    -- Binary File Write \n      FileName     : string ; \n      StartAddr    : std_logic_vector ; \n      EndAddr      : std_logic_vector\n    ) ;\n    procedure FileWriteB (FileName : string ;  StartAddr : std_logic_vector) ;\n    procedure FileWriteB (FileName : string) ;    \n\n  end protected MemoryPType ;\n\nend MemoryGenericPkg ;\n\npackage body MemoryGenericPkg is \n  constant BLOCK_WIDTH : integer := 10 ; \n\n  type MemoryPType is protected body\n\n    type MemBlockType      is array (integer range <>) of MemoryBaseType ;\n    type MemBlockPtrType   is access MemBlockType ;\n    type MemArrayType      is array (integer range <>) of MemBlockPtrType ;\n    type MemArrayPtrType   is access MemArrayType ; \n    \n    type FileFormatType is (BINARY, HEX) ; \n        \n    type MemStructType is record\n      MemArrayPtr         : MemArrayPtrType ; \n      AddrWidth           : integer ;\n      DataWidth           : natural ;\n      BlockWidth          : natural ; \n      MemoryBaseTypeWidth : natural ; \n      AlertLogID          : AlertLogIDType ; \n    end record MemStructType ; \n    \n    -- New Structure\n    type     ItemArrayType    is array (integer range <>) of MemStructType ; \n    type     ItemArrayPtrType is access ItemArrayType ;\n    \n    variable Template         : ItemArrayType(1 to 1) := (1 => (NULL, -1, 1, 0, 0, OSVVM_MEMORY_ALERTLOG_ID)) ;  -- Work around for QS 2020.04 and 2021.02\n    constant MEM_STRUCT_PTR_LEFT : integer := Template'left ; \n    variable MemStructPtr     : ItemArrayPtrType := new ItemArrayType'(Template) ;   \n    variable NumItems         : integer := 0 ; \n--    constant MIN_NUM_ITEMS    : integer := 4 ; -- Temporarily small for testing\n    constant MIN_NUM_ITEMS    : integer := 32 ; -- Min amount to resize array\n    variable LocalNameStore   : NameStorePType ; \n    \n    ------------------------------------------------------------\n    -- Package Local\n    function NormalizeArraySize( NewNumItems, MinNumItems : integer ) return integer is\n    ------------------------------------------------------------\n      variable NormNumItems : integer := NewNumItems ;\n      variable ModNumItems  : integer := 0;\n    begin\n      ModNumItems := NewNumItems mod MinNumItems ; \n      if ModNumItems > 0 then \n        NormNumItems := NormNumItems + (MinNumItems - ModNumItems) ; \n      end if ; \n      return NormNumItems ; \n    end function NormalizeArraySize ;\n\n    ------------------------------------------------------------\n    -- Package Local\n    procedure GrowNumberItems (\n    ------------------------------------------------------------\n      variable ItemArrayPtr     : InOut ItemArrayPtrType ;\n      variable NumItems         : InOut integer ;\n      constant GrowAmount       : in integer ;\n--      constant NewNumItems      : in integer ;\n--      constant CurNumItems      : in integer ;\n      constant MinNumItems      : in integer \n    ) is\n      variable oldItemArrayPtr  : ItemArrayPtrType ;\n      variable NewNumItems : integer ;\n    begin\n      NewNumItems := NumItems + GrowAmount ;\n      -- Array Allocated in declaration to have a single item, but no items (historical mode)\n      -- if ItemArrayPtr = NULL then\n      --  ItemArrayPtr := new ItemArrayType(1 to NormalizeArraySize(NewNumItems, MinNumItems)) ;\n      -- elsif NewNumItems > ItemArrayPtr'length then\n      if NewNumItems > ItemArrayPtr'length then\n        oldItemArrayPtr := ItemArrayPtr ;\n        ItemArrayPtr := new ItemArrayType(1 to NormalizeArraySize(NewNumItems, MinNumItems)) ;\n        ItemArrayPtr.all(1 to NumItems) := oldItemArrayPtr.all(1 to NumItems) ;\n        deallocate(oldItemArrayPtr) ;\n      end if ;\n      NumItems := NewNumItems ; \n    end procedure GrowNumberItems ;  \n    \n   ------------------------------------------------------------\n    -- PT Local \n    procedure MemInit (ID : integer ;  AddrWidth, DataWidth  : integer ) is\n    ------------------------------------------------------------\n      constant ADJ_BLOCK_WIDTH : integer := minimum(BLOCK_WIDTH, AddrWidth) ;\n    begin\n      if AddrWidth <= 0 then \n        Alert(MemStructPtr(ID).AlertLogID, \"MemoryPkg.MemInit/NewID.  AddrWidth = \" & to_string(AddrWidth) & \" must be > 0.\", FAILURE) ; \n        return ; \n      end if ; \n--      if DataWidth <= 0 or DataWidth > 31 then \n--        Alert(MemStructPtr(ID).AlertLogID, \"MemoryPkg.MemInit/NewID.  DataWidth = \" & to_string(DataWidth) & \" must be > 0 and <= 31.\", FAILURE) ; \n      if DataWidth <= 0 then \n        Alert(MemStructPtr(ID).AlertLogID, \"MemoryPkg.MemInit/NewID.  DataWidth = \" & to_string(DataWidth) & \" must be > 0 \", FAILURE) ; \n        return ; \n      end if ; \n\n      MemStructPtr(ID).AddrWidth           := AddrWidth ; \n      MemStructPtr(ID).DataWidth           := DataWidth ; \n      MemStructPtr(ID).MemoryBaseTypeWidth := SizeMemoryBaseType(DataWidth) ; \n      MemStructPtr(ID).BlockWidth          := ADJ_BLOCK_WIDTH ;\n      MemStructPtr(ID).MemArrayPtr         := new MemArrayType(0 to 2**(AddrWidth-ADJ_BLOCK_WIDTH)-1) ;  \n    end procedure MemInit ;\n    \n    ------------------------------------------------------------\n    impure function NewID (\n    ------------------------------------------------------------\n      Name                : String ; \n      AddrWidth           : integer ; \n      DataWidth           : integer ; \n      ParentID            : AlertLogIDType          := OSVVM_MEMORY_ALERTLOG_ID ;\n      ReportMode          : AlertLogReportModeType  := ENABLED ; \n      Search              : NameSearchType          := PRIVATE_NAME ;\n      PrintParent         : AlertLogPrintParentType := PRINT_NAME_AND_PARENT\n    ) return integer is \n      variable NameID              : integer ; \n      variable ResolvedSearch      : NameSearchType ; \n      variable ResolvedPrintParent : AlertLogPrintParentType ; \n    begin\n      ResolvedSearch      := ResolveSearch     (ParentID /= OSVVM_MEMORY_ALERTLOG_ID, Search) ; \n      ResolvedPrintParent := ResolvePrintParent(ParentID /= OSVVM_MEMORY_ALERTLOG_ID, PrintParent) ; \n      \n      NameID := LocalNameStore.find(Name, ParentID, ResolvedSearch) ; \n\n      -- Share the memory if they match\n      if NameID /= ID_NOT_FOUND.ID then\n        if MemStructPtr(NumItems).MemArrayPtr /= NULL then \n          -- Found ID and structure exists, does structure match?\n          AlertIf(MemStructPtr(NumItems).AlertLogID, AddrWidth /= MemStructPtr(NameID).AddrWidth,  \n            \"NewID: AddrWidth: \" & to_string(AddrWidth) & \" /= Existing AddrWidth: \"  & to_string(MemStructPtr(NameID).AddrWidth), FAILURE);\n          AlertIf(MemStructPtr(NumItems).AlertLogID, DataWidth /= MemStructPtr(NameID).DataWidth,  \n            \"NewID: DataWidth: \" & to_string(DataWidth) & \" /= Existing DataWidth: \"  & to_string(MemStructPtr(NameID).DataWidth), FAILURE);\n          -- NameStore IDs are issued sequentially and match MemoryID\n        else \n          -- Found ID and structure does not exist, Reconstruct Memory\n          MemInit(NameID, AddrWidth, DataWidth) ;\n        end if ; \n        return NameID ; \n        \n      else\n        -- Add New Memory to Structure \n        GrowNumberItems(MemStructPtr, NumItems, GrowAmount => 1, MinNumItems => MIN_NUM_ITEMS) ;\n        -- Create AlertLogID\n        MemStructPtr(NumItems).AlertLogID := NewID(Name, ParentID, ReportMode, ResolvedPrintParent, CreateHierarchy => FALSE) ;\n        -- Construct Memory, Reports agains AlertLogID\n        MemInit(NumItems, AddrWidth, DataWidth) ;\n        -- Add item to NameStore\n        NameID := LocalNameStore.NewID(Name, ParentID, ResolvedSearch) ;\n        -- Check NameStore Index vs MemoryIndex\n        AlertIfNotEqual(MemStructPtr(NumItems).AlertLogID, NameID, NumItems, \"MemoryStore, Check Index of LocalNameStore matches MemoryID\") ;  \n        return NumItems ; \n      end if ;\n    end function NewID ;\n    \n    ------------------------------------------------------------\n    -- PT Local \n    impure function IdOutOfRange(\n    ------------------------------------------------------------\n      constant ID    : in integer ; \n      constant Name  : in string\n    ) return boolean is \n    begin\n      return AlertIf(OSVVM_MEMORY_ALERTLOG_ID, ID < MemStructPtr'Low or ID > MemStructPtr'High, \n         \"MemoryPkg.\" & Name & \" ID: \" & to_string(ID) & \n               \"is not in the range (\" & to_string(MemStructPtr'Low) &\n               \" to \" & to_string(MemStructPtr'High) & \")\",\n         FAILURE ) ;\n    end function IdOutOfRange ; \n\n    ------------------------------------------------------------\n    -- Local\n    -- This is a temporary solution that works around GHDL issues\n    function InitMemoryBlockType(BlockWidth, BaseWidth : integer) return MemBlockType is  \n    ------------------------------------------------------------\n-- This keeps MemoryBaseType from being a generic type\n      constant BaseU : MemoryBaseType(BaseWidth-1 downto 0) := InitMemoryBaseType(BaseWidth) ;\n--!! GHDL Bug     constant BaseU : MemoryBaseType := InitMemoryBaseType(BaseWidth) ;\n    begin\n      return MemBlockType'(0 to 2**BlockWidth-1 => BaseU) ;\n    end function InitMemoryBlockType ; \n\n    ------------------------------------------------------------\n    procedure MemWrite ( \n    ------------------------------------------------------------\n      ID    : integer ; \n      Addr  : std_logic_vector ;\n      Data  : std_logic_vector \n    ) is \n      variable BlockWidth, AddrWidth : integer ;\n      variable MemoryBaseWidth : integer ;\n--      constant BlockWidth : integer := MemStructPtr(ID).BlockWidth;\n      variable BlockAddr, WordAddr  : integer ;\n      alias aAddr : std_logic_vector (Addr'length-1 downto 0) is Addr ; \n--      subtype MemBlockSubType is MemBlockType(0 to 2**BlockWidth-1) ;\n    begin\n      if IdOutOfRange(ID, \"MemWrite\") then \n        return ;\n      end if ; \n      \n      AddrWidth  := MemStructPtr(ID).AddrWidth  ;\n      \n      -- Check Bounds of Address and if memory is initialized\n      if Addr'length > AddrWidth then\n        if (MemStructPtr(ID).MemArrayPtr = NULL) then \n          Alert(MemStructPtr(ID).AlertLogID, \"MemoryPkg.MemWrite:  Memory not initialized, Write Ignored.\", FAILURE) ; \n          return ; \n        elsif aAddr(aAddr'left downto AddrWidth) /= 0 then\n          Alert(MemStructPtr(ID).AlertLogID, \"MemoryPkg.MemWrite:  Address value \" & to_hxstring(Addr) & \" goes beyond memory address width: \" & to_string(MemStructPtr(ID).AddrWidth), FAILURE) ; \n          return ; \n        end if ; \n      end if ; \n\n      -- Check Bounds on Data\n      if Data'length /= MemStructPtr(ID).DataWidth then\n        Alert(MemStructPtr(ID).AlertLogID, \"MemoryPkg.MemWrite:  Data'length: \" & to_string(Data'length) & \" /= Memory Data Width: \" & to_string(MemStructPtr(ID).DataWidth), FAILURE) ; \n        return ; \n      end if ; \n\n      if is_X( Addr ) then\n        Alert(MemStructPtr(ID).AlertLogID, \"MemoryPkg.MemWrite:  Address X, Write Ignored.\") ; \n        return ;\n      end if ; \n\n      BlockWidth := MemStructPtr(ID).BlockWidth ; \n\n      -- Slice out upper address to form block address\n      if aAddr'high >= BlockWidth then\n        BlockAddr := to_integer(aAddr(aAddr'high downto BlockWidth)) ;\n      else\n        BlockAddr  := 0 ; \n      end if ; \n\n      MemoryBaseWidth := MemStructPtr(ID).MemoryBaseTypeWidth ; \n\n      -- If empty, allocate a memory block\n      if (MemStructPtr(ID).MemArrayPtr(BlockAddr) = NULL) then \n        MemStructPtr(ID).MemArrayPtr(BlockAddr) := new \n            MemBlockType'(InitMemoryBlockType(BlockWidth, MemoryBaseWidth)) ;\n\n-- Long term, we need the first one to allow transition of MemoryBaseType to a generic.\n--!! GHDL Bug        MemStructPtr(ID).MemArrayPtr(BlockAddr) := new \n--!! GHDL Bug            MemBlockType'(0 to 2**BlockWidth-1 =>  InitMemoryBaseType(MemoryBaseWidth) ) ;\n--        MemStructPtr(ID).MemArrayPtr(BlockAddr) := new \n--          MemBlockType(0 to 2**BlockWidth-1)(MemoryBaseWidth-1 downto 0) ;\n--!! GHDL Bug        MemStructPtr(ID).MemArrayPtr(BlockAddr).all := (0 to 2**BlockWidth-1 => InitMemoryBaseType(MemoryBaseWidth));\n      end if ; \n\n      -- Address of a word within a block\n      WordAddr  := to_integer(aAddr(BlockWidth -1 downto 0)) ;\n\n      -- Write to BlockAddr, WordAddr\n      MemStructPtr(ID).MemArrayPtr(BlockAddr)(WordAddr) := ToMemoryBaseType(Data, MemoryBaseWidth) ;\n    end procedure MemWrite ; \n\n    ------------------------------------------------------------\n    procedure MemRead (  \n    ------------------------------------------------------------\n      ID    : in integer ;\n      Addr  : in  std_logic_vector ;\n      Data  : out std_logic_vector \n    ) is\n      variable BlockWidth, AddrWidth : integer ;\n      variable BlockAddr, WordAddr  : integer ;\n      alias aAddr : std_logic_vector (Addr'length-1 downto 0) is Addr ; \n    begin\n      if IdOutOfRange(ID, \"MemRead\") then \n        return ;\n      end if ; \n      \n      AddrWidth := MemStructPtr(ID).AddrWidth ;\n\n      -- Check Bounds of Address and if memory is initialized\n      if Addr'length > AddrWidth then\n        Data := (Data'range => 'U') ; \n        if (MemStructPtr(ID).MemArrayPtr = NULL) then \n          Alert(MemStructPtr(ID).AlertLogID, \"MemoryPkg.MemRead:  Memory not initialized. Returning U\", FAILURE) ; \n          return ; \n        elsif aAddr(aAddr'left downto AddrWidth) /= 0 then\n          Alert(MemStructPtr(ID).AlertLogID, \"MemoryPkg.MemRead:  Address value \" & to_hxstring(Addr) & \" goes beyond memory address width: \" & to_string(MemStructPtr(ID).AddrWidth), FAILURE) ; \n          return ; \n        end if ; \n      end if ; \n      \n      -- Check Bounds on Data\n      if Data'length /= MemStructPtr(ID).DataWidth then\n        Alert(MemStructPtr(ID).AlertLogID, \"MemoryPkg.MemRead:  Data'length: \" & to_string(Data'length) & \" /= Memory Data Width: \" & to_string(MemStructPtr(ID).DataWidth), FAILURE) ; \n        Data := (Data'range => 'U') ; \n        return ; \n      end if ; \n\n      -- If Addr X, data = X\n      if is_X( aAddr ) then\n        Data := (Data'range => 'X') ; \n        return ; \n      end if ; \n\n      BlockWidth := MemStructPtr(ID).BlockWidth ;\n\n      -- Slice out upper address to form block address\n      if aAddr'high >= BlockWidth then\n        BlockAddr := to_integer(aAddr(aAddr'high downto BlockWidth)) ;\n      else\n        BlockAddr  := 0 ; \n      end if ; \n      \n      -- Empty Block, return all U\n      if (MemStructPtr(ID).MemArrayPtr(BlockAddr) = NULL) then \n        Data := (Data'range => 'U') ; \n        return ; \n      end if ; \n\n      -- Address of a word within a block\n      WordAddr := to_integer(aAddr(BlockWidth -1 downto 0)) ;\n      \n      Data := FromMemoryBaseType(MemStructPtr(ID).MemArrayPtr(BlockAddr)(WordAddr), Data'length) ; \n\n    end procedure MemRead ; \n\n    ------------------------------------------------------------\n    impure function MemRead ( \n      ID    : integer ; \n      Addr  : std_logic_vector \n    ) return std_logic_vector is\n    ------------------------------------------------------------\n      constant ID_CHECK_OK : boolean := IdOutOfRange(ID, \"MemRead function\") ;\n      constant DATA_WIDTH : integer := MemStructPtr(ID).DataWidth ; \n      variable Data  : std_logic_vector(DATA_WIDTH-1 downto 0) ; \n    begin\n      MemRead(ID, Addr, Data) ; \n      return Data ; \n    end function MemRead ; \n\n    ------------------------------------------------------------\n    procedure MemErase(ID : integer) is \n    -- Erase the memory, but not the array of pointers\n    ------------------------------------------------------------\n    begin\n      if IdOutOfRange(ID, \"MemErase\") then \n        return ;\n      end if ; \n\n      for BlockAddr in MemStructPtr(ID).MemArrayPtr'range loop \n        if (MemStructPtr(ID).MemArrayPtr(BlockAddr) /= NULL) then \n          deallocate (MemStructPtr(ID).MemArrayPtr(BlockAddr)) ; \n        end if ; \n      end loop ; \n    end procedure ; \n    \n    ------------------------------------------------------------\n    impure function GetAlertLogID (ID : integer) return AlertLogIDType is\n    ------------------------------------------------------------\n    begin\n      if IdOutOfRange(ID, \"MemErase\") then \n        return ALERTLOG_ID_NOT_FOUND ;\n      else\n        return MemStructPtr(ID).AlertLogID ; \n      end if ; \n    end function GetAlertLogID ;\n\n    ------------------------------------------------------------\n    -- PT Local\n    procedure FileReadX (\n    -- Hexadecimal or Binary File Read \n    ------------------------------------------------------------\n      ID           : integer ;\n      FileName     : string ;\n      DataFormat   : FileFormatType ; \n      StartAddr    : std_logic_vector ; \n      EndAddr      : std_logic_vector\n    ) is\n      constant ADDR_WIDTH : integer := MemStructPtr(ID).AddrWidth ;\n      constant DATA_WIDTH : integer := MemStructPtr(ID).DataWidth ; \n--      constant TemplateRange : std_logic_vector := (ADDR_WIDTH-1 downto 0 => '0') ;\n      -- Format:  \n      --  @hh..h     -- Address in hex\n      --  hhh_XX_ZZ  -- data values in hex - space delimited \n      --  \"--\" or \"//\" -- comments\n      file MemFile : text open READ_MODE is FileName ;\n     \n      variable Addr             : std_logic_vector(ADDR_WIDTH - 1 downto 0) ;\n      variable SmallAddr        : std_logic_vector(ADDR_WIDTH - 1 downto 0) ;\n      variable BigAddr          : std_logic_vector(ADDR_WIDTH - 1 downto 0) ;\n      variable Data             : std_logic_vector(DATA_WIDTH - 1 downto 0) ;\n      variable LineNum          : natural ; \n      variable ItemNum          : natural ; \n      variable AddrInc          : std_logic_vector(ADDR_WIDTH - 1 downto 0) ; \n      variable buf              : line ;\n      variable ReadValid        : boolean ;\n      variable Empty            : boolean ; \n      variable MultiLineComment : boolean ; \n      variable NextChar         : character ; \n      variable StrLen           : integer ; \n    begin\n      MultiLineComment := FALSE ; \n      if StartAddr'length /= ADDR_WIDTH and EndAddr'length /= ADDR_WIDTH then\n        if (MemStructPtr(ID).MemArrayPtr = NULL) then \n          Alert(MemStructPtr(ID).AlertLogID, \"MemoryPkg.FileReadX:  Memory not initialized, FileRead Ignored.\", FAILURE) ; \n        else\n          Alert(MemStructPtr(ID).AlertLogID, \"MemoryPkg.FileReadX:  Addr'length: \" & to_string(Addr'length) & \" /= Memory Address Width: \" & to_string(ADDR_WIDTH), FAILURE) ; \n        end if ; \n        return ; \n      end if ; \n\n      Addr    := StartAddr ; \n      LineNum := 0 ; \n      \n      if StartAddr <= EndAddr then \n        SmallAddr := StartAddr ; \n        BigAddr   := EndAddr ; \n        AddrInc   := (ADDR_WIDTH -1 downto 0 => '0') + 1 ;  \n      else\n        SmallAddr := EndAddr ; \n        BigAddr   := StartAddr ; \n        AddrInc   := (others => '1') ;  -- -1\n      end if; \n      \n      ReadLineLoop : while not EndFile(MemFile) loop\n        ReadLine(MemFile, buf) ;\n        LineNum := LineNum + 1 ; \n        ItemNum := 0 ; \n        \n        ItemLoop : loop \n          EmptyOrCommentLine(buf, Empty, MultiLineComment) ; \n          exit ItemLoop when Empty ; \n          ItemNum := ItemNum + 1 ; \n          NextChar := buf.all(buf'left) ;\n          \n          if (NextChar = '@') then \n          -- Get Address\n            read(buf, NextChar) ; \n            ReadHexToken(buf, Addr, StrLen) ; \n            exit ReadLineLoop when AlertIf(MemStructPtr(ID).AlertLogID, StrLen = 0, \"MemoryPkg.FileReadX: Address length 0 on line: \" & to_string(LineNum), FAILURE) ;\n            exit ItemLoop when AlertIf(MemStructPtr(ID).AlertLogID, Addr < SmallAddr, \n                                           \"MemoryPkg.FileReadX: Address in file: \" & to_hxstring(Addr) & \n                                           \" < StartAddr: \" & to_hxstring(StartAddr) & \" on line: \" & to_string(LineNum)) ; \n            exit ItemLoop when AlertIf(MemStructPtr(ID).AlertLogID, Addr > BigAddr, \n                                           \"MemoryPkg.FileReadX: Address in file: \" & to_hxstring(Addr) & \n                                           \" > EndAddr: \" & to_hxstring(BigAddr) & \" on line: \" & to_string(LineNum)) ; \n          \n          elsif DataFormat = HEX and IsHexOrStdLogic(NextChar) then \n          -- Get Hex Data\n            ReadHexToken(buf, data, StrLen) ;\n            exit ReadLineLoop when AlertIfNot(MemStructPtr(ID).AlertLogID, StrLen > 0, \n              \"MemoryPkg.FileReadH: Error while reading data on line: \" & to_string(LineNum) &\n              \"  Item number: \" & to_string(ItemNum), FAILURE) ;\n            log(MemStructPtr(ID).AlertLogID, \"MemoryPkg.FileReadX:  MemWrite(Addr => \" & to_hxstring(Addr) & \", Data => \" & to_hxstring(Data) & \")\", DEBUG) ; \n            MemWrite(ID, Addr, data) ; \n            Addr := Addr + AddrInc ; \n            \n          elsif DataFormat = BINARY and isstd_logic(NextChar) then \n          -- Get Binary Data\n            -- read(buf, data, ReadValid) ;\n            ReadBinaryToken(buf, data, StrLen) ;\n            -- exit ReadLineLoop when AlertIfNot(MemStructPtr(ID).AlertLogID, ReadValid, \n            exit ReadLineLoop when AlertIfNot(MemStructPtr(ID).AlertLogID, StrLen > 0, \n              \"MemoryPkg.FileReadB: Error while reading data on line: \" & to_string(LineNum) &\n              \"  Item number: \" & to_string(ItemNum), FAILURE) ;\n            log(MemStructPtr(ID).AlertLogID, \"MemoryPkg.FileReadX:  MemWrite(Addr => \" & to_hxstring(Addr) & \", Data => \" & to_string(Data) & \")\", DEBUG) ; \n            MemWrite(ID, Addr, data) ; \n            Addr := Addr + AddrInc ; \n          \n          else\n            if NextChar = LF or NextChar = CR then \n              -- If LF or CR, silently skip the character (DOS file in Unix)\n              read(buf, NextChar) ; \n            else\n              -- invalid Text, issue warning and skip rest of line\n              Alert(MemStructPtr(ID).AlertLogID,  \n                \"MemoryPkg.FileReadX: Invalid text on line: \" & to_string(LineNum) &\n                \"  Item: \" & to_string(ItemNum) & \".  Skipping text: \" & buf.all) ;\n              exit ItemLoop ; \n            end if ; \n          end if ; \n          \n        end loop ItemLoop ; \n      end loop ReadLineLoop ; \n      \n--      -- must read EndAddr-StartAddr number of words if both start and end specified\n--      if (StartAddr /= 0 or (not EndAddr) /= 0) and (Addr /= EndAddr) then \n--        Alert(\"MemoryPkg.FileReadH: insufficient data values\", WARNING) ; \n--      end if ;       \n      file_close(MemFile) ; \n    end FileReadX ;\n    \n    ------------------------------------------------------------\n    procedure FileReadH (\n    -- Hexadecimal File Read \n    ------------------------------------------------------------\n      ID           : integer ;\n      FileName     : string ; \n      StartAddr    : std_logic_vector ; \n      EndAddr      : std_logic_vector\n    ) is\n      constant ID_CHECK_OK : boolean := IdOutOfRange(ID, \"FileReadH\") ;\n    begin\n      FileReadX(ID, FileName, HEX, StartAddr, EndAddr) ; \n    end FileReadH ;\n    \n    ------------------------------------------------------------\n    -- Hexadecimal File Read \n    procedure FileReadH (\n    ------------------------------------------------------------\n      ID           : integer ;\n      FileName     : string ;  \n      StartAddr    : std_logic_vector\n    ) is\n      constant ID_CHECK_OK : boolean := IdOutOfRange(ID, \"FileReadH\") ;\n      constant ADDR_WIDTH  : integer := MemStructPtr(ID).AddrWidth ;\n      constant EndAddr     : std_logic_vector := (ADDR_WIDTH - 1 downto 0 => '1') ;\n    begin\n      FileReadX(ID, FileName, HEX, StartAddr, EndAddr) ; \n    end FileReadH ;\n\n    ------------------------------------------------------------\n    -- Hexadecimal File Read \n    procedure FileReadH (\n    ------------------------------------------------------------\n      ID           : integer ;\n      FileName     : string \n    ) is \n      constant ID_CHECK_OK : boolean := IdOutOfRange(ID, \"FileReadH\") ;\n      constant ADDR_WIDTH  : integer := MemStructPtr(ID).AddrWidth ;\n      constant StartAddr   : std_logic_vector := (ADDR_WIDTH - 1 downto 0 => '0') ;\n      constant EndAddr     : std_logic_vector := (ADDR_WIDTH - 1 downto 0 => '1') ;\n    begin\n      FileReadX(ID, FileName, HEX, StartAddr, EndAddr) ; \n    end FileReadH ;    \n    \n    ------------------------------------------------------------\n    -- Binary File Read \n    procedure FileReadB (\n    ------------------------------------------------------------\n      ID           : integer ;\n      FileName     : string ; \n      StartAddr    : std_logic_vector ; \n      EndAddr      : std_logic_vector\n    ) is\n      constant ID_CHECK_OK : boolean := IdOutOfRange(ID, \"FileReadB\") ;\n    begin\n      FileReadX(ID, FileName, BINARY, StartAddr, EndAddr) ; \n    end FileReadB ;\n    \n    ------------------------------------------------------------\n    -- Binary File Read \n    procedure FileReadB (\n    ------------------------------------------------------------\n      ID           : integer ;\n      FileName     : string ;  \n      StartAddr    : std_logic_vector\n    ) is\n      constant ID_CHECK_OK : boolean := IdOutOfRange(ID, \"FileReadB\") ;\n      constant ADDR_WIDTH  : integer := MemStructPtr(ID).AddrWidth ;\n      constant EndAddr     : std_logic_vector := (ADDR_WIDTH - 1 downto 0 => '1') ;\n    begin \n      FileReadX(ID, FileName, BINARY, StartAddr, EndAddr) ; \n    end FileReadB ;\n\n    ------------------------------------------------------------\n    -- Binary File Read \n    procedure FileReadB (\n    ------------------------------------------------------------\n      ID           : integer ;\n      FileName     : string \n    ) is \n      constant ID_CHECK_OK : boolean := IdOutOfRange(ID, \"FileReadB\") ;\n      constant ADDR_WIDTH  : integer := MemStructPtr(ID).AddrWidth ;\n      constant StartAddr   : std_logic_vector := (ADDR_WIDTH - 1 downto 0 => '0') ;\n      constant EndAddr     : std_logic_vector := (ADDR_WIDTH - 1 downto 0 => '1') ;\n    begin\n      FileReadX(ID, FileName, BINARY, StartAddr, EndAddr) ; \n    end FileReadB ;    \n\n    ------------------------------------------------------------\n    -- PT Local\n    -- Hexadecimal or Binary File Write \n    procedure FileWriteX (\n    ------------------------------------------------------------\n      ID           : integer ;\n      FileName     : string ; \n      DataFormat   : FileFormatType ; \n      StartAddr    : std_logic_vector ; \n      EndAddr      : std_logic_vector\n    ) is\n      constant ADDR_WIDTH  : integer := MemStructPtr(ID).AddrWidth ;\n      constant DATA_WIDTH  : integer := MemStructPtr(ID).DataWidth ; \n      constant BLOCK_WIDTH : integer := MemStructPtr(ID).BlockWidth ;\n      -- Format:  \n      --  @hh..h     -- Address in hex\n      --  hhhhh      -- data one per line in either hex or binary as specified \n      file MemFile : text open WRITE_MODE is FileName ;\n      alias normStartAddr     : std_logic_vector(StartAddr'length-1 downto 0) is StartAddr ; \n      alias normEndAddr       : std_logic_vector(EndAddr'length-1 downto 0) is EndAddr ; \n      variable StartBlockAddr : natural ;\n      variable EndBlockAddr   : natural ;\n      variable StartWordAddr  : natural ; \n      variable EndWordAddr    : natural ; \n      variable FoundData      : boolean ; \n      variable buf            : line ;\n      variable Data           : std_logic_vector(DATA_WIDTH-1 downto 0) ;\n      constant AllU           : std_logic_vector := (DATA_WIDTH-1 downto 0 => 'U');\n      \n    begin\n      if StartAddr'length /= ADDR_WIDTH and EndAddr'length /= ADDR_WIDTH then\n      -- Check StartAddr and EndAddr Widths and Memory not initialized\n        if (MemStructPtr(ID).MemArrayPtr = NULL) then \n          Alert(MemStructPtr(ID).AlertLogID, \"MemoryPkg.FileWriteX:  Memory not initialized, FileRead Ignored.\", FAILURE) ; \n        else\n          AlertIf(MemStructPtr(ID).AlertLogID, StartAddr'length /= ADDR_WIDTH, \"MemoryPkg.FileWriteX:  StartAddr'length: \" \n                               & to_string(StartAddr'length) & \n                               \" /= Memory Address Width: \" & to_string(ADDR_WIDTH), FAILURE) ; \n          AlertIf(MemStructPtr(ID).AlertLogID, EndAddr'length /= ADDR_WIDTH, \"MemoryPkg.FileWriteX:  EndAddr'length: \" \n                               & to_string(EndAddr'length) & \n                               \" /= Memory Address Width: \" & to_string(ADDR_WIDTH), FAILURE) ; \n        end if ; \n        return ; \n      end if ; \n\n      if StartAddr > EndAddr then \n      -- Only support ascending addresses\n        Alert(MemStructPtr(ID).AlertLogID, \"MemoryPkg.FileWriteX:  StartAddr: \" & to_hxstring(StartAddr) & \n                             \" > EndAddr: \" & to_hxstring(EndAddr), FAILURE) ;\n        return ; \n      end if ; \n            \n      -- Slice out upper address to form block address\n      if ADDR_WIDTH >= BLOCK_WIDTH then\n        StartBlockAddr := to_integer(normStartAddr(ADDR_WIDTH-1 downto BLOCK_WIDTH)) ;\n        EndBlockAddr   := to_integer(  normEndAddr(ADDR_WIDTH-1 downto BLOCK_WIDTH)) ;\n      else\n        StartBlockAddr  := 0 ; \n        EndBlockAddr  := 0 ; \n      end if ; \n            \n      BlockAddrLoop : for BlockAddr in StartBlockAddr to EndBlockAddr loop \n        next BlockAddrLoop when MemStructPtr(ID).MemArrayPtr(BlockAddr) = NULL ;  \n        if BlockAddr = StartBlockAddr then \n          StartWordAddr := to_integer(normStartAddr(BLOCK_WIDTH-1 downto 0)) ; \n        else\n          StartWordAddr := 0 ;\n        end if ; \n        if BlockAddr = EndBlockAddr then \n          EndWordAddr := to_integer(normEndAddr(BLOCK_WIDTH-1 downto 0)) ; \n        else \n          EndWordAddr := 2**BLOCK_WIDTH-1 ;\n        end if ; \n        FoundData := FALSE ; \n        WordAddrLoop : for WordAddr in StartWordAddr to EndWordAddr loop \n          Data := FromMemoryBaseType(MemStructPtr(ID).MemArrayPtr(BlockAddr)(WordAddr), Data'length) ;\n          if MetaMatch(Data, AllU) then \n            FoundData := FALSE ;\n          else \n            if not FoundData then\n              -- Write Address\n              write(buf, '@') ; \n              hwrite(buf, to_slv(BlockAddr, ADDR_WIDTH-BLOCK_WIDTH) & to_slv(WordAddr, BLOCK_WIDTH)) ; \n              writeline(MemFile, buf) ; \n            end if ; \n            FoundData := TRUE ; \n          end if ;\n          if FoundData then  -- Write Data\n            if DataFormat = HEX then\n              hwrite(buf, Data) ; \n              writeline(MemFile, buf) ; \n            else\n              write(buf, Data) ; \n              writeline(MemFile, buf) ; \n            end if; \n          end if ;                \n        end loop WordAddrLoop ; \n      end loop BlockAddrLoop ;       \n      file_close(MemFile) ; \n    end FileWriteX ;\n    \n    ------------------------------------------------------------\n    -- Hexadecimal File Write \n    procedure FileWriteH (\n    ------------------------------------------------------------\n      ID           : integer ;\n      FileName     : string ; \n      StartAddr    : std_logic_vector ; \n      EndAddr      : std_logic_vector\n    ) is\n      constant ID_CHECK_OK : boolean := IdOutOfRange(ID, \"FileWriteH\") ;\n    begin\n      FileWriteX(ID, FileName, HEX, StartAddr, EndAddr) ; \n    end FileWriteH ;\n\n    ------------------------------------------------------------\n    -- Hexadecimal File Write \n    procedure FileWriteH (\n    ------------------------------------------------------------\n      ID           : integer ;\n      FileName     : string ;  \n      StartAddr    : std_logic_vector\n    ) is\n      constant ID_CHECK_OK : boolean := IdOutOfRange(ID, \"FileWriteH\") ;\n      constant ADDR_WIDTH  : integer := MemStructPtr(ID).AddrWidth ;\n      constant EndAddr     : std_logic_vector := (ADDR_WIDTH-1 downto 0 => '1') ;\n    begin\n      FileWriteX(ID, FileName, HEX, StartAddr, EndAddr) ; \n    end FileWriteH ;\n\n    ------------------------------------------------------------\n    -- Hexadecimal File Write \n    procedure FileWriteH (\n    ------------------------------------------------------------\n      ID           : integer ;\n      FileName     : string \n    ) is \n      constant ID_CHECK_OK : boolean := IdOutOfRange(ID, \"FileWriteH\") ;\n      constant ADDR_WIDTH  : integer := MemStructPtr(ID).AddrWidth ;\n      constant StartAddr   : std_logic_vector := (ADDR_WIDTH-1 downto 0 => '0') ;\n      constant EndAddr     : std_logic_vector := (ADDR_WIDTH-1 downto 0 => '1') ;\n    begin\n      FileWriteX(ID, FileName, HEX, StartAddr, EndAddr) ; \n    end FileWriteH ;    \n    \n    ------------------------------------------------------------\n    -- Binary File Write \n    procedure FileWriteB (\n    ------------------------------------------------------------\n      ID           : integer ;\n      FileName     : string ; \n      StartAddr    : std_logic_vector ; \n      EndAddr      : std_logic_vector\n    ) is\n      constant ID_CHECK_OK : boolean := IdOutOfRange(ID, \"FileWriteB\") ;\n    begin\n      FileWriteX(ID, FileName, BINARY, StartAddr, EndAddr) ; \n    end FileWriteB ;\n    \n    ------------------------------------------------------------\n    -- Binary File Write \n    procedure FileWriteB (\n    ------------------------------------------------------------\n      ID           : integer ;\n      FileName     : string ;  \n      StartAddr    : std_logic_vector\n    ) is\n      constant ID_CHECK_OK : boolean := IdOutOfRange(ID, \"FileWriteB\") ;\n      constant ADDR_WIDTH  : integer := MemStructPtr(ID).AddrWidth ;\n      constant EndAddr     : std_logic_vector := (ADDR_WIDTH-1 downto 0 => '1') ;\n    begin\n      FileWriteX(ID, FileName, BINARY, StartAddr, EndAddr) ; \n    end FileWriteB ;\n\n    ------------------------------------------------------------\n    -- Binary File Write \n    procedure FileWriteB (\n    ------------------------------------------------------------\n      ID           : integer ;\n      FileName     : string \n    ) is \n      constant ID_CHECK_OK : boolean := IdOutOfRange(ID, \"FileWriteB\") ;\n      constant ADDR_WIDTH  : integer := MemStructPtr(ID).AddrWidth ;\n      constant StartAddr   : std_logic_vector := (ADDR_WIDTH-1 downto 0 => '0') ;\n      constant EndAddr     : std_logic_vector := (ADDR_WIDTH-1 downto 0 => '1') ;\n    begin\n      FileWriteX(ID, FileName, BINARY, StartAddr, EndAddr) ; \n    end FileWriteB ;  \n\n-- /////////////////////////////////////////\n-- /////////////////////////////////////////\n-- Structure Wide Methods\n-- /////////////////////////////////////////\n-- /////////////////////////////////////////\n    ------------------------------------------------------------\n    -- Erase the memory\n    -- Used between independent pieces of a test\n    -- to erase the all memory model contents, but\n    -- keeps the memory size and infrastructure\n    procedure MemErase is \n    ------------------------------------------------------------\n    begin\n      for ID in MemStructPtr'range loop \n        MemErase(ID) ;\n      end loop ;\n    end procedure ; \n\n    ------------------------------------------------------------\n    -- Destroys the entire data structure\n    -- Usage:  At the end of the simulation to remove all \n    -- memory used by data structure.  \n    -- Note, a normal simulator does this for you.  \n    -- You only need this if the simulator is broken.\n    ------------------------------------------------------------\n    -- PT Local\n     procedure deallocate (ID : integer) is \n    ------------------------------------------------------------\n    begin\n      MemErase(ID) ; \n      deallocate(MemStructPtr(ID).MemArrayPtr) ; \n      MemStructPtr(ID).AddrWidth   := -1 ;\n      MemStructPtr(ID).DataWidth   := 1 ;\n      MemStructPtr(ID).BlockWidth  := 0 ;\n--! removed      -- deallocate(MemStructPtr(ID).Name) ; \n    end procedure ; \n\n    procedure deallocate is\n    begin\n      for ID in MemStructPtr'range loop \n        deallocate(ID) ;\n      end loop ;\n--! Deallocate not able to be called on MemoryStore - no accessor procedure\n--! if make directly visible, then do this, but otherwise no.\n--      deallocate(MemStructPtr) ;   \n--      NumItems := 0 ; \n    end procedure deallocate ; \n\n-- /////////////////////////////////////////\n-- /////////////////////////////////////////\n-- Compatibility Methods\n-- /////////////////////////////////////////\n-- /////////////////////////////////////////\n   ------------------------------------------------------------\n    procedure MemInit ( AddrWidth, DataWidth  : in  integer ) is\n    ------------------------------------------------------------\n    begin\n      MemInit(MEM_STRUCT_PTR_LEFT, AddrWidth, DataWidth) ;\n    end procedure MemInit ;\n\n    ------------------------------------------------------------\n    procedure MemWrite (  Addr, Data  : in  std_logic_vector ) is \n    ------------------------------------------------------------\n    begin\n      MemWrite(MEM_STRUCT_PTR_LEFT, Addr, Data) ; \n    end procedure MemWrite ; \n\n    ------------------------------------------------------------\n    procedure MemRead (  \n    ------------------------------------------------------------\n      Addr  : In   std_logic_vector ;\n      Data  : Out  std_logic_vector \n    ) is\n    begin\n      MemRead(MEM_STRUCT_PTR_LEFT, Addr, Data) ; \n    end procedure MemRead ; \n\n    ------------------------------------------------------------\n    impure function MemRead ( Addr  : std_logic_vector ) return std_logic_vector is\n    ------------------------------------------------------------\n      constant DATA_WIDTH : integer := MemStructPtr(MEM_STRUCT_PTR_LEFT).DataWidth ; \n      variable Data  : std_logic_vector(DATA_WIDTH-1 downto 0) ; \n    begin\n      MemRead(MEM_STRUCT_PTR_LEFT, Addr, Data) ; \n      return Data ; \n    end function MemRead ; \n\n    ------------------------------------------------------------\n    procedure SetAlertLogID (A : AlertLogIDType) is\n    ------------------------------------------------------------\n    begin\n      MemStructPtr(MEM_STRUCT_PTR_LEFT).AlertLogID  := A ;\n    end procedure SetAlertLogID ;\n\n    ------------------------------------------------------------\n    procedure SetAlertLogID(Name : string ; ParentID : AlertLogIDType := OSVVM_MEMORY_ALERTLOG_ID ; CreateHierarchy : Boolean := TRUE) is\n    ------------------------------------------------------------\n    begin\n      MemStructPtr(MEM_STRUCT_PTR_LEFT).AlertLogID := GetAlertLogID(Name, ParentID, CreateHierarchy) ;\n    end procedure SetAlertLogID ;\n    \n    ------------------------------------------------------------\n    impure function GetAlertLogID return AlertLogIDType is\n    ------------------------------------------------------------\n    begin\n      return MemStructPtr(MEM_STRUCT_PTR_LEFT).AlertLogID ; \n    end function GetAlertLogID ;\n      \n    ------------------------------------------------------------\n    procedure FileReadH (\n    -- Hexadecimal File Read \n    ------------------------------------------------------------\n      FileName     : string ; \n      StartAddr    : std_logic_vector ; \n      EndAddr      : std_logic_vector\n    ) is\n    begin\n      FileReadH(MEM_STRUCT_PTR_LEFT, FileName, StartAddr, EndAddr) ; \n    end FileReadH ;\n    \n    ------------------------------------------------------------\n    procedure FileReadH (FileName : string ;  StartAddr : std_logic_vector) is\n    -- Hexadecimal File Read \n    ------------------------------------------------------------\n    begin\n      FileReadH(MEM_STRUCT_PTR_LEFT, FileName, StartAddr) ; \n    end FileReadH ;\n\n    ------------------------------------------------------------\n    procedure FileReadH (FileName : string) is \n    -- Hexadecimal File Read \n    ------------------------------------------------------------\n    begin\n      FileReadH(MEM_STRUCT_PTR_LEFT, FileName) ; \n    end FileReadH ;    \n    \n     ------------------------------------------------------------\n    procedure FileReadB (\n    -- Binary File Read \n    ------------------------------------------------------------\n      FileName     : string ; \n      StartAddr    : std_logic_vector ; \n      EndAddr      : std_logic_vector\n    ) is\n    begin\n      FileReadB(MEM_STRUCT_PTR_LEFT, FileName, StartAddr, EndAddr) ; \n    end FileReadB ;\n    \n    ------------------------------------------------------------\n    procedure FileReadB (FileName : string ;  StartAddr : std_logic_vector) is\n    -- Binary File Read \n    ------------------------------------------------------------\n    begin\n      FileReadB(MEM_STRUCT_PTR_LEFT, FileName, StartAddr) ; \n    end FileReadB ;\n\n    ------------------------------------------------------------\n    procedure FileReadB (FileName : string) is \n    -- Binary File Read \n    ------------------------------------------------------------\n    begin\n      FileReadB(MEM_STRUCT_PTR_LEFT, FileName) ; \n    end FileReadB ;    \n\n    ------------------------------------------------------------\n    procedure FileWriteH (\n    -- Hexadecimal File Write \n    ------------------------------------------------------------\n      FileName     : string ; \n      StartAddr    : std_logic_vector ; \n      EndAddr      : std_logic_vector\n    ) is\n    begin\n      FileWriteH(MEM_STRUCT_PTR_LEFT, FileName, StartAddr, EndAddr) ; \n    end FileWriteH ;\n    \n    ------------------------------------------------------------\n    procedure FileWriteH (FileName : string ;  StartAddr : std_logic_vector) is\n    -- Hexadecimal File Write \n    ------------------------------------------------------------\n    begin\n      FileWriteH(MEM_STRUCT_PTR_LEFT, FileName, StartAddr) ; \n    end FileWriteH ;\n\n    ------------------------------------------------------------\n    procedure FileWriteH (FileName : string) is \n    -- Hexadecimal File Write \n    ------------------------------------------------------------\n    begin\n      FileWriteH(MEM_STRUCT_PTR_LEFT, FileName) ; \n    end FileWriteH ;    \n    \n     ------------------------------------------------------------\n    procedure FileWriteB (\n    -- Binary File Write \n    ------------------------------------------------------------\n      FileName     : string ; \n      StartAddr    : std_logic_vector ; \n      EndAddr      : std_logic_vector\n    ) is\n    begin\n      FileWriteB(MEM_STRUCT_PTR_LEFT, FileName, StartAddr, EndAddr) ; \n    end FileWriteB ;\n    \n    ------------------------------------------------------------\n    procedure FileWriteB (FileName : string ;  StartAddr : std_logic_vector) is\n    -- Binary File Write \n    ------------------------------------------------------------\n    begin\n      FileWriteB(MEM_STRUCT_PTR_LEFT, FileName, StartAddr) ; \n    end FileWriteB ;\n\n    ------------------------------------------------------------\n    procedure FileWriteB (FileName : string) is \n    -- Binary File Write \n    ------------------------------------------------------------\n    begin\n      FileWriteB(MEM_STRUCT_PTR_LEFT, FileName) ; \n    end FileWriteB ;        \n  end protected body MemoryPType ;\n \n-- /////////////////////////////////////////\n-- /////////////////////////////////////////\n-- Singleton Data Structure\n-- /////////////////////////////////////////\n-- /////////////////////////////////////////\n  shared variable MemoryStore : MemoryPType ;\n \n   ------------------------------------------------------------\n  impure function NewID (\n    Name                : String ; \n    AddrWidth           : integer ; \n    DataWidth           : integer ; \n    ParentID            : AlertLogIDType          := OSVVM_MEMORY_ALERTLOG_ID ;\n    ReportMode          : AlertLogReportModeType  := ENABLED ; \n    Search              : NameSearchType          := PRIVATE_NAME ;\n    PrintParent         : AlertLogPrintParentType := PRINT_NAME_AND_PARENT\n  ) return MemoryIDType is\n    variable Result : MemoryIDType ; \n  begin\n    Result.ID := MemoryStore.NewID(Name, AddrWidth, DataWidth, ParentID, ReportMode, Search, PrintParent) ; \n    return Result ; \n  end function NewID ; \n\n  ------------------------------------------------------------\n  procedure MemWrite ( \n    ID    : MemoryIDType ; \n    Addr  : std_logic_vector ;\n    Data  : std_logic_vector \n  ) is\n  begin\n    MemoryStore.MemWrite(ID.ID, Addr, Data) ; \n  end procedure MemWrite ; \n  \n  procedure MemRead (  \n    ID    : in MemoryIDType ;\n    Addr  : in  std_logic_vector ;\n    Data  : out std_logic_vector \n  ) is\n  begin\n    MemoryStore.MemRead(ID.ID, Addr, Data) ; \n  end procedure MemRead ; \n  \n  impure function MemRead ( \n    ID    : MemoryIDType ; \n    Addr  : std_logic_vector \n  ) return std_logic_vector is\n  begin\n    return MemoryStore.MemRead(ID.ID, Addr) ; \n  end function MemRead ; \n\n  ------------------------------------------------------------\n  procedure MemErase (ID : in MemoryIDType) is\n  begin\n    MemoryStore.MemErase(ID.ID) ; \n  end procedure MemErase ;  \n  \n  ------------------------------------------------------------\n  impure function GetAlertLogID (\n    ID : in MemoryIDType\n  ) return AlertLogIDType is\n  begin\n    return MemoryStore.GetAlertLogID(ID.ID) ; \n  end function GetAlertLogID ; \n  \n  ------------------------------------------------------------\n  procedure FileReadH (    -- Hexadecimal File Read \n    ID           : MemoryIDType ;\n    FileName     : string ; \n    StartAddr    : std_logic_vector ; \n    EndAddr      : std_logic_vector\n  ) is\n  begin\n    MemoryStore.FileReadH(ID.ID, FileName, StartAddr, EndAddr) ; \n  end procedure FileReadH ; \n  \n  procedure FileReadH (\n    ID           : MemoryIDType ;\n    FileName     : string ;  \n    StartAddr    : std_logic_vector\n  ) is\n  begin\n    MemoryStore.FileReadH(ID.ID, FileName, StartAddr) ; \n  end procedure FileReadH ; \n\n  procedure FileReadH (\n    ID           : MemoryIDType ;\n    FileName     : string \n  ) is\n  begin\n    MemoryStore.FileReadH(ID.ID, FileName) ; \n  end procedure FileReadH ; \n\n  ------------------------------------------------------------\n  procedure FileReadB (    -- Binary File Read \n    ID           : MemoryIDType ;\n    FileName     : string ; \n    StartAddr    : std_logic_vector ; \n    EndAddr      : std_logic_vector\n  ) is\n  begin\n    MemoryStore.FileReadB(ID.ID, FileName, StartAddr, EndAddr) ; \n  end procedure FileReadB ; \n\n  procedure FileReadB (\n    ID           : MemoryIDType ;\n    FileName     : string ;  \n    StartAddr    : std_logic_vector\n  ) is\n  begin\n    MemoryStore.FileReadB(ID.ID, FileName, StartAddr) ; \n  end procedure FileReadB ; \n\n  procedure FileReadB (\n    ID           : MemoryIDType ;\n    FileName     : string \n  ) is\n  begin\n    MemoryStore.FileReadB(ID.ID, FileName) ; \n  end procedure FileReadB ; \n\n  ------------------------------------------------------------\n  procedure FileWriteH (    -- Hexadecimal File Write \n    ID           : MemoryIDType ;\n    FileName     : string ; \n    StartAddr    : std_logic_vector ; \n    EndAddr      : std_logic_vector\n  ) is\n  begin\n    MemoryStore.FileWriteH(ID.ID, FileName, StartAddr, EndAddr) ; \n  end procedure FileWriteH ; \n\n  procedure FileWriteH (\n    ID           : MemoryIDType ;\n    FileName     : string ;  \n    StartAddr    : std_logic_vector\n  ) is\n  begin\n    MemoryStore.FileWriteH(ID.ID, FileName, StartAddr) ; \n  end procedure FileWriteH ; \n  \n  procedure FileWriteH (\n    ID           : MemoryIDType ;\n    FileName     : string \n  ) is\n  begin\n    MemoryStore.FileWriteH(ID.ID, FileName) ; \n  end procedure FileWriteH ; \n  \n  ------------------------------------------------------------\n  procedure FileWriteB (    -- Binary File Write \n    ID           : MemoryIDType ;\n    FileName     : string ; \n    StartAddr    : std_logic_vector ; \n    EndAddr      : std_logic_vector\n  ) is\n  begin\n    MemoryStore.FileWriteB(ID.ID, FileName, StartAddr, EndAddr) ; \n  end procedure FileWriteB ; \n  \n  procedure FileWriteB (\n    ID           : MemoryIDType ;\n    FileName     : string ;  \n    StartAddr    : std_logic_vector\n  ) is\n  begin\n    MemoryStore.FileWriteB(ID.ID, FileName, StartAddr) ; \n  end procedure FileWriteB ; \n\n  procedure FileWriteB (\n    ID           : MemoryIDType ;\n    FileName     : string \n  ) is\n  begin\n    MemoryStore.FileWriteB(ID.ID, FileName) ; \n  end procedure FileWriteB ; \nend MemoryGenericPkg ;","lang":"vhdl"};
processSrcData(g_data);