var g_data = {"name":"C:/SynthWorks/Dev/_osvvm/OsvvmLibraries/AXI4/Axi4/src/Axi4Subordinate.vhd","src":"--\n--  File Name:         Axi4Subordinate.vhd\n--  Design Unit Name:  Axi4Subordinate\n--  Revision:          OSVVM MODELS STANDARD VERSION\n--\n--  Maintainer:        Jim Lewis      email:  jim@synthworks.com\n--  Contributor(s):\n--     Jim Lewis      jim@synthworks.com\n--\n--\n--  Description:\n--      Simple AXI Full Subordinate Transactor Model\n--\n--\n--  Developed by:\n--        SynthWorks Design Inc.\n--        VHDL Training Classes\n--        http://www.SynthWorks.com\n--\n--  Revision History:\n--    Date      Version    Description\n--    05/2023   2023.05    Adding Randomization of Valid and Ready timing   \n--    10/2022   2022.10    Changed enum value PRIVATE to PRIVATE_NAME due to VHDL-2019 keyword conflict.   \n--    05/2022   2022.05    Updated FIFOs so they are Search => PRIVATE\n--    03/2022   2022.03    Updated calls to NewID for AlertLogID and FIFOs\n--    02/2022   2022.02    Replaced to_hstring with to_hxstring\n--    01/2022   2022.01    Moved MODEL_INSTANCE_NAME and MODEL_NAME to entity declarative region\n--    09/2021   2021.09    Minor fix to push WriteDataFifo \n--    07/2021   2021.07    All FIFOs and Scoreboards now use the New Scoreboard/FIFO capability \n--    06/2021   2021.06    Updates for GHDL.   \n--    02/2021   2021.02    Added MultiDriver Detect.  Updated Generics.   \n--    12/2020   2020.12    Updated.  \n--    09/2017   2017       Initial revision\n--\n--\n--  This file is part of OSVVM.\n--\n--  Copyright (c) 2017 - 2023 by SynthWorks Design Inc.\n--\n--  Licensed under the Apache License, Version 2.0 (the \"License\");\n--  you may not use this file except in compliance with the License.\n--  You may obtain a copy of the License at\n--\n--      https://www.apache.org/licenses/LICENSE-2.0\n--\n--  Unless required by applicable law or agreed to in writing, software\n--  distributed under the License is distributed on an \"AS IS\" BASIS,\n--  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n--  See the License for the specific language governing permissions and\n--  limitations under the License.\n--\n\nlibrary ieee ;\n  use ieee.std_logic_1164.all ;\n  use ieee.numeric_std.all ;\n  use ieee.numeric_std_unsigned.all ;\n  use ieee.math_real.all ;\n\nlibrary osvvm ;\n  context osvvm.OsvvmContext ;\n  use osvvm.ScoreboardPkg_slv.all ;\n\nlibrary OSVVM_Common ;\n  context OSVVM_Common.OsvvmCommonContext ;\n\n  use work.Axi4OptionsPkg.all ;\n  use work.Axi4InterfaceCommonPkg.all ;\n  use work.Axi4InterfacePkg.all ;\n  use work.Axi4ModelPkg.all ;\n  use work.Axi4CommonPkg.all ;\n\nentity Axi4Subordinate is\ngeneric (\n  MODEL_ID_NAME   : string := \"\" ;\n  tperiod_Clk     : time   := 10 ns ;\n\n  DEFAULT_DELAY   : time   := 1 ns ; \n\n  tpd_Clk_AWReady : time   := DEFAULT_DELAY ;\n\n  tpd_Clk_WReady  : time   := DEFAULT_DELAY ;\n\n  tpd_Clk_BValid  : time   := DEFAULT_DELAY ;\n  tpd_Clk_BResp   : time   := DEFAULT_DELAY ;\n  tpd_Clk_BID     : time   := DEFAULT_DELAY ;\n  tpd_Clk_BUser   : time   := DEFAULT_DELAY ;\n\n  tpd_Clk_ARReady : time   := DEFAULT_DELAY ;\n\n  tpd_Clk_RValid  : time   := DEFAULT_DELAY ;\n  tpd_Clk_RData   : time   := DEFAULT_DELAY ;\n  tpd_Clk_RResp   : time   := DEFAULT_DELAY ;\n  tpd_Clk_RID     : time   := DEFAULT_DELAY ;\n  tpd_Clk_RUser   : time   := DEFAULT_DELAY \n) ;\nport (\n  -- Globals\n  Clk         : in   std_logic ;\n  nReset      : in   std_logic ;\n\n  -- AXI Manager Functional Interface\n  AxiBus      : inout Axi4RecType ;\n\n  -- Testbench Transaction Interface\n  TransRec    : inout AddressBusRecType\n) ;\n\n  -- Model Configuration\n  -- Access via transactions or external name\n  shared variable Params : ModelParametersPType ;\n\n  -- Derive AXI interface properties from the AxiBus\n  constant AXI_ADDR_WIDTH : integer := AxiBus.WriteAddress.Addr'length ;\n  constant AXI_DATA_WIDTH : integer := AxiBus.WriteData.Data'length ;\n\n  -- Derive ModelInstance label from path_name\n  -- use MODEL_ID_NAME Generic if set, otherwise use instance label (preferred if set as entityname_1)\n  constant MODEL_INSTANCE_NAME : string :=\n    IfElse(MODEL_ID_NAME /= \"\", MODEL_ID_NAME, PathTail(to_lower(Axi4Subordinate'PATH_NAME))) ;\n\n  constant MODEL_NAME : string := \"Axi4Subordinate\" ;\n\nend entity Axi4Subordinate ;\n\narchitecture Transactor of Axi4Subordinate is\n\n  signal ModelID, ProtocolID, DataCheckID, BusFailedID : AlertLogIDType ;\n  signal WriteAddressDelayCov, WriteDataDelayCov, WriteResponseDelayCov : DelayCoverageIDType ;\n  signal ReadAddressDelayCov,  ReadDataDelayCov : DelayCoverageIDType ;\n  signal UseCoverageDelays : boolean := FALSE ; \n\n  constant AXI_DATA_BYTE_WIDTH : integer := AXI_DATA_WIDTH / 8 ;\n  constant AXI_BYTE_ADDR_WIDTH : integer := integer(ceil(log2(real(AXI_DATA_BYTE_WIDTH)))) ;\n\n  signal WriteAddressFifo           : osvvm.ScoreboardPkg_slv.ScoreboardIDType ;\n  signal WriteDataFifo              : osvvm.ScoreboardPkg_slv.ScoreboardIDType ;\n  signal WriteTransactionFifo       : osvvm.ScoreboardPkg_slv.ScoreboardIDType ;\n  signal WriteResponseFifo          : osvvm.ScoreboardPkg_slv.ScoreboardIDType ;\n  signal ReadAddressFifo            : osvvm.ScoreboardPkg_slv.ScoreboardIDType ;\n  signal ReadAddressTransactionFifo : osvvm.ScoreboardPkg_slv.ScoreboardIDType ;\n  signal ReadDataFifo               : osvvm.ScoreboardPkg_slv.ScoreboardIDType ;\n\n  -- Setup so that if no configuration is done, accept transactions\n  signal WriteAddressExpectCount     : integer := 0 ;\n  signal WriteDataExpectCount        : integer := 0 ;\n\n  signal WriteAddressReceiveCount    : integer := 0 ;\n  signal WriteDataReceiveCount       : integer := 0 ;\n  signal WriteReceiveCount           : integer := 0 ;\n  signal WriteResponseDoneCount      : integer := 0 ;\n\n  signal ReadAddressReceiveCount     : integer := 0 ;\n\n  signal ReadDataRequestCount        : integer := 0 ;\n  signal ReadDataDoneCount           : integer := 0 ;\n\n  -- A hack of a way to set the parameters for now.\n  signal ModelBResp  : Axi4RespType := to_Axi4RespType(OKAY) ;\n  signal ModelRResp  : Axi4RespType := to_Axi4RespType(OKAY) ;\n  \n  signal ModelBUSER  : std_logic_vector(AxiBus.WriteResponse.User'length - 1 downto 0) := (others => '0') ;\n  signal ModelBID    : std_logic_vector(AxiBus.WriteResponse.ID'length - 1 downto 0) := (others => '0') ;\n\n  signal ModelRUSER  : std_logic_vector(AxiBus.ReadData.User'length - 1 downto 0) := (others => '0') ;\n  signal ModelRID    : std_logic_vector(AxiBus.ReadData.ID'length - 1 downto 0) := (others => '0') ;\n\nbegin\n\n  ------------------------------------------------------------\n  -- Turn off drivers not being driven by this model\n  ------------------------------------------------------------\n  InitAxi4Rec (AxiBusRec => AxiBus ) ;\n\n\n  ------------------------------------------------------------\n  --  Initialize AlertLogIDs\n  ------------------------------------------------------------\n  Initalize : process\n    variable ID : AlertLogIDType ;\n  begin\n    InitAxiOptions(Params) ;\n\n    -- Alerts\n    ID                      := NewID(MODEL_INSTANCE_NAME) ;\n    ModelID                 <= ID ;\n--    TransRec.AlertLogID     <= NewID(\"Transaction\", ID ) ;\n    ProtocolID              <= NewID(\"Protocol Error\", ID ) ;\n    DataCheckID             <= NewID(\"Data Check\",     ID ) ;\n    BusFailedID             <= NewID(\"No response\",    ID ) ;\n\n    -- FIFOs get an AlertLogID with NewID, however, it does not print in ReportAlerts (due to DoNotReport)\n    --   FIFOS only generate usage type errors \n    WriteAddressFifo           <= NewID(\"WriteAddressFIFO\",             ID, ReportMode => DISABLED, Search => PRIVATE_NAME);\n    WriteDataFifo              <= NewID(\"WriteDataFifo\",                ID, ReportMode => DISABLED, Search => PRIVATE_NAME);\n    WriteTransactionFifo       <= NewID(\"WriteTransactionFifo\",         ID, ReportMode => DISABLED, Search => PRIVATE_NAME);\n    WriteResponseFifo          <= NewID(\"WriteResponseFifo\",            ID, ReportMode => DISABLED, Search => PRIVATE_NAME);\n\n    ReadAddressFifo            <= NewID(\"ReadAddressFifo\",              ID, ReportMode => DISABLED, Search => PRIVATE_NAME);\n    ReadAddressTransactionFifo <= NewID(\"ReadAddressTransactionFifo\",   ID, ReportMode => DISABLED, Search => PRIVATE_NAME);\n    ReadDataFifo               <= NewID(\"ReadDataFifo\",                 ID, ReportMode => DISABLED, Search => PRIVATE_NAME);\n\n    wait ;\n  end process Initalize ;\n\n\n  ------------------------------------------------------------\n  --  Transaction Dispatcher\n  --    Handles transactions between TestCtrl and Model\n  ------------------------------------------------------------\n  TransactionDispatcher : process\n\n    -- Formulate local copies of values for AXI Interface\n    variable LocalAW : AxiBus.WriteAddress'subtype ;\n    variable LocalWD : AxiBus.WriteData'subtype ;\n--    variable LocalWR : AxiBus.WriteResponse'subtype ;\n    variable LocalAR : AxiBus.ReadAddress'subtype ;\n    variable LocalRD : AxiBus.ReadData'subtype ;\n\n    variable WriteAvailable      : boolean := FALSE ;\n\n    variable WriteByteCount : integer ;\n    variable WriteByteAddr  : integer ;\n\n    variable ReadByteAddr  : integer ;\n    variable ReadAvailable : boolean := FALSE ;\n\n    variable Axi4Option    : Axi4OptionsType ; \n    variable Axi4OptionVal : integer ; \n    \n    variable FilterUndrivenWriteData       : boolean := TRUE ;\n    variable UndrivenWriteDataValue        : std_logic := '0' ;\n\n    variable TransactionCount              : integer := 0 ; \n    variable WriteAddressTransactionCount  : integer := 0 ; \n    variable WriteDataTransactionCount     : integer := 0 ; \n    variable WriteResponseTransactionCount : integer := 0 ; \n  begin\n    wait for 0 ns ; -- Allow ModelID to become valid\n    WriteAddressDelayCov    <= NewID(\"WriteAddressDelayCov\",   ModelID, ReportMode => DISABLED) ; \n    WriteDataDelayCov       <= NewID(\"WriteDataDelayCov\",      ModelID, ReportMode => DISABLED) ; \n    WriteResponseDelayCov   <= NewID(\"WriteResponseDelayCov\",  ModelID, ReportMode => DISABLED) ; \n    ReadAddressDelayCov     <= NewID(\"ReadAddressDelayCov\",    ModelID, ReportMode => DISABLED) ; \n    ReadDataDelayCov        <= NewID(\"ReadDataDelayCov\",       ModelID, ReportMode => DISABLED) ; \n\n    DispatchLoop : loop\n      WaitForTransaction(\n         Clk      => Clk,\n         Rdy      => TransRec.Rdy,\n         Ack      => TransRec.Ack\n      ) ;\n      TransactionCount := TransactionCount + 1 ; \n\n      case TransRec.Operation is\n        when WAIT_FOR_TRANSACTION =>\n          -- wait for write or read transaction to be available\n          loop\n            exit when not empty(WriteAddressFifo) and not empty(WriteDataFifo) ; -- Write Available\n            exit when not empty(ReadAddressFifo) ; -- Read Available\n            wait on WriteAddressReceiveCount, WriteDataReceiveCount, ReadAddressReceiveCount ;\n          end loop ;\n\n        when WAIT_FOR_WRITE_TRANSACTION =>\n          -- wait for write transaction to be available\n          if empty(WriteAddressFifo) then\n            WaitForToggle(WriteAddressReceiveCount) ;\n          end if ;\n          if empty(WriteDataFifo) then\n            WaitForToggle(WriteDataReceiveCount) ;\n          end if ;\n\n        when WAIT_FOR_READ_TRANSACTION =>\n          -- wait for read transaction to be available\n          if empty(ReadAddressFifo) then\n            WaitForToggle(ReadAddressReceiveCount) ;\n          end if ;\n\n  --  Alternate interpretation of wait for transaction\n  --      when WAIT_FOR_WRITE_TRANSACTION =>\n  --        -- Wait for next write to memory to complete\n  --        if (WriteAddressReceiveCount /= WriteReceiveCount) or (WriteReceiveCount /= WriteResponseDoneCount) then\n  --          wait until (WriteAddressReceiveCount = WriteReceiveCount) and (WriteReceiveCount = WriteResponseDoneCount) ;\n  --        end if ;\n  --\n  --      when WAIT_FOR_READ_TRANSACTION =>\n  --        -- Wait for a requested Read Data Transaction to complete\n  --        if ReadDataRequestCount /= ReadDataDoneCount then\n  --          wait until ReadDataRequestCount = ReadDataDoneCount ;\n  --        end if ;\n  --\n        when WAIT_FOR_CLOCK =>\n          WaitForClock(Clk, TransRec.IntToModel) ;\n\n        when GET_ALERTLOG_ID =>\n          TransRec.IntFromModel <= integer(ModelID) ;\n\n        when SET_USE_RANDOM_DELAYS =>        \n          UseCoverageDelays      <= TransRec.BoolToModel ; \n\n        when GET_USE_RANDOM_DELAYS =>\n          TransRec.BoolFromModel <= UseCoverageDelays ;\n\n        when SET_DELAYCOV_ID =>\n          case TransRec.Options is\n            when WRITE_ADDRESS_ID  =>  WriteAddressDelayCov  <= GetDelayCoverage(TransRec.IntToModel) ;\n            when WRITE_DATA_ID     =>  WriteDataDelayCov     <= GetDelayCoverage(TransRec.IntToModel) ;\n            when WRITE_RESPONSE_ID =>  WriteResponseDelayCov <= GetDelayCoverage(TransRec.IntToModel) ;\n            when READ_ADDRESS_ID   =>  ReadAddressDelayCov   <= GetDelayCoverage(TransRec.IntToModel) ;\n            when READ_DATA_ID      =>  ReadDataDelayCov      <= GetDelayCoverage(TransRec.IntToModel) ;\n            when others =>  Alert(ModelID, \"SetDelayCoverageID, Invalid ID requested = \" & to_string(TransRec.IntToModel), FAILURE) ;  \n          end case ; \n          UseCoverageDelays <= TRUE ; \n\n        when GET_DELAYCOV_ID =>\n          case TransRec.Options is\n            when WRITE_ADDRESS_ID  =>  TransRec.IntFromModel <= WriteAddressDelayCov.ID  ;\n            when WRITE_DATA_ID     =>  TransRec.IntFromModel <= WriteDataDelayCov.ID     ;\n            when WRITE_RESPONSE_ID =>  TransRec.IntFromModel <= WriteResponseDelayCov.ID ;\n            when READ_ADDRESS_ID   =>  TransRec.IntFromModel <= ReadAddressDelayCov.ID   ;\n            when READ_DATA_ID      =>  TransRec.IntFromModel <= ReadDataDelayCov.ID      ;\n            when others =>  Alert(ModelID, \"GetDelayCoverageID, Invalid ID requested = \" & to_string(TransRec.IntToModel), FAILURE) ;  \n          end case ; \n          UseCoverageDelays <= TRUE ; \n\n        when GET_TRANSACTION_COUNT =>\n          TransRec.IntFromModel <= integer(TransRec.Rdy) ;\n\n        when GET_WRITE_TRANSACTION_COUNT =>\n          TransRec.IntFromModel <= WriteAddressReceiveCount ;\n\n        when GET_READ_TRANSACTION_COUNT =>\n          TransRec.IntFromModel <= ReadAddressReceiveCount ;\n\n        when WRITE_OP | WRITE_ADDRESS | WRITE_DATA |\n             ASYNC_WRITE | ASYNC_WRITE_ADDRESS | ASYNC_WRITE_DATA =>\n\n          if (IsTryWriteAddress(TransRec.Operation) and empty(WriteAddressFifo)) or\n             (IsTryWriteData(TransRec.Operation)    and empty(WriteDataFifo)) then\n            WriteAvailable         := FALSE ;\n            TransRec.DataFromModel <= (TransRec.DataFromModel'range => '0') ; \n          else\n            WriteAvailable         := TRUE ;\n          end if ;\n          TransRec.BoolFromModel <= WriteAvailable ;\n\n          if WriteAvailable and IsWriteAddress(TransRec.Operation) then\n            -- Find Write Address transaction\n            if empty(WriteAddressFifo) then\n              WaitForToggle(WriteAddressReceiveCount) ;\n            end if ;\n\n            (LocalAW.Addr, LocalAW.Prot) := pop(WriteAddressFifo) ;\n            TransRec.Address       <= SafeResize(LocalAW.Addr, TransRec.Address'length) ;\n            WriteAddressTransactionCount := Increment(WriteAddressTransactionCount) ; \n\n  --!! Address checks intentionally removed - only want an error if the value changes.  \n  --          AlertIf(ModelID, TransRec.AddrWidth /= AXI_ADDR_WIDTH, \"SlaveGetWrite, Address length does not match\", FAILURE) ;\n  --!! Add checking for AWProt?\n  --     Suppress signaling of error during timeout?  return \"----\" on timeout\n  --          AlertIfNotEqual(ModelID, LocalAW.Prot, ModelWProt, \"SlaveGetWrite, WProt\", ERROR) ;\n          end if ;\n\n          if WriteAvailable and IsWriteData(TransRec.Operation) then\n            -- Find Write Data transaction\n            if empty(WriteDataFifo) then\n              WaitForToggle(WriteDataReceiveCount) ;\n            end if ;\n\n            (LocalWD.Data, LocalWD.Strb, LocalWD.Last, LocalWD.User, LocalWD.ID) := pop(WriteDataFifo) ;\n\n            if IsWriteAddress(TransRec.Operation) then\n              WriteByteAddr := CalculateByteAddress(LocalAW.Addr, AXI_BYTE_ADDR_WIDTH) ;\n            else \n              -- Calculate byte address based on strobes\n              WriteByteAddr := 0 ; \n              for i in LocalWD.Strb'reverse_range loop \n                exit when LocalWD.Strb(i) = '1' ; \n                WriteByteAddr := WriteByteAddr + 1 ; \n              end loop ; \n            end if ; \n            \n            GetAxi4Parameter(Params, WRITE_DATA_FILTER_UNDRIVEN, FilterUndrivenWriteData) ;\n            GetAxi4Parameter(Params, WRITE_DATA_UNDRIVEN_VALUE,  UndrivenWriteDataValue) ;\n            if FilterUndrivenWriteData then\n              FilterUndrivenData(LocalWD.Data, LocalWD.Strb, UndrivenWriteDataValue) ;\n            end if ;\n\n            \n            LocalWD.Data := AlignDataBusToBytes(LocalWD.Data, TransRec.DataWidth, WriteByteAddr) ;\n            TransRec.DataFromModel  <= SafeResize(LocalWD.Data, TransRec.DataFromModel'length) ;\n            \n            if LocalWD.Last = '1' then\n              WriteDataTransactionCount := Increment(WriteDataTransactionCount) ; \n            end if ;\n\n\n            -- Check Data Size\n            CheckDataIsBytes(ModelID, TransRec.DataWidth, \"GetWrite\", WriteDataTransactionCount) ;\n            CheckDataWidth(ModelID, TransRec.DataWidth, WriteByteAddr, AXI_DATA_WIDTH, \"GetWrite\", WriteDataTransactionCount) ; \n\n  --!! ??? Add Checking for WSTRB?\n  -- Works for SlaveGetWriteData - but only if access is correct sized, but not SlaveGetWrite\n  --          -- Check WStrb\n  --          ByteCount := TransRec.DataWidth / 8 ;\n  --          ExpectedWStrb := CalculateWriteStrobe(WriteByteAddr, ByteCount, AXI_DATA_BYTE_WIDTH) ;\n  --          AlertIfNotEqual(ModelID, LocalWD.Strb, ExpectedWStrb, \"SlaveGetWrite, WStrb\", ERROR) ;\n\n          end if ;\n\n          if WriteAddressTransactionCount /= WriteResponseTransactionCount and \n                WriteDataTransactionCount /= WriteResponseTransactionCount then\n            push(WriteResponseFifo, ModelBResp) ;\n            increment(WriteReceiveCount) ;\n            WriteResponseTransactionCount := Increment(WriteResponseTransactionCount) ; \n          end if ;\n\n  --    -- Log this operation\n  --    Log(ModelID,\n  --      \"Write Operation.\" &\n  --      \"  AWAddr: \"    & to_hxstring(LocalAW.Addr) &\n  --      \"  AWProt: \"    & to_string(LocalAW.Prot) &\n  --      \"  WData: \"     & to_hxstring(LocalWD.Data) &\n  --      \"  WStrb: \"     & to_string(LocalWD.Strb) &\n  --      \"  Operation# \" & to_string(WriteReceiveCount),\n  --      DEBUG\n  --    ) ;\n\n          wait for 0 ns ;\n\n\n        when READ_OP | READ_ADDRESS | READ_DATA |\n             ASYNC_READ | ASYNC_READ_ADDRESS | ASYNC_READ_DATA =>\n\n          if (IsTryReadAddress(TransRec.Operation) and empty(ReadAddressFifo)) then\n            ReadAvailable          := FALSE ;\n          else\n            ReadAvailable          := TRUE ;\n          end if ;\n          TransRec.BoolFromModel <= ReadAvailable ;\n\n          if ReadAvailable and IsReadAddress(TransRec.Operation) then\n            -- Expect Read Address Cycle\n            if empty(ReadAddressFifo) then\n              WaitForToggle(ReadAddressReceiveCount) ;\n            end if ;\n            (LocalAR.Addr, LocalAR.Prot)  := pop(ReadAddressFifo) ;\n            TransRec.Address         <= SafeResize(LocalAR.Addr, TransRec.Address'length) ;\n  --         AlertIf(ModelID, TransRec.AddrWidth /= AXI_ADDR_WIDTH, \"Slave Read, Address length does not match\", FAILURE) ;\n  --!TODO Add Check here for actual PROT vs expected (ModelRProt)\n  --        TransRec.Prot           <= to_integer(LocalAR.Prot) ;\n          end if ;\n\n          if ReadAvailable and IsReadData(TransRec.Operation) then\n            LocalAR.Addr := pop(ReadAddressTransactionFifo) ;\n            ReadByteAddr  :=  CalculateByteAddress(LocalAR.Addr, AXI_BYTE_ADDR_WIDTH);\n\n            -- Data Sizing Checks\n            CheckDataIsBytes(ModelID, TransRec.DataWidth, \"Read Data\", ReadDataRequestCount) ;\n            CheckDataWidth  (ModelID, TransRec.DataWidth, ReadByteAddr, AXI_DATA_WIDTH, \"Read Data\", ReadDataRequestCount) ; \n   \n            -- Get Read Data Response Values\n            LocalRD.Data  := AlignBytesToDataBus(SafeResize(TransRec.DataToModel, LocalRD.Data'length), TransRec.DataWidth, ReadByteAddr) ;\n            push(ReadDataFifo, LocalRD.Data & ModelRResp) ;\n            Increment(ReadDataRequestCount) ;\n\n  -- Currently all ReadData Operations are Async\n  -- Add blocking until completion here\n          end if ;\n\n          wait for 0 ns ;\n         \n        when SET_MODEL_OPTIONS =>\n          -- Set Model Options\n          Axi4Option := Axi4OptionsType'val(TransRec.Options) ;\n          if IsAxiParameter(Axi4Option) then\n            SetAxi4Parameter(Params, Axi4Option, TransRec.IntToModel) ;\n          else\n            case Axi4Option is\n              -- RESP Settings\n              when BRESP =>                ModelBResp <= to_slv(TransRec.IntToModel, ModelBResp'length) ;\n              when RRESP =>                ModelRResp <= to_slv(TransRec.IntToModel, ModelRResp'length) ;\n              -- ID Settings\n              when BID =>                  ModelBID <= to_slv(TransRec.IntToModel, ModelBID'length) ;\n              when RID =>                  ModelRID <= to_slv(TransRec.IntToModel, ModelRID'length) ;\n              -- User Settings\n              when BUSER =>                ModelBUser <= to_slv(TransRec.IntToModel, ModelBUser'length) ;\n              when RUSER =>                ModelRUser <= to_slv(TransRec.IntToModel, ModelRUser'length) ;\n              --\n              -- The End -- Done\n              when others =>              \n                Alert(ModelID, \"SetOptions, Unimplemented Option: \" & to_string(Axi4OptionsType'val(TransRec.Options)), FAILURE) ;\n            end case ;\n          end if ;\n\n        when GET_MODEL_OPTIONS =>\n          Axi4Option := Axi4OptionsType'val(TransRec.Options) ;\n          if IsAxiParameter(Axi4Option) then\n            GetAxi4Parameter(Params, Axi4Option, Axi4OptionVal) ;\n            TransRec.IntFromModel <= Axi4OptionVal ;\n          else\n            case Axi4Option is\n              -- RESP Settings\n              when BRESP =>                TransRec.IntFromModel <= to_integer(ModelBResp) ;\n              when RRESP =>                TransRec.IntFromModel <= to_integer(ModelRResp) ;\n              -- ID Settings\n              when BID =>                  TransRec.IntFromModel <= to_integer(ModelBID) ;\n              when RID =>                  TransRec.IntFromModel <= to_integer(ModelRID) ;\n              -- User Settings\n              when BUSER =>                TransRec.IntFromModel <= to_integer(ModelBUser) ;\n              when RUSER =>                TransRec.IntFromModel <= to_integer(ModelRUser) ;\n              --\n              -- The End -- Done\n              when others =>              \n                Alert(ModelID, \"GetOptions, Unimplemented Option: \" & to_string(Axi4OptionsType'val(TransRec.Options)), FAILURE) ;\n            end case ;\n          end if ;\n\n          when MULTIPLE_DRIVER_DETECT =>\n            Alert(ModelID, \"Multiple Drivers on Transaction Record.\" & \n                           \"  Transaction # \" & to_string(TransRec.Rdy), FAILURE) ;\n\n        when others =>\n            Alert(ModelID, \"Unimplemented Transaction: \" & to_string(TransRec.Operation), FAILURE) ;\n      end case ;\n\n      -- Wait for 1 delta cycle, required if a wait is not in all case branches above\n      wait for 0 ns ;\n    end loop DispatchLoop ; \n\n  end process TransactionDispatcher ;\n\n  ------------------------------------------------------------\n  --  WriteAddressHandler\n  --    Execute Write Address Transactions\n  ------------------------------------------------------------\n  WriteAddressHandler : process\n    alias    AW : AxiBus.WriteAddress'subtype is AxiBus.WriteAddress ;\n    variable ReadyBeforeValid    : boolean := TRUE ;\n    variable intReadyBeforeValid : integer ;\n    variable ReadyDelayCycles    : integer := 0 ;\n  begin\n    AW.Ready <= '0' ;\n    wait for 0 ns ; -- Allow Cov models to initialize \n    wait for 0 ns ; -- Allow Cov models to initialize \n    AddBins (WriteAddressDelayCov.BurstLengthCov,  GenBin(2,10,1)) ;\n    -- Delays for Ready\n    AddCross(WriteAddressDelayCov.BurstDelayCov,   GenBin(0,1,1), GenBin(2,5,1)) ;\n    AddCross(WriteAddressDelayCov.BeatDelayCov,    GenBin(0),     GenBin(0)) ;  -- No beat delay\n    WaitForClock(Clk, 2) ;  -- Initialize\n\n    WriteAddressOperation : loop\n      if UseCoverageDelays then \n        -- BurstCoverage Delays\n        (intReadyBeforeValid, ReadyDelayCycles)  := GetRandDelay(WriteAddressDelayCov) ; \n        ReadyBeforeValid := intReadyBeforeValid = 0 ; \n      else\n        -- Deprecated static settings\n        GetAxi4Parameter(Params, WRITE_ADDRESS_READY_BEFORE_VALID, ReadyBeforeValid) ;\n        GetAxi4Parameter(Params, WRITE_ADDRESS_READY_DELAY_CYCLES, ReadyDelayCycles) ;\n      end if ; \n\n      ---------------------\n      DoAxiReadyHandshake (\n      ---------------------\n        Clk                     => Clk,\n        Valid                   => AxiBus.WriteAddress.Valid,\n        Ready                   => AxiBus.WriteAddress.Ready,\n        ReadyBeforeValid        => ReadyBeforeValid,\n        ReadyDelayCycles        => ReadyDelayCycles * tperiod_Clk,\n        tpd_Clk_Ready           => tpd_Clk_AWReady,\n        AlertLogID              => BusFailedID -- ,\n--        TimeOutMessage          => \"Write Address # \" & to_string(WriteAddressReceiveCount + 1)\n      ) ;\n\n      -- capture address, prot\n      push(WriteAddressFifo, AW.Addr & AW.Prot) ;\n\n      -- Log this operation\n      Log(ModelID,\n        \"Write Address.\" &\n        \"  AWAddr: \"  & to_hxstring(AW.Addr) &\n        \"  AWProt: \"  & to_string(AW.Prot) &\n        \"  Operation# \" & to_string(WriteAddressReceiveCount + 1),\n        INFO\n      ) ;\n\n      -- Signal completion\n      increment(WriteAddressReceiveCount) ;\n      wait for 0 ns ;\n    end loop WriteAddressOperation ;\n  end process WriteAddressHandler ;\n\n\n  ------------------------------------------------------------\n  --  WriteDataHandler\n  --    Execute Write Data Transactions\n  ------------------------------------------------------------\n  WriteDataHandler : process\n    alias    WD : AxiBus.WriteData'subtype is AxiBus.WriteData ;\n    variable ReadyBeforeValid     : boolean := TRUE ;\n    variable intReadyBeforeValid  : integer ;\n    variable ReadyDelayCycles     : integer := 0 ;\n  begin\n    WD.Ready <= '0' ;\n    wait for 0 ns ; -- Allow Cov models to initialize \n    wait for 0 ns ; -- Allow Cov models to initialize \n    AddBins (WriteDataDelayCov.BurstLengthCov,  GenBin(2,10,1)) ;\n    -- Delays for Ready\n    AddCross(WriteDataDelayCov.BurstDelayCov,   GenBin(0,1,1), GenBin(2,5,1)) ;\n    AddCross(WriteDataDelayCov.BeatDelayCov,    GenBin(0),     GenBin(0)) ;  -- No beat delay\n    WaitForClock(Clk, 2) ;  -- Initialize\n\n    WriteDataOperation : loop\n      if UseCoverageDelays then \n        -- BurstCoverage Delays\n        (intReadyBeforeValid, ReadyDelayCycles)  := GetRandDelay(WriteDataDelayCov) ; \n        ReadyBeforeValid := intReadyBeforeValid = 0 ; \n      else\n        -- Deprecated static delays\n        GetAxi4Parameter(Params, WRITE_DATA_READY_BEFORE_VALID, ReadyBeforeValid) ;\n        GetAxi4Parameter(Params, WRITE_DATA_READY_DELAY_CYCLES, ReadyDelayCycles) ;\n      end if ; \n\n      ---------------------\n      DoAxiReadyHandshake(\n      ---------------------\n        Clk                     => Clk,\n        Valid                   => AxiBus.WriteData.Valid,\n        Ready                   => AxiBus.WriteData.Ready,\n        ReadyBeforeValid        => ReadyBeforeValid,\n        ReadyDelayCycles        => ReadyDelayCycles * tperiod_Clk,\n        tpd_Clk_Ready           => tpd_Clk_WReady,  \n        AlertLogID              => BusFailedID  -- ,\n--        TimeOutMessage          => \"Write Data # \" & to_string(WriteDataReceiveCount + 1)\n      ) ;\n\n      -- capture Data, wstrb\n      if WD.Valid = '1' then\n        push(WriteDataFifo, WD.Data & WD.Strb & WD.Last & WD.User & WD.ID) ;\n      else\n        -- On failure to receive Valid, assert LAST\n        push(WriteDataFifo, WD.Data & WD.Strb & '1' & WD.User & WD.ID) ;\n      end if ;\n\n      -- Log this operation\n      Log(ModelID,\n        \"Write Data.\" &\n        \"  WData: \"  & to_hxstring(WD.Data) &\n        \"  WStrb: \"  & to_string(WD.Strb) &\n        \"  Operation# \" & to_string(WriteDataReceiveCount + 1),\n        INFO\n      ) ;\n\n      -- Signal completion\n      increment(WriteDataReceiveCount) ;\n      wait for 0 ns ;\n    end loop WriteDataOperation ;\n  end process WriteDataHandler ;\n\n\n  ------------------------------------------------------------\n  -- WriteResponseHandler\n  --   Receive and Check Write Responses\n  ------------------------------------------------------------\n  WriteResponseHandler : process\n    alias    WR    : AxiBus.WriteResponse'subtype is AxiBus.WriteResponse ;\n    variable Local : AxiBus.WriteResponse'subtype ;\n    variable WriteResponseReadyTimeOut: integer := 25 ;\n    variable DelayCycles : integer ; \n  begin\n    -- initialize\n    WR.Valid <= '0' ;\n    WR.Resp  <= (WR.Resp'range => '0') ;\n    WR.ID    <= (WR.ID'range => '0') ;\n    WR.User  <= (WR.User'range => '0') ;\n    wait for 0 ns ; -- Allow WriteResponseFifo to initialize\n    wait for 0 ns ; -- Allow Cov models to initialize \n    AddBins (WriteResponseDelayCov.BurstLengthCov,  GenBin(2,10,1)) ;\n    AddBins (WriteResponseDelayCov.BurstDelayCov,   GenBin(2,5,1)) ;\n    AddBins (WriteResponseDelayCov.BeatDelayCov,    GenBin(0)) ;\n\n    WriteResponseLoop : loop\n      -- Find Transaction\n--! Done always less than Receive, change to just \"=\"\n--! \">\" will break due to roll over if there are more than 2**30 transfers\n      if WriteResponseDoneCount >= WriteReceiveCount then\n        WaitForToggle(WriteReceiveCount) ;\n      end if ;\n      if not empty(WriteResponseFifo) then\n        Local.Resp := pop(WriteResponseFifo) ;\n      else\n        Local.Resp := AXI4_RESP_OKAY ;\n      end if ;\n      \n      if UseCoverageDelays then \n        -- BurstCoverage Delays\n        DelayCycles := GetRandDelay(WriteResponseDelayCov) ; \n        WaitForClock(Clk, DelayCycles) ;\n      else\n        -- Deprecated delays\n        WaitForClock(Clk, integer'(Params.Get(Axi4OptionsType'POS(WRITE_RESPONSE_VALID_DELAY_CYCLES)))) ; \n      end if ; \n\n      -- Do Transaction\n      WR.Resp  <= Local.Resp  after tpd_Clk_BResp ;\n      WR.ID    <= ModelBID    after tpd_Clk_BID ; \n      WR.User  <= ModelBUser  after tpd_Clk_BUser ; \n\n      Log(ModelID,\n        \"Write Response.\" &\n        \"  BResp: \"  & to_hxstring(Local.Resp) &\n        \"  Operation# \" & to_string(WriteResponseDoneCount + 1),\n        INFO\n      ) ;\n      \n      GetAxi4Parameter(Params, WRITE_RESPONSE_READY_TIME_OUT, WriteResponseReadyTimeOut) ;\n\n      ---------------------\n      DoAxiValidHandshake (\n      ---------------------\n        Clk            =>  Clk,\n        Valid          =>  AxiBus.WriteResponse.Valid,\n        Ready          =>  AxiBus.WriteResponse.Ready,\n        tpd_Clk_Valid  =>  tpd_Clk_BValid,\n        AlertLogID     =>  BusFailedID,\n        TimeOutMessage =>  \"Write Response # \" & to_string(WriteResponseDoneCount + 1),\n        TimeOutPeriod  =>  WriteResponseReadyTimeOut * tperiod_Clk\n      ) ;\n\n      -- State after operation\n      WR.Resp  <= not Local.Resp after tpd_Clk_BResp ;\n      WR.ID    <= not ModelBID    after tpd_Clk_BID ; \n      WR.User  <= not ModelBUser  after tpd_Clk_BUser ; \n\n      -- Signal completion\n      Increment(WriteResponseDoneCount) ;\n      wait for 0 ns ;\n    end loop WriteResponseLoop ;\n  end process WriteResponseHandler ;\n\n  ------------------------------------------------------------\n  --  ReadAddressHandler\n  --    Execute Read Address Transactions\n  ------------------------------------------------------------\n  ReadAddressHandler : process\n    alias    AR : AxiBus.ReadAddress'subtype is AxiBus.ReadAddress ;\n    variable ReadyBeforeValid    : boolean := TRUE ;\n    variable intReadyBeforeValid : integer ;\n    variable ReadyDelayCycles    : integer := 0 ;\n  begin\n    -- Initialize\n    AR.Ready <= '0' ;\n    wait for 0 ns ; -- Allow Cov models to initialize \n    wait for 0 ns ; -- Allow Cov models to initialize \n    AddBins (ReadAddressDelayCov.BurstLengthCov,  GenBin(2,10,1)) ;\n    -- Delays for Ready\n    AddCross(ReadAddressDelayCov.BurstDelayCov,   GenBin(0,1,1), GenBin(2,5,1)) ;\n    AddCross(ReadAddressDelayCov.BeatDelayCov,    GenBin(0),     GenBin(0)) ;  -- No beat delay\n    WaitForClock(Clk, 2) ;  -- Initialize\n\n    ReadAddressOperation : loop\n      if UseCoverageDelays then \n        -- BurstCoverage Delays\n        (intReadyBeforeValid, ReadyDelayCycles)  := GetRandDelay(ReadAddressDelayCov) ; \n        ReadyBeforeValid := intReadyBeforeValid = 0 ; \n      else\n        -- Deprecated static settings\n        GetAxi4Parameter(Params, READ_ADDRESS_READY_BEFORE_VALID, ReadyBeforeValid) ;\n        GetAxi4Parameter(Params, READ_ADDRESS_READY_DELAY_CYCLES, ReadyDelayCycles) ;\n      end if ; \n      \n      ---------------------\n      DoAxiReadyHandshake (\n      ---------------------\n        Clk                     => Clk,\n        Valid                   => AxiBus.ReadAddress.Valid,\n        Ready                   => AxiBus.ReadAddress.Ready,\n        ReadyBeforeValid        => ReadyBeforeValid,\n        ReadyDelayCycles        => ReadyDelayCycles * tperiod_Clk,\n        tpd_Clk_Ready           => tpd_Clk_ARReady,\n        AlertLogID              => BusFailedID  --,\n--        TimeOutMessage          => \"Read Address # \" & to_string(ReadAddressReceiveCount + 1)\n      ) ;\n\n      -- capture address, prot\n      push(ReadAddressFifo, AR.Addr & AR.Prot) ;\n      push(ReadAddressTransactionFifo, AR.Addr) ;\n      increment(ReadAddressReceiveCount) ;\n      wait for 0 ns ;\n\n      Log(ModelID,\n        \"Read Address.\" &\n        \"  ARAddr: \"  & to_hxstring(AR.Addr) &\n        \"  ARProt: \"  & to_string(AR.Prot) &\n        \"  Operation# \" & to_string(ReadAddressReceiveCount), -- adjusted for delay of ReadAddressReceiveCount\n        INFO\n      ) ;\n    end loop ReadAddressOperation ;\n  end process ReadAddressHandler ;\n\n  ------------------------------------------------------------\n  --  ReadDataHandler\n  --    Receive Read Data Transactions\n  ------------------------------------------------------------\n  ReadDataHandler : process\n    alias    RD    : AxiBus.ReadData'subtype is AxiBus.ReadData ;\n    variable Local : AxiBus.ReadData'subtype ;\n    variable ReadDataReadyTimeOut: integer := 25 ;\n    variable DelayCycles : integer ; \n  begin\n    -- initialize\n    RD.Valid <= '0' ;\n    RD.Data  <= (RD.Data'range => '0') ;\n    RD.Resp  <= (RD.Resp'range => '0') ;\n    RD.ID    <= (RD.ID'range => '0') ;\n    RD.User  <= (RD.User'range => '0') ; \n    wait for 0 ns ; -- Allow ReadDataFifo to initialize\n    wait for 0 ns ; -- Allow Cov models to initialize \n    AddBins (ReadDataDelayCov.BurstLengthCov,  GenBin(2,10,1)) ;\n    AddBins (ReadDataDelayCov.BurstDelayCov,   GenBin(2,5,1)) ;\n    AddBins (ReadDataDelayCov.BeatDelayCov,    GenBin(0)) ;\n\n    ReadDataLoop : loop\n      -- Start a Read Data Response Transaction after receiving a read address\n      if ReadAddressReceiveCount <= ReadDataDoneCount then\n        WaitForToggle(ReadAddressReceiveCount) ;\n      end if ;\n\n      if UseCoverageDelays then \n        -- BurstCoverage Delays\n        DelayCycles := GetRandDelay(ReadDataDelayCov) ; \n        WaitForClock(Clk, DelayCycles) ;\n      else\n        -- Deprecated delays\n        WaitForClock(Clk, integer'(Params.Get(Axi4OptionsType'POS(READ_DATA_VALID_DELAY_CYCLES)))) ; \n      end if ;\n\n      if empty(ReadDataFifo) then\n        WaitForToggle(ReadDataRequestCount) ;\n      end if ;\n\n      (Local.Data, Local.Resp) := pop(ReadDataFifo) ;\n\n--      -- Find Response if available\n--      if not empty(ReadDataFifo) then\n--        (Local.Data, Local.Resp) := pop(ReadDataFifo) ;\n--      else\n--        Local.Data := to_slv(ReadAddressReceiveCount, RData'length) ;\n--        Local.Resp := AXI4_RESP_OKAY ;\n--      end if ;\n\n      -- Transaction Values\n      RD.Data  <= Local.Data  after tpd_Clk_RDATA ;\n      RD.Resp  <= Local.Resp  after tpd_Clk_RResp ;\n      RD.ID    <= ModelRID    after tpd_Clk_RID ; \n      RD.User  <= ModelRUser  after tpd_Clk_RUser ; \n\n      Log(ModelID,\n        \"Read Data.\" &\n        \"  RData: \"  & to_hxstring(Local.Data) &\n        \"  RResp: \"  & to_hxstring(Local.Resp) &\n        \"  Operation# \" & to_string(ReadDataDoneCount + 1),\n        INFO\n      ) ;\n\n      GetAxi4Parameter(Params, READ_DATA_READY_TIME_OUT, ReadDataReadyTimeOut) ;\n      \n      ---------------------\n      DoAxiValidHandshake (\n      ---------------------\n        Clk            =>  Clk,\n        Valid          =>  AxiBus.ReadData.Valid,\n        Ready          =>  AxiBus.ReadData.Ready,\n        tpd_Clk_Valid  =>  tpd_Clk_RValid,\n        AlertLogID     =>  BusFailedID,\n        TimeOutMessage =>  \"Read Data # \" & to_string(ReadDataDoneCount + 1),\n        TimeOutPeriod  =>  ReadDataReadyTimeOut * tperiod_Clk\n      ) ;\n\n      -- State after operation\n      RD.Valid <= '0' after tpd_Clk_RValid ;\n      RD.Data  <= not Local.Data after tpd_clk_RData ;\n      RD.Resp  <= not Local.Resp after tpd_Clk_RResp ;\n      RD.ID    <= not ModelRID    after tpd_Clk_RID ; \n      RD.User  <= not ModelRUser  after tpd_Clk_RUser ; \n\n      -- Signal completion\n      Increment(ReadDataDoneCount) ;\n      wait for 0 ns ;\n    end loop ReadDataLoop ;\n  end process ReadDataHandler ;\nend architecture Transactor ;\n","lang":"vhdl"};
processSrcData(g_data);