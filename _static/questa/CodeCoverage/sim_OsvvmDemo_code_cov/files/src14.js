var g_data = {"name":"C:/SynthWorks/Dev/_osvvm/OsvvmLibraries/Common/src/FifoFillPkg_slv.vhd","src":"--\n--  File Name:         FifoFillPkg_slv.vhd\n--  Design Unit Name:  FifoFillPkg_slv\n--  Revision:          STANDARD VERSION\n--\n--  Maintainer:        Jim Lewis      email:  jim@synthworks.com\n--  Contributor(s):\n--     Jim Lewis          email:  jim@synthworks.com\n--\n--\n--  Description:\n--    Fill and check data in burst fifos \n--    Defines type ScoreBoardPType\n--    Defines methods for putting values the scoreboard\n--\n--  Developed for:\n--        SynthWorks Design Inc.\n--        VHDL Training Classes\n--        11898 SW 128th Ave.  Tigard, Or  97223\n--        http://www.SynthWorks.com\n--\n--  Revision History:\n--    Date      Version     Description\n--    10/2022   2022.10     Updated PushBurstRandom and CheckBurstRandom for bugs in Questa Intel edition 2021.2 \n--    01/2022   2022.01     Added new burst patterns\n--    06/2021   2021.06     Updated to work with new FIFO/Scoreboard data structures\n--    10/2020   2020.10     Updating comments to serve as documentation\n--    09/2020   2020.09     Updating comments to serve as documentation\n--    05/2020   2020.05     Initial revision\n--\n--  This file is part of OSVVM.\n--  \n--  Copyright (c) 2020 by SynthWorks Design Inc.  \n--  \n--  Licensed under the Apache License, Version 2.0 (the \"License\");\n--  you may not use this file except in compliance with the License.\n--  You may obtain a copy of the License at\n--  \n--      https://www.apache.org/licenses/LICENSE-2.0\n--  \n--  Unless required by applicable law or agreed to in writing, software\n--  distributed under the License is distributed on an \"AS IS\" BASIS,\n--  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n--  See the License for the specific language governing permissions and\n--  limitations under the License.\n--  \n\n\nuse std.textio.all ;\n\nlibrary ieee ;\n  use ieee.std_logic_1164.all ;\n  use ieee.numeric_std.all ;\n  use ieee.numeric_std_unsigned.all ;\n  \nlibrary osvvm ; \n  context osvvm.OsvvmContext ;   \n  use osvvm.ScoreboardPkg_slv.all ;\n\npackage FifoFillPkg_slv is\n  ------------------------------------------------------------\n  procedure PushBurstVector (\n  -- Push each value in the VectorOfWords parameter into the FIFO.   \n  -- FifoWidth must match the std_logic_vector parameter.    \n  ------------------------------------------------------------\n    constant Fifo          : In    ScoreboardIdType ;\n    constant VectorOfWords : In    slv_vector \n  ) ;\n\n  ------------------------------------------------------------\n  procedure PushBurstVector (\n  -- Push each value in the VectorOfWords parameter into the FIFO.   \n  -- Only FifoWidth bits of each value will be pushed.    \n  ------------------------------------------------------------\n    constant Fifo           : in    ScoreboardIdType ;\n    constant VectorOfWords  : in    integer_vector ;\n    constant FifoWidth      : in    integer\n  ) ;\n\n  ------------------------------------------------------------\n  procedure PushBurstIncrement (\n  -- Push Count number of values into FIFO.  The first value \n  -- pushed will be FirstWord and following values are one greater \n  -- than the previous one.  \n  -- FifoWidth must match the std_logic_vector parameter.    \n  ------------------------------------------------------------\n    constant Fifo           : In    ScoreboardIdType ;\n    constant FirstWord      : In    std_logic_vector ;\n    constant Count          : In    integer \n  ) ;\n\n  ------------------------------------------------------------\n  procedure PushBurstIncrement (\n  -- Push Count number of values into FIFO.  The first value \n  -- pushed will be FirstWord and following values are one greater \n  -- than the previous one.  \n  -- Only FifoWidth bits of each value will be pushed.    \n  ------------------------------------------------------------\n    constant Fifo         : in    ScoreboardIdType ;\n    constant FirstWord    : in    integer ;\n    constant Count        : in    integer ;\n    constant FifoWidth    : in    integer := 8\n  ) ;\n  \n  ------------------------------------------------------------\n  procedure PushBurstRandom (\n  -- Push Count number of values into FIFO.  The first value \n  -- pushed will be FirstWord and following values are randomly generated \n  -- using the first value as the randomization seed.\n  -- FifoWidth must match the std_logic_vector parameter.    \n  ------------------------------------------------------------\n    constant Fifo           : In    ScoreboardIdType ;\n    constant FirstWord      : In    std_logic_vector ;\n    constant Count          : In    integer \n  ) ;\n\n  ------------------------------------------------------------\n  procedure PushBurstRandom (\n  -- Push Count number of values into FIFO.  The first value \n  -- pushed will be FirstWord and following values are randomly generated \n  -- using the first value as the randomization seed.\n  -- Only FifoWidth bits of each value will be pushed.    \n  ------------------------------------------------------------\n    constant Fifo         : in    ScoreboardIdType ;\n    constant FirstWord    : in    integer ;\n    constant Count        : in    integer ;\n    constant FifoWidth    : in    integer := 8\n  ) ;\n  \n  ------------------------------------------------------------\n  -- Experimental and Provisional\n  procedure PushBurstRandom (\n  -- Push Count number of values into FIFO.  Values are \n  -- randomly generated using the coverage model.\n  -- Only FifoWidth bits of each value will be pushed.    \n  ------------------------------------------------------------\n    constant Fifo         : in    ScoreboardIdType ;\n    constant CoverID      : in    CoverageIdType ;\n    constant Count        : in    integer ;\n    constant FifoWidth    : in    integer := 8\n  ) ;\n\n  ------------------------------------------------------------\n  procedure PopBurstVector (\n  -- Pop values from the FIFO into the VectorOfWords parameter.\n  -- Width of VectorOfWords(i) shall match the width of the Fifo \n  ------------------------------------------------------------\n    constant Fifo           : in    ScoreboardIdType ;\n    variable VectorOfWords  : out   slv_vector \n  ) ;\n\n  ------------------------------------------------------------\n  procedure PopBurstVector (\n  -- Pop values from the FIFO into the VectorOfWords parameter.\n  -- Each value popped will be FifoWidth bits wide.   \n  ------------------------------------------------------------\n    constant Fifo           : in    ScoreboardIdType ;\n    variable VectorOfWords  : out   integer_vector \n  ) ;\n\n  ------------------------------------------------------------\n  procedure CheckBurstFifo (\n  -- Check received values from the FIFO against \n  -- expected values in the scoreboard\n  ------------------------------------------------------------\n    constant Scoreboard     : in    ScoreboardIdType ;\n    constant Fifo           : in    ScoreboardIdType ;\n    constant Count          : in    integer \n  ) ;\n\n  ------------------------------------------------------------\n  procedure CheckBurstVector (\n  -- Check values from the FIFO against the values \n  -- in the VectorOfWords parameter.   \n  -- Width of VectorOfWords(i) shall match the width of the Fifo \n  ------------------------------------------------------------\n    constant Fifo           : in    ScoreboardIdType ;\n    constant VectorOfWords  : in    slv_vector \n  ) ;\n\n  ------------------------------------------------------------\n  procedure CheckBurstVector (\n  -- Check values from the FIFO against the values \n  -- in the VectorOfWords parameter.   \n  -- Each value of VectorOfWords shall be converted to FifoWidth bits wide.   \n  ------------------------------------------------------------\n    constant Fifo           : in    ScoreboardIdType ;\n    constant VectorOfWords  : in    integer_vector ;\n    constant FifoWidth      : in    integer\n  ) ;\n\n  ------------------------------------------------------------\n  procedure CheckBurstIncrement (\n  -- Check values from the FIFO against the incrementing values \n  -- that start with the value of the FirstWord.\n  -- Width of FirstWord shall match the width of the Fifo \n  ------------------------------------------------------------\n    constant Fifo         : in    ScoreboardIdType ;\n    constant FirstWord    : in    std_logic_vector ;\n    constant Count        : in    integer \n  ) ;\n  \n  ------------------------------------------------------------\n  procedure CheckBurstIncrement (\n  -- Check values from the FIFO against the incrementing values \n  -- that start with the value of the FirstWord.\n  -- Each value of VectorOfWords shall be converted to FifoWidth bits wide.   \n  ------------------------------------------------------------\n    constant Fifo         : in    ScoreboardIdType ;\n    constant FirstWord    : in    integer ;\n    constant Count        : in    integer ;\n    constant FifoWidth    : in    integer := 8\n  ) ;\n\n  ------------------------------------------------------------\n  procedure CheckBurstRandom (\n  -- Check values from the FIFO against the random values \n  -- that are generated using the value of the FirstWord and \n  -- NumFifoWords as the randomization seeds.\n  -- Width of FirstWord shall match the width of the Fifo \n  ------------------------------------------------------------\n    constant Fifo         : in    ScoreboardIdType ;\n    constant FirstWord    : in    std_logic_vector ;\n    constant Count        : in    integer \n  ) ;\n  \n  ------------------------------------------------------------\n  procedure CheckBurstRandom (\n  -- Check values from the FIFO against the random values \n  -- that are generated using the value of the FirstWord and \n  -- Count as the randomization seeds.\n  -- Each value of VectorOfWords shall be converted to FifoWidth bits wide.   \n  ------------------------------------------------------------\n    constant Fifo         : in    ScoreboardIdType ;\n    constant FirstWord    : in    integer ;\n    constant Count        : in    integer ;\n    constant FifoWidth    : in    integer := 8\n  ) ;\n\n  ------------------------------------------------------------\n  -- Experimental and Provisional\n  procedure CheckBurstRandom (\n  ------------------------------------------------------------\n    constant Fifo         : in    ScoreboardIdType ;\n    constant CoverID      : in    CoverageIdType ;\n    constant Count        : in    integer ;\n    constant FifoWidth    : in    integer := 8\n  ) ;\n\n  -- ========================================================\n  --  Verification Component Support\n  -- ========================================================\n\n  ------------------------------------------------------------\n  procedure PopWord (\n  -- Pop bytes from BurstFifo and form a word \n  -- Current implementation for now assumes it is assembling bytes.   \n  --\n  ------------------------------------------------------------\n    constant Fifo              : in    ScoreboardIdType ;\n    variable Valid             : out   boolean ;\n    variable Data              : out   std_logic_vector ; \n    variable BytesToSend       : inout integer ;\n    constant ByteAddress       : in    natural := 0 \n  ) ; \n\n  ------------------------------------------------------------\n  procedure PushWord (\n  -- Push a word into the byte oriented BurstFifo\n  -- Current implementation for now assumes it is assembling bytes.   \n  --\n  ------------------------------------------------------------\n    constant Fifo              : in    ScoreboardIdType ;\n    variable Data              : in    std_logic_vector ; \n    constant DropUndriven      : in    boolean := FALSE ;\n    constant ByteAddress       : in    natural := 0 \n  ) ; \n  \n  ------------------------------------------------------------\n  procedure CheckWord (\n  -- Check a word using the byte oriented BurstFifo\n  -- Current implementation for now assumes it is assembling bytes.   \n  --\n  ------------------------------------------------------------\n    constant Fifo              : in    ScoreboardIdType ;\n    variable Data              : in    std_logic_vector ; \n    constant DropUndriven      : in    boolean := FALSE ;\n    constant ByteAddress       : in    natural := 0 \n  ) ;\n\n  ------------------------------------------------------------\n  function CountBytes(\n  -- Count number of bytes in a word\n  --\n  ------------------------------------------------------------\n    constant Data              : in    std_logic_vector ;\n    constant DropUndriven      : in    boolean := FALSE ;\n    constant ByteAddress       : in    natural := 0 \n  ) return integer ;\n  \n  -- ========================================================\n  --  Deprecated\n  -- ========================================================\n\n  ------------------------------------------------------------\n  -- Deprecated and replaced by PushBurstVector\n  procedure PushBurst (\n  -- Push each value in the VectorOfWords parameter into the FIFO.   \n  -- Only FifoWidth bits of each value will be pushed.    \n  ------------------------------------------------------------\n    constant Fifo           : in    ScoreboardIdType ;\n    constant VectorOfWords  : in    integer_vector ;\n    constant FifoWidth      : in    integer := 8\n  ) ;\n\n  ------------------------------------------------------------\n  -- Deprecated and replaced by CheckBurstVector\n  procedure CheckBurst (\n  -- Pop values from the FIFO and check them against each value \n  -- in the VectorOfWords parameter.   \n  -- Each value popped will be FifoWidth bits wide.   \n  ------------------------------------------------------------\n    constant Fifo           : in    ScoreboardIdType ;\n    constant VectorOfWords  : in    integer_vector ;\n    constant FifoWidth      : in    integer := 8\n  ) ;\n\nend package FifoFillPkg_slv ;\n-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\npackage body FifoFillPkg_slv is\n  constant NUMBER_POSITIVE_INTEGER_BITS : integer := 31 ; \n\n  ------------------------------------------------------------\n  procedure PushBurstVector (\n  ------------------------------------------------------------\n    constant Fifo          : In    ScoreboardIdType ;\n    constant VectorOfWords : In    slv_vector \n  ) is\n  begin\n    for i in VectorOfWords'range loop\n      Push( Fifo, VectorOfWords(i) ) ;\n    end loop ; \n  end procedure PushBurstVector ;\n\n  ------------------------------------------------------------\n  procedure PushBurstVector (\n  ------------------------------------------------------------\n    constant Fifo           : in    ScoreboardIdType ;\n    constant VectorOfWords  : in    integer_vector ;\n    constant FifoWidth      : in    integer\n  ) is\n  begin\n    for i in VectorOfWords'range loop \n      if VectorOfWords(i) < 0 then \n        Push(Fifo, (FifoWidth downto 1 => 'U')) ;\n      elsif FifoWidth < NUMBER_POSITIVE_INTEGER_BITS then \n        Push(Fifo, to_slv(VectorOfWords(i) mod (2**FifoWidth), FifoWidth)) ;\n      else \n        Push(Fifo, to_slv(VectorOfWords(i), FifoWidth)) ;\n      end if ; \n    end loop ;\n  end procedure PushBurstVector ;\n\n  ------------------------------------------------------------\n  procedure PushBurstIncrement (\n  ------------------------------------------------------------\n    constant Fifo           : In    ScoreboardIdType ;\n    constant FirstWord      : In    std_logic_vector ;\n    constant Count          : In    integer \n  ) is\n  begin\n    for i in 0 to Count-1 loop\n      Push( Fifo, FirstWord+i ) ;\n    end loop ; \n  end procedure PushBurstIncrement ;\n  \n  ------------------------------------------------------------\n  procedure PushBurstIncrement (\n  ------------------------------------------------------------\n    constant Fifo         : in    ScoreboardIdType ;\n    constant FirstWord    : in    integer ;\n    constant Count        : in    integer ;\n    constant FifoWidth    : in    integer := 8\n  ) is\n    variable intFirstWord : integer ; \n    variable AdjFirstWord : std_logic_vector(FifoWidth-1 downto 0) ;\n  begin\n    if FirstWord < 0 then \n      intFirstWord := -FirstWord ; \n    else\n      intFirstWord := FirstWord ; \n    end if ; \n    if FifoWidth < NUMBER_POSITIVE_INTEGER_BITS then \n      AdjFirstWord := to_slv(intFirstWord mod (2**FifoWidth), FifoWidth) ;\n    else\n      AdjFirstWord := to_slv(intFirstWord, FifoWidth) ;\n    end if ; \n    for i in 0 to Count-1 loop \n      Push( Fifo, AdjFirstWord+i ) ;\n    end loop ;\n  end procedure PushBurstIncrement ;\n  \n  ------------------------------------------------------------\n  procedure PushBurstRandom (\n  ------------------------------------------------------------\n    constant Fifo           : In    ScoreboardIdType ;\n    constant FirstWord      : In    std_logic_vector ;\n    constant Count          : In    integer \n  ) is\n    variable RV         : RandomPType ; \n    alias    aFirstWord : std_logic_vector(FirstWord'length-1 downto 0) is FirstWord ; \n    constant FW_LEFT    : integer := minimum(30, FirstWord'length) - 1 ;\n  begin\n    RV.InitSeed(to_integer(MetaTo01(aFirstWord(FW_LEFT downto 0))) + Count, UseNewSeedMethods => TRUE) ;\n    Push( Fifo, FirstWord ) ;\n    for i in 2 to Count loop\n      Push( Fifo, RV.RandSlv(FirstWord'length) ) ;\n    end loop ; \n  end procedure PushBurstRandom ;\n\n  ------------------------------------------------------------\n  procedure PushBurstRandom (\n  ------------------------------------------------------------\n    constant Fifo         : in    ScoreboardIdType ;\n    constant FirstWord    : in    integer ;\n    constant Count        : in    integer ;\n    constant FifoWidth    : in    integer := 8\n  ) is\n    variable intFirstWord : integer ; \n--    variable RV : RandomPType ; \n--    variable SlvWord : std_logic_vector(FifoWidth-1 downto 0) ; \n  begin\n    if FirstWord < 0 then \n      intFirstWord := -FirstWord ; \n    else\n      intFirstWord := FirstWord ; \n    end if ; \n\n    PushBurstRandom(Fifo, to_slv(intFirstWord, FifoWidth), Count) ; \n    \n--    -- Initialize seed and toss first random value  \n--    RV.InitSeed(intFirstWord mod 2**30 + Count, UseNewSeedMethods => TRUE) ;\n--    \n--    if FifoWidth < NUMBER_POSITIVE_INTEGER_BITS then \n--      SlvWord := to_slv(intFirstWord mod (2**FifoWidth), FifoWidth) ;\n--    else \n--      SlvWord := to_slv(intFirstWord, FifoWidth) ;\n--    end if ; \n--    Push(Fifo, SlvWord) ;\n--    \n--    for i in 2 to Count loop \n--      -- Extra Var added for QuestaSim\n--      SlvWord := RV.RandSlv(FifoWidth) ;\n--      Push(Fifo, SlvWord) ;\n--    end loop ;\n  end procedure PushBurstRandom ;\n\n  ------------------------------------------------------------\n  -- Experimental and Provisional\n  procedure PushBurstRandom (\n  ------------------------------------------------------------\n    constant Fifo         : in    ScoreboardIdType ;\n    constant CoverID      : in    CoverageIdType ;\n    constant Count        : in    integer ;\n    constant FifoWidth    : in    integer := 8\n  ) is\n    variable RandValue : std_logic_vector(FifoWidth-1 downto 0) ; \n  begin    \n    for i in 1 to Count loop \n      RandValue := to_slv(GetRandPoint(CoverID), FifoWidth) ;\n      Push(Fifo, RandValue) ;\n      ICoverLast(CoverID) ; \n    end loop ;\n  end procedure PushBurstRandom ;\n\n  ------------------------------------------------------------\n  procedure PopBurstVector (\n  ------------------------------------------------------------\n    constant Fifo           : in    ScoreboardIdType ;\n    variable VectorOfWords  : out   slv_vector \n  ) is\n  begin\n    for i in VectorOfWords'range loop \n      VectorOfWords(i) := Pop(Fifo) ; \n    end loop ;\n  end procedure PopBurstVector ;\n\n  ------------------------------------------------------------\n  procedure PopBurstVector (\n  ------------------------------------------------------------\n    constant Fifo           : in    ScoreboardIdType ;\n    variable VectorOfWords  : out   integer_vector \n  ) is\n  begin\n    for i in VectorOfWords'range loop \n      VectorOfWords(i) := to_integer(Pop(Fifo)) ; \n    end loop ;\n  end procedure PopBurstVector ;\n\n  ------------------------------------------------------------\n  procedure CheckBurstFifo (\n  ------------------------------------------------------------\n    constant Scoreboard     : in    ScoreboardIdType ;\n    constant Fifo           : in    ScoreboardIdType ;\n    constant Count          : in    integer \n  ) is\n  begin\n    for i in 1 to Count loop\n      Check(Scoreboard, Pop(Fifo)) ; \n    end loop ; \n  end procedure CheckBurstFifo ;\n\n  ------------------------------------------------------------\n  procedure CheckBurstVector (\n  ------------------------------------------------------------\n    constant Fifo           : in    ScoreboardIdType ;\n    constant VectorOfWords  : in    slv_vector \n  ) is\n  begin\n    for i in VectorOfWords'range loop\n      CheckExpected( Fifo, VectorOfWords(i) ) ;\n    end loop ; \n  end procedure CheckBurstVector ;\n\n  ------------------------------------------------------------\n  procedure CheckBurstVector (\n  ------------------------------------------------------------\n    constant Fifo           : in    ScoreboardIdType ;\n    constant VectorOfWords  : in    integer_vector ;\n    constant FifoWidth      : in    integer \n  ) is\n  begin\n    for i in VectorOfWords'range loop \n      if VectorOfWords(i) < 0 then \n        CheckExpected( Fifo, (FifoWidth downto 1 => 'U') ) ;\n      elsif FifoWidth < NUMBER_POSITIVE_INTEGER_BITS then \n        CheckExpected( Fifo, to_slv(VectorOfWords(i) mod (2**FifoWidth), FifoWidth) ) ;\n      else \n        CheckExpected( Fifo, to_slv(VectorOfWords(i), FifoWidth) ) ;\n      end if ; \n    end loop ;\n  end procedure CheckBurstVector ;\n\n  ------------------------------------------------------------\n  procedure CheckBurstIncrement (\n  ------------------------------------------------------------\n    constant Fifo         : in    ScoreboardIdType ;\n    constant FirstWord    : in    std_logic_vector ;\n    constant Count        : in    integer \n  ) is\n  begin\n    for i in 0 to Count-1 loop\n      CheckExpected( Fifo, FirstWord+i ) ;\n    end loop ; \n  end procedure CheckBurstIncrement ;\n\n  ------------------------------------------------------------\n  procedure CheckBurstIncrement (\n  ------------------------------------------------------------\n    constant Fifo         : in    ScoreboardIdType ;\n    constant FirstWord    : in    integer ;\n    constant Count        : in    integer ;\n    constant FifoWidth    : in    integer := 8\n  ) is\n    variable intFirstWord : integer ; \n    variable AdjFirstWord : std_logic_vector(FifoWidth-1 downto 0) ;\n  begin\n    if FirstWord < 0 then \n      intFirstWord := -FirstWord ; \n    else\n      intFirstWord := FirstWord ; \n    end if ; \n    if FifoWidth < NUMBER_POSITIVE_INTEGER_BITS then \n      AdjFirstWord := to_slv(intFirstWord mod (2**FifoWidth), FifoWidth) ;\n    else\n      AdjFirstWord := to_slv(intFirstWord, FifoWidth) ;\n    end if ; \n    for i in 0 to Count-1 loop \n      CheckExpected( Fifo, AdjFirstWord+i ) ;\n    end loop ;\n  end procedure CheckBurstIncrement ;\n  \n  ------------------------------------------------------------\n  procedure CheckBurstRandom (\n  ------------------------------------------------------------\n    constant Fifo         : in    ScoreboardIdType ;\n    constant FirstWord    : in    std_logic_vector ;\n    constant Count        : in    integer \n  ) is\n    variable RV         : RandomPType ; \n    alias    aFirstWord : std_logic_vector(FirstWord'length-1 downto 0) is FirstWord ; \n    constant FW_LEFT    : integer := minimum(30, FirstWord'length) - 1 ;\n  begin\n    RV.InitSeed(to_integer(MetaTo01(aFirstWord(FW_LEFT downto 0))) + Count, UseNewSeedMethods => TRUE) ;\n    CheckExpected( Fifo, FirstWord ) ;\n    for i in 2 to Count loop\n      CheckExpected( Fifo, RV.RandSlv(FirstWord'length) ) ;\n    end loop ; \n  end procedure CheckBurstRandom ;\n\n  ------------------------------------------------------------\n  procedure CheckBurstRandom (\n  ------------------------------------------------------------\n    constant Fifo         : in    ScoreboardIdType ;\n    constant FirstWord    : in    integer ;\n    constant Count        : in    integer ;\n    constant FifoWidth    : in    integer := 8\n  ) is\n    variable intFirstWord : integer ; \n--    variable RV           : RandomPType ; \n--    variable SlvWord : std_logic_vector(FifoWidth-1 downto 0) ; \n  begin\n    if FirstWord < 0 then \n      intFirstWord := -FirstWord ; \n    else\n      intFirstWord := FirstWord ; \n    end if ; \n    CheckBurstRandom(Fifo, to_slv(intFirstWord, FifoWidth), Count) ; \n    \n--    -- Initialize seed and toss first random value  \n--    RV.InitSeed(intFirstWord mod 2**30 + Count, UseNewSeedMethods => TRUE) ;\n--    \n--    if FifoWidth < NUMBER_POSITIVE_INTEGER_BITS then \n--      SlvWord := to_slv(intFirstWord mod (2**FifoWidth), FifoWidth) ;\n--    else \n--      SlvWord := to_slv(intFirstWord, FifoWidth) ;\n--    end if ; \n--    CheckExpected(Fifo, SlvWord) ;\n--    \n--    for i in 2 to Count loop \n--      -- Extra Var added for QuestaSim\n--      SlvWord := RV.RandSlv(FifoWidth) ; \n--      CheckExpected(Fifo, SlvWord) ;\n--    end loop ;\n  end procedure CheckBurstRandom ;\n  \n  ------------------------------------------------------------\n  -- Experimental and Provisional\n  procedure CheckBurstRandom (\n  ------------------------------------------------------------\n    constant Fifo         : in    ScoreboardIdType ;\n    constant CoverID      : in    CoverageIdType ;\n    constant Count        : in    integer ;\n    constant FifoWidth    : in    integer := 8\n  ) is\n    variable RandValue : std_logic_vector(FifoWidth-1 downto 0) ; \n  begin    \n    for i in 1 to Count loop \n      RandValue := to_slv(GetRandPoint(CoverID), FifoWidth) ;\n      CheckExpected(Fifo, RandValue) ;\n      ICoverLast(CoverID) ; \n    end loop ;\n  end procedure CheckBurstRandom ;\n\n  -- ========================================================\n  --  Verification Component Support\n  -- ========================================================\n\n  ------------------------------------------------------------\n  procedure PopWord (\n  -- Pop bytes from BurstFifo and form a word \n  -- Current implementation for now assumes it is assembling bytes.   \n  --\n  ------------------------------------------------------------\n    constant Fifo              : in    ScoreboardIdType ;\n    variable Valid             : out   boolean ;\n    variable Data              : out   std_logic_vector ; \n    variable BytesToSend       : inout integer ;\n    constant ByteAddress       : in    natural := 0 \n  ) is\n    variable Index    : integer := ByteAddress * 8 ; \n    constant DataLeft : integer := Data'length-1; \n    alias aData       : std_logic_vector(DataLeft downto 0) is Data;\n  begin\n    aData := (aData'range => 'U') ;  -- Default Undriven\n    Valid := TRUE ; \n    GetWord : while Index <= DataLeft loop  \n      if not Empty(Fifo) then \n        aData(Index+7 downto Index) := Pop(Fifo) ; \n        BytesToSend := BytesToSend - 1 ; \n        exit when BytesToSend = 0 ; \n      else\n        Valid := FALSE ; \n        exit ; \n      end if ; \n      Index := Index + 8 ; \n    end loop GetWord ;\n  end PopWord ; \n\n  ------------------------------------------------------------\n  procedure PushWord (\n  -- Push a word into the byte oriented BurstFifo\n  -- Current implementation for now assumes it is assembling bytes.   \n  --\n  ------------------------------------------------------------\n    constant Fifo              : in    ScoreboardIdType ;\n    variable Data              : in    std_logic_vector ; \n    constant DropUndriven      : in    boolean := FALSE ;\n    constant ByteAddress       : in    natural := 0 \n  ) is\n    variable Index    : integer := ByteAddress * 8 ; \n    constant DataLeft : integer := Data'length-1; \n    alias    aData    : std_logic_vector(DataLeft downto 0) is Data;\n  begin\n    PushBytes : while Index <= DataLeft loop  \n      if not ((DropUndriven and aData(Index) = 'U') or aData(Index) = '-') then \n        Push(Fifo, aData(Index+7 downto Index)) ; \n      end if ;\n      Index := Index + 8 ; \n    end loop PushBytes ; \n  end PushWord ; \n\n  ------------------------------------------------------------\n  procedure CheckWord (\n  -- Push a word into the byte oriented BurstFifo\n  -- Current implementation for now assumes it is assembling bytes.   \n  --\n  ------------------------------------------------------------\n    constant Fifo              : in    ScoreboardIdType ;\n    variable Data              : in    std_logic_vector ; \n    constant DropUndriven      : in    boolean := FALSE ;\n    constant ByteAddress       : in    natural := 0 \n  ) is\n    variable Index    : integer := ByteAddress * 8 ; \n    constant DataLeft : integer := Data'length-1; \n    alias aData       : std_logic_vector(DataLeft downto 0) is Data;\n  begin\n    PushBytes : while Index <= DataLeft loop  \n      if not ((DropUndriven and aData(Index) = 'U') or aData(Index) = '-') then \n        Check(Fifo, aData(Index+7 downto Index)) ; \n      end if ;\n      Index := Index + 8 ; \n    end loop PushBytes ; \n  end CheckWord ; \n\n  ------------------------------------------------------------\n  function CountBytes(\n  -- Count number of bytes in a word\n  --\n  ------------------------------------------------------------\n    constant Data              : in    std_logic_vector ;\n    constant DropUndriven      : in    boolean := FALSE ;\n    constant ByteAddress       : in    natural := 0 \n  ) return integer is\n    variable Index    : integer := ByteAddress * 8 ; \n    variable Count    : integer := 0 ; \n    constant DataLeft : integer := Data'length-1 ;\n    alias aData       : std_logic_vector(DataLeft downto 0) is Data ; \n  begin\n    while Index <= DataLeft loop\n      if not ((DropUndriven and aData(Index) = 'U') or aData(Index) = '-') then \n        Count := Count + 1 ; \n      end if ;\n      Index := Index + 8 ; \n    end loop ; \n    return Count ;\n  end function CountBytes ; \n\n  -- ========================================================\n  --  Deprecated\n  -- ========================================================\n\n  ------------------------------------------------------------\n  -- Deprecated.  Replaced by PushBurstVector\n  procedure PushBurst (\n  ------------------------------------------------------------\n    constant Fifo           : in    ScoreboardIdType ;\n    constant VectorOfWords  : in    integer_vector ;\n    constant FifoWidth      : in    integer := 8\n  ) is\n  begin\n    PushBurstVector(Fifo, VectorOfWords, FifoWidth) ; \n  end procedure PushBurst ;\n\n  ------------------------------------------------------------\n  -- Deprecated and replaced by CheckBurstVector\n  procedure CheckBurst (\n  -- Pop values from the FIFO and check them against each value \n  -- in the VectorOfWords parameter.   \n  -- Each value popped will be FifoWidth bits wide.   \n  ------------------------------------------------------------\n    constant Fifo           : in    ScoreboardIdType ;\n    constant VectorOfWords  : in    integer_vector ;\n    constant FifoWidth      : in    integer := 8\n  ) is\n  begin\n    CheckBurstVector(Fifo, VectorOfWords, FifoWidth) ; \n  end procedure CheckBurst ;\n  \nend FifoFillPkg_slv ;","lang":"vhdl"};
processSrcData(g_data);