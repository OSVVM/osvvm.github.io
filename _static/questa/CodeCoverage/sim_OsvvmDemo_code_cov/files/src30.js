var g_data = {"name":"C:/SynthWorks/Dev/_osvvm/OsvvmLibraries/osvvm/RandomPkg.vhd","src":"--\n--  File Name :         RandomPkg.vhd\n--  Design Unit Name :  RandomPkg\n--  Revision :          STANDARD VERSION\n--\n--  Maintainer :        Jim Lewis      email :  jim@synthworks.com\n--  Contributor(s) :\n--     Jim Lewis      email:  jim@synthworks.com\n--     Lars Asplund   email:  lars.anders.asplund@gmail.com - RandBool, RandSl, RandBit, DistBool, DistSl, DistBit\n--     *\n--\n--   * In writing procedures normal, poisson, the following sources were referenced :\n--     Wikipedia\n--     package rnd2 written by John Breen and Ken Christensen\n--     package RNG written by Gnanasekaran Swaminathan\n--\n--\n--  Description :\n--    RandomPType, a protected type, defined to hold randomization RandomSeeds and\n--    function methods to facilitate randomization with uniform and weighted\n--    distributions\n--\n--  Developed for :\n--        SynthWorks Design Inc.\n--        VHDL Training Classes\n--        11898 SW 128th Ave.  Tigard, Or  97223\n--        http ://www.SynthWorks.com\n--\n--  Revision History :\n--    Date       Version    Description\n--    06/2023    2023.06    Updated InitSeed for type time to do (T mod 2**30*std.env.resolution_limit)\n--    06/2021    2021.06    Updated InitSeed, moved shared stuff to RandomBasePkg\n--    08/2020    2020.08    RandBool, RandSl, RandBit, DistBool, DistSl, DistBit (from Lars)\n--    01/2020    2020.01    Updated Licenses to Apache\n--    11/2016    2016.11    No changes.  Updated release numbers to make documentation and\n--                          package have consistent release identifiers.\n--    5/2015     2015.06    Revised Alerts to Alert(OSVVM_ALERTLOG_ID, ...) ;\n--    1/2015     2015.01    Changed Assert/Report to Alert\n--    1/2014     2014.01    Added RandTime, RandReal(set), RandIntV, RandRealV, RandTimeV\n--                          Made sort, revsort from SortListPkg_int visible via aliases\n--    5/2013     2013.05    Big vector randomization added overloading RandUnsigned, RandSlv, and RandSigned\n--                          Added NULL_RANGE_TYPE to minimize null range warnings\n--    5/2013     -          Removed extra variable declaration in functions RandInt and RandReal\n--    04/2013    2013.04    Changed DistInt.  Return array indices now match input\n--                          Better Min, Max error handling in Uniform, FavorBig, FavorSmall, Normal, Poisson\n--    06/2012    2.2        Removed '_' in the name of subprograms FavorBig and FavorSmall\n--    07/2011    2.1        Bug fix to convenience functions for slv, unsigned, and signed.\n--    03/2011    2.0        Major clean-up. Moved RandomParmType and control to here\n--    06/2010    1.2        Added Normal and Poisson distributions\n--    02/2009 :  1.0        First Public Released Version\n--    02/25/2009 1.1        Replaced reference to std_2008 with a reference to\n--                          ieee_proposed.standard_additions.all ;\n--                          Numerous revisions for SynthWorks' Advanced VHDL Testbenches and Verification\n--    12/2006 :  0.1        Initial revision\n--\n--  This file is part of OSVVM.\n--  \n--  Copyright (c) 2006 - 2021 by SynthWorks Design Inc.  \n--  Copyright (C) 2021 by OSVVM Authors   \n--  \n--  Licensed under the Apache License, Version 2.0 (the \"License\");\n--  you may not use this file except in compliance with the License.\n--  You may obtain a copy of the License at\n--  \n--      https://www.apache.org/licenses/LICENSE-2.0\n--  \n--  Unless required by applicable law or agreed to in writing, software\n--  distributed under the License is distributed on an \"AS IS\" BASIS,\n--  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n--  See the License for the specific language governing permissions and\n--  limitations under the License.\n--  \n\nuse work.OsvvmGlobalPkg.all ; \nuse work.AlertLogPkg.all ; \nuse work.RandomBasePkg.all ;\nuse work.SortListPkg_int.all ;\n\nuse std.textio.all ;\n\nlibrary ieee ;\nuse ieee.std_logic_1164.all ;\nuse ieee.numeric_std.all ;\nuse ieee.numeric_std_unsigned.all ;\nuse ieee.math_real.all ;\n\n-- comment out following 3 lines with VHDL-2008.  Leave in for VHDL-2002\n-- library ieee_proposed ;						               -- remove with VHDL-2008\n-- use ieee_proposed.standard_additions.all ;        -- remove with VHDL-2008\n-- use ieee_proposed.standard_textio_additions.all ; -- remove with VHDL-2008\n\n\npackage RandomPkg is\n\n  -- make things from SortListPkg_int visible\n--  alias sort    is work.SortListPkg_int.sort   [integer_vector return integer_vector] ;\n--  alias revsort is work.SortListPkg_int.revsort[integer_vector return integer_vector] ;\n\n  -- Supports DistValInt functionality\n  type DistRecType is record\n    Value  : integer ;\n    Weight : integer ;\n  end record ;\n  type DistType is array (natural range <>) of DistRecType ;\n\n  -- Weight vectors not indexed by integers\n  type NaturalVBoolType is array (boolean range <>) of natural;\n  type NaturalVSlType   is array (std_logic range <>) of natural;\n  type NaturalVBitType  is array (bit range <>) of natural;\n  \n\n  --- ///////////////////////////////////////////////////////////////////////////\n  --- ///////////////////////////////////////////////////////////////////////////\n  ---   \n  ---  RandomPType\n  ---   \n  --- ///////////////////////////////////////////////////////////////////////////\n  --- ///////////////////////////////////////////////////////////////////////////\n  type RandomPType is protected\n  \n    --- ///////////////////////////////////////////////////////////////////////////\n    ---\n    --- Parameter Settings\n    ---\n    --- ///////////////////////////////////////////////////////////////////////////\n    ------------------------------------------------------------\n    --  Seed Manipulation\n    ------------------------------------------------------------\n    -- Known ambiguity between InitSeed with string and integer_vector\n    -- Recommendation, use :  RV.InitSeed(RV'instance_path) ;\n    -- For integer_vector use either : RV.InitSeed(IV => (1,5)) ;\n    --   or : RV.InitSeed(integer_vector'(1,5)) ;\n    -- Initialize Seeds\n    procedure InitSeed         ( S : string ;  UseNewSeedMethods : boolean := FALSE ) ;\n    procedure InitSeed         ( I : integer ; UseNewSeedMethods : boolean := FALSE ) ;\n    procedure InitSeed         ( T : time ;    UseNewSeedMethods : boolean := TRUE ) ;\n    procedure InitSeed         ( IV : integer_vector ; UseNewSeedMethods : boolean := FALSE ) ;\n    -- Save and restore seed values\n    procedure       SetSeed    (RandomSeedIn : RandomSeedType ) ;\n    impure function GetSeed    return RandomSeedType ;\n    procedure       SeedRandom (RandomSeedIn : RandomSeedType ) ;\n    impure function SeedRandom return RandomSeedType ;\n    -- alias SeedRandom is SetSeed [RandomSeedType] ;\n    -- alias SeedRandom is GetSeed [return RandomSeedType] ;\n\n    ------------------------------------------------------------\n    --  Setting Randomization Parameters\n    ------------------------------------------------------------\n    procedure SetRandomParm (RandomParmIn : RandomParmType) ;\n    procedure SetRandomParm (\n      Distribution : RandomDistType ;\n      Mean         : Real := 0.0 ;\n      Deviation    : Real := 0.0\n    ) ;\n    impure function GetRandomParm return RandomParmType ;\n    impure function GetRandomParm return RandomDistType ;\n    -- For compatibility with previous version - replace with alias\n    procedure SetRandomMode (RandomDistIn : RandomDistType) ;\n    -- alias SetRandomMode is SetRandomParm [RandomDistType, Real, Real] ;\n\n    --- ///////////////////////////////////////////////////////////////////////////\n    ---\n    --- Base Randomization Distributions\n    ---\n    --- ///////////////////////////////////////////////////////////////////////////\n    ------------------------------------------------------------\n    --\n    -- Uniform\n    -- Generate a random number with a Uniform distribution\n    --\n    ------------------------------------------------------------\n    impure function Uniform (Min, Max : in real) return real ;\n    impure function Uniform (Min, Max : integer) return integer ;\n    impure function Uniform (Min, Max : integer ; Exclude : integer_vector) return integer ;\n\n    ------------------------------------------------------------\n    --\n    -- FavorSmall\n    --   Generate random numbers with a greater number of small\n    --   values than large values\n    --\n    ------------------------------------------------------------\n    impure function FavorSmall (Min, Max : real) return real ;\n    impure function FavorSmall (Min, Max : integer) return integer ;\n    impure function FavorSmall (Min, Max : integer ; Exclude : integer_vector) return integer ;\n\n    ------------------------------------------------------------\n    --\n    -- FavorBig\n    --   Generate random numbers with a greater number of large\n    --   values than small values\n    --\n    ------------------------------------------------------------\n    impure function FavorBig (Min, Max : real) return real ;\n    impure function FavorBig (Min, Max : integer) return integer ;\n    impure function FavorBig (Min, Max : integer ; Exclude : integer_vector) return integer ;\n\n    -----------------------------------------------------------------\n    --\n    -- Normal\n    --   Generate a random number with a normal distribution\n    --   Uses Box Muller, per Wikipedia\n    --\n    ------------------------------------------------------------\n    impure function Normal (Mean, StdDeviation : real) return real ;\n    impure function Normal (Mean, StdDeviation, Min, Max : real) return real ;\n    impure function Normal (\n      Mean          : real ;\n      StdDeviation  : real ;\n      Min           : integer ;\n      Max           : integer ;\n      Exclude       : integer_vector := NULL_INTV\n    ) return integer ;\n\n    -----------------------------------------------------------------\n    -- Poisson\n    --   Generate a random number with a poisson distribution\n    --   Discrete distribution = only generates integral values\n    --   Uses knuth method, per Wikipedia\n    --\n    ------------------------------------------------------------\n    impure function Poisson (Mean : real) return real ;\n    impure function Poisson (Mean, Min, Max : real) return real ;\n    impure function Poisson (\n      Mean          : real ;\n      Min           : integer ;\n      Max           : integer ;\n      Exclude       : integer_vector := NULL_INTV\n    ) return integer ;\n\n    --- ///////////////////////////////////////////////////////////////////////////\n    --\n    --  Randomization with range.\n    --    Uses internal settings of RandomParm to deterimine distribution.\n    --\n    --- ///////////////////////////////////////////////////////////////////////////\n    ------------------------------------------------------------\n    impure function RandInt      (Min, Max : integer) return integer ;\n    impure function RandReal     (Min, Max : Real) return real ;\n    impure function RandTime     (Min, Max : time ; Unit : time := ns) return time ;\n    impure function RandSlv      (Min, Max, Size : natural) return std_logic_vector ;\n    impure function RandUnsigned (Min, Max, Size : natural) return Unsigned ;\n    impure function RandSigned   (Min, Max : integer ; Size   : natural) return Signed ;\n    impure function RandIntV     (Min, Max : integer ; Size   : natural) return integer_vector ;\n    impure function RandIntV     (Min, Max : integer ; Unique : natural ; Size : natural) return integer_vector ;\n    impure function RandRealV    (Min, Max : real ;    Size   : natural) return real_vector ;\n    impure function RandTimeV    (Min, Max : time ;    Size   : natural ; Unit : time := ns) return time_vector ;\n    impure function RandTimeV    (Min, Max : time ;    Unique : natural ; Size : natural ; Unit : time := ns) return time_vector ;\n\n\n    --- ///////////////////////////////////////////////////////////////////////////\n    --\n    --  Randomization with range and exclude vector.\n    --    Uses internal settings of RandomParm to deterimine distribution.\n    --\n    --- ///////////////////////////////////////////////////////////////////////////\n    ------------------------------------------------------------\n    impure function RandInt      (Min, Max : integer ; Exclude : integer_vector ) return integer ;\n    impure function RandTime     (Min, Max : time ;    Exclude : time_vector ;    Unit   : time := ns) return time ;\n    impure function RandSlv      (Min, Max : natural ; Exclude : integer_vector ; Size   : natural) return std_logic_vector ;\n    impure function RandUnsigned (Min, Max : natural ; Exclude : integer_vector ; Size   : natural) return Unsigned ;\n    impure function RandSigned   (Min, Max : integer ; Exclude : integer_vector ; Size   : natural) return Signed ;\n    impure function RandIntV     (Min, Max : integer ; Exclude : integer_vector ; Size   : natural) return integer_vector ;\n    impure function RandIntV     (Min, Max : integer ; Exclude : integer_vector ; Unique : natural ; Size : natural) return integer_vector ;\n    impure function RandTimeV    (Min, Max : time ;    Exclude : time_vector ;    Size   : natural ; Unit : in time := ns) return time_vector ;\n    impure function RandTimeV    (Min, Max : time ;    Exclude : time_vector ;    Unique : natural ; Size : natural ; Unit : in time := ns) return time_vector ;\n\n\n    --- ///////////////////////////////////////////////////////////////////////////\n    --\n    --  Randomly select a value within a set of values\n    --    Uses internal settings of RandomParm to deterimine distribution.\n    --\n    --- ///////////////////////////////////////////////////////////////////////////\n    ------------------------------------------------------------\n    impure function RandInt      (A : integer_vector ) return integer ;\n    impure function RandReal     (A : real_vector    ) return real ;\n    impure function RandTime     (A : time_vector    ) return time ;\n    impure function RandSlv      (A : integer_vector ; Size : natural) return std_logic_vector  ;\n    impure function RandUnsigned (A : integer_vector ; Size : natural) return Unsigned ;\n    impure function RandSigned   (A : integer_vector ; Size : natural) return Signed ;\n    impure function RandIntV     (A : integer_vector ; Size : natural) return integer_vector ;\n    impure function RandIntV     (A : integer_vector ; Unique : natural ; Size : natural) return integer_vector ;\n    impure function RandRealV    (A : real_vector ;    Size   : natural) return real_vector ;\n    impure function RandRealV    (A : real_vector ;    Unique : natural ; Size : natural) return real_vector ;\n    impure function RandTimeV    (A : time_vector ;    Size   : natural) return time_vector ;\n    impure function RandTimeV    (A : time_vector ;    Unique : natural ; Size : natural) return time_vector ;\n\n\n    --- ///////////////////////////////////////////////////////////////////////////\n    --\n    --  Randomly select a value within a set of values with exclude values (so can skip last or last n)\n    --    Uses internal settings of RandomParm to deterimine distribution.\n    --\n    --- ///////////////////////////////////////////////////////////////////////////\n    ------------------------------------------------------------\n    impure function RandInt      (A, Exclude : integer_vector  ) return integer ;\n    impure function RandReal     (A, Exclude : real_vector ) return real ;\n    impure function RandTime     (A, Exclude : time_vector) return time ;\n    impure function RandSlv      (A, Exclude : integer_vector ; Size : natural) return std_logic_vector  ;\n    impure function RandUnsigned (A, Exclude : integer_vector ; Size : natural) return Unsigned ;\n    impure function RandSigned   (A, Exclude : integer_vector ; Size : natural ) return Signed ;\n    impure function RandIntV     (A, Exclude : integer_vector ; Size : natural) return integer_vector ;\n    impure function RandIntV     (A, Exclude : integer_vector ; Unique : natural ; Size : natural) return integer_vector ;\n    impure function RandRealV    (A, Exclude : real_vector ; Size : natural) return real_vector ;\n    impure function RandRealV    (A, Exclude : real_vector ; Unique : natural ; Size : natural) return real_vector ;\n    impure function RandTimeV    (A, Exclude : time_vector ; Size : natural) return time_vector ;\n    impure function RandTimeV    (A, Exclude : time_vector ; Unique : natural ; Size : natural) return time_vector ;\n\n    --- ///////////////////////////////////////////////////////////////////////////\n    --\n    --  Basic Discrete Distributions\n    --    Randomly select between 0 and N-1 based on the specified weight.\n    --    where N = number values in weight array\n    --    Always uses Uniform\n    --\n    --- ///////////////////////////////////////////////////////////////////////////\n    ------------------------------------------------------------\n    impure function DistInt      (Weight : integer_vector   ) return integer ;\n    impure function DistSlv      (Weight : integer_vector ; Size  : natural ) return std_logic_vector ;\n    impure function DistUnsigned (Weight : integer_vector ; Size  : natural ) return unsigned ;\n    impure function DistSigned   (Weight : integer_vector ; Size  : natural ) return signed ;\n    impure function DistBool     (Weight : NaturalVBoolType ) return boolean ;\n    impure function DistSl       (Weight : NaturalVSlType   ) return std_logic ;\n    impure function DistBit      (Weight : NaturalVBitType  ) return bit ;\n\n    --- ///////////////////////////////////////////////////////////////////////////\n    --\n    --  Basic Distributions with exclude values (so can skip last or last n)\n    --    Always uses Uniform via DistInt\n    --\n    --- ///////////////////////////////////////////////////////////////////////////\n    ------------------------------------------------------------\n    impure function DistInt      (Weight : integer_vector ; Exclude : integer_vector ) return integer ;\n    impure function DistSlv      (Weight : integer_vector ; Exclude : integer_vector ; Size  : natural ) return std_logic_vector ;\n    impure function DistUnsigned (Weight : integer_vector ; Exclude : integer_vector ; Size  : natural ) return unsigned ;\n    impure function DistSigned   (Weight : integer_vector ; Exclude : integer_vector ; Size  : natural ) return signed ;\n\n    --- ///////////////////////////////////////////////////////////////////////////\n    --\n    --  Distribution for sparse values\n    --    Specify weight and value\n    --    Always uses Uniform via DistInt\n    --\n    --- ///////////////////////////////////////////////////////////////////////////\n    ------------------------------------------------------------\n    impure function DistValInt      (A : DistType ) return integer ;\n    impure function DistValSlv      (A : DistType ; Size  : natural) return std_logic_vector ;\n    impure function DistValUnsigned (A : DistType ; Size  : natural) return unsigned ;\n    impure function DistValSigned   (A : DistType ; Size  : natural) return signed ;\n\n    --- ///////////////////////////////////////////////////////////////////////////\n    --\n    --  Distribution for sparse values with exclude values (so can skip last or last n)\n    --    Specify weight and value\n    --    Always uses Uniform via DistInt\n    --\n    --- ///////////////////////////////////////////////////////////////////////////\n    ------------------------------------------------------------\n    impure function DistValInt      (A : DistType ; Exclude : integer_vector ) return integer ;\n    impure function DistValSlv      (A : DistType ; Exclude : integer_vector ; Size  : natural) return std_logic_vector ;\n    impure function DistValUnsigned (A : DistType ; Exclude : integer_vector ; Size  : natural) return unsigned ;\n    impure function DistValSigned   (A : DistType ; Exclude : integer_vector ; Size  : natural) return signed ;\n\n    --- ///////////////////////////////////////////////////////////////////////////\n    --\n    -- Large vector handling.\n    --\n    --- ///////////////////////////////////////////////////////////////////////////\n    ------------------------------------------------------------\n    impure function RandUnsigned (Size : natural) return unsigned ;\n    impure function RandSlv      (Size : natural) return std_logic_vector ;\n    impure function RandSigned   (Size : natural) return signed ;\n    impure function RandUnsigned (Max : Unsigned) return unsigned ;\n    impure function RandSlv      (Max : std_logic_vector) return std_logic_vector ;\n    impure function RandSigned   (Max : signed) return signed ;\n    impure function RandUnsigned (Min, Max : unsigned) return unsigned ;\n    impure function RandSlv      (Min, Max : std_logic_vector) return std_logic_vector ;\n    impure function RandSigned   (Min, Max : signed) return signed ;\n\n    --- ///////////////////////////////////////////////////////////////////////////\n    --\n    --  Convenience Functions.  Resolve into calls into the other functions\n    --\n    --- ///////////////////////////////////////////////////////////////////////////\n    ------------------------------------------------------------\n    impure function RandReal     return real ; -- 0.0 to 1.0\n    impure function RandReal     (Max : Real) return real ; -- 0.0 to Max\n    impure function RandInt      (Max : integer) return integer ;\n    impure function RandSlv      (Max, Size : natural) return std_logic_vector ;\n    impure function RandUnsigned (Max, Size : natural) return Unsigned ;\n    impure function RandSigned   (Max : integer ; Size : natural ) return Signed ;\n    impure function RandBool     return boolean;\n    impure function RandSl       return std_logic;\n    impure function RandBit      return bit;\n\n  end protected RandomPType ;\n\nend RandomPkg ;\n\n--- ///////////////////////////////////////////////////////////////////////////\n--- ///////////////////////////////////////////////////////////////////////////\n--- ///////////////////////////////////////////////////////////////////////////\n\npackage body RandomPkg is\n\n  -----------------------------------------------------------------\n  --  Local Randomization Support\n  -----------------------------------------------------------------\n  constant NULL_SLV : std_logic_vector (NULL_RANGE_TYPE) := (others => '0') ;\n  constant NULL_UV  : unsigned (NULL_RANGE_TYPE) := (others => '0') ;\n  constant NULL_SV  : signed   (NULL_RANGE_TYPE) := (others => '0') ;\n\n\n  --- ///////////////////////////////////////////////////////////////////////////\n  --- RandomPType Body\n  --- ///////////////////////////////////////////////////////////////////////////\n  type RandomPType is protected body\n  \n    variable RandomSeed : RandomSeedType := OldGenRandSeed(integer_vector'(1,7)) ;\n\n    --- ///////////////////////////////////////////////////////////////////////////\n    ---\n    --- Base Call to Uniform.   Use this one rather than RandomBasePkg\n    ---\n    --- ///////////////////////////////////////////////////////////////////////////\n    -----------------------------------------------------------------\n    impure function Uniform return real is \n    -----------------------------------------------------------------\n      variable rRandom : real ; \n    begin\n      ieee.math_real.Uniform (RandomSeed(RandomSeed'left), RandomSeed(RandomSeed'right), rRandom) ;\n      return rRandom ; \n    end function Uniform ;\n\n    --- ///////////////////////////////////////////////////////////////////////////\n    ---\n    --- Seed Manipulation\n    ---\n    --- ///////////////////////////////////////////////////////////////////////////\n    ------------------------------------------------------------\n    procedure InitSeed (S : string ; UseNewSeedMethods : boolean := FALSE ) is\n    ------------------------------------------------------------\n      variable ChurnSeed : real ;\n    begin\n      if UseNewSeedMethods then\n        RandomSeed := GenRandSeed(S) ;\n        Uniform(ChurnSeed, RandomSeed) ;\n      else\n        RandomSeed := OldGenRandSeed(S) ;\n      end if ;\n    end procedure InitSeed ;\n\n    ------------------------------------------------------------\n    procedure InitSeed (I : integer ; UseNewSeedMethods : boolean := FALSE ) is\n    ------------------------------------------------------------\n      variable ChurnSeed : real ;\n    begin\n      if UseNewSeedMethods then\n        RandomSeed := GenRandSeed(I) ;\n        Uniform(ChurnSeed, RandomSeed) ;\n      else\n        RandomSeed := OldGenRandSeed(I) ;\n      end if ;\n    end procedure InitSeed ;\n    \n    ------------------------------------------------------------\n    procedure InitSeed (T : time ; UseNewSeedMethods : boolean := TRUE ) is\n    ------------------------------------------------------------\n      variable ChurnSeed : real ;\n    begin\n      -- Allow specification of UseNewSeedMethods \n      -- but ignore it as this is a new method and will churn the seed.\n      -- NVC fatals on the integer conversion time values >= 2**31, hence, the following was removed\n      --      RandomSeed := GenRandSeed(T /std.env.resolution_limit) ;\n      -- Also consider:\n      --      RandomSeed := GenRandSeed( (T - (T/2**30)*2**30) /std.env.resolution_limit) ;\n      RandomSeed := GenRandSeed( (T mod (2**30*std.env.resolution_limit)) /std.env.resolution_limit) ;\n      Uniform(ChurnSeed, RandomSeed) ;\n    end procedure InitSeed ;\n\n    ------------------------------------------------------------\n    procedure InitSeed (IV : integer_vector ; UseNewSeedMethods : boolean := FALSE ) is\n    ------------------------------------------------------------\n      variable ChurnSeed : real ;\n    begin\n      if UseNewSeedMethods then\n        RandomSeed := GenRandSeed(IV) ;\n        Uniform(ChurnSeed, RandomSeed) ;\n      else\n        RandomSeed := OldGenRandSeed(IV) ;\n      end if ;\n    end procedure InitSeed ;\n\n    ------------------------------------------------------------\n    procedure SetSeed (RandomSeedIn : RandomSeedType ) is\n    ------------------------------------------------------------\n    begin\n      RandomSeed := RandomSeedIn ;\n    end procedure SetSeed ;\n\n    ------------------------------------------------------------\n    procedure SeedRandom (RandomSeedIn : RandomSeedType ) is\n    ------------------------------------------------------------\n    begin\n      RandomSeed := RandomSeedIn ;\n    end procedure SeedRandom ;\n\n    ------------------------------------------------------------\n    impure function GetSeed return RandomSeedType is\n    ------------------------------------------------------------\n    begin\n      return RandomSeed ;\n    end function GetSeed ;\n\n    ------------------------------------------------------------\n    impure function SeedRandom return RandomSeedType is\n    ------------------------------------------------------------\n    begin\n      return RandomSeed ;\n    end function SeedRandom ;\n\n\n    --- ///////////////////////////////////////////////////////////////////////////\n    ---\n    ---   Setting Randomization Parameters\n    ---\n    --- ///////////////////////////////////////////////////////////////////////////\n    ------------------------------------------------------------\n    variable RandomParm : RandomParmType ; -- left most values ok for init\n\n    ------------------------------------------------------------\n    procedure SetRandomParm (RandomParmIn : RandomParmType) is\n    ------------------------------------------------------------\n    begin\n      RandomParm := RandomParmIn ;\n    end procedure SetRandomParm ;\n\n    ------------------------------------------------------------\n    procedure SetRandomParm (\n    ------------------------------------------------------------\n      Distribution : RandomDistType ;\n      Mean         : Real := 0.0 ;\n      Deviation    : Real := 0.0\n    ) is\n    begin\n      RandomParm := RandomParmType'(Distribution, Mean, Deviation) ;\n    end procedure SetRandomParm ;\n\n\n    ------------------------------------------------------------\n    impure function GetRandomParm return RandomParmType is\n    ------------------------------------------------------------\n    begin\n      return RandomParm ;\n    end function GetRandomParm ;\n\n\n    ------------------------------------------------------------\n    impure function GetRandomParm return RandomDistType is\n    ------------------------------------------------------------\n    begin\n      return RandomParm.Distribution ;\n    end function GetRandomParm ;\n\n\n    ------------------------------------------------------------\n    -- Deprecated.  For compatibility with previous version\n    procedure SetRandomMode (RandomDistIn : RandomDistType) is\n    ------------------------------------------------------------\n    begin\n      SetRandomParm(RandomDistIn) ;\n    end procedure SetRandomMode ;\n\n    --- ///////////////////////////////////////////////////////////////////////////\n    ---\n    ---  Check ranges for Randomization and Generate FAILURE\n    ---\n    --- ///////////////////////////////////////////////////////////////////////////\n    ------------------------------------------------------------\n    -- PT Local\n    impure function CheckMinMax(\n    ------------------------------------------------------------\n      constant Name  : in string ;\n      constant Min   : in real ;\n      constant Max   : in real\n    ) return real is\n    begin\n      if Min > Max then\n        Alert(OSVVM_RANDOM_ALERTLOG_ID,\n          \"RandomPkg.\" & Name &\n               \": Min: \" & to_string(Min, 2) &\n               \" >  Max: \" & to_string(Max, 2),\n          FAILURE ) ;\n        return Min ;\n      else\n        return Max ;\n      end if;\n    end function CheckMinMax ;\n\n    ------------------------------------------------------------\n    -- PT Local\n    impure function CheckMinMax(\n    ------------------------------------------------------------\n      constant Name  : in string ;\n      constant Min   : in integer ;\n      constant Max   : in integer\n    ) return integer is\n    begin\n      if Min > Max then\n        Alert(OSVVM_RANDOM_ALERTLOG_ID,\n          \"RandomPkg.\" & Name &\n               \": Min: \" & to_string(Min) &\n               \" >  Max: \" & to_string(Max),\n          FAILURE ) ;\n        return Min ;\n      else\n        return Max ;\n      end if;\n    end function CheckMinMax ;\n\n    ------------------------------------------------------------\n    -- PT Local\n    impure function CheckMinMax(\n    ------------------------------------------------------------\n      constant Name  : in string ;\n      constant Min   : in time ;\n      constant Max   : in time\n    ) return time is\n    begin\n      if Min > Max then\n        Alert(OSVVM_RANDOM_ALERTLOG_ID,\n          \"RandomPkg.\" & Name &\n               \": Min: \" & to_string(Min, ns) &\n               \" >  Max: \" & to_string(Max, ns),\n          FAILURE ) ;\n        return Min ;\n      else\n        return Max ;\n      end if;\n    end function CheckMinMax ;\n    \n    --- ///////////////////////////////////////////////////////////////////////////\n    ---\n    --- Base Randomization Distributions\n    ---\n    --- ///////////////////////////////////////////////////////////////////////////\n    ------------------------------------------------------------\n    --\n    -- Uniform\n    -- Generate a random number with a Uniform distribution\n    --\n    ------------------------------------------------------------\n    impure function LocalUniform (Min, Max : in real) return real is\n    ------------------------------------------------------------\n    begin\n      return scale(Uniform, Min, Max) ;\n    end function LocalUniform ;\n\n    ------------------------------------------------------------\n    impure function Uniform (Min, Max : in real) return real is\n    ------------------------------------------------------------\n      constant CkMax      : real := CheckMinMax(\"Uniform\", Min, Max) ;\n    begin\n      return LocalUniform(Min, CkMax) ;\n    end function Uniform ;\n\n    ------------------------------------------------------------\n    impure function LocalUniform (Min, Max : integer) return integer is\n    ------------------------------------------------------------\n    begin\n      return scale(Uniform, Min, Max) ;\n    end function LocalUniform ;\n\n    ------------------------------------------------------------\n    impure function Uniform (Min, Max : integer) return integer is\n    ------------------------------------------------------------\n      constant CkMax      : integer := CheckMinMax(\"Uniform\", Min, Max) ;\n    begin\n      return LocalUniform(Min, CkMax) ;\n    end function Uniform ;\n\n    ------------------------------------------------------------\n    impure function LocalUniform (Min, Max : integer ; Exclude : integer_vector) return integer is\n    ------------------------------------------------------------\n      variable iRandomVal  : integer ;\n      variable ExcludeList : SortListPType ;\n      variable count       : integer ;\n    begin\n      ExcludeList.add(Exclude, Min, Max) ;\n      count := ExcludeList.count ;\n      iRandomVal := Uniform(Min, Max - count) ;\n      -- adjust count, note iRandomVal changes while checking.\n      for i in 1 to count loop\n        exit when iRandomVal < ExcludeList.Get(i) ;\n        iRandomVal := iRandomVal + 1 ;\n      end loop ;\n      ExcludeList.erase ;\n      return iRandomVal ;\n    end function LocalUniform ;\n\n    ------------------------------------------------------------\n    impure function Uniform (Min, Max : integer ; Exclude : integer_vector) return integer is\n    ------------------------------------------------------------\n      constant CkMax : integer := CheckMinMax(\"Uniform\", Min, Max) ;\n    begin\n      return LocalUniform (Min, Max, Exclude) ; \n    end function Uniform ;\n\n\n    ------------------------------------------------------------\n    --\n    -- FavorSmall\n    --   Generate random numbers with a greater number of small\n    --   values than large values\n    --\n    ------------------------------------------------------------\n    impure function FavorSmall (Min, Max : real) return real is\n    ------------------------------------------------------------\n      constant CkMax      : real := CheckMinMax(\"FavorSmall\", Min, Max) ;\n    begin\n      return scale(FavorSmall(Uniform), Min, CkMax) ; -- real\n    end function FavorSmall ;\n\n    ------------------------------------------------------------\n    impure function FavorSmall (Min, Max : integer) return integer is\n    ------------------------------------------------------------\n      constant CkMax      : integer := CheckMinMax(\"FavorSmall\", Min, Max) ;\n    begin\n      return scale(FavorSmall(Uniform), Min, CkMax) ; -- integer\n    end function FavorSmall ;\n\n    ------------------------------------------------------------\n    impure function FavorSmall (Min, Max : integer ; Exclude : integer_vector) return integer is\n    ------------------------------------------------------------\n      variable iRandomVal  : integer ;\n      variable ExcludeList : SortListPType ;\n      variable count       : integer ;\n      constant CkMax       : integer := CheckMinMax(\"FavorSmall\", Min, Max) ;\n    begin\n      ExcludeList.add(Exclude, Min, CkMax) ;\n      count := ExcludeList.count ;\n      iRandomVal := FavorSmall(Min, CkMax - count) ;\n      -- adjust count, note iRandomVal changes while checking.\n      for i in 1 to count loop\n        exit when iRandomVal < ExcludeList.Get(i) ;\n        iRandomVal := iRandomVal + 1 ;\n      end loop ;\n      ExcludeList.erase ;\n      return iRandomVal ;\n    end function FavorSmall ;\n\n\n    ------------------------------------------------------------\n    --\n    -- FavorBig\n    --   Generate random numbers with a greater number of large\n    --   values than small values\n    --\n    ------------------------------------------------------------\n    impure function FavorBig (Min, Max : real) return real is\n    ------------------------------------------------------------\n      constant CkMax      : real := CheckMinMax(\"FavorBig\", Min, Max) ;\n    begin\n      return scale(FavorBig(Uniform), Min, CkMax) ; -- real\n    end function FavorBig ;\n\n    ------------------------------------------------------------\n    impure function FavorBig (Min, Max : integer) return integer is\n    ------------------------------------------------------------\n      constant CkMax      : integer := CheckMinMax(\"FavorBig\", Min, Max) ;\n    begin\n      return scale(FavorBig(Uniform), Min, CkMax) ; -- integer\n    end function FavorBig ;\n\n    ------------------------------------------------------------\n    impure function FavorBig (Min, Max : integer ; Exclude : integer_vector) return integer is\n    ------------------------------------------------------------\n      variable iRandomVal  : integer ;\n      variable ExcludeList : SortListPType ;\n      variable count       : integer ;\n      constant CkMax       : integer := CheckMinMax(\"FavorBig\", Min, Max) ;\n    begin\n      ExcludeList.add(Exclude, Min, CkMax) ;\n      count := ExcludeList.count ;\n      iRandomVal := FavorBig(Min, CkMax - count) ;\n      -- adjust count, note iRandomVal changes while checking.\n      for i in 1 to count loop\n        exit when iRandomVal < ExcludeList.Get(i) ;\n        iRandomVal := iRandomVal + 1 ;\n      end loop ;\n      ExcludeList.erase ;\n      return iRandomVal ;\n    end function FavorBig ;\n\n\n    -----------------------------------------------------------------\n    --\n    --  Normal\n    --    Generate a random number with a normal distribution\n    --\n    --  Use Box Muller, per Wikipedia :\n    --     http ://en.wikipedia.org/wiki/Box%E2%80%93Muller_transform\n    --\n    ------------------------------------------------------------\n    impure function Normal (Mean, StdDeviation : real) return real is\n    ------------------------------------------------------------\n      variable x01, y01 : real ;\n      variable StdNormalDist : real ; -- mean 0, variance 1\n    begin\n      -- add this check to set parameters?\n      if StdDeviation < 0.0 then\n        Alert(OSVVM_RANDOM_ALERTLOG_ID, \"RandomPkg.Normal: Standard deviation must be >= 0.0\", FAILURE) ;\n        return -1.0 ;\n      end if ;\n\n      -- Box Muller\n--      Uniform (x01, RandomSeed) ;\n--      Uniform (y01, RandomSeed) ;\n      x01 := Uniform ;\n      y01 := Uniform ;\n      StdNormalDist := sqrt(-2.0 * log(x01)) * cos(math_2_pi*y01) ;\n\n      -- Polar form rejected due to mean 50.0, std deviation = 5 resulted\n      -- in a median of 49\n      -- -- find two Uniform distributed values with range -1 to 1\n      -- -- that satisify S = X **2 + Y**2 < 1.0\n      -- loop\n        -- Uniform (x01, RandomSeed) ;\n        -- Uniform (y01, RandomSeed) ;\n        -- x := 2.0 * x01 - 1.0 ; -- scale to -1 to 1\n        -- y := 2.0 * y01 - 1.0 ;\n        -- s := x*x + y*y ;\n        -- exit when s < 1.0 and s > 0.0 ;\n      -- end loop ;\n\n      -- -- Calculate Standard Normal Distribution\n      -- StdNormalDist := x * sqrt((-2.0 * log(s)) / s) ;\n\n      -- Convert to have Mean and StdDeviation\n      return StdDeviation * StdNormalDist + Mean ;\n    end function Normal ;\n\n    ------------------------------------------------------------\n    -- Normal + RandomVal >= Min and RandomVal <= Max\n    impure function Normal (Mean, StdDeviation, Min, Max : real) return real is\n    ------------------------------------------------------------\n      variable rRandomVal : real ;\n    begin\n      if Max < Min then\n         Alert(OSVVM_RANDOM_ALERTLOG_ID, \n           \"RandomPkg.Normal: Min: \" & to_string(Min, 2) &\n               \" >  Max: \" & to_string(Max, 2),  \n           FAILURE) ;\n         return Mean ; \n      else\n        loop\n          rRandomVal := Normal (Mean, StdDeviation) ;\n          exit when rRandomVal >= Min and rRandomVal <= Max ;\n        end loop ;\n      end if ;\n      return rRandomVal ;\n    end function Normal ;\n\n    ------------------------------------------------------------\n    -- Normal + RandomVal >= Min and RandomVal <= Max\n    impure function Normal (\n    ------------------------------------------------------------\n      Mean          : real ;\n      StdDeviation  : real ;\n      Min           : integer ;\n      Max           : integer ;\n      Exclude       : integer_vector := NULL_INTV\n    ) return integer is\n      variable iRandomVal : integer ;\n    begin\n      if Max < Min then\n        Alert(OSVVM_RANDOM_ALERTLOG_ID, \n          \"RandomPkg.Normal: Min: \" & to_string(Min) &\n             \" >  Max: \" & to_string(Max),  \n          FAILURE) ;\n        return integer(round(Mean)) ;\n      else\n        loop\n          iRandomVal := integer(round(  Normal(Mean, StdDeviation)  )) ;\n          exit when iRandomVal >= Min and iRandomVal <= Max and\n                     not inside(iRandomVal, Exclude) ;\n        end loop ;\n      end if ;\n      return iRandomVal ;\n    end function Normal ;\n\n\n    -----------------------------------------------------------------\n    -- Poisson\n    --   Generate a random number with a poisson distribution\n    --   Discrete distribution = only generates integral values\n    --\n    -- Use knuth method, per Wikipedia :\n    --   http ://en.wikipedia.org/wiki/Poisson_distribution\n    --\n    ------------------------------------------------------------\n    impure function Poisson (Mean : real) return real is\n    ------------------------------------------------------------\n      variable Product      : Real := 1.0 ;\n      variable Bound        : Real := 0.0 ;\n      variable UniformRand  : Real := 0.0 ;\n      variable PoissonRand  : Real := 0.0 ;\n    begin\n      Bound := exp(-1.0 * Mean) ;\n      Product := 1.0 ;\n\n      -- add this check to set parameters?\n      if Mean <= 0.0 or Bound <= 0.0 then\n        Alert(OSVVM_RANDOM_ALERTLOG_ID, \"RandomPkg.Poisson: Mean < 0 or too large.  Mean = \" & real'image(Mean), FAILURE) ;\n        return Mean ;\n      end if ;\n\n      while (Product >= Bound) loop\n        PoissonRand := PoissonRand + 1.0 ;\n        UniformRand := Uniform ;\n        Product := Product * UniformRand ;\n      end loop ;\n      return PoissonRand ;\n    end function  Poisson ; -- no range\n\n    ------------------------------------------------------------\n    -- Poisson + RandomVal >= Min and RandomVal < Max\n    impure function Poisson (Mean, Min, Max : real) return real is\n    ------------------------------------------------------------\n      variable rRandomVal : real ;\n    begin\n      if Max < Min then\n        Alert(OSVVM_RANDOM_ALERTLOG_ID, \n           \"RandomPkg.Poisson: Min: \" & to_string(Min, 2) &\n               \" >  Max: \" & to_string(Max, 2),  \n           FAILURE) ;        \n        return Mean ; \n      else\n        loop\n          rRandomVal := Poisson (Mean) ;\n          exit when rRandomVal >= Min and rRandomVal <= Max ;\n        end loop ;\n      end if ;\n      return rRandomVal ;\n    end function  Poisson ;\n\n    ------------------------------------------------------------\n    impure function Poisson (\n    ------------------------------------------------------------\n      Mean          : real ;\n      Min           : integer ;\n      Max           : integer ;\n      Exclude       : integer_vector := NULL_INTV\n    ) return integer is\n      variable iRandomVal : integer ;\n    begin\n      if Max < Min then\n        Alert(OSVVM_RANDOM_ALERTLOG_ID, \n           \"RandomPkg.Poisson: Min: \" & to_string(Min) &\n               \" >  Max: \" & to_string(Max),  \n           FAILURE) ;        \n        return integer(round(Mean)) ; \n      else\n        loop\n          iRandomVal := integer(round(  Poisson (Mean)  )) ;\n          exit when iRandomVal >= Min and iRandomVal <= Max and\n                     not inside(iRandomVal, Exclude) ;\n        end loop ;\n      end if ;\n      return iRandomVal ;\n    end function  Poisson ;\n    \n\n    --- ///////////////////////////////////////////////////////////////////////////\n    --\n    --  Randomization with range.\n    --    Uses internal settings of RandomParm to deterimine distribution.\n    --\n    --- ///////////////////////////////////////////////////////////////////////////\n    ------------------------------------------------------------\n    impure function LocalRandInt (Min, Max : integer) return integer is\n    ------------------------------------------------------------\n    begin\n      case RandomParm.Distribution is\n        when NONE | UNIFORM =>  return LocalUniform(Min, Max) ;\n        when FAVOR_SMALL  =>    return FavorSmall(Min, Max) ;\n        when FAVOR_BIG    =>    return FavorBig (Min, Max) ;\n        when NORMAL =>          return Normal(RandomParm.Mean, RandomParm.StdDeviation, Min, Max) ;\n        when POISSON =>         return Poisson(RandomParm.Mean, Min, Max) ;\n        when others =>\n          Alert(OSVVM_RANDOM_ALERTLOG_ID, \"RandomPkg.RandInt: RandomParm.Distribution not implemented\", FAILURE) ;\n          return integer'low ;\n      end case ;\n    end function LocalRandInt ;\n    \n    ------------------------------------------------------------\n    impure function RandInt (Min, Max : integer) return integer is\n    ------------------------------------------------------------\n      constant CkMax : integer := CheckMinMax(\"RandInt\", Min, Max) ;\n    begin\n      return LocalRandInt(Min, CkMax) ;\n    end function RandInt ;\n\n    ------------------------------------------------------------\n    impure function RandSlv (Min, Max, Size : natural) return std_logic_vector is\n    ------------------------------------------------------------\n      constant CkMax : integer := CheckMinMax(\"RandSlv\", Min, Max) ;\n    begin\n      return std_logic_vector(to_unsigned(LocalRandInt(Min, CkMax), Size)) ;\n    end function RandSlv ;\n\n    ------------------------------------------------------------\n    impure function RandUnsigned (Min, Max, Size : natural) return Unsigned is\n    ------------------------------------------------------------\n      constant CkMax : integer := CheckMinMax(\"RandUnsigned\", Min, Max) ;\n    begin\n      return to_unsigned(LocalRandInt(Min, CkMax), Size) ;\n    end function RandUnsigned ;\n\n    ------------------------------------------------------------\n    impure function RandSigned (Min, Max : integer ; Size : natural ) return Signed is\n    ------------------------------------------------------------\n      constant CkMax : integer := CheckMinMax(\"RandSigned\", Min, Max) ;\n    begin\n      return to_signed(LocalRandInt(Min, CkMax), Size) ;\n    end function RandSigned ;\n\n    ------------------------------------------------------------\n    impure function RandIntV (Min, Max : integer ; Size : natural) return integer_vector is\n    ------------------------------------------------------------\n      variable result : integer_vector(1 to Size) ;\n      constant CkMax  : integer := CheckMinMax(\"RandIntV\", Min, Max) ;\n    begin\n      for i in result'range loop\n        result(i) := LocalRandInt(Min, CkMax) ;\n      end loop ;\n      return result ;\n    end function RandIntV ;\n\n    ------------------------------------------------------------\n    impure function RandIntV (Min, Max : integer ; Unique : natural ; Size : natural) return integer_vector is\n    ------------------------------------------------------------\n      variable result : integer_vector(1 to Size) ;\n      variable iUnique : natural ; \n    begin\n      -- if Unique = 0, it is more efficient to call RandIntV(Min, Max, Size)\n      iUnique := Unique ; \n      if Max-Min+1 < Unique then\n        Alert(OSVVM_RANDOM_ALERTLOG_ID, \"RandomPkg.(RandIntV | RandRealV | RandTimeV): Unique > number of values available\", FAILURE) ;\n        iUnique := Max-Min+1 ; \n      end if ; \n      for i in result'range loop\n        result(i) := RandInt(Min, Max, result(maximum(1, 1 + i - iUnique) to Size)) ;\n      end loop ;\n      return result ;\n    end function RandIntV ;\n\n    ------------------------------------------------------------\n    impure function LocalRandReal(Min, Max : Real) return real is\n    ------------------------------------------------------------\n    begin\n      case RandomParm.Distribution is\n        when NONE | UNIFORM =>  return LocalUniform(Min, Max) ;\n        when FAVOR_SMALL  =>    return FavorSmall(Min, Max) ;\n        when FAVOR_BIG    =>    return FavorBig (Min, Max) ;\n        when NORMAL =>          return Normal(RandomParm.Mean, RandomParm.StdDeviation, Min, Max) ;\n        when POISSON =>         return Poisson(RandomParm.Mean, Min, Max) ;\n        when others =>\n          Alert(OSVVM_RANDOM_ALERTLOG_ID, \"RandomPkg.RandReal: Specified RandomParm.Distribution not implemented\", FAILURE) ;\n          return real(integer'low) ;\n      end case ;\n    end function LocalRandReal ;\n\n    ------------------------------------------------------------\n    impure function RandReal(Min, Max : Real) return real is\n    ------------------------------------------------------------\n      constant CkMax : real := CheckMinMax(\"RandReal\", Min, Max) ;\n    begin\n      return LocalRandReal(Min, CkMax) ; \n    end function RandReal ;\n\n    ------------------------------------------------------------\n    impure function RandRealV (Min, Max : real ; Size : natural) return real_vector is\n    ------------------------------------------------------------\n      variable result : real_vector(1 to Size) ;\n      constant CkMax  : real := CheckMinMax(\"RandRealV\", Min, Max) ;\n    begin\n      for i in result'range loop\n        result(i) := LocalRandReal(Min, CkMax) ;\n      end loop ;\n      return result ;\n    end function RandRealV ;\n\n    ------------------------------------------------------------\n    impure function LocalRandTime (Min, Max : time ; Unit :time := ns) return time is\n    ------------------------------------------------------------\n      variable IntVal : integer ;\n    begin\n      --  if Max - Min > 2**31 result will be out of range\n      IntVal := LocalRandInt(0, (Max - Min)/Unit) ;\n      return Min + Unit*IntVal ;\n    end function LocalRandTime ;\n\n    ------------------------------------------------------------\n    impure function RandTime (Min, Max : time ; Unit :time := ns) return time is\n    ------------------------------------------------------------\n      constant CkMax  : time := CheckMinMax(\"RandTime\", Min, Max) ;\n    begin\n      return LocalRandTime (Min, CkMax, Unit) ;\n    end function RandTime ;\n\n    ------------------------------------------------------------\n    impure function RandTimeV (Min, Max : time ; Size : natural ; Unit : time := ns) return time_vector is\n    ------------------------------------------------------------\n      variable result : time_vector(1 to Size) ;\n      constant CkMax  : time := CheckMinMax(\"RandTimeV\", Min, Max) ;\n    begin\n      for i in result'range loop\n        result(i) := LocalRandTime(Min, CkMax, Unit) ;\n      end loop ;\n      return result ;\n    end function RandTimeV ;\n    \n    ------------------------------------------------------------\n    impure function RandTimeV (Min, Max : time ; Unique : natural ; Size : natural ; Unit : time := ns) return time_vector is\n    ------------------------------------------------------------\n      constant CkMax  : time := CheckMinMax(\"RandTimeV\", Min, Max) ;\n    begin\n      -- if Unique = 0, it is more efficient to call RandTimeV(Min, Max, Size)\n      return to_time_vector(RandIntV(Min/Unit, CkMax/Unit, Unique, Size), Unit) ; \n    end function RandTimeV ;\n\n\n    --- ///////////////////////////////////////////////////////////////////////////\n    --\n    --  Randomization with range and exclude vector.\n    --    Uses internal settings of RandomParm to deterimine distribution.\n    --\n    --- ///////////////////////////////////////////////////////////////////////////\n    ------------------------------------------------------------\n    impure function LocalRandInt (Min, Max : integer ; Exclude : integer_vector ) return integer is\n    ------------------------------------------------------------\n    begin\n      case RandomParm.Distribution is\n        when NONE | UNIFORM =>  return  LocalUniform(Min, Max, Exclude) ;\n        when FAVOR_SMALL  =>    return  FavorSmall(Min, Max, Exclude) ;\n        when FAVOR_BIG    =>    return  FavorBig (Min, Max, Exclude) ;\n        when NORMAL =>          return  Normal(RandomParm.Mean, RandomParm.StdDeviation, Min, Max, Exclude) ;\n        when POISSON =>         return  Poisson(RandomParm.Mean, Min, Max, Exclude) ;\n        when others =>\n          Alert(OSVVM_RANDOM_ALERTLOG_ID, \"RandomPkg.RandInt: Specified RandomParm.Distribution not implemented\", FAILURE) ;\n          return integer'low ;\n      end case ;\n    end function LocalRandInt ;\n\n    ------------------------------------------------------------\n    impure function RandInt (Min, Max : integer ; Exclude : integer_vector ) return integer is\n    ------------------------------------------------------------\n      constant CkMax : integer := CheckMinMax(\"RandInt\", Min, Max) ;\n    begin\n      return  LocalRandInt(Min, CkMax, Exclude) ;\n    end function RandInt ;\n\n    ------------------------------------------------------------\n    impure function RandSlv (Min, Max : natural ; Exclude : integer_vector ; Size  : natural ) return std_logic_vector is\n    ------------------------------------------------------------\n      constant CkMax : integer := CheckMinMax(\"RandSlv\", Min, Max) ;\n    begin\n      return std_logic_vector(to_unsigned(RandInt(Min, CkMax, Exclude), Size)) ;\n    end function RandSlv ;\n\n    ------------------------------------------------------------\n    impure function RandUnsigned (Min, Max : natural ; Exclude : integer_vector ; Size  : natural ) return Unsigned is\n    ------------------------------------------------------------\n      constant CkMax : integer := CheckMinMax(\"RandUnsigned\", Min, Max) ;\n    begin\n      return to_unsigned(RandInt(Min, CkMax, Exclude), Size) ;\n    end function RandUnsigned ;\n\n    ------------------------------------------------------------\n    impure function RandSigned (Min, Max : integer ; Exclude : integer_vector ; Size  : natural ) return Signed is\n    ------------------------------------------------------------\n      constant CkMax : integer := CheckMinMax(\"RandSigned\", Min, Max) ;\n    begin\n      return to_signed(RandInt(Min, CkMax, Exclude), Size) ;\n    end function RandSigned ;\n\n    ------------------------------------------------------------\n    impure function RandIntV (Min, Max : integer ; Exclude : integer_vector ; Size : natural) return integer_vector is\n    ------------------------------------------------------------\n      variable result : integer_vector(1 to Size) ;\n      constant CkMax  : integer := CheckMinMax(\"RandIntV\", Min, Max) ;\n    begin\n      for i in result'range loop\n        result(i) := RandInt(Min, CkMax, Exclude) ;\n      end loop ;\n      return result ;\n    end function RandIntV ;\n\n    ------------------------------------------------------------\n    impure function RandIntV (Min, Max : integer ; Exclude : integer_vector ; Unique : natural ; Size : natural) return integer_vector is\n    ------------------------------------------------------------\n      variable ResultPlus : integer_vector(1 to Size + Exclude'length) ;\n      constant CkMax  : integer := CheckMinMax(\"RandIntV\", Min, Max) ;\n    begin\n      -- if Unique = 0, it is more efficient to call RandIntV(Min, Max, Size)\n      ResultPlus(Size+1 to ResultPlus'right) := Exclude ;\n      for i in 1 to Size loop\n        ResultPlus(i) := RandInt(Min, CkMax, ResultPlus(maximum(1, 1 + i - Unique) to ResultPlus'right)) ;\n      end loop ;\n      return ResultPlus(1 to Size) ;\n    end function RandIntV ;\n\n    ------------------------------------------------------------\n    impure function RandTime (Min, Max : time ; Exclude : time_vector ; Unit : time := ns) return time is\n    ------------------------------------------------------------\n      variable IntVal : integer ;\n      constant CkMax  : time := CheckMinMax(\"RandTime\", Min, Max) ;\n    begin\n      --  if Min or Max > 2**31 value will be out of range\n      return RandInt(Min/Unit, Max/Unit, to_integer_vector(Exclude, Unit)) * Unit ;\n    end function RandTime ;\n\n    ------------------------------------------------------------\n    impure function RandTimeV (Min, Max : time ; Exclude : time_vector ; Size : natural ; Unit : in time := ns) return time_vector is\n    ------------------------------------------------------------\n      constant CkMax  : time := CheckMinMax(\"RandTimeV\", Min, Max) ;\n    begin\n      return to_time_vector( RandIntV(Min/Unit, CkMax/Unit, to_integer_vector(Exclude, Unit), Size), Unit ) ; \n    end function RandTimeV ;\n\n    ------------------------------------------------------------\n    impure function RandTimeV (Min, Max : time ; Exclude : time_vector ; Unique : natural ; Size : natural ; Unit : in time := ns) return time_vector is\n    ------------------------------------------------------------\n      constant CkMax  : time := CheckMinMax(\"RandTimeV\", Min, Max) ;\n    begin\n      -- if Unique = 0, it is more efficient to call RandIntV(Min, Max, Size)\n      return to_time_vector( RandIntV(Min/Unit, CkMax/Unit, to_integer_vector(Exclude, Unit), Unique, Size), Unit ) ; \n    end function RandTimeV ;\n\n\n    --- ///////////////////////////////////////////////////////////////////////////\n    --\n    --  Randomly select a value within a set of values\n    --    Uses internal settings of RandomParm to deterimine distribution.\n    --\n    --- ///////////////////////////////////////////////////////////////////////////\n    ------------------------------------------------------------\n    impure function RandInt ( A : integer_vector ) return integer is\n     ------------------------------------------------------------\n     alias A_norm : integer_vector(1 to A'length) is A ;\n    begin\n      return A_norm( RandInt(1, A'length) ) ;\n    end function RandInt ;\n\n    ------------------------------------------------------------\n    impure function RandReal ( A : real_vector ) return real is\n    ------------------------------------------------------------\n      alias A_norm : real_vector(1 to A'length) is A ;\n    begin\n      return A_norm( RandInt(1, A'length) ) ;\n    end function RandReal ;\n\n    ------------------------------------------------------------\n    impure function RandTime ( A : time_vector ) return time is\n    ------------------------------------------------------------\n      alias A_norm : time_vector(1 to A'length) is A ;\n    begin\n      return A_norm( RandInt(1, A'length) ) ;\n    end function RandTime ;\n\n    ------------------------------------------------------------\n    impure function RandSlv (A : integer_vector ; Size : natural) return std_logic_vector is\n    ------------------------------------------------------------\n    begin\n      return std_logic_vector(to_unsigned(RandInt(A), Size)) ;\n    end function RandSlv ;\n\n    ------------------------------------------------------------\n    impure function RandUnsigned (A : integer_vector ; Size : natural) return Unsigned is\n    ------------------------------------------------------------\n    begin\n      return to_unsigned(RandInt(A), Size) ;\n    end function RandUnsigned ;\n\n    ------------------------------------------------------------\n    impure function RandSigned (A : integer_vector ; Size : natural ) return Signed is\n    ------------------------------------------------------------\n    begin\n      return to_signed(RandInt(A), Size) ;\n    end function RandSigned ;\n\n    ------------------------------------------------------------\n    impure function RandIntV (A : integer_vector ; Size : natural) return integer_vector is\n    ------------------------------------------------------------\n      variable result : integer_vector(1 to Size) ;\n    begin\n      for i in result'range loop\n        result(i) := RandInt(A) ;\n      end loop ;\n      return result ;\n    end function RandIntV ;\n\n    ------------------------------------------------------------\n    impure function RandIntV (A : integer_vector ; Unique : natural ; Size : natural) return integer_vector is\n    ------------------------------------------------------------\n      variable result : integer_vector(1 to Size) ;\n      variable iUnique : natural ; \n    begin\n      -- if Unique = 0, it is more efficient to call RandIntV(A, Size)\n      -- require A'length >= Unique\n      iUnique := Unique ; \n      if A'length < Unique then\n        Alert(OSVVM_RANDOM_ALERTLOG_ID, \"RandomPkg.RandIntV: Unique > length of set of values\", FAILURE) ;\n        iUnique := A'length ; \n      end if ; \n      for i in result'range loop\n        result(i) := RandInt(A, result(maximum(1, 1 + i - iUnique) to Size)) ;\n      end loop ;\n      return result ;\n    end function RandIntV ;\n\n    ------------------------------------------------------------\n    impure function RandRealV (A : real_vector ; Size : natural) return real_vector is\n    ------------------------------------------------------------\n      variable result : real_vector(1 to Size) ;\n    begin\n      for i in result'range loop\n        result(i) := RandReal(A) ;\n      end loop ;\n      return result ;\n    end function RandRealV ;\n\n    ------------------------------------------------------------\n    impure function RandRealV (A : real_vector ; Unique : natural ; Size : natural) return real_vector is\n    ------------------------------------------------------------\n      alias A_norm : real_vector(1 to A'length) is A ;\n      variable result : real_vector(1 to Size) ;\n      variable IntResult : integer_vector(result'range) ;\n    begin\n      -- randomly generate indices\n      IntResult := RandIntV(1, A'length, Unique, Size) ;\n      -- translate indicies into result values\n      for i in result'range loop\n        result(i) := A_norm(IntResult(i)) ;\n      end loop ;\n      return result ;\n    end function RandRealV ;\n\n    ------------------------------------------------------------\n    impure function RandTimeV (A : time_vector ; Size : natural) return time_vector is\n    ------------------------------------------------------------\n      variable result : time_vector(1 to Size) ;\n    begin\n      for i in result'range loop\n        result(i) := RandTime(A) ;\n      end loop ;\n      return result ;\n    end function RandTimeV ;\n\n    ------------------------------------------------------------\n    impure function RandTimeV (A : time_vector ; Unique : natural ; Size : natural) return time_vector is\n    ------------------------------------------------------------\n      alias A_norm : time_vector(1 to A'length) is A ;\n      variable result : time_vector(1 to Size) ;\n      variable IntResult : integer_vector(result'range) ;\n    begin\n      -- randomly generate indices\n      IntResult := RandIntV(1, A'length, Unique, Size) ;\n      -- translate indicies into result values\n      for i in result'range loop\n        result(i) := A_norm(IntResult(i)) ;\n      end loop ;\n      return result ;\n    end function RandTimeV ;\n\n\n    --- ///////////////////////////////////////////////////////////////////////////\n    --\n    --  Randomly select a value within a set of values with exclude values (so can skip last or last n)\n    --    Uses internal settings of RandomParm to deterimine distribution.\n    --\n    --- ///////////////////////////////////////////////////////////////////////////\n    ------------------------------------------------------------\n    impure function RandInt ( A, Exclude : integer_vector ) return integer is\n    ------------------------------------------------------------\n      variable NewA : integer_vector(1 to A'length) ;\n      variable NewALength : natural ;\n    begin\n      -- Remove Exclude from A\n      RemoveExclude(A, Exclude, NewA, NewALength) ;\n      -- Randomize Index\n      return NewA(RandInt(1, NewALength)) ;\n    end function RandInt ;\n\n    ------------------------------------------------------------\n    impure function RandReal ( A, Exclude : real_vector ) return real is\n    ------------------------------------------------------------\n      variable NewA : real_vector(1 to A'length) ;\n      variable NewALength : natural ;\n    begin\n      -- Remove Exclude from A\n      RemoveExclude(A, Exclude, NewA, NewALength) ;\n      -- Randomize Index\n      return NewA(RandInt(1, NewALength)) ;\n    end function RandReal ;\n\n    ------------------------------------------------------------\n    impure function RandTime ( A, Exclude : time_vector ) return time is\n    ------------------------------------------------------------\n      variable NewA : time_vector(1 to A'length) ;\n      variable NewALength : natural ;\n    begin\n      -- Remove Exclude from A\n      RemoveExclude(A, Exclude, NewA, NewALength) ;\n      -- Randomize Index\n      return NewA(RandInt(1, NewALength)) ;\n    end function RandTime ;\n\n    ------------------------------------------------------------\n    impure function RandSlv (A, Exclude : integer_vector ; Size : natural) return std_logic_vector is\n    ------------------------------------------------------------\n    begin\n      return std_logic_vector(to_unsigned(RandInt(A, Exclude), Size)) ;\n    end function RandSlv ;\n\n    ------------------------------------------------------------\n    impure function RandUnsigned (A, Exclude : integer_vector ; Size : natural) return Unsigned is\n    ------------------------------------------------------------\n    begin\n      return to_unsigned(RandInt(A, Exclude), Size) ;\n    end function RandUnsigned ;\n\n    ------------------------------------------------------------\n    impure function RandSigned (A, Exclude : integer_vector ; Size : natural ) return Signed is\n    ------------------------------------------------------------\n    begin\n      return to_signed(RandInt(A, Exclude), Size) ;\n    end function RandSigned ;\n\n    ------------------------------------------------------------\n    impure function RandIntV (A, Exclude : integer_vector ; Size : natural) return integer_vector is\n    ------------------------------------------------------------\n      variable result : integer_vector(1 to Size) ;\n      variable NewA  : integer_vector(1 to A'length) ;\n      variable NewALength : natural ;\n    begin\n      -- Remove Exclude from A\n      RemoveExclude(A, Exclude, NewA, NewALength) ;\n      -- Randomize Index\n      for i in result'range loop\n        result(i) := NewA(RandInt(1, NewALength)) ;\n      end loop ;\n      return result ;\n    end function RandIntV ;\n\n    ------------------------------------------------------------\n    impure function RandIntV (A, Exclude : integer_vector ; Unique : natural ; Size : natural) return integer_vector is\n    ------------------------------------------------------------\n      variable result : integer_vector(1 to Size) ;\n      variable NewA  : integer_vector(1 to A'length) ;\n      variable NewALength, iUnique : natural ;\n    begin\n      -- if Unique = 0, it is more efficient to call RandIntV(Min, Max, Size)\n      -- Remove Exclude from A\n      RemoveExclude(A, Exclude, NewA, NewALength) ;\n      -- Require NewALength >= Unique\n      iUnique := Unique ; \n      if NewALength < Unique then \n        Alert(OSVVM_RANDOM_ALERTLOG_ID, \"RandomPkg.RandIntV: Unique > Length of Set A - Exclude\", FAILURE) ;\n        iUnique := NewALength ; \n      end if ; \n      -- Randomize using exclude list of Unique # of newly generated values\n      for i in result'range loop\n        result(i) := RandInt(NewA(1 to NewALength), result(maximum(1, 1 + i - iUnique) to Size)) ;\n      end loop ;\n      return result ;\n    end function RandIntV ;\n\n    ------------------------------------------------------------\n    impure function RandRealV (A, Exclude : real_vector ; Size : natural) return real_vector is\n    ------------------------------------------------------------\n      variable result : real_vector(1 to Size) ;\n      variable NewA  : real_vector(1 to A'length) ;\n      variable NewALength : natural ;\n    begin\n      -- Remove Exclude from A\n      RemoveExclude(A, Exclude, NewA, NewALength) ;\n      -- Randomize Index\n      for i in result'range loop\n        result(i) := NewA(RandInt(1, NewALength)) ;\n      end loop ;\n      return result ;\n    end function RandRealV ;\n\n    ------------------------------------------------------------\n    impure function RandRealV (A, Exclude : real_vector ; Unique : natural ; Size : natural) return real_vector is\n    ------------------------------------------------------------\n      variable result : real_vector(1 to Size) ;\n      variable NewA  : real_vector(1 to A'length) ;\n      variable NewALength, iUnique : natural ;\n    begin\n      -- if Unique = 0, it is more efficient to call RandRealV(Min, Max, Size)\n      -- Remove Exclude from A\n      RemoveExclude(A, Exclude, NewA, NewALength) ;\n      -- Require NewALength >= Unique\n      iUnique := Unique ; \n      if NewALength < Unique then \n        Alert(OSVVM_RANDOM_ALERTLOG_ID, \"RandomPkg.RandRealV: Unique > Length of Set A - Exclude\", FAILURE) ;\n        iUnique := NewALength ; \n      end if ; \n      -- Randomize using exclude list of Unique # of newly generated values\n      for i in result'range loop\n        result(i) := RandReal(NewA(1 to NewALength), result(maximum(1, 1 + i - iUnique) to Size)) ;\n      end loop ;\n      return result ;\n    end function RandRealV ;\n\n    ------------------------------------------------------------\n    impure function RandTimeV (A, Exclude : time_vector ; Size : natural) return time_vector is\n    ------------------------------------------------------------\n      variable result : time_vector(1 to Size) ;\n      variable NewA  : time_vector(1 to A'length) ;\n      variable NewALength : natural ;\n    begin\n      -- Remove Exclude from A\n      RemoveExclude(A, Exclude, NewA, NewALength) ;\n      -- Randomize Index\n      for i in result'range loop\n        result(i) := NewA(RandInt(1, NewALength)) ;\n      end loop ;\n      return result ;\n    end function RandTimeV ;\n\n    ------------------------------------------------------------\n    impure function RandTimeV (A, Exclude : time_vector ; Unique : natural ; Size : natural) return time_vector is\n    ------------------------------------------------------------\n      variable result : time_vector(1 to Size) ;\n      variable NewA  : time_vector(1 to A'length) ;\n      variable NewALength, iUnique : natural ;\n    begin\n      -- if Unique = 0, it is more efficient to call RandRealV(Min, Max, Size)\n      -- Remove Exclude from A\n      RemoveExclude(A, Exclude, NewA, NewALength) ;\n      -- Require NewALength >= Unique\n      iUnique := Unique ; \n      if NewALength < Unique then \n        Alert(OSVVM_RANDOM_ALERTLOG_ID, \"RandomPkg.RandTimeV: Unique > Length of Set A - Exclude\", FAILURE) ;\n        iUnique := NewALength ; \n      end if ; \n      -- Randomize using exclude list of Unique # of newly generated values\n      for i in result'range loop\n        result(i) := RandTime(NewA(1 to NewALength), result(maximum(1, 1 + i - iUnique) to Size)) ;\n      end loop ;\n      return result ;\n    end function RandTimeV ;\n\n\n    --- ///////////////////////////////////////////////////////////////////////////\n    --\n    --  Basic Discrete Distributions\n    --    Always uses Uniform\n    --\n    --- ///////////////////////////////////////////////////////////////////////////\n    ------------------------------------------------------------\n    impure function DistInt ( Weight : integer_vector ) return integer is\n    ------------------------------------------------------------\n      variable DistArray : integer_vector(weight'range) ;\n      variable sum : integer ;\n      variable iRandomVal : integer ;\n    begin\n      DistArray := Weight ;\n      sum := 0 ;\n      for i in DistArray'range loop\n        DistArray(i) := DistArray(i) + sum ;\n        if DistArray(i) < sum then\n          Alert(OSVVM_RANDOM_ALERTLOG_ID, \"RandomPkg.DistInt: negative weight or sum > 31 bits\", FAILURE) ;\n          return DistArray'low ; -- allows debugging vs integer'left, out of range\n        end if ;\n        sum := DistArray(i) ;\n      end loop ;\n      if sum >= 1 then\n        iRandomVal := Uniform(1, sum) ;\n        for i in DistArray'range loop\n          if iRandomVal <= DistArray(i) then\n            return i ;\n          end if ;\n        end loop ;\n        Alert(OSVVM_RANDOM_ALERTLOG_ID, \"RandomPkg.DistInt: randomization failed\", FAILURE) ;\n      else\n        Alert(OSVVM_RANDOM_ALERTLOG_ID, \"RandomPkg.DistInt: No randomization weights\", FAILURE) ;\n      end if ;\n      return DistArray'low ; -- allows debugging vs integer'left, out of range\n    end function DistInt ;\n\n    ------------------------------------------------------------\n    impure function DistSlv ( Weight : integer_vector ; Size  : natural ) return std_logic_vector is\n    ------------------------------------------------------------\n    begin\n      return std_logic_vector(to_unsigned(DistInt(Weight), Size)) ;\n    end function DistSlv ;\n\n    ------------------------------------------------------------\n    impure function DistUnsigned ( Weight : integer_vector ; Size  : natural ) return unsigned is\n    ------------------------------------------------------------\n    begin\n      return to_unsigned(DistInt(Weight), Size) ;\n    end function DistUnsigned ;\n\n    ------------------------------------------------------------\n    impure function DistSigned ( Weight : integer_vector ; Size  : natural ) return signed is\n    ------------------------------------------------------------\n    begin\n      return to_signed(DistInt(Weight), Size) ;\n    end function DistSigned ;\n\n    ------------------------------------------------------------\n    impure function DistBool ( Weight : NaturalVBoolType ) return boolean is\n    ------------------------------------------------------------\n      variable FullWeight : integer_vector(0 to 1) := (others => 0);\n    begin\n      for i in Weight'range loop\n        FullWeight(boolean'pos(i)) := Weight(i) ;\n      end loop ; \n      return boolean'val(DistInt(FullWeight)) ;\n    end function DistBool ;\n\n    ------------------------------------------------------------\n    impure function DistSl ( Weight : NaturalVSlType ) return std_logic is\n    ------------------------------------------------------------\n      variable FullWeight : integer_vector(0 to 8) := (others => 0);\n    begin\n      for i in Weight'range loop\n        FullWeight(std_logic'pos(i)) := Weight(i) ;\n      end loop ; \n      return std_logic'val(DistInt(FullWeight)) ;\n    end function DistSl ;\n\n    ------------------------------------------------------------\n    impure function DistBit ( Weight : NaturalVBitType ) return bit is\n    ------------------------------------------------------------\n      variable FullWeight : integer_vector(0 to 1) := (others => 0);\n    begin\n      for i in Weight'range loop\n        FullWeight(bit'pos(i)) := Weight(i) ;\n      end loop ; \n      return bit'val(DistInt(FullWeight)) ;\n    end function DistBit ;\n\n\n    --- ///////////////////////////////////////////////////////////////////////////\n    --\n    --  Basic Distributions with exclude values (so can skip last or last n)\n    --    Always uses Uniform via DistInt\n    --\n    --- ///////////////////////////////////////////////////////////////////////////\n    ------------------------------------------------------------\n    impure function DistInt ( Weight : integer_vector ; Exclude : integer_vector ) return integer is\n    ------------------------------------------------------------\n      variable DistArray : integer_vector(weight'range) ;\n      variable ExcludeTemp : integer ;\n    begin\n      DistArray := Weight ;\n      for i in Exclude'range loop\n        ExcludeTemp := Exclude(i) ;\n        if ExcludeTemp >= DistArray'low and ExcludeTemp <= DistArray'high then\n          DistArray(ExcludeTemp) := 0 ;\n        end if ;\n      end loop ;\n      return DistInt(DistArray) ;\n    end function DistInt ;\n\n    ------------------------------------------------------------\n    impure function DistSlv ( Weight : integer_vector ; Exclude : integer_vector ; Size  : natural ) return std_logic_vector is\n    ------------------------------------------------------------\n    begin\n      return std_logic_vector(to_unsigned(DistInt(Weight, Exclude), Size)) ;\n    end function DistSlv ;\n\n    ------------------------------------------------------------\n    impure function DistUnsigned ( Weight : integer_vector ; Exclude : integer_vector ; Size  : natural ) return unsigned is\n    ------------------------------------------------------------\n    begin\n      return to_unsigned(DistInt(Weight, Exclude), Size) ;\n    end function DistUnsigned ;\n\n    ------------------------------------------------------------\n    impure function DistSigned ( Weight : integer_vector ; Exclude : integer_vector ; Size  : natural ) return signed is\n    ------------------------------------------------------------\n    begin\n      return to_signed(DistInt(Weight, Exclude), Size) ;\n    end function DistSigned ;\n\n\n    --- ///////////////////////////////////////////////////////////////////////////\n    --\n    --  Distribution for sparse values\n    --    Always uses Uniform via DistInt\n    --\n    --- ///////////////////////////////////////////////////////////////////////////\n    ------------------------------------------------------------\n    impure function DistValInt ( A : DistType ) return integer is\n    ------------------------------------------------------------\n      variable DistArray : integer_vector(0 to A'length -1) ;\n      alias DistRecArray : DistType(DistArray'range) is A ;\n    begin\n      for i in DistArray'range loop\n        DistArray(i) := DistRecArray(i).Weight ;\n      end loop ;\n      return DistRecArray(DistInt(DistArray)).Value ;\n    end function DistValInt ;\n\n    ------------------------------------------------------------\n    impure function DistValSlv ( A : DistType ; Size  : natural ) return std_logic_vector is\n    ------------------------------------------------------------\n    begin\n      return std_logic_vector(to_unsigned(DistValInt(A), Size)) ;\n    end function DistValSlv ;\n\n    ------------------------------------------------------------\n    impure function DistValUnsigned ( A : DistType ; Size  : natural ) return unsigned is\n    ------------------------------------------------------------\n    begin\n      return to_unsigned(DistValInt(A), Size) ;\n    end function DistValUnsigned ;\n\n    ------------------------------------------------------------\n    impure function DistValSigned ( A : DistType ; Size  : natural ) return signed is\n    ------------------------------------------------------------\n    begin\n      return to_signed(DistValInt(A), Size) ;\n    end function DistValSigned ;\n\n\n    --- ///////////////////////////////////////////////////////////////////////////\n    --\n    --  Distribution for sparse values with exclude values (so can skip last or last n)\n    --    Always uses Uniform via DistInt\n    --\n    --- ///////////////////////////////////////////////////////////////////////////\n    ------------------------------------------------------------\n    impure function DistValInt ( A : DistType ; Exclude : integer_vector ) return integer is\n    ------------------------------------------------------------\n      variable DistArray : integer_vector(0 to A'length -1) ;\n      alias DistRecArray : DistType(DistArray'range) is A ;\n    begin\n      for i in DistRecArray'range loop\n        if inside(DistRecArray(i).Value, exclude) then\n          DistArray(i) := 0 ; -- exclude\n        else\n          DistArray(i) := DistRecArray(i).Weight ;\n        end if ;\n      end loop ;\n      return DistRecArray(DistInt(DistArray)).Value ;\n    end function DistValInt ;\n\n    ------------------------------------------------------------\n    impure function DistValSlv ( A : DistType ; Exclude : integer_vector ; Size  : natural ) return std_logic_vector is\n    ------------------------------------------------------------\n    begin\n      return std_logic_vector(to_unsigned(DistValInt(A, Exclude), Size)) ;\n    end function DistValSlv ;\n\n    ------------------------------------------------------------\n    impure function DistValUnsigned ( A : DistType ; Exclude : integer_vector ; Size  : natural ) return unsigned is\n    ------------------------------------------------------------\n    begin\n      return to_unsigned(DistValInt(A, Exclude), Size) ;\n    end function DistValUnsigned ;\n\n    ------------------------------------------------------------\n    impure function DistValSigned ( A : DistType ; Exclude : integer_vector ; Size  : natural ) return signed is\n    ------------------------------------------------------------\n    begin\n      return to_signed(DistValInt(A, Exclude), Size) ;\n    end function DistValSigned ;\n\n\n    --- ///////////////////////////////////////////////////////////////////////////\n    --\n    -- Large vector handling.\n    --\n    --- ///////////////////////////////////////////////////////////////////////////\n    ------------------------------------------------------------\n    impure function RandUnsigned (Size : natural) return unsigned is\n    ------------------------------------------------------------\n      constant NumLoops : integer := integer(ceil(real(Size)/30.0)) ;\n      constant Remain : integer := (Size - 1) mod 30 + 1 ; -- range 1 to 30\n      variable RandVal : unsigned(1 to Size) ;\n    begin\n      if size = 0 then\n        return NULL_UV ; -- Null array\n      end if ;\n      for i in 0 to NumLoops-2 loop\n        RandVal(1 + 30*i to 30 + 30*i) := to_unsigned(RandInt(0, 2**30-1), 30) ;\n      end loop ;\n      RandVal(1+30*(NumLoops-1) to Remain + 30*(NumLoops-1)) := to_unsigned(RandInt(0, 2**Remain-1), Remain) ;\n      return RandVal ;\n    end function RandUnsigned ;\n\n    ------------------------------------------------------------\n    impure function RandSlv (Size : natural) return std_logic_vector is\n    ------------------------------------------------------------\n    begin\n      return std_logic_vector(RandUnsigned(Size)) ;\n    end function RandSlv ;\n\n    ------------------------------------------------------------\n    impure function RandSigned (Size : natural) return signed is\n    ------------------------------------------------------------\n    begin\n      return signed(RandUnsigned(Size)) ;\n    end function RandSigned ;\n\n    ------------------------------------------------------------\n    impure function SizeByLeftMostBit (A : unsigned) return integer is\n    ------------------------------------------------------------\n      alias normA : unsigned (A'length downto 1) is A ;\n    begin\n      for i in normA'range loop \n        if normA(i) = '1' then \n          return i ; \n        end if ; \n      end loop ;\n      return -1 ; \n    end function SizeByLeftMostBit ; \n\n    ------------------------------------------------------------\n    impure function RandUnsigned (Max : unsigned) return unsigned is\n    ------------------------------------------------------------\n      alias normMax : unsigned (Max'length downto 1) is Max ;\n      variable Result : unsigned(Max'range) := (others => '0') ;\n      alias normResult : unsigned(normMax'range) is Result ;\n      variable Size : integer ;\n    begin\n      -- Size = -1 if not found or Max'length = 0\n      Size := SizeByLeftMostBit(Max) ;\n\n      if Size > 0 then\n        loop\n          normResult(Size downto 1) := RandUnsigned(Size) ;\n          exit when normResult <= Max ;\n        end loop ;\n        return Result ; -- = normResult with range same as Max\n      else\n        return resize(\"0\", Max'length) ;\n      end if ;\n    end function RandUnsigned ;\n\n    -- Working version that scales the value\n    -- impure function RandUnsigned (Max : unsigned) return unsigned is\n    --   constant MaxVal  : unsigned(Max'length+3 downto 1) := (others => '1') ;\n    -- begin\n    --   if max'length > 0 then\n    --     -- \"Max'length+3\" creates 3 guard bits\n    --     return resize( RandUnsigned(Max'length+3) * ('0'&Max+1) / ('0'&MaxVal+1), Max'length) ;\n    --   else\n    --     return NULL_UV ; -- Null Array\n    --   end if ;\n    -- end function RandUnsigned ;\n\n    ------------------------------------------------------------\n    impure function RandSlv (Max : std_logic_vector) return std_logic_vector is\n    ------------------------------------------------------------\n    begin\n      return std_logic_vector(RandUnsigned( unsigned(Max))) ;\n    end function RandSlv ;\n\n    ------------------------------------------------------------\n    impure function RandSigned (Max : signed) return signed is\n    ------------------------------------------------------------\n    begin\n      if max'length > 0 then\n        AlertIf (OSVVM_RANDOM_ALERTLOG_ID, Max < 0, \"RandomPkg.RandSigned: Max < 0\", FAILURE) ;\n        return signed(RandUnsigned( unsigned(Max))) ;\n      else\n        return NULL_SV ; -- Null Array\n      end if ;\n    end function RandSigned ;\n\n    ------------------------------------------------------------\n    impure function RandUnsigned (Min, Max : unsigned) return unsigned is\n    ------------------------------------------------------------\n      constant LEN : integer := maximum(Max'length, Min'length) ;\n    begin\n      if LEN > 0 and Min <= Max then\n        return RandUnsigned(Max-Min) + Min ;\n      else\n        if Len > 0 then\n          Alert(OSVVM_RANDOM_ALERTLOG_ID, \"RandomPkg.RandUnsigned: Max < Min\", FAILURE) ;\n        end if ;\n        return NULL_UV ;\n      end if ;\n    end function RandUnsigned ;\n\n    ------------------------------------------------------------\n    impure function RandSlv (Min, Max : std_logic_vector) return std_logic_vector is\n    ------------------------------------------------------------\n      constant LEN : integer := maximum(Max'length, Min'length) ;\n    begin\n      if LEN > 0 and Min <= Max then\n        return RandSlv(Max-Min) + Min ;\n      else\n        if Len > 0 then\n          Alert(OSVVM_RANDOM_ALERTLOG_ID, \"RandomPkg.RandSlv: Max < Min\", FAILURE) ;\n        end if ;\n          return NULL_SlV ;\n      end if ;\n    end function RandSlv ;\n\n    ------------------------------------------------------------\n    impure function RandSigned (Min, Max : signed) return signed is\n    ------------------------------------------------------------\n      constant LEN : integer := maximum(Max'length, Min'length) ;\n    begin\n      if LEN > 0 and Min <= Max then\n        return resize(RandSigned(resize(Max,LEN+1) - resize(Min,LEN+1)) + Min, LEN) ;\n      else\n        if Len > 0 then\n          Alert(OSVVM_RANDOM_ALERTLOG_ID, \"RandomPkg.RandSigned: Max < Min\", FAILURE) ;\n        end if ;\n        return NULL_SV ;\n      end if ;\n    end function RandSigned ;\n\n\n    --- ///////////////////////////////////////////////////////////////////////////\n    --\n    --  Convenience Functions.  Resolve into calls into the other functions\n    --\n    --- ///////////////////////////////////////////////////////////////////////////\n    ------------------------------------------------------------\n    impure function RandReal return real is\n    ------------------------------------------------------------\n    begin\n      return RandReal(0.0, 1.0) ;\n    end function RandReal ;\n\n    ------------------------------------------------------------\n    impure function RandReal(Max : Real) return real is  -- 0.0 to Max\n    ------------------------------------------------------------\n    begin\n      return RandReal(0.0, Max) ;\n    end function RandReal ;\n\n    ------------------------------------------------------------\n    impure function RandInt (Max : integer) return integer is\n    ------------------------------------------------------------\n    begin\n      return RandInt(0, Max) ;\n    end function RandInt ;\n\n    ------------------------------------------------------------\n    impure function RandSlv (Max, Size : natural) return std_logic_vector is\n    ------------------------------------------------------------\n    begin\n      return std_logic_vector(to_unsigned(RandInt(0, Max), Size)) ;\n    end function RandSlv ;\n\n    ------------------------------------------------------------\n    impure function RandUnsigned (Max, Size : natural) return Unsigned is\n    ------------------------------------------------------------\n    begin\n      return to_unsigned(RandInt(0, Max), Size) ;\n    end function RandUnsigned ;\n\n    ------------------------------------------------------------\n    impure function RandSigned (Max : integer ; Size : natural ) return Signed is\n    ------------------------------------------------------------\n    begin\n      -- chose 0 to Max rather than -Max to +Max to be same as RandUnsigned, either seems logical\n      return to_signed(RandInt(0, Max), Size) ;\n    end function RandSigned ;\n\n    ------------------------------------------------------------\n    impure function RandBool return boolean is\n    ------------------------------------------------------------\n    begin\n      return RandInt(1) = 1;\n    end function RandBool ;\n\n    ------------------------------------------------------------\n    impure function RandSl return std_logic is\n    ------------------------------------------------------------\n    begin\n      return std_logic'val(RandInt(8));\n    end function RandSl ;\n  \n    ------------------------------------------------------------\n    impure function RandBit return bit is\n    ------------------------------------------------------------\n    begin\n      return bit'val(RandInt(1));\n    end function RandBit ;\n  \n  end protected body RandomPType ;\n\nend RandomPkg ;\n","lang":"vhdl"};
processSrcData(g_data);