var g_data = {"name":"C:/SynthWorks/Dev/_osvvm/OsvvmLibraries/DpRam/src/DpRam_Singleton.vhd","src":"--\n--  File Name:		DpRam_Singleton.vhd\n--  Block Name:		DpRam_Singleton\n--  Revision:          STANDARD VERSION\n--\n--  Maintainer:        Jim Lewis      email:  jim@synthworks.com \n--  Contributor(s):            \n--     Jim Lewis      email:  jim@synthworks.com   \n--\n--  Description\n--      Package defines a protected type, MemoryPType, and methods  \n--      for efficiently implementing memory data structures\n--    \n--  Developed for: \n--        SynthWorks Design Inc. \n--        VHDL Training Classes\n--        11898 SW 128th Ave.  Tigard, Or  97223\n--        http://www.SynthWorks.com\n--\n--  Revision History:\n--    Date      Version    Description\n--    12/2021   2021.12    Initial for PT\n--\n--\n--  This file is part of OSVVM.\n--  \n--  Copyright (c) 2021 by SynthWorks Design Inc.  \n--  \n--  Licensed under the Apache License, Version 2.0 (the \"License\");\n--  you may not use this file except in compliance with the License.\n--  You may obtain a copy of the License at\n--  \n--      https://www.apache.org/licenses/LICENSE-2.0\n--  \n--  Unless required by applicable law or agreed to in writing, software\n--  distributed under the License is distributed on an \"AS IS\" BASIS,\n--  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n--  See the License for the specific language governing permissions and\n--  limitations under the License.\n--  \n\nlibrary IEEE ;\n  use ieee.std_logic_1164.all ;\nlibrary OSVVM ; \n  context OSVVM.OsvvmContext ;\n\nentity DpRam is\n  generic ( \n    ADDR_WIDTH   : integer ;\n    DATA_WIDTH   : integer ; \n    REGA_OUT     : boolean := FALSE ; \n    REGB_OUT     : boolean := FALSE ;\n    MEMORY_NAME  : string  := \"\"\n  ) ;\n  port (\n    ClkA        : In  std_logic ;\n    WriteA      : In  std_logic ;\n    AddrA       : In  std_logic_vector(ADDR_WIDTH-1 downto 0) ;\n    DataInA     : In  std_logic_vector(DATA_WIDTH-1 downto 0) ;\n    DataOutA    : Out std_logic_vector(DATA_WIDTH-1 downto 0) ;\n	\n    ClkB        : In  std_logic ;\n    WriteB      : In  std_logic ;\n    AddrB       : In  std_logic_vector(ADDR_WIDTH-1 downto 0) ;\n    DataInB     : In  std_logic_vector(DATA_WIDTH-1 downto 0) ;\n    DataOutB    : Out std_logic_vector(DATA_WIDTH-1 downto 0) \n  ) ; \nend entity DPRam ;\n\narchitecture Singleton of DpRam is\n  constant RESOLVED_MEMORY_NAME : string :=\n    IfElse(MEMORY_NAME /= \"\", MEMORY_NAME, to_lower(PathTail(DpRam'PATH_NAME))) ;\n    \n  constant Mem : MemoryIdType := NewID(\n    Name      => RESOLVED_MEMORY_NAME, \n    AddrWidth => ADDR_WIDTH,  \n    DataWidth => DATA_WIDTH, \n    Search    => NAME\n  ) ;\n  \n  signal iDataOutA, iDataOutB : std_logic_vector(DATA_WIDTH-1 downto 0) ;\nbegin\n  \n  MemProcA : process (ClkA) \n  begin\n    if rising_edge(ClkA) then	  \n      iDataOutA <= MemRead(Mem, AddrA) ; \n      if WriteA = '1' then \n        MemWrite(Mem, AddrA, DataInA) ; \n      end if ;\n    end if ;\n  end process MemProcA ;\n  \n  RegAOutGen : if REGA_OUT generate \n    RegAProc : process(ClkA)\n    begin\n      if rising_edge(ClkA) then	  \n        DataOutA <= iDataOutA ; \n      end if ;\n    end process RegAProc ; \n  else generate \n    DataOutA <= iDataOutA ; \n  end generate ; \n\n  MemProcB : process (ClkB) \n  begin	\n    if rising_edge(ClkB) then	  \n      iDataOutB <= MemRead(Mem, AddrB) ; \n      if WriteB = '1' then \n        MemWrite(Mem, AddrB, DataInB) ; \n      end if ;\n    end if ;\n  end process MemProcB ;\n  \n  RegBOutGen : if REGB_OUT generate \n    RegBProc : process(ClkB)\n    begin\n      if rising_edge(ClkB) then	  \n        DataOutB <= iDataOutB ; \n      end if ;\n    end process RegBProc ; \n  else generate \n    DataOutB <= iDataOutB ; \n  end generate ; \n\nend Singleton ;\n","lang":"vhdl"};
processSrcData(g_data);