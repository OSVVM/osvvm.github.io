var g_data = {"name":"C:/SynthWorks/Dev/_osvvm/OsvvmLibraries/AXI4/common/src/Axi4InterfacePkg.vhd","src":"--\n--  File Name:         Axi4InterfacePkg.vhd\n--  Design Unit Name:  Axi4InterfacePkg\n--  Revision:          OSVVM MODELS STANDARD VERSION\n--\n--  Maintainer:        Jim Lewis      email:  jim@synthworks.com\n--  Contributor(s):\n--     Jim Lewis      jim@synthworks.com\n--\n--\n--  Description:\n--      Defines types, constants, and subprograms to support the Axi4 interface to DUT\n--      These are currently only intended for testbench models.\n--      When VHDL-2018 intefaces gain popular support, these will be changed to support them. \n--          \n--\n--  Developed by:\n--        SynthWorks Design Inc.\n--        VHDL Training Classes\n--        http://www.SynthWorks.com\n--\n--  Revision History:\n--    Date      Version    Description\n--    03/2022   2022.03    Factored out of Axi4InterfaceCommonPkg\n--    01/2020   2020.01    Updated license notice\n--    09/2017   2017       Initial revision\n--\n--\n--  This file is part of OSVVM.\n--  \n--  Copyright (c) 2017 - 2022 by SynthWorks Design Inc.  \n--  \n--  Licensed under the Apache License, Version 2.0 (the \"License\");\n--  you may not use this file except in compliance with the License.\n--  You may obtain a copy of the License at\n--  \n--      https://www.apache.org/licenses/LICENSE-2.0\n--  \n--  Unless required by applicable law or agreed to in writing, software\n--  distributed under the License is distributed on an \"AS IS\" BASIS,\n--  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n--  See the License for the specific language governing permissions and\n--  limitations under the License.\n--  \n\nlibrary ieee ; \n  use ieee.std_logic_1164.all ;\n  use ieee.numeric_std.all ;\n  use ieee.numeric_std_unsigned.all ;\n  \nuse work.Axi4InterfaceCommonPkg.all ;\n\npackage Axi4InterfacePkg is \n  -- AXI Write Address Channel\n  type Axi4WriteAddressRecType is record\n    -- AXI4 Lite\n    Addr      : std_logic_vector ; \n    Prot      : Axi4ProtType ;\n    Valid     : std_logic ; \n    Ready     : std_logic ; \n    -- AXI4 Full\n    -- User Config - AXI recommended 3:0 for master, 7:0 at slave\n    ID        : std_logic_vector ; \n    -- BurstLength = AxLen+1.  AXI4: 7:0,  AXI3: 3:0\n    Len       : std_logic_vector(7 downto 0) ; \n    -- #Bytes in transfer = 2**AxSize\n    Size      : std_logic_vector(2 downto 0) ; \n    -- AxBurst Binary Encoded (Fixed, Incr, Wrap, NotDefined)\n    Burst     : std_logic_vector(1 downto 0) ; \n    Lock      : std_logic ;\n    -- AxCache One-hot (Write-Allocate, Read-Allocate, Modifiable, Bufferable)\n    Cache     : std_logic_vector(3 downto 0) ;\n    QOS       : std_logic_vector(3 downto 0) ;\n    Region    : std_logic_vector(3 downto 0) ;\n    User      : std_logic_vector ; -- User Config\n  end record Axi4WriteAddressRecType ; \n  \n  function InitAxi4WriteAddressRec (\n    WriteAddress  : in Axi4WriteAddressRecType ;\n    InitVal       : std_logic := 'Z'\n  ) return Axi4WriteAddressRecType ;\n    \n--\n--!TODO Add VHDL-2018 mode declarations here\n-- Comment out for now, also include `ifdef for language revision\n--\n  \n  -- AXI Write Data Channel\n  type Axi4WriteDataRecType is record\n    -- AXI4 Lite\n    Data       : std_logic_vector ; \n    Strb       : std_logic_vector ; \n    Valid      : std_logic ; \n    Ready      : std_logic ; \n    -- AXI 4 Full\n    Last       : std_logic ;\n    User       : std_logic_vector ;\n    -- AXI3\n    ID         : std_logic_vector ;\n  end record Axi4WriteDataRecType ; \n  \n  function InitAxi4WriteDataRec (\n    WriteData : Axi4WriteDataRecType ;\n    InitVal   : std_logic := 'Z'\n  ) return Axi4WriteDataRecType ;\n\n-- Add VHDL-2018 modes here\n\n  \n  -- AXI Write Response Channel\n  type Axi4WriteResponseRecType is record\n    -- AXI4 Lite\n    Valid      : std_logic ; \n    Ready      : std_logic ; \n    Resp       : Axi4RespType ; \n    -- AXI 4 Full\n    ID         : std_logic_vector ;\n    User       : std_logic_vector ;\n  end record Axi4WriteResponseRecType ; \n  \n  function InitAxi4WriteResponseRec(\n    WriteResponse : Axi4WriteResponseRecType ;\n    InitVal   : std_logic := 'Z'\n  ) return Axi4WriteResponseRecType ;\n  \n-- Add VHDL-2018 modes here\n\n  \n  -- AXI Read Address Channel\n  type Axi4ReadAddressRecType is record\n    -- AXI4 Lite\n    Addr      : std_logic_vector ; \n    Prot      : Axi4ProtType ; \n    Valid     : std_logic ; \n    Ready     : std_logic ; \n    -- AXI 4 Full\n    -- User Config - AXI recommended 3:0 for master, 7:0 at slave\n    ID        : std_logic_vector ; \n    -- BurstLength = AxLen+1.  AXI4: 7:0,  AXI3: 3:0\n    Len       : std_logic_vector(7 downto 0) ; \n    -- #Bytes in transfer = 2**AxSize\n    Size      : std_logic_vector(2 downto 0) ; \n    -- AxBurst Binary Encoded (Fixed, Incr, Wrap, NotDefined)\n    Burst     : std_logic_vector(1 downto 0) ; \n    Lock      : std_logic ;\n    -- AxCache One-hot (Write-Allocate, Read-Allocate, Modifiable, Bufferable)\n    Cache     : std_logic_vector(3 downto 0) ;\n    QOS       : std_logic_vector(3 downto 0) ;\n    Region    : std_logic_vector(3 downto 0) ;\n    User      : std_logic_vector ; -- User Config\n  end record Axi4ReadAddressRecType ; \n  \n  function InitAxi4ReadAddressRec (\n    ReadAddress : Axi4ReadAddressRecType ;\n    InitVal   : std_logic := 'Z'\n  ) return Axi4ReadAddressRecType ;\n\n-- Add VHDL-2018 modes here\n\n  -- AXI Read Data Channel\n  type Axi4ReadDataRecType is record\n    -- AXI4 Lite\n    Data       : std_logic_vector ; \n    Resp       : Axi4RespType ;\n    Valid      : std_logic ; \n    Ready      : std_logic ; \n    -- AXI 4 Full\n    Last       : std_logic ;\n    User       : std_logic_vector ;\n    ID         : std_logic_vector ;\n  end record Axi4ReadDataRecType ; \n  \n  function InitAxi4ReadDataRec (\n    ReadData : Axi4ReadDataRecType ;\n    InitVal   : std_logic := 'Z'\n  ) return Axi4ReadDataRecType ;\n\n  \n-- Add VHDL-2018 modes here\n  \n  type Axi4BaseRecType is record\n    WriteAddress   : Axi4WriteAddressRecType ; \n    WriteData      : Axi4WriteDataRecType ; \n    WriteResponse  : Axi4WriteResponseRecType ; \n    ReadAddress    : Axi4ReadAddressRecType ; \n    ReadData       : Axi4ReadDataRecType ; \n  end record Axi4BaseRecType ; \n  \n  -- Axi4RecType with sized elements\n  -- Get From Above\n\n  -- Axi4 Record, Axi4 full elements are null arrays  \n--  subtype Axi4LiteRecType is Axi4BaseRecType( \n--    WriteAddress ( Addr(open), ID(0 downto 1), User(0 downto 1) ),\n--    WriteData    ( Data(open), Strb(open), User(0 downto 1), ID(0 downto 1) ),  -- ID only AXI3\n--    WriteResponse( ID(0 downto 1), User(0 downto 1) ),\n--    ReadAddress  ( Addr(open), ID(0 downto 1), User(0 downto 1) ),\n--    ReadData     ( Data(open), ID(0 downto 1), User(0 downto 1) )\n--  ) ;\n--   alias Axi4LiteRecType is Axi4BaseRecType ; \n\n-- -- Axi4 Record, Axi4 full elements are null arrays  \n-- subtype Axi4RecType is Axi4BaseRecType( \n--   WriteAddress ( Addr(open), ID(7 downto 0), User(7 downto 0) ),\n--   WriteData    ( Data(open), Strb(open), User(7 downto 0), ID(7 downto 0) ),  -- ID only AXI3\n--   WriteResponse( ID(7 downto 0), User(7 downto 0) ),\n--   ReadAddress  ( Addr(open), ID(7 downto 0), User(7 downto 0) ),\n--   ReadData     ( Data(open), ID(7 downto 0), User(7 downto 0) )\n-- ) ;\n \n  alias Axi4RecType is Axi4BaseRecType ; \n  \n  function InitAxi4Rec (\n    AxiBusRec : in Axi4RecType ;\n    InitVal   : std_logic := 'Z'\n  ) return Axi4RecType ;\n  \n  procedure InitAxi4Rec (\n    signal AxiBusRec : inout Axi4RecType ;\n    InitVal          : std_logic := 'Z'\n  ) ;\n  \nend package Axi4InterfacePkg ;\npackage body Axi4InterfacePkg is \n\n  function InitAxi4WriteAddressRec (\n    WriteAddress  : in Axi4WriteAddressRecType ;\n    InitVal       : std_logic := 'Z'\n  ) return Axi4WriteAddressRecType is\n  begin\n    return (\n      -- AXI4 Lite\n      Addr   => (WriteAddress.Addr'range => InitVal), \n      Prot   => (WriteAddress.Prot'range => InitVal),\n      Valid  => InitVal, \n      Ready  => InitVal, \n      -- AXI 4 Full\n      ID     => (WriteAddress.ID'range => InitVal),\n      Len    => (WriteAddress.Len'range => InitVal), \n      Size   => (WriteAddress.Size'range => InitVal), \n      Burst  => (WriteAddress.Burst'range => InitVal), \n      Lock   => InitVal,\n      Cache  => (WriteAddress.Cache'range => InitVal),\n      QOS    => (WriteAddress.QOS'range => InitVal),\n      Region => (WriteAddress.Region'range => InitVal),\n      User   => (WriteAddress.User'range => InitVal)\n    ) ;\n  end function InitAxi4WriteAddressRec ; \n\n  function InitAxi4WriteDataRec (\n    WriteData : Axi4WriteDataRecType ;\n    InitVal   : std_logic := 'Z'\n  ) return Axi4WriteDataRecType is\n    constant DataWidth : integer := WriteData.Data'length ; \n  begin\n    return (\n      -- AXI4 Lite\n      Data   => (DataWidth-1 downto 0 => InitVal),  \n      Strb   => ((DataWidth/8)-1 downto 0 => InitVal),\n      Valid  => InitVal,\n      Ready  => InitVal,\n      -- AXI 4 Full\n      Last   => InitVal,\n      User   => (WriteData.User'range => InitVal),\n      -- AXI3\n      ID     => (WriteData.ID'range => InitVal)\n    ) ;\n  end function InitAxi4WriteDataRec ; \n\n  function InitAxi4WriteResponseRec(\n    WriteResponse : Axi4WriteResponseRecType ;\n    InitVal   : std_logic := 'Z'\n  ) return Axi4WriteResponseRecType is\n  begin\n    return (\n      -- AXI4 Lite\n      Resp   => (WriteResponse.Resp'range =>InitVal),  \n      Valid  => InitVal,\n      Ready  => InitVal,\n      -- AXI 4 Full\n      ID     => (WriteResponse.ID'range => InitVal),\n      User   => (WriteResponse.User'range => InitVal)\n\n    ) ;\n  end function InitAxi4WriteResponseRec ; \n\n  function InitAxi4ReadAddressRec (\n    ReadAddress : Axi4ReadAddressRecType ;\n    InitVal   : std_logic := 'Z'\n  ) return Axi4ReadAddressRecType is\n  begin\n    return (\n      -- AXI4 Lite\n      Addr   => (ReadAddress.Addr'range => InitVal), \n      Prot   => (ReadAddress.Prot'range => InitVal),\n      Valid  => InitVal, \n      Ready  => InitVal, \n      -- AXI 4 Full\n      ID     => (ReadAddress.ID'range => InitVal),\n      Len    => (ReadAddress.Len'range => InitVal), \n      Size   => (ReadAddress.Size'range => InitVal), \n      Burst  => (ReadAddress.Burst'range => InitVal), \n      Lock   => InitVal,\n      Cache  => (ReadAddress.Cache'range => InitVal),\n      QOS    => (ReadAddress.QOS'range => InitVal),\n      Region => (ReadAddress.Region'range => InitVal),\n      User   => (ReadAddress.User'range => InitVal)\n    ) ;\n  end function InitAxi4ReadAddressRec ; \n\n  function InitAxi4ReadDataRec (\n    ReadData : Axi4ReadDataRecType ;\n    InitVal   : std_logic := 'Z'\n  ) return Axi4ReadDataRecType is\n  begin\n    return (\n      -- AXI4 Lite\n      Data   => (ReadData.Data'range => InitVal),  \n      Resp   => (ReadData.Resp'range => InitVal),  \n      Valid  => InitVal,\n      Ready  => InitVal,\n      -- AXI 4 Full\n      ID     => (ReadData.ID'range => InitVal),\n      Last   => InitVal,\n      User   => (ReadData.User'range => InitVal)\n    ) ;\n  end function InitAxi4ReadDataRec ; \n    \n  function InitAxi4Rec (\n    AxiBusRec : in Axi4RecType ;\n    InitVal   : std_logic := 'Z'\n  ) return Axi4RecType is\n  begin\n    return ( \n      WriteAddress   => InitAxi4WriteAddressRec(AxiBusRec.WriteAddress, InitVal),\n      WriteData      => InitAxi4WriteDataRec(AxiBusRec.WriteData, InitVal),\n      WriteResponse  => InitAxi4WriteResponseRec(AxiBusRec.WriteResponse, InitVal), \n      ReadAddress    => InitAxi4ReadAddressRec(AxiBusRec.ReadAddress, InitVal),\n      ReadData       => InitAxi4ReadDataRec(AxiBusRec.ReadData, InitVal)\n    ) ;\n  end function InitAxi4Rec ; \n\n  procedure InitAxi4Rec (\n    signal AxiBusRec : inout Axi4RecType ;\n    InitVal          : std_logic := 'Z'\n  ) is\n  begin\n    AxiBusRec <= InitAxi4Rec(AxiBusRec, InitVal) ;\n  end procedure InitAxi4Rec ;\n\nend package body Axi4InterfacePkg ; \n\n  \n\n","lang":"vhdl"};
processSrcData(g_data);