var g_data = {"name":"C:/SynthWorks/Dev/_osvvm/OsvvmLibraries/Ethernet/src/xMiiPhyTxReceiver.vhd","src":"--\n--  File Name:         xMiiPhyTxReceiver.vhd\n--  Design Unit Name:  xMiiPhyTxReceiver\n--  Revision:          OSVVM MODELS STANDARD VERSION\n--\n--  Maintainer:        Jim Lewis      email:  jim@synthworks.com\n--  Contributor(s):\n--     Jim Lewis      jim@synthworks.com\n--\n--\n--  Description:\n--      Ethernet GMII/RGMII/MII/RMII VC\n--      First target is to support PHY\n--      Later on need basis consider supporting MAC\n--\n--\n--  Developed by:\n--        SynthWorks Design Inc.\n--        VHDL Training Classes\n--        http://www.SynthWorks.com\n--\n--  Revision History:\n--    Date      Version    Description\n--    10/2022   2022.10    Initial Release\n--\n--\n--  This file is part of OSVVM.\n--\n--  Copyright (c) 2022 by SynthWorks Design Inc.\n--\n--  Licensed under the Apache License, Version 2.0 (the \"License\");\n--  you may not use this file except in compliance with the License.\n--  You may obtain a copy of the License at\n--\n--      https://www.apache.org/licenses/LICENSE-2.0\n--\n--  Unless required by applicable law or agreed to in writing, software\n--  distributed under the License is distributed on an \"AS IS\" BASIS,\n--  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n--  See the License for the specific language governing permissions and\n--  limitations under the License.\n--\n\nlibrary ieee ;\n  use ieee.std_logic_1164.all ;\n  use ieee.numeric_std.all ;\n  use ieee.numeric_std_unsigned.all ;\n  use ieee.math_real.all ;\n\nlibrary osvvm ;\n  context osvvm.OsvvmContext ;\n  use osvvm.ScoreboardPkg_slv.all ;\n  use osvvm.ScoreboardPkg_int.all ;\n\nlibrary osvvm_common ;\n  context osvvm_common.OsvvmCommonContext ;\n\n  use work.xMiiTbPkg.all ;\n\nentity xMiiPhyTxReceiver is\n  generic (\n    MODEL_ID_NAME  : string := \"\" ;\n    DEFAULT_DELAY  : time := 1 ns ;\n    tpd            : time := DEFAULT_DELAY \n  ) ;\n  port (\n    -- Configured by MDIO - it can change during operation based on PHY negotiation\n    xMiiInterface : in xMiiInterfaceType := GMII ;\n    xMiiBps       : in xMiiBpsType       := BPS_1G ;\n    \n    -- xMiiPhyTxReceiver Transmitter Functional Interface\n    GTx_Clk   : in  std_logic ;  -- GMII, RGMII\n    Tx_Clk    : out std_logic ;  -- MII\n    TxD       : in  std_logic_vector(0 to 7) ; \n    Tx_En     : in  std_logic ; \n    Tx_Er     : in  std_logic ; \n    Tx_Ctl    : in  std_logic ; \n    \n    -- Testbench Transaction Interface\n    TransRec  : inout StreamRecType    -- Information inbound to this VC\n  ) ;\n\n  -- Use MODEL_ID_NAME Generic if set, otherwise,\n  -- use model instance label (preferred if set as entityname_1)\n  constant MODEL_INSTANCE_NAME : string :=\n    IfElse(MODEL_ID_NAME'length > 0, MODEL_ID_NAME, \n      to_lower(PathTail(xMiiPhyTxReceiver'PATH_NAME))) ;\n\nend entity xMiiPhyTxReceiver ;\narchitecture behavioral of xMiiPhyTxReceiver is\n\n  signal tperiod_xClk : time := CalcPeriod(BPS_1G, GMII) ; \n  signal RefTxClk     : std_logic := '0' ; \n  signal iTxClk       : std_logic := '0' ; \n  signal iTxD         : std_logic_vector(0 to 7) ; \n  signal iTx_En       : std_logic ; \n  signal iTx_Er       : std_logic ; \n  signal iTx_Ctl      : std_logic ; \n  signal Enable       : std_logic ; \n\n  signal ModelID      : AlertLogIDType ;\n\n  signal DataFifo  : osvvm.ScoreboardPkg_slv.ScoreboardIDType ;\n  signal MetaFifo  : osvvm.ScoreboardPkg_int.ScoreboardIDType ;\n\n  signal PacketReceiveCount : integer := 0 ;\n\nbegin\n\n  ------------------------------------------------------------\n  --  Initialize alerts\n  ------------------------------------------------------------\n  Initialize : process\n    variable ID : AlertLogIDType ;\n  begin\n    -- Alerts\n    ID           := NewID(MODEL_INSTANCE_NAME) ;\n    ModelID      <= ID ;\n    DataFifo     <= NewID(\"DataFifo\",  ID, ReportMode => DISABLED, Search => PRIVATE_NAME) ; \n    MetaFifo     <= NewID(\"MetaFifo\",  ID, ReportMode => DISABLED, Search => PRIVATE_NAME) ; \n    wait ;\n  end process Initialize ;\n\n\n  ------------------------------------------------------------\n  ClkProc : process\n  ------------------------------------------------------------\n  begin\n    wait for 0 ns ;  -- calc init value on tperiod_xClk\n    loop \n      RefTxClk <= not RefTxClk after tperiod_xClk ; \n      wait on RefTxClk ; \n    end loop ; \n  end process ; \n\n  tperiod_xClk <= CalcPeriod(xMiiBps, xMiiInterface) ; \n  \n  Tx_Clk <= RefTxClk ;\n\n  -- Internal timing reference - caution:  shifted by delta cycle\n  iTxClk <= GTx_Clk when xMiiInterface = GMII or xMiiInterface = RGMII \n            else RefTxClk when xMiiInterface = MII else\n--!!TODO resolve source of RMII Clk\n            RefTxClk ; -- Source of RMII\n\n  -- Since iTxClk is delayed, all input signals must be delayed \n  -- or RTL signals may not be sampled correctly.\n  iTxD     <= TxD   ;\n  iTx_En   <= Tx_En ;\n  iTx_Er   <= Tx_Er ;\n  iTx_Ctl  <= Tx_Ctl;\n\n\n  ------------------------------------------------------------\n  TransactionDispatcher : process\n  ------------------------------------------------------------\n    variable NumberTransfers : integer ;\n    variable PacketTransferCount : integer := 0 ;\n  begin\n    wait for 0 ns ; \n    TransRec.BurstFifo <= NewID(\"BurstFifo\", ModelId, ReportMode => DISABLED, Search => PRIVATE_NAME) ;\n    \n    DispatchLoop : loop \n      WaitForTransaction(\n         Clk      => iTxClk,\n         Rdy      => TransRec.Rdy,\n         Ack      => TransRec.Ack\n      ) ;\n\n      case TransRec.Operation is\n        when WAIT_FOR_CLOCK =>\n          WaitForClock(iTxClk, TransRec.IntToModel) ;\n\n        when WAIT_FOR_TRANSACTION =>\n--!! TODO:  Does this wait until a transaction is received?\n--!!          if PacketReceiveCount /= PacketTransferCount then\n--!!            wait until PacketReceiveCount = PacketTransferCount ;\n--!!          end if ;\n\n        when GET_TRANSACTION_COUNT =>\n          TransRec.IntFromModel <= PacketTransferCount ;\n          wait for 0 ns ;\n\n        when GET_ALERTLOG_ID =>\n          TransRec.IntFromModel <= integer(ModelId) ;\n          wait for 0 ns ;\n\n        when GET_BURST | TRY_GET_BURST =>\n          if (PacketReceiveCount - PacketTransferCount) = 0 and IsTry(TransRec.Operation) then\n            -- Return if no data\n            TransRec.BoolFromModel  <= FALSE ;\n            wait for 0 ns ;\n          else\n            -- Get data\n            TransRec.BoolFromModel <= TRUE ;\n            if (PacketReceiveCount - PacketTransferCount) = 0 then\n              -- Wait for data\n              WaitForToggle(PacketReceiveCount) ;\n            end if ;\n            NumberTransfers := Pop(MetaFifo) ; \n            TransRec.IntFromModel <= NumberTransfers ; \n-- Do we need a separate DataFifo or \n-- is it ok to put values directly into the BurstFifo?\n-- For now, could assign DataFifo to TransRec.BurstFifo \n            for i in 1 to NumberTransfers loop\n              Push(TransRec.BurstFifo, Pop(DataFifo)) ;\n            end loop ; \n            PacketTransferCount := Increment(PacketTransferCount) ; \n            \n            Log(ModelId,\n              \"Received Packet# \" & to_string (PacketTransferCount),\n              INFO, TransRec.BoolToModel or IsLogEnabled(ModelId, PASSED)\n            ) ;\n            wait for 0 ns ;\n          end if ;\n         \n        when SET_MODEL_OPTIONS | GET_MODEL_OPTIONS =>\n          Alert(ModelId, \"Configuration done via MDIO Interface.\" & \n                         \"  Transaction # \" & to_string(TransRec.Rdy), FAILURE) ;\n\n        when MULTIPLE_DRIVER_DETECT =>\n          Alert(ModelId, \"Multiple Drivers on Transaction Record.\" & \n                         \"  Transaction # \" & to_string(TransRec.Rdy), FAILURE) ;\n\n        -- The End -- Done\n        when others =>\n          Alert(ModelId, \"Unimplemented Transaction: \" & to_string(TransRec.Operation), FAILURE) ;\n      end case ;\n\n      -- Wait for 1 delta cycle, required if a wait is not in all case branches above\n      wait for 0 ns ;\n    end loop DispatchLoop ;\n  end process TransactionDispatcher ;\n  \n  Enable <= xMiiEnable (\n              xMiiInterface => xMiiInterface, \n              iEnDv         => iTx_En, \n              iCtl          => iTx_Ctl ) ;\n  \n  ------------------------------------------------------------\n  PhyTxHandler : process\n  --  Phy receives data on Phy Transmitter Interface\n  ------------------------------------------------------------\n    variable PacketLength : integer ; \n    variable ErrorLoc : integer ; \n    variable oData : std_logic_vector(0 to 7) ;\n    variable oEn, oEr : std_logic ; \n    \n    procedure GetByte (\n      variable oData         : out std_logic_vector(0 to 7);  \n      variable oEn           : out std_logic ; \n      variable oEr           : out std_logic \n    ) is \n    begin\n      GetByte (\n        Clk           => iTxClk,\n        oData         => oData,  \n        oEnDv         => oEn,\n        oEr           => oEr,\n        Tpd           => Tpd,\n        xMiiInterface => xMiiInterface,\n        iData         => iTxD,  \n        iEnDv         => iTx_En,\n        iEr           => iTx_Er,\n        iCtl          => iTx_Ctl\n      ) ;\n    end procedure GetByte ;\n  begin\n    wait for 0 ns ; -- Allow DataFifo to initialize \n\n    GetLoop : loop\n      wait on iTxClk until Enable = '1' and rising_edge(iTxClk) ;\n    \n      -- Find SFD\n      while oData /= X\"AB\" loop \n        GetByte(oData, oEn, oEr) ;\n        if oEn /= '1' then\n          Alert(ModelId, \"Incomplete Preamble and SFD\") ;\n          next GetLoop ;\n        end if ; \n        Log(ModelId,\n          \"Received Byte \" & to_hstring (oData) & \"  oEn = \" & to_string(oEn),\n          DEBUG\n        ) ;\n      end loop ; \n      \n      -- Get A Packet of Data\n      ErrorLoc     := 0 ; \n      PacketLength := MaxPacketLength ;\n      for i in 1 to MaxPacketLength loop \n        GetByte(oData, oEn, oEr) ;\n        if oEr = '1' then \n          ErrorLoc := i ; \n        end if ; \n        if oEn = '1' then \n          Push(DataFifo, oData) ; \n        else\n          PacketLength := i - 1 ; \n          exit ;\n        end if ;\n      end loop ;\n      Push(MetaFifo, PacketLength) ;\n      Increment(PacketReceiveCount) ;\n      \n      if PacketLength = MaxPacketLength then\n        GetByte(oData, oEn, oEr) ;\n        if oEn = '1' then \n          Alert(ModelId, \"PacketLength = \" & to_string(PacketLength) & \n              \".  Packet truncated due to exceeding maximum length = \" & \n              to_string(MaxPacketLength)) ; \n          while oEn = '1' loop\n            GetByte(oData, oEn, oEr) ;\n          end loop ;\n        end if ; \n      end if ; \n      wait for 0 ns ;\n    end loop GetLoop ;\n  end process PhyTxHandler ;\nend architecture behavioral ;\n","lang":"vhdl"};
processSrcData(g_data);