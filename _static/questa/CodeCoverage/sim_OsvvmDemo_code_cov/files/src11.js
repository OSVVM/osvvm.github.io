var g_data = {"name":"C:/SynthWorks/Dev/_osvvm/OsvvmLibraries/Common/src/AddressBusResponderTransactionPkg.vhd","src":"--\n--  File Name:         AddressBusResponderTransactionPkg.vhd\n--  Design Unit Name:  AddressBusResponderTransactionPkg\n--  Revision:          OSVVM MODELS STANDARD VERSION\n--\n--  Maintainer:        Jim Lewis      email:  jim@synthworks.com\n--  Contributor(s):\n--     Jim Lewis      jim@synthworks.com\n--\n--\n--  Description:\n--      Defines types, constants, and subprograms used by\n--      OSVVM Address Bus Slave Transaction Based Models (aka: TBM, TLM, VVC)\n--\n--\n--  Developed by:\n--        SynthWorks Design Inc.\n--        VHDL Training Classes\n--        http://www.SynthWorks.com\n--\n--  Revision History:\n--    Date      Version    Description\n--    09/2017   2017       Initial revision as Axi4LiteTransactionPkg\n--    01/2020   2020.01    Updated license notice\n--    02/2020   2020.02    Refactored from Axi4LiteSlaveTransactionPkg\n--    05/2020   2020.05    Removed Generics due to simulator bugs\n--    09/2020   2020.09    Updating comments to serve as documentation\n--\n--  This file is part of OSVVM.\n--\n--  Copyright (c) 2017 - 2020 by SynthWorks Design Inc.\n--\n--  Licensed under the Apache License, Version 2.0 (the \"License\");\n--  you may not use this file except in compliance with the License.\n--  You may obtain a copy of the License at\n--\n--      https://www.apache.org/licenses/LICENSE-2.0\n--\n--  Unless required by applicable law or agreed to in writing, software\n--  distributed under the License is distributed on an \"AS IS\" BASIS,\n--  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n--  See the License for the specific language governing permissions and\n--  limitations under the License.\n--\n\nlibrary ieee ;\n  use ieee.std_logic_1164.all ;\n  use ieee.numeric_std.all ;\n  use ieee.numeric_std_unsigned.all ;\n  use ieee.math_real.all ;\n\nlibrary osvvm ;\n    context osvvm.OsvvmContext ;\n    \n  use work.AddressBusTransactionPkg.all; \n\npackage AddressBusResponderTransactionPkg is\n  -- ========================================================\n  --  Types of Transactions\n  --  A transaction may be either a directive or an interface transaction.\n  --\n  --  Directive transactions interact with the verification component \n  --  without generating any transactions or interface waveforms.\n  --\n  --  An interface transaction results in interface signaling to the DUT.\n  --\n  --  A blocking transaction is an interface transaction that does not \n  --  does not return (complete) until the interface operation   \n  --  requested by the transaction has completed.\n  --\n  --  An asynchronous transaction is nonblocking interface transaction\n  --  that returns before the transaction has completed - typically \n  --  immediately and before the transaction has started. \n  --\n  --  A Try transaction is nonblocking interface transaction that \n  --  checks to see if transaction information is available, \n  --  such as read data, and if it is returns it.  \n  --\n  -- ========================================================\n  \n  \n  -- ========================================================\n  --  Interface Independent Transactions\n  --  These transactions work independent of the interface.\n  --  Recommended for all tests that verify internal design functionality.\n  --  Many are blocking transactions which do not return (complete)\n  --  until the interface operation requested by the transaction  \n  --  has completed.\n  --  Some are asynchronous, which means they return before the\n  --  transaction is complete - typically even before it starts.\n  --  Supported by all verification components\n  -- ========================================================\n  ------------------------------------------------------------\n  procedure GetWrite (\n  -- Blocking write transaction.  \n  -- Block until the write address and data are available.\n  -- oData variable should be sized to match the size of the data \n  -- being transferred.\n  ------------------------------------------------------------\n    signal   TransactionRec  : InOut AddressBusRecType ;\n    variable oAddr           : Out   std_logic_vector ;\n    variable oData           : Out   std_logic_vector ;\n    constant StatusMsgOn     : In    boolean := false\n  ) ;\n  \n  ------------------------------------------------------------\n  procedure TryGetWrite (\n  -- Try write transaction.  \n  -- If a write cycle has already completed return Address and Data, \n  -- and return Available as TRUE, otherwise, return Available as FALSE. \n  -- oData variable should be sized to match the size of the data \n  -- being transferred.\n  ------------------------------------------------------------\n    signal   TransactionRec  : InOut AddressBusRecType ;\n    variable oAddr           : Out   std_logic_vector ;\n    variable oData           : Out   std_logic_vector ;\n    variable Available       : Out   boolean ;\n    constant StatusMsgOn     : In    boolean := false\n  ) ;\n\n  ------------------------------------------------------------\n  procedure SendRead (\n  -- Blocking Read transaction.   \n  -- Block until address is available and data is sent.\n  -- iData variable should be sized to match the size of the data \n  -- being transferred.\n  ------------------------------------------------------------\n    signal   TransactionRec  : InOut AddressBusRecType ;\n    variable oAddr           : Out   std_logic_vector ;\n    constant iData           : In    std_logic_vector ;\n    constant StatusMsgOn     : In    boolean := false\n  ) ;\n  \n  ------------------------------------------------------------\n  procedure TrySendRead (\n  -- Try Read transaction.   \n  -- If a read address already been received return Address, \n  -- send iData as the read data, and return Available as TRUE,\n  -- otherwise return Available as FALSE.\n  -- iData variable should be sized to match the size of the data \n  -- being transferred.\n  ------------------------------------------------------------\n    signal   TransactionRec  : InOut AddressBusRecType ;\n    variable oAddr           : Out   std_logic_vector ;\n    constant iData           : In    std_logic_vector ;\n    variable Available       : Out   boolean ;\n    constant StatusMsgOn     : In    boolean := false\n  ) ;\n  \n  \n  -- ========================================================\n  --  Interface Specific Transactions\n  --  Support split transaction interfaces - such as AXI which\n  --  independently operates the write address, write data, \n  --  write response, read address, and read data interfaces. \n  --  For split transaction interfaces, these transactions are \n  --  required to fully test the interface characteristics.  \n  --  Most of these transactions are asynchronous.  \n  -- ========================================================\n  ------------------------------------------------------------\n  procedure GetWriteAddress (\n  -- Blocking write address transaction.  \n  ------------------------------------------------------------\n    signal   TransactionRec  : InOut AddressBusRecType ;\n    variable oAddr           : Out   std_logic_vector ;\n    constant StatusMsgOn     : In    boolean := false\n  ) ;\n  \n  ------------------------------------------------------------\n  procedure TryGetWriteAddress (\n  -- Try write address transaction.  \n  -- If a write address cycle has already completed return oAddr and \n  -- return Available as TRUE, otherwise, return Available as FALSE.\n  ------------------------------------------------------------\n    signal   TransactionRec  : InOut AddressBusRecType ;\n    variable oAddr           : Out   std_logic_vector ;\n    variable Available       : Out   boolean ;\n    constant StatusMsgOn     : In    boolean := false\n  ) ;\n\n  ------------------------------------------------------------\n  procedure GetWriteData (\n  -- Blocking write data transaction.  \n  -- oData should be sized to match the size of the data \n  -- being transferred.  \n  ------------------------------------------------------------\n    signal   TransactionRec  : InOut AddressBusRecType ;\n    constant iAddr           : In    std_logic_vector ;\n    variable oData           : Out   std_logic_vector ;\n    constant StatusMsgOn     : In    boolean := false\n  ) ;\n  \n  ------------------------------------------------------------\n  procedure TryGetWriteData (\n  -- Try write data transaction.  \n  -- If a write data cycle has already completed return oData and \n  -- return Available as TRUE, otherwise, return Available as FALSE.\n  -- oData should be sized to match the size of the data \n  -- being transferred.  \n  ------------------------------------------------------------\n    signal   TransactionRec  : InOut AddressBusRecType ;\n    constant iAddr           : In    std_logic_vector ;\n    variable oData           : Out   std_logic_vector ;\n    variable Available       : Out   boolean ;\n    constant StatusMsgOn     : In    boolean := false\n  ) ;\n  \n  ------------------------------------------------------------\n  procedure GetWriteData (\n  -- Blocking write data transaction.  \n  -- oData should be sized to match the size of the data \n  -- being transferred.  iAddr = 0\n  ------------------------------------------------------------\n    signal   TransactionRec  : InOut AddressBusRecType ;\n    variable oData           : Out   std_logic_vector ;\n    constant StatusMsgOn     : In    boolean := false\n  ) ;\n\n  ------------------------------------------------------------\n  procedure TryGetWriteData (\n  -- Try write data transaction.  \n  -- If a write data cycle has already completed return oData and \n  -- return Available as TRUE, otherwise, return Available as FALSE.\n  -- oData should be sized to match the size of the data \n  -- being transferred.  iAddr = 0\n  ------------------------------------------------------------\n    signal   TransactionRec  : InOut AddressBusRecType ;\n    variable oData           : Out   std_logic_vector ;\n    variable Available       : Out   boolean ;\n    constant StatusMsgOn     : In    boolean := false\n  ) ;\n  \n  ------------------------------------------------------------\n  procedure GetReadAddress (\n  -- Blocking Read address transaction.   \n  ------------------------------------------------------------\n    signal   TransactionRec  : InOut AddressBusRecType ;\n    variable oAddr           : Out   std_logic_vector ;\n    constant StatusMsgOn     : In    boolean := false\n  ) ;\n  \n  ------------------------------------------------------------\n  procedure TryGetReadAddress (\n  -- Try read address transaction.  \n  -- If a read address cycle has already completed return oAddr and \n  -- return Available as TRUE, otherwise, return Available as FALSE.\n  ------------------------------------------------------------\n    signal   TransactionRec  : InOut AddressBusRecType ;\n    variable oAddr           : Out   std_logic_vector ;\n    variable Available       : Out   boolean ;\n    constant StatusMsgOn     : In    boolean := false\n  ) ;\n  \n  ------------------------------------------------------------\n  procedure SendReadData (\n  -- Blocking Send Read Data transaction.  \n  -- iData should be sized to match the size of the data \n  -- being transferred.\n  ------------------------------------------------------------\n    signal   TransactionRec  : InOut AddressBusRecType ;\n    constant iData           : In    std_logic_vector ;\n    constant StatusMsgOn     : In    boolean := false\n  ) ;\n  \n  ------------------------------------------------------------\n  procedure SendReadDataAsync (\n  -- Asynchronous Send Read Data transaction.  \n  -- iData should be sized to match the size of the data \n  -- being transferred.\n  ------------------------------------------------------------\n    signal   TransactionRec  : InOut AddressBusRecType ;\n    constant iData           : In    std_logic_vector ;\n    constant StatusMsgOn     : In    boolean := false\n  ) ;   \n  \nend package AddressBusResponderTransactionPkg ;\n\n-- /////////////////////////////////////////////////////////////////////////////////////////\n-- /////////////////////////////////////////////////////////////////////////////////////////\n\npackage body AddressBusResponderTransactionPkg is\n\n  ------------------------------------------------------------\n  procedure GetWrite (\n  -- Blocks until Address and Data are both available\n  ------------------------------------------------------------\n    signal   TransactionRec  : InOut AddressBusRecType ;\n    variable oAddr           : Out   std_logic_vector ;\n    variable oData           : Out   std_logic_vector ;\n    constant StatusMsgOn     : In    boolean := false\n  ) is\n  begin\n    -- Put values in record\n    TransactionRec.Operation     <= WRITE_OP ;\n    TransactionRec.AddrWidth     <= oAddr'length ;\n    TransactionRec.DataWidth     <= oData'length ;\n    TransactionRec.StatusMsgOn   <= StatusMsgOn ;\n    RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;\n    oAddr  := FromTransaction(TransactionRec.Address, oAddr'length) ;\n    oData  := FromTransaction(TransactionRec.DataFromModel, oData'length) ;\n  end procedure GetWrite ;\n\n  ------------------------------------------------------------\n  procedure TryGetWrite (\n  -- Return address and data if both available otherwise return false\n  ------------------------------------------------------------\n    signal   TransactionRec  : InOut AddressBusRecType ;\n    variable oAddr           : Out   std_logic_vector ;\n    variable oData           : Out   std_logic_vector ;\n    variable Available       : Out   boolean ;\n    constant StatusMsgOn     : In    boolean := false\n  ) is\n  begin\n    -- Put values in record\n    TransactionRec.Operation     <= ASYNC_WRITE ;\n    TransactionRec.AddrWidth     <= oAddr'length ;\n    TransactionRec.DataWidth     <= oData'length ;\n    TransactionRec.StatusMsgOn   <= StatusMsgOn ;\n    RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;\n    oAddr  := FromTransaction(TransactionRec.Address, oAddr'length) ;\n    oData  := FromTransaction(TransactionRec.DataFromModel, oData'length) ;\n    Available := TransactionRec.BoolFromModel ;\n  end procedure TryGetWrite ;\n\n  ------------------------------------------------------------\n  procedure GetWriteAddress (\n  -- Blocks until Address is available\n  ------------------------------------------------------------\n    signal   TransactionRec  : InOut AddressBusRecType ;\n    variable oAddr           : Out   std_logic_vector ;\n    constant StatusMsgOn     : In    boolean := false\n  ) is\n  begin\n    -- Put values in record\n    TransactionRec.Operation     <= WRITE_ADDRESS ;\n    TransactionRec.AddrWidth     <= oAddr'length ;\n    TransactionRec.StatusMsgOn   <= StatusMsgOn ;\n    RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;\n    oAddr  := FromTransaction(TransactionRec.Address, oAddr'length) ;\n  end procedure GetWriteAddress ;\n  \n  ------------------------------------------------------------\n  procedure TryGetWriteAddress (\n  -- Return address if available otherwise return false\n  ------------------------------------------------------------\n    signal   TransactionRec  : InOut AddressBusRecType ;\n    variable oAddr           : Out   std_logic_vector ;\n    variable Available       : Out   boolean ;\n    constant StatusMsgOn     : In    boolean := false\n  ) is\n  begin\n    -- Put values in record\n    TransactionRec.Operation     <= ASYNC_WRITE_ADDRESS ;\n    TransactionRec.AddrWidth     <= oAddr'length ;\n    TransactionRec.StatusMsgOn   <= StatusMsgOn ;\n    RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;\n    oAddr  := FromTransaction(TransactionRec.Address, oAddr'length) ;\n    Available := TransactionRec.BoolFromModel ;\n  end procedure TryGetWriteAddress ;\n\n  ------------------------------------------------------------\n  procedure GetWriteData (\n  -- Blocking write data transaction.  \n  -- oData should be sized to match the size of the data \n  -- being transferred.  \n  ------------------------------------------------------------\n    signal   TransactionRec  : InOut AddressBusRecType ;\n    constant iAddr           : In    std_logic_vector ;\n    variable oData           : Out   std_logic_vector ;\n    constant StatusMsgOn     : In    boolean := false\n  ) is\n    alias aAddr : std_logic_vector(iAddr'length-1 downto 0) is iAddr ;\n    constant ADDR_LEN : integer := minimum(aAddr'left, 30) ;\n  begin\n    -- Put values in record\n    TransactionRec.Operation     <= WRITE_DATA ;\n    TransactionRec.AddrWidth     <= to_integer(aAddr(ADDR_LEN downto 0)) ; -- Allows bursts upto 2**31\n    TransactionRec.DataWidth     <= oData'length ;\n    TransactionRec.StatusMsgOn   <= StatusMsgOn ;\n    RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;\n    oData  := FromTransaction(TransactionRec.DataFromModel, oData'length) ;\n  end procedure GetWriteData ;\n  \n  ------------------------------------------------------------\n  procedure TryGetWriteData (\n  -- Try write data transaction.  \n  -- If a write data cycle has already completed return oData and \n  -- return Available as TRUE, otherwise, return Available as FALSE.\n  -- oData should be sized to match the size of the data \n  -- being transferred.  \n  ------------------------------------------------------------\n    signal   TransactionRec  : InOut AddressBusRecType ;\n    constant iAddr           : In    std_logic_vector ;\n    variable oData           : Out   std_logic_vector ;\n    variable Available       : Out   boolean ;\n    constant StatusMsgOn     : In    boolean := false\n  ) is\n    alias aAddr : std_logic_vector(iAddr'length-1 downto 0) is iAddr ;\n    constant ADDR_LEN : integer := minimum(aAddr'left, 30) ;\n  begin\n    -- Put values in record\n    TransactionRec.Operation     <= ASYNC_WRITE_DATA ;\n    TransactionRec.AddrWidth     <= to_integer(aAddr(ADDR_LEN downto 0)) ; -- Allows bursts upto 2**31\n    TransactionRec.DataWidth     <= oData'length ;\n    TransactionRec.StatusMsgOn   <= StatusMsgOn ;\n    RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;\n    oData  := FromTransaction(TransactionRec.DataFromModel, oData'length) ;\n    Available := TransactionRec.BoolFromModel ;\n  end procedure TryGetWriteData ;\n  \n  ------------------------------------------------------------\n  procedure GetWriteData (\n  -- Blocks until Data is available\n  ------------------------------------------------------------\n    signal   TransactionRec  : InOut AddressBusRecType ;\n    variable oData           : Out   std_logic_vector ;\n    constant StatusMsgOn     : In    boolean := false\n  ) is\n  begin\n    GetWriteData(TransactionRec, X\"00\", oData, StatusMsgOn) ;\n  end procedure GetWriteData ;\n\n  ------------------------------------------------------------\n  procedure TryGetWriteData (\n  -- Return data if available otherwise return false\n  ------------------------------------------------------------\n    signal   TransactionRec  : InOut AddressBusRecType ;\n    variable oData           : Out   std_logic_vector ;\n    variable Available       : Out   boolean ;\n    constant StatusMsgOn     : In    boolean := false\n  ) is\n  begin\n    TryGetWriteData(TransactionRec, X\"00\", oData, Available, StatusMsgOn) ;\n  end procedure TryGetWriteData ;\n\n  ------------------------------------------------------------\n  procedure SendRead (\n  -- Block until address is available and data is done\n  ------------------------------------------------------------\n    signal   TransactionRec  : InOut AddressBusRecType ;\n    variable oAddr           : Out   std_logic_vector ;\n    constant iData           : In    std_logic_vector ;\n    constant StatusMsgOn     : In    boolean := false\n  ) is\n  begin\n    -- Put values in record\n    TransactionRec.Operation     <= READ_OP ;\n    TransactionRec.AddrWidth     <= oAddr'length ;\n    TransactionRec.DataWidth     <= iData'length ;\n    TransactionRec.DataToModel   <= ToTransaction(iData, TransactionRec.DataToModel'length) ;\n    TransactionRec.StatusMsgOn   <= StatusMsgOn ;\n    RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;\n    oAddr  := FromTransaction(TransactionRec.Address, oAddr'length) ;\n  end procedure SendRead ;\n  \n  ------------------------------------------------------------\n  procedure TrySendRead (\n  -- Return address if available, send data if address available\n  ------------------------------------------------------------\n    signal   TransactionRec  : InOut AddressBusRecType ;\n    variable oAddr           : Out   std_logic_vector ;\n    constant iData           : In    std_logic_vector ;\n    variable Available       : Out   boolean ;\n    constant StatusMsgOn     : In    boolean := false\n  ) is\n  begin\n    -- Put values in record\n    TransactionRec.Operation     <= ASYNC_READ ;\n    TransactionRec.AddrWidth     <= oAddr'length ;\n    TransactionRec.DataWidth     <= iData'length ;\n    TransactionRec.DataToModel   <= ToTransaction(iData, TransactionRec.DataToModel'length) ;\n    TransactionRec.StatusMsgOn   <= StatusMsgOn ;\n    RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;\n    oAddr  := FromTransaction(TransactionRec.Address, oAddr'length) ;\n    Available  := TransactionRec.BoolFromModel ;\n  end procedure TrySendRead ;\n    \n  ------------------------------------------------------------\n  procedure GetReadAddress (\n  -- Block until address is available\n  ------------------------------------------------------------\n    signal   TransactionRec  : InOut AddressBusRecType ;\n    variable oAddr           : Out   std_logic_vector ;\n    constant StatusMsgOn     : In    boolean := false\n  ) is\n  begin\n    -- Put values in record\n    TransactionRec.Operation     <= READ_ADDRESS ;\n    TransactionRec.AddrWidth     <= oAddr'length ;\n    TransactionRec.StatusMsgOn   <= StatusMsgOn ;\n    RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;\n    oAddr  := FromTransaction(TransactionRec.Address, oAddr'length) ;\n  end procedure GetReadAddress ;\n  \n  ------------------------------------------------------------\n  procedure TryGetReadAddress (\n  -- Return read address if available, otherwise return false on Available\n  ------------------------------------------------------------\n    signal   TransactionRec  : InOut AddressBusRecType ;\n    variable oAddr           : Out   std_logic_vector ;\n    variable Available       : Out   boolean ;\n    constant StatusMsgOn     : In    boolean := false\n  ) is\n  begin\n    -- Put values in record\n    TransactionRec.Operation     <= ASYNC_READ_ADDRESS ;\n    TransactionRec.AddrWidth     <= oAddr'length ;\n    TransactionRec.StatusMsgOn   <= StatusMsgOn ;\n    RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;\n    oAddr  := FromTransaction(TransactionRec.Address, oAddr'length) ;\n    Available  := TransactionRec.BoolFromModel ;\n  end procedure TryGetReadAddress ;\n  \n  ------------------------------------------------------------\n  procedure SendReadData (\n  -- Block until data is done\n  ------------------------------------------------------------\n    signal   TransactionRec  : InOut AddressBusRecType ;\n    constant iData           : In    std_logic_vector ;\n    constant StatusMsgOn     : In    boolean := false\n  ) is\n  begin\n    -- Put values in record\n    TransactionRec.Operation     <= READ_DATA ;\n    TransactionRec.DataWidth     <= iData'length ;\n    TransactionRec.DataToModel   <= ToTransaction(iData, TransactionRec.DataToModel'length) ;\n    TransactionRec.StatusMsgOn   <= StatusMsgOn ;\n    RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;\n  end procedure SendReadData ;\n  \n  ------------------------------------------------------------\n  procedure SendReadDataAsync (\n  -- Queue Read Data\n  ------------------------------------------------------------\n    signal   TransactionRec  : InOut AddressBusRecType ;\n    constant iData           : In    std_logic_vector ;\n    constant StatusMsgOn     : In    boolean := false\n  ) is\n  begin\n    -- Put values in record\n    TransactionRec.Operation     <= ASYNC_READ_DATA ;\n    TransactionRec.DataWidth     <= iData'length ;\n    TransactionRec.DataToModel   <= ToTransaction(iData, TransactionRec.DataToModel'length) ;\n    TransactionRec.StatusMsgOn   <= StatusMsgOn ;\n    RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;\n  end procedure SendReadDataAsync ;  \n  \nend package body AddressBusResponderTransactionPkg ;","lang":"vhdl"};
processSrcData(g_data);