var g_data = {"name":"C:/SynthWorks/Dev/_osvvm/OsvvmLibraries/AXI4/Axi4/src/Axi4Manager.vhd","src":"--\n--  File Name:         Axi4Manager.vhd\n--  Design Unit Name:  Axi4Manager\n--  Revision:          OSVVM MODELS STANDARD VERSION\n--\n--  Maintainer:        Jim Lewis      email:  jim@synthworks.com\n--  Contributor(s):\n--     Jim Lewis      jim@synthworks.com\n--\n--\n--  Description:\n--      AXI Full Manager Model\n--\n--\n--  Developed by:\n--        SynthWorks Design Inc.\n--        VHDL Training Classes\n--        http://www.SynthWorks.com\n--\n--  Revision History:\n--    Date      Version    Description\n--    12/2022   2022.12    Updated read check to use MetaMatch.   \n--    10/2022   2022.10    Changed enum value PRIVATE to PRIVATE_NAME due to VHDL-2019 keyword conflict.   \n--    05/2022   2022.05    Updated FIFOs so they are Search => PRIVATE\n--    03/2022   2022.03    Updated calls to NewID for AlertLogID and FIFOs\n--    02/2022   2022.02    Replaced to_hstring with to_hxstring\n--    01/2022   2022.01    Moved MODEL_INSTANCE_NAME and MODEL_NAME to entity declarative region\n--    07/2021   2021.07    All FIFOs and Scoreboards now use the New Scoreboard/FIFO capability\n--    06/2021   2021.06    GHDL support + New Burst FIFOs \n--    02/2021   2021.02    Added MultiDriver Detect.  Added Valid Delays.  Updated Generics.   \n--    12/2020   2020.12    Added Burst Word Mode.  Refactored code.  \n--    07/2020   2020.07    Created Axi4 FULL from Axi4Lite\n--    01/2020   2020.01    Updated license notice\n--    04/2018   2018.04    First Release\n--    09/2017   2017       Initial revision\n--\n--\n--  This file is part of OSVVM.\n--\n--  Copyright (c) 2017 - 2022 by SynthWorks Design Inc.\n--\n--  Licensed under the Apache License, Version 2.0 (the \"License\");\n--  you may not use this file except in compliance with the License.\n--  You may obtain a copy of the License at\n--\n--      https://www.apache.org/licenses/LICENSE-2.0\n--\n--  Unless required by applicable law or agreed to in writing, software\n--  distributed under the License is distributed on an \"AS IS\" BASIS,\n--  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n--  See the License for the specific language governing permissions and\n--  limitations under the License.\n--\nlibrary ieee ;\n  use ieee.std_logic_1164.all ;\n  use ieee.numeric_std.all ;\n  use ieee.numeric_std_unsigned.all ;\n  use ieee.math_real.all ;\n\nlibrary osvvm ;\n  context osvvm.OsvvmContext ;\n  use osvvm.ScoreboardPkg_slv.all ;\n\nlibrary osvvm_common ;\n  context osvvm_common.OsvvmCommonContext ;\n\n  use work.Axi4OptionsPkg.all ;\n  use work.Axi4ModelPkg.all ;\n  use work.Axi4InterfaceCommonPkg.all ;\n  use work.Axi4InterfacePkg.all ;\n  use work.Axi4CommonPkg.all ;\n\nentity Axi4Manager is\ngeneric (\n  MODEL_ID_NAME    : string := \"\" ;\n  tperiod_Clk      : time   := 10 ns ;\n  \n  DEFAULT_DELAY    : time   := 1 ns ; \n\n  tpd_Clk_AWAddr   : time   := DEFAULT_DELAY ;\n  tpd_Clk_AWProt   : time   := DEFAULT_DELAY ;\n  tpd_Clk_AWValid  : time   := DEFAULT_DELAY ;\n  -- AXI4 Full\n  tpd_clk_AWLen    : time   := DEFAULT_DELAY ;\n  tpd_clk_AWID     : time   := DEFAULT_DELAY ;\n  tpd_clk_AWSize   : time   := DEFAULT_DELAY ;\n  tpd_clk_AWBurst  : time   := DEFAULT_DELAY ;\n  tpd_clk_AWLock   : time   := DEFAULT_DELAY ;\n  tpd_clk_AWCache  : time   := DEFAULT_DELAY ;\n  tpd_clk_AWQOS    : time   := DEFAULT_DELAY ;\n  tpd_clk_AWRegion : time   := DEFAULT_DELAY ;\n  tpd_clk_AWUser   : time   := DEFAULT_DELAY ;\n\n  tpd_Clk_WValid   : time   := DEFAULT_DELAY ;\n  tpd_Clk_WData    : time   := DEFAULT_DELAY ;\n  tpd_Clk_WStrb    : time   := DEFAULT_DELAY ;\n  -- AXI4 Full\n  tpd_Clk_WLast    : time   := DEFAULT_DELAY ;\n  tpd_Clk_WUser    : time   := DEFAULT_DELAY ;\n  -- AXI3\n  tpd_Clk_WID      : time   := DEFAULT_DELAY ;\n\n  tpd_Clk_BReady   : time   := DEFAULT_DELAY ;\n\n  tpd_Clk_ARValid  : time   := DEFAULT_DELAY ;\n  tpd_Clk_ARProt   : time   := DEFAULT_DELAY ;\n  tpd_Clk_ARAddr   : time   := DEFAULT_DELAY ;\n  -- AXI4 Full\n  tpd_clk_ARLen    : time   := DEFAULT_DELAY ;\n  tpd_clk_ARID     : time   := DEFAULT_DELAY ;\n  tpd_clk_ARSize   : time   := DEFAULT_DELAY ;\n  tpd_clk_ARBurst  : time   := DEFAULT_DELAY ;\n  tpd_clk_ARLock   : time   := DEFAULT_DELAY ;\n  tpd_clk_ARCache  : time   := DEFAULT_DELAY ;\n  tpd_clk_ARQOS    : time   := DEFAULT_DELAY ;\n  tpd_clk_ARRegion : time   := DEFAULT_DELAY ;\n  tpd_clk_ARUser   : time   := DEFAULT_DELAY ;\n\n  tpd_Clk_RReady   : time   := DEFAULT_DELAY\n) ;\nport (\n  -- Globals\n  Clk         : in   std_logic ;\n  nReset      : in   std_logic ;\n\n  -- AXI Manager Functional Interface\n  AxiBus      : inout Axi4RecType ;\n\n  -- Testbench Transaction Interface\n  TransRec    : inout AddressBusRecType \n) ;\n\n  -- Model Configuration \n  -- Access via transactions or external name\n  shared variable params : ModelParametersPType ;\n\n  -- Derive AXI interface properties from the AxiBus\n  constant AXI_ADDR_WIDTH      : integer := AxiBus.WriteAddress.Addr'length ;\n  constant AXI_DATA_WIDTH      : integer := AxiBus.WriteData.Data'length ;\n  \n  -- Derive ModelInstance label from path_name\n  constant MODEL_INSTANCE_NAME : string :=\n    -- use MODEL_ID_NAME Generic if set, otherwise use instance label (preferred if set as entityname_1)\n    IfElse(MODEL_ID_NAME /= \"\", MODEL_ID_NAME, to_lower(PathTail(Axi4Manager'PATH_NAME))) ;\n\n  constant MODEL_NAME : string := \"Axi4Manager\" ;\n  \nend entity Axi4Manager ;\narchitecture AxiFull of Axi4Manager is\n\n\n  signal ModelID, ProtocolID, DataCheckID, BusFailedID : AlertLogIDType ;\n\n  constant AXI_DATA_BYTE_WIDTH : integer := AXI_DATA_WIDTH / 8 ;\n  constant AXI_BYTE_ADDR_WIDTH : integer := integer(ceil(log2(real(AXI_DATA_BYTE_WIDTH)))) ;\n  constant AXI_STRB_WIDTH      : integer := AXI_DATA_WIDTH/8 ;\n\n  -- Internal Resources\n  signal WriteAddressFifo            : osvvm.ScoreboardPkg_slv.ScoreboardIDType ;\n  signal WriteDataFifo               : osvvm.ScoreboardPkg_slv.ScoreboardIDType ;\n\n  signal ReadAddressFifo             : osvvm.ScoreboardPkg_slv.ScoreboardIDType ;\n  signal ReadAddressTransactionFifo  : osvvm.ScoreboardPkg_slv.ScoreboardIDType ;\n  signal ReadDataFifo                : osvvm.ScoreboardPkg_slv.ScoreboardIDType ;\n\n  signal WriteResponseScoreboard     : osvvm.ScoreboardPkg_slv.ScoreboardIDType ;\n  signal ReadResponseScoreboard      : osvvm.ScoreboardPkg_slv.ScoreboardIDType ;\n\n  signal WriteAddressRequestCount, WriteAddressDoneCount      : integer := 0 ;\n  signal WriteDataRequestCount,    WriteDataDoneCount         : integer := 0 ;\n  signal WriteResponseExpectCount, WriteResponseReceiveCount  : integer := 0 ;\n  signal ReadAddressRequestCount,  ReadAddressDoneCount       : integer := 0 ;\n  signal ReadDataExpectCount,      ReadDataReceiveCount       : integer := 0 ;\n\n  signal WriteResponseActive, ReadDataActive : boolean ;\n  \n  constant DEFAULT_BURST_MODE : AddressBusFifoBurstModeType := ADDRESS_BUS_BURST_WORD_MODE ;\n  signal   BurstFifoMode      : AddressBusFifoBurstModeType := DEFAULT_BURST_MODE ;\n  signal   BurstFifoByteMode  : boolean := (DEFAULT_BURST_MODE = ADDRESS_BUS_BURST_BYTE_MODE) ; \nbegin\n\n  ------------------------------------------------------------\n  -- Turn off drivers not being driven by this model\n  ------------------------------------------------------------\n  InitAxi4Rec (AxiBusRec => AxiBus) ;\n\n\n  ------------------------------------------------------------\n  --  Initialize alerts\n  ------------------------------------------------------------\n  Initialize : process\n    variable ID : AlertLogIDType ;\n  begin\n    InitAxiOptions(Params) ;\n\n    -- Alerts\n    ID                      := NewID(MODEL_INSTANCE_NAME) ;\n    ModelID                 <= ID ;\n    ProtocolID              <= NewID(\"Protocol Error\", ID ) ;\n    DataCheckID             <= NewID(\"Data Check\", ID ) ;\n    BusFailedID             <= NewID(\"No response\", ID ) ;\n\n    WriteResponseScoreboard <= NewID(\"WriteResponse Scoreboard\", ID, Search => PRIVATE_NAME);\n    ReadResponseScoreboard  <= NewID(\"ReadResponse Scoreboard\",  ID, Search => PRIVATE_NAME);\n\n    -- FIFOs get an AlertLogID with NewID, however, it does not print in ReportAlerts (due to DoNotReport)\n    --   FIFOS only generate usage type errors \n    WriteAddressFifo           <= NewID(\"WriteAddressFIFO\",             ID, ReportMode => DISABLED, Search => PRIVATE_NAME);\n    WriteDataFifo              <= NewID(\"WriteDataFifo\",                ID, ReportMode => DISABLED, Search => PRIVATE_NAME);\n    ReadAddressFifo            <= NewID(\"ReadAddressFifo\",              ID, ReportMode => DISABLED, Search => PRIVATE_NAME);\n    ReadAddressTransactionFifo <= NewID(\"ReadAddressTransactionFifo\",   ID, ReportMode => DISABLED, Search => PRIVATE_NAME);\n    ReadDataFifo               <= NewID(\"ReadDataFifo\",                 ID, ReportMode => DISABLED, Search => PRIVATE_NAME);\n\n    wait ;\n  end process Initialize ;\n\n\n  ------------------------------------------------------------\n  --  Transaction Dispatcher\n  --    Dispatches transactions to\n  ------------------------------------------------------------\n  TransactionDispatcher : process\n    variable ReadDataTransactionCount : integer := 1 ;\n    variable ByteCount          : integer ;\n    variable TransfersInBurst   : integer ;\n\n    variable Axi4Option    : Axi4OptionsType ;\n    variable Axi4OptionVal : integer ;\n\n    variable AxiDefaults    : AxiBus'subtype ;\n\n    alias    LAW : AxiDefaults.WriteAddress'subtype  is AxiDefaults.WriteAddress ;\n    alias    LWD : AxiDefaults.WriteData'subtype     is AxiDefaults.WriteData ;\n    alias    LWR : AxiDefaults.WriteResponse'subtype is AxiDefaults.WriteResponse ;\n    alias    LAR : AxiDefaults.ReadAddress'subtype   is AxiDefaults.ReadAddress ;\n    alias    LRD : AxiDefaults.ReadData'subtype      is AxiDefaults.ReadData ;\n    \n    variable WriteByteAddr   : integer ;\n\n    variable BytesToSend              : integer ;\n    variable BytesPerTransfer         : integer ;\n    variable MaxBytesInFirstTransfer  : integer ;\n\n    variable BytesInTransfer : integer ;\n    variable BytesToReceive  : integer ;\n    variable DataBitOffset   : integer ;\n\n    variable ReadByteAddr    : integer ;\n    variable ReadProt        : Axi4ProtType ;\n\n    variable ExpectedData    : std_logic_vector(LRD.Data'range) ;\n\n    variable Operation       : AddressBusOperationType ;\n    variable WriteDataCount   : integer := 0 ;\n  begin\n    AxiDefaults := InitAxi4Rec(AxiDefaults, '0') ;\n    LAW.Size    := to_slv(AXI_BYTE_ADDR_WIDTH, LAW.Size'length) ;\n    LAW.Burst   := \"01\" ;  -- INCR\n    LWR.Resp    := to_Axi4RespType(OKAY);\n    LAR.Size    := to_slv(AXI_BYTE_ADDR_WIDTH, LAR.Size'length) ;\n    LAR.Burst   := \"01\" ;  -- INCR\n    LRD.Resp    := to_Axi4RespType(OKAY) ;\n    \n    wait for 0 ns ; \n    TransRec.WriteBurstFifo <= NewID(\"WriteBurstFifo\", ModelID, Search => PRIVATE_NAME) ;\n    TransRec.ReadBurstFifo  <= NewID(\"ReadBurstFifo\",  ModelID, Search => PRIVATE_NAME) ;\n    \n--!! AWCache, ARCache Defaults\n    loop\n      WaitForTransaction(\n         Clk      => Clk,\n         Rdy      => TransRec.Rdy,\n         Ack      => TransRec.Ack\n      ) ;\n      Operation := TransRec.Operation ;\n\n      case Operation is\n        -- Execute Standard Directive Transactions\n        when WAIT_FOR_TRANSACTION =>\n          -- Waits for All WRITE and READ Transactions to complete\n          if WriteAddressRequestCount /= WriteAddressDoneCount then\n            -- Block until both write address done.\n            wait until WriteAddressRequestCount = WriteAddressDoneCount ;\n          end if ;\n          if WriteDataRequestCount /= WriteDataDoneCount then\n            -- Block until both write data done.\n            wait until WriteDataRequestCount = WriteDataDoneCount ;\n          end if ;\n          if WriteResponseExpectCount /= WriteResponseReceiveCount then\n            -- Block until both write response done.\n            wait until WriteResponseExpectCount = WriteResponseReceiveCount ;\n          end if ;\n\n          if ReadAddressRequestCount /= ReadAddressDoneCount then\n            -- Block until both read address done.\n            wait until ReadAddressRequestCount = ReadAddressDoneCount ;\n          end if ;\n          if ReadDataExpectCount /= ReadDataReceiveCount then\n            -- Block until both read data done.\n            wait until ReadDataExpectCount = ReadDataReceiveCount ;\n          end if ;\n\n        when WAIT_FOR_WRITE_TRANSACTION =>\n          if WriteAddressRequestCount /= WriteAddressDoneCount then\n            -- Block until both write address done.\n            wait until WriteAddressRequestCount = WriteAddressDoneCount ;\n          end if ;\n          if WriteDataRequestCount /= WriteDataDoneCount then\n            -- Block until both write data done.\n            wait until WriteDataRequestCount = WriteDataDoneCount ;\n          end if ;\n          if WriteResponseExpectCount /= WriteResponseReceiveCount then\n            -- Block until both write response done.\n            wait until WriteResponseExpectCount = WriteResponseReceiveCount ;\n          end if ;\n          wait for 0 ns ; \n\n        when WAIT_FOR_READ_TRANSACTION =>\n          if ReadAddressRequestCount /= ReadAddressDoneCount then\n            -- Block until both read address done.\n            wait until ReadAddressRequestCount = ReadAddressDoneCount ;\n          end if ;\n          if ReadDataExpectCount /= ReadDataReceiveCount then\n            -- Block until both read data done.\n            wait until ReadDataExpectCount = ReadDataReceiveCount ;\n          end if ;\n          wait for 0 ns ; \n\n        when WAIT_FOR_CLOCK =>\n          WaitForClock(Clk, TransRec.IntToModel) ;\n\n        when GET_ALERTLOG_ID =>\n          TransRec.IntFromModel <= integer(ModelID) ;\n          wait for 0 ns ; \n\n        when SET_BURST_MODE =>                      \n          BurstFifoMode       <= TransRec.IntToModel ;\n          BurstFifoByteMode   <= (TransRec.IntToModel = ADDRESS_BUS_BURST_BYTE_MODE) ;\n          wait for 0 ns ; \n          AlertIf(ModelID, not IsAddressBusBurstMode(BurstFifoMode), \n            \"Invalid Burst Mode \" & to_string(BurstFifoMode), FAILURE) ;\n              \n        when GET_BURST_MODE =>                      \n          TransRec.IntFromModel <= BurstFifoMode ;\n\n        when GET_TRANSACTION_COUNT =>\n          TransRec.IntFromModel <= integer(TransRec.Rdy) ; --  WriteAddressDoneCount + ReadAddressDoneCount ;\n          wait for 0 ns ; \n\n        when GET_WRITE_TRANSACTION_COUNT =>\n          TransRec.IntFromModel <= WriteAddressDoneCount ;\n          wait for 0 ns ; \n\n        when GET_READ_TRANSACTION_COUNT =>\n          TransRec.IntFromModel <= ReadAddressDoneCount ;\n          wait for 0 ns ; \n\n        -- Model Transaction Dispatch\n        when WRITE_OP | WRITE_ADDRESS | WRITE_DATA | ASYNC_WRITE | ASYNC_WRITE_ADDRESS | ASYNC_WRITE_DATA =>\n          -- For All Write Operations - Write Address and Write Data\n          LAW.Addr  := SafeResize(TransRec.Address, LAW.Addr'length) ;\n          WriteByteAddr := CalculateByteAddress(LAW.Addr, AXI_BYTE_ADDR_WIDTH) ;\n\n          if IsWriteAddress(Operation) then\n            -- AlertIf(ModelID, TransRec.AddrWidth /= AXI_ADDR_WIDTH, \"Write Address length does not match\", FAILURE) ;\n\n            LAW.Len := (others => '0') ;\n\n            -- Initiate Write Address\n            Push(WriteAddressFifo, LAW.Addr  & LAW.Len & LAW.Prot & LAW.ID & LAW.Size & LAW.Burst & LAW.Lock & LAW.Cache & LAW.QOS & LAW.Region & LAW.User) ;\n            Increment(WriteAddressRequestCount) ;\n          end if ;\n\n          if IsWriteData(Operation) then\n            -- Single Transfer Write Data Handling\n            CheckDataIsBytes(ModelID, TransRec.DataWidth, \"Manager Write: \", WriteDataRequestCount+1) ;\n            CheckDataWidth  (ModelID, TransRec.DataWidth, WriteByteAddr, AXI_DATA_WIDTH, \"Manager Write: \", WriteDataRequestCount+1) ;\n            LWD.Data  := AlignBytesToDataBus(SafeResize(TransRec.DataToModel, LWD.Data'length), TransRec.DataWidth, WriteByteAddr) ;\n            LWD.Strb  := CalculateWriteStrobe(LWD.Data) ;\n            Push(WriteDataFifo, '0' & '1' & LWD.Data & LWD.Strb & LWD.User & LWD.ID) ;\n\n            Increment(WriteDataRequestCount) ;\n            WriteDataCount := WriteDataCount + 1 ; \n          end if ;\n          \n          -- Allow RequestCounts to update\n          wait for 0 ns ;  \n\n--!! If burst emulation is added, then this will need to be a while loop since\n--!! more than one transaction will be dispatched at a time.\n          if WriteAddressRequestCount /= WriteResponseExpectCount and\n             WriteDataCount           /= WriteResponseExpectCount \n          then\n            -- Queue Expected Write Response\n            Push(WriteResponseScoreboard, LWR.Resp) ;\n            Increment(WriteResponseExpectCount) ;\n          end if ;\n          \n          if IsBlockOnWriteAddress(Operation) and\n              WriteAddressRequestCount /= WriteAddressDoneCount then\n            -- Block until both write address done.\n            wait until WriteAddressRequestCount = WriteAddressDoneCount ;\n          end if ;\n          if IsBlockOnWriteData(Operation) and\n              WriteDataRequestCount /= WriteDataDoneCount then\n            -- Block until both write data done.\n            wait until WriteDataRequestCount = WriteDataDoneCount ;\n          end if ;\n\n\n        -- Model Transaction Dispatch\n        when WRITE_BURST | ASYNC_WRITE_BURST =>\n          LAW.Addr  := SafeResize(TransRec.Address, LAW.Addr'length) ;\n          WriteByteAddr := CalculateByteAddress(LAW.Addr, AXI_BYTE_ADDR_WIDTH);\n          BytesPerTransfer := AXI_DATA_BYTE_WIDTH ;\n--!!          BytesPerTransfer := 2**to_integer(LAW.Size);\n--            AlertIf(ModelID, BytesPerTransfer /= AXI_DATA_BYTE_WIDTH,\n--              \"Write Bytes Per Transfer (\" & to_string(BytesPerTransfer) & \") \" &\n--              \"/= AXI_DATA_BYTE_WIDTH (\" & to_string(AXI_DATA_BYTE_WIDTH) & \")\"\n--            );\n\n          if IsWriteAddress(Operation) then\n            -- Write Address Handling\n--            AlertIf(ModelID, TransRec.AddrWidth /= AXI_ADDR_WIDTH, \"Write Address length does not match\", FAILURE) ;\n\n            -- Burst transfer, calculate burst length\n            if BurstFifoByteMode then \n              LAW.Len := to_slv(CalculateBurstLen(TransRec.DataWidth, WriteByteAddr, BytesPerTransfer), LAW.Len'length) ;\n            else \n              LAW.Len := to_slv(TransRec.DataWidth-1, LAW.Len'length) ;\n            end if ;\n            \n            -- Initiate Write Address\n            Push(WriteAddressFifo, LAW.Addr  & LAW.Len & LAW.Prot & LAW.ID & LAW.Size & LAW.Burst & LAW.Lock & LAW.Cache & LAW.QOS & LAW.Region & LAW.User) ;\n\n            Increment(WriteAddressRequestCount) ;\n          end if ;\n\n          if IsWriteData(Operation) then\n            if BurstFifoByteMode then \n              BytesToSend       := TransRec.DataWidth ;\n              TransfersInBurst  := 1 + CalculateBurstLen(BytesToSend, WriteByteAddr, BytesPerTransfer) ;\n            else\n              TransfersInBurst := TransRec.DataWidth ;\n            end if ; \n            \n            PopWriteBurstData(TransRec.WriteBurstFifo, BurstFifoMode, LWD.Data, LWD.Strb, BytesToSend, WriteByteAddr) ;\n\n            for BurstLoop in TransfersInBurst downto 2 loop    \n              Push(WriteDataFifo, '1' & '0' & LWD.Data & LWD.Strb & LWD.User & LWD.ID) ;\n              PopWriteBurstData(TransRec.WriteBurstFifo, BurstFifoMode, LWD.Data, LWD.Strb, BytesToSend, 0) ;\n            end loop ; \n            \n            -- Special handle last push\n            Push(WriteDataFifo, '1' & '1' & LWD.Data & LWD.Strb & LWD.User & LWD.ID) ;\n\n            -- Increment(WriteDataRequestCount) ;\n            WriteDataRequestCount        <= Increment(WriteDataRequestCount, TransfersInBurst) ;\n            WriteDataCount := WriteDataCount + 1 ; \n          end if ;\n\n          -- Allow RequestCounts to update\n          wait for 0 ns ;  \n\n--!! will need to be a while loop if more than one transaction can be dispatched at a time.\n--!! only happens if bursts are emulated - ie translated from a burst cycle to a multiple individual cycles\n          if WriteAddressRequestCount /= WriteResponseExpectCount and \n             WriteDataCount           /= WriteResponseExpectCount \n          then\n            -- Queue Expected Write Response\n            Push(WriteResponseScoreboard, LWR.Resp) ;\n            Increment(WriteResponseExpectCount) ;\n          end if ;\n\n          if IsBlockOnWriteAddress(Operation) and\n              WriteAddressRequestCount /= WriteAddressDoneCount then\n            -- Block until write address done.\n            wait until WriteAddressRequestCount = WriteAddressDoneCount ;\n          end if ;\n          if IsBlockOnWriteData(Operation) and\n              WriteDataRequestCount /= WriteDataDoneCount then\n            -- Block until write data done.\n            wait until WriteDataRequestCount = WriteDataDoneCount ;\n          end if ;\n\n        when READ_OP | READ_CHECK | READ_ADDRESS | READ_DATA | READ_DATA_CHECK | ASYNC_READ_ADDRESS | ASYNC_READ_DATA | ASYNC_READ_DATA_CHECK =>\n          if IsReadAddress(Operation) then\n            -- Send Read Address to Read Address Handler and Read Data Handler\n            LAR.Addr   :=  SafeResize(TransRec.Address, LAR.Addr'length) ;\n            ReadByteAddr  :=  CalculateByteAddress(LAR.Addr, AXI_BYTE_ADDR_WIDTH);\n--             AlertIf(ModelID, TransRec.AddrWidth /= AXI_ADDR_WIDTH, \"Read Address length does not match\", FAILURE) ;\n            BytesPerTransfer := 2**to_integer(LAR.Size);\n\n            LAR.Len := (others => '0') ;\n\n            Push(ReadAddressFifo, LAR.Addr & LAR.Len & LAR.Prot & LAR.ID & LAR.Size & LAR.Burst & LAR.Lock & LAR.Cache & LAR.QOS & LAR.Region & LAR.User) ;\n            Push(ReadAddressTransactionFifo, LAR.Addr & LAR.Prot);\n            Increment(ReadAddressRequestCount) ;\n\n            -- Expect a Read Data Cycle\n            Push(ReadResponseScoreboard, LRD.Resp) ;\n            increment(ReadDataExpectCount) ;\n          end if ;\n          wait for 0 ns ; \n\n          if IsTryReadData(Operation) and Empty(ReadDataFifo) then\n            -- Data not available\n            -- ReadDataReceiveCount < ReadDataTransactionCount then\n            TransRec.BoolFromModel <= FALSE ;\n            TransRec.DataFromModel <= (TransRec.DataFromModel'range => '0') ; \n          elsif IsReadData(Operation) then\n            (LAR.Addr, ReadProt) := Pop(ReadAddressTransactionFifo) ;\n            ReadByteAddr  :=  CalculateByteAddress(LAR.Addr, AXI_BYTE_ADDR_WIDTH);\n\n            -- Wait for Data Ready\n            if Empty(ReadDataFifo) then\n              WaitForToggle(ReadDataReceiveCount) ;\n            end if ;\n            TransRec.BoolFromModel <= TRUE ;\n\n            -- Get Read Data\n            LRD.Data := Pop(ReadDataFifo) ;\n            CheckDataIsBytes(ModelID, TransRec.DataWidth, \"Manager Read: \", ReadDataExpectCount) ;\n            CheckDataWidth  (ModelID, TransRec.DataWidth, ReadByteAddr, AXI_DATA_WIDTH, \"Manager Read: \", ReadDataExpectCount) ;\n            LRD.Data := AlignDataBusToBytes(LRD.Data, TransRec.DataWidth, ReadByteAddr) ;\n--            AxiReadDataAlignCheck (ModelID, LRD.Data, TransRec.DataWidth, LAR.Addr, AXI_DATA_BYTE_WIDTH, AXI_BYTE_ADDR_WIDTH) ;\n            TransRec.DataFromModel <= SafeResize(LRD.Data, TransRec.DataFromModel'length) ;\n\n            -- Check or Log Read Data\n            if IsReadCheck(TransRec.Operation) then\n              ExpectedData := SafeResize(TransRec.DataToModel, ExpectedData'length) ;\n  --!!9 TODO:  Change format to Transaction #, Address, Prot, Read Data\n  --!! Run regressions before changing\n              AffirmIf( DataCheckID, MetaMatch(LRD.Data, ExpectedData),\n                \"Read Data: \" & to_hxstring(LRD.Data) &\n                \"  Read Address: \" & to_hxstring(LAR.Addr) &\n                \"  Prot: \" & to_hxstring(ReadProt),\n                \"  Expected: \" & to_hxstring(ExpectedData),\n                TransRec.StatusMsgOn or IsLogEnabled(ModelID, INFO) ) ;\n            else\n  --!!9 TODO:  Change format to Transaction #, Address, Prot, Read Data\n  --!! Run regressions before changing\n              Log( ModelID,\n                \"Read Data: \" & to_hxstring(LRD.Data) &\n                \"  Read Address: \" & to_hxstring(LAR.Addr) &\n                \"  Prot: \" & to_hxstring(ReadProt),\n                INFO,\n                TransRec.StatusMsgOn\n              ) ;\n            end if ;\n          end if ;\n\n          -- Transaction wait time\n          wait for 0 ns ;  wait for 0 ns ;\n\n        when READ_BURST =>\n          if IsReadAddress(Operation) then\n            -- Send Read Address to Read Address Handler and Read Data Handler\n            LAR.Addr   :=  SafeResize(TransRec.Address, LAR.Addr'length) ;\n            ReadByteAddr  :=  CalculateByteAddress(LAR.Addr, AXI_BYTE_ADDR_WIDTH);\n--            AlertIf(ModelID, TransRec.AddrWidth /= AXI_ADDR_WIDTH, \"Read Address length does not match\", FAILURE) ;\n            BytesPerTransfer := 2**to_integer(LAR.Size);\n\n            -- Burst transfer, calculate burst length\n            if BurstFifoByteMode then \n              TransfersInBurst := 1 + CalculateBurstLen(TransRec.DataWidth, ReadByteAddr, BytesPerTransfer) ;\n            else \n              TransfersInBurst := TransRec.DataWidth ; \n            end if ;\n            LAR.Len := to_slv(TransfersInBurst - 1, LAR.Len'length) ;\n\n            Push(ReadAddressFifo, LAR.Addr & LAR.Len & LAR.Prot & LAR.ID & LAR.Size & LAR.Burst & LAR.Lock & LAR.Cache & LAR.QOS & LAR.Region & LAR.User) ;\n            Push(ReadAddressTransactionFifo, LAR.Addr & LAR.Prot);\n            Increment(ReadAddressRequestCount) ;\n\n            -- Expect a Read Data Cycle\n            for i in 1 to TransfersInBurst loop\n              Push(ReadResponseScoreboard, LRD.Resp) ;\n            end loop ;\n  -- Should this be + TransfersInBurst ; ???\n            ReadDataExpectCount <= Increment(ReadDataExpectCount, TransfersInBurst) ;\n          end if ;\n\n  --!!3 Implies that any separate ReadDataBurst or TryReadDataBurst\n  --!!3 must include the transfer length and for Try\n  --!!3 if ReadDataFifo has that number of transfers.\n  --!!3 First Check IsReadData, then Calculate #Transfers,\n  --!!3 Then if TryRead, and ReadDataFifo.FifoCount < #Transfers, then FALSE\n  --!!3 Which reverses the order of the following IF statements\n          if IsTryReadData(Operation) and Empty(ReadDataFifo) then\n            -- Data not available\n            -- ReadDataReceiveCount < ReadDataTransactionCount then\n            TransRec.BoolFromModel <= FALSE ;\n          elsif IsReadData(Operation) then\n            TransRec.BoolFromModel <= TRUE ;\n            (LAR.Addr, ReadProt) := Pop(ReadAddressTransactionFifo) ;\n            ReadByteAddr := CalculateByteAddress(LAR.Addr, AXI_BYTE_ADDR_WIDTH);\n            BytesPerTransfer := 2**to_integer(LAR.Size);\n--!!            BytesPerTransfer  := AXI_DATA_BYTE_WIDTH ;\n\n--!!            AlertIf(ModelID, BytesPerTransfer /= AXI_DATA_BYTE_WIDTH,\n--!!              \"Write Bytes Per Transfer (\" & to_string(BytesPerTransfer) & \") \" &\n--!!              \"/= AXI_DATA_BYTE_WIDTH (\" & to_string(AXI_DATA_BYTE_WIDTH) & \")\"\n--!!            );\n\n            if BurstFifoByteMode then \n              BytesToReceive    := TransRec.DataWidth ;\n              TransfersInBurst  := 1 + CalculateBurstLen(BytesToReceive, ReadByteAddr, BytesPerTransfer) ;\n            else\n              TransfersInBurst  := TransRec.DataWidth ;\n            end if ; \n\n            for BurstLoop in 1 to TransfersInBurst loop\n              if Empty(ReadDataFifo) then\n                WaitForToggle(ReadDataReceiveCount) ;\n              end if ;\n              LRD.Data := Pop(ReadDataFifo) ;\n              \n              PushReadBurstData(TransRec.ReadBurstFifo, BurstFifoMode, LRD.Data, BytesToReceive, ReadByteAddr) ;\n              ReadByteAddr := 0 ;\n            end loop ;\n          end if ;\n\n        -- Model Configuration Options\n        when SET_MODEL_OPTIONS =>\n          Axi4Option := Axi4OptionsType'val(TransRec.Options) ;\n          if IsAxiInterface(Axi4Option) then\n            SetAxi4InterfaceDefault(AxiDefaults, Axi4Option, TransRec.IntToModel) ;\n          else\n            SetAxi4Parameter(Params, Axi4Option, TransRec.IntToModel) ;\n          end if ;\n\n        when GET_MODEL_OPTIONS =>\n          Axi4Option := Axi4OptionsType'val(TransRec.Options) ;\n          if IsAxiInterface(Axi4Option) then\n            TransRec.IntFromModel <= GetAxi4InterfaceDefault(AxiDefaults, Axi4Option) ;\n          else\n            GetAxi4Parameter(Params, Axi4Option, Axi4OptionVal) ;\n            TransRec.IntFromModel <= Axi4OptionVal ;\n          end if ;\n\n        when MULTIPLE_DRIVER_DETECT =>\n          Alert(ModelID, \"Multiple Drivers on Transaction Record.\" & \n                         \"  Transaction # \" & to_string(TransRec.Rdy), FAILURE) ;\n\n        when others =>\n          Alert(ModelID, \"Unimplemented Transaction: \" & to_string(TransRec.Operation), FAILURE) ;\n      end case ;\n    end loop ;\n  end process TransactionDispatcher ;\n\n  ------------------------------------------------------------\n  --  WriteAddressHandler\n  --    Execute Write Address Transactions\n  ------------------------------------------------------------\n  WriteAddressHandler : process\n    alias    AW    : AxiBus.WriteAddress'subtype is AxiBus.WriteAddress ;\n    variable Local : AxiBus.WriteAddress'subtype ;\n    variable WriteAddressReadyTimeOut : integer ;\n  begin\n    -- AXI4 Lite Signaling\n    AW.Valid  <= '0' ;\n    AW.Addr   <= (Local.Addr'range   => '0') ;\n    AW.Prot   <= (Local.Prot'range   => '0') ;\n    -- AXI4 Full Signaling\n    AW.Len    <= (Local.Len'range    => '0') ;\n    AW.ID     <= (Local.ID'range     => '0') ;\n    AW.Size   <= (Local.Size'range   => '0') ;\n    AW.Burst  <= (Local.Burst'range  => '0') ;\n    AW.Lock   <= '0' ;\n    AW.Cache  <= (Local.Cache'range  => '0') ;\n    AW.QOS    <= (Local.QOS'range    => '0') ;\n    AW.Region <= (Local.Region'range => '0') ;\n    AW.User   <= (Local.User'range   => '0') ;\n    wait for 0 ns ; -- Allow WriteAddressFifo to initialize\n\n    WriteAddressLoop : loop\n      -- Find Transaction\n      if Empty(WriteAddressFifo) then\n         WaitForToggle(WriteAddressRequestCount) ;\n      end if ;\n      (Local.Addr, Local.Len, Local.Prot, Local.ID, Local.Size, Local.Burst, Local.Lock, Local.Cache, Local.QOS, Local.Region, Local.User) := Pop(WriteAddressFifo) ;\n\n      WaitForClock(Clk, integer'(Params.Get(Axi4OptionsType'POS(WRITE_ADDRESS_VALID_DELAY_CYCLES)))) ; \n\n      -- Do Transaction\n      AW.Addr   <= Local.Addr      after tpd_Clk_AWAddr   ;\n      AW.Prot   <= Local.Prot      after tpd_clk_AWProt   ;\n      -- AXI4 Full\n      AW.Len    <= Local.Len       after tpd_clk_AWLen    ;\n      AW.ID     <= Local.ID        after tpd_clk_AWID     ;\n      AW.Size   <= Local.Size      after tpd_clk_AWSize   ;\n      AW.Burst  <= Local.Burst     after tpd_clk_AWBurst  ;\n      AW.Lock   <= Local.Lock      after tpd_clk_AWLock   ;\n      AW.Cache  <= Local.Cache     after tpd_clk_AWCache  ;\n      AW.QOS    <= Local.QOS       after tpd_clk_AWQOS    ;\n      AW.Region <= Local.Region    after tpd_clk_AWRegion ;\n      AW.User   <= Local.User      after tpd_clk_AWUser   ;\n\n      Log(ModelID,\n        \"Write Address.\" &\n        \"  AWAddr: \"  & to_hxstring(Local.Addr) &\n        \"  AWProt: \"  & to_string(Local.Prot) &\n        \"  Operation# \" & to_string(WriteAddressDoneCount + 1),\n        INFO\n      ) ;\n\n      GetAxi4Parameter(Params, WRITE_ADDRESS_READY_TIME_OUT, WriteAddressReadyTimeOut) ;\n\n      ---------------------\n      DoAxiValidHandshake (\n      ---------------------\n        Clk            =>  Clk,\n        Valid          =>  AxiBus.WriteAddress.Valid,  --!GHDL\n        Ready          =>  AxiBus.WriteAddress.Ready,  --!GHDL\n        tpd_Clk_Valid  =>  tpd_Clk_AWValid,\n        AlertLogID     =>  BusFailedID,\n        TimeOutMessage =>  \"Write Address # \" & to_string(WriteAddressDoneCount + 1),\n        TimeOutPeriod  =>  WriteAddressReadyTimeOut * tperiod_Clk\n      ) ;\n\n      -- State after operation\n      AW.Addr   <= Local.Addr   + 4  after tpd_Clk_AWAddr   ;\n      AW.Prot   <= Local.Prot   + 1  after tpd_clk_AWProt   ;\n      -- AXI4 Full\n      AW.Len    <= Local.Len    + 1  after tpd_clk_AWLen    ;\n      AW.ID     <= Local.ID     + 1  after tpd_clk_AWID     ;\n      AW.Size   <= Local.Size   + 1  after tpd_clk_AWSize   ;\n      AW.Burst  <= Local.Burst  + 1  after tpd_clk_AWBurst  ;\n      AW.Lock   <= Local.Lock        after tpd_clk_AWLock   ;\n      AW.Cache  <= Local.Cache  + 1  after tpd_clk_AWCache  ;\n      AW.QOS    <= Local.QOS    + 1  after tpd_clk_AWQOS    ;\n      AW.Region <= Local.Region + 1  after tpd_clk_AWRegion ;\n      AW.User   <= Local.User   + 1  after tpd_clk_AWUser   ;\n      -- Signal completion\n      Increment(WriteAddressDoneCount) ;\n      wait for 0 ns ;\n    end loop WriteAddressLoop ;\n  end process WriteAddressHandler ;\n\n  ------------------------------------------------------------\n  --  WriteDataHandler\n  --    Execute Write Data Transactions\n  ------------------------------------------------------------\n  WriteDataHandler : process\n    alias    WD : AxiBus.WriteData'subtype is AxiBus.WriteData ;\n\n    variable Local : AxiBus.WriteData'subtype ;\n    \n    variable WriteDataReadyTimeOut : integer ;\n    variable Burst    : std_logic ; \n    variable NewTransfer : std_logic := '1' ; \n  begin\n    -- initialize\n    WD.Valid <= '0' ;\n    WD.Data  <= (Local.Data'range => '0') ;\n    WD.Strb  <= (Local.Strb'range => '0') ;\n    -- AXI4 Full\n    WD.Last  <= '0' ;\n    WD.User  <= (Local.User'range => '0') ;\n    -- AXI3\n    WD.ID    <= (Local.ID'range   => '0') ;\n    wait for 0 ns ; -- Allow WriteDataFifo to initialize\n\n    WriteDataLoop : loop\n      -- Find Transaction\n      if Empty(WriteDataFifo) then\n         WaitForToggle(WriteDataRequestCount) ;\n      end if ;\n      (Burst, Local.Last, Local.Data, Local.Strb, Local.User, Local.ID) := Pop(WriteDataFifo) ;\n            \n      if NewTransfer then\n        WaitForClock(Clk, integer'(Params.Get(Axi4OptionsType'POS(WRITE_DATA_VALID_DELAY_CYCLES)))) ; \n      elsif Burst then \n        WaitForClock(Clk, integer'(Params.Get(Axi4OptionsType'POS(WRITE_DATA_VALID_BURST_DELAY_CYCLES)))) ; \n      end if ; \n      \n      NewTransfer := Local.Last ; -- Last is '1' for burst end and single word transfers\n\n      -- Do Transaction\n      WD.Data  <= Local.Data after tpd_clk_WStrb ;\n      WD.Strb  <= Local.Strb after tpd_Clk_WData ;\n      -- AXI4 Full\n      WD.Last  <= Local.Last after tpd_Clk_WLast ;\n      WD.User  <= Local.User after tpd_Clk_WUser ;\n      -- AXI3\n      WD.ID    <= Local.ID   after tpd_Clk_WID ;\n\n      Log(ModelID,\n        \"Write Data.\" &\n        \"  WData: \"  & to_hxstring(Local.Data) &\n        \"  WStrb: \"  & to_string( Local.Strb) &\n        \"  Operation# \" & to_string(WriteDataDoneCount + 1),\n        INFO\n      ) ;\n\n      GetAxi4Parameter(Params, WRITE_DATA_READY_TIME_OUT, WriteDataReadyTimeOut) ;\n\n      ---------------------\n      DoAxiValidHandshake (\n      ---------------------\n        Clk            =>  Clk,\n        Valid          =>  AxiBus.WriteData.Valid,  --!GHDL\n        Ready          =>  AxiBus.WriteData.Ready,  --!GHDL\n        tpd_Clk_Valid  =>  tpd_Clk_WValid,\n        AlertLogID     =>  BusFailedID,\n        TimeOutMessage =>  \"Write Data # \" & to_string(WriteDataDoneCount + 1),\n        TimeOutPeriod  =>  WriteDataReadyTimeOut * tperiod_Clk\n      ) ;\n\n      -- State after operation\n      WD.Data  <= not Local.Data      after tpd_Clk_WData ;\n      WD.Strb  <= Local.Strb          after tpd_clk_WStrb ; -- allow writes\n      -- AXI4 Full\n      WD.Last  <= not Local.Last      after tpd_Clk_WLast ;\n      WD.User  <= Local.User          after tpd_Clk_WUser ;\n      -- AXI3\n      WD.ID    <= Local.ID            after tpd_Clk_WID ;\n\n      -- Signal completion\n      Increment(WriteDataDoneCount) ;\n      wait for 0 ns ;\n    end loop WriteDataLoop ;\n  end process WriteDataHandler ;\n\n  ------------------------------------------------------------\n  -- WriteResponseHandler\n  --   Receive and Check Write Responses\n  ------------------------------------------------------------\n  WriteResponseHandler : process\n    variable WriteResponseReadyBeforeValid  : boolean ;\n    variable WriteResponseReadyDelayCycles  : integer ;\n    variable WriteResponseValidTimeOut : integer ;\n    variable WriteResponseTimeOut : boolean ; \n  begin\n    -- initialize\n    AxiBus.WriteResponse.Ready <= '0' ;\n    wait for 0 ns ; -- Allow WriteResponseScoreboard to initialize\n\n    WriteResponseOperation : loop\n      -- Find Expected Transaction\n      WriteResponseActive <= FALSE ;\n      if empty(WriteResponseScoreboard) then\n        WaitForToggle(WriteResponseExpectCount) ;\n      end if ;\n      WriteResponseActive <= TRUE ;\n\n      Log(ModelID, \"Waiting for Write Response.\", DEBUG) ;\n\n\n      GetAxi4Parameter(Params, WRITE_RESPONSE_READY_BEFORE_VALID, WriteResponseReadyBeforeValid) ;\n      GetAxi4Parameter(Params, WRITE_RESPONSE_READY_DELAY_CYCLES, WriteResponseReadyDelayCycles) ;\n      GetAxi4Parameter(Params, WRITE_RESPONSE_VALID_TIME_OUT,     WriteResponseValidTimeOut) ;\n\n      ---------------------\n      DoAxiReadyHandshake (\n      ---------------------\n        Clk                     => Clk,\n        Valid                   => AxiBus.WriteResponse.Valid,\n        Ready                   => AxiBus.WriteResponse.Ready,\n        ReadyBeforeValid        => WriteResponseReadyBeforeValid,\n        ReadyDelayCycles        => WriteResponseReadyDelayCycles * tperiod_Clk,\n        tpd_Clk_Ready           => tpd_Clk_BReady,\n        AlertLogID              => BusFailedID,\n        TimeOutMessage          => \"Write Response # \" & to_string(WriteResponseReceiveCount + 1),\n        TimeOutPeriod           => WriteResponseValidTimeOut * tperiod_Clk\n      ) ;\n\n      -- Check Write Response\n      Check(WriteResponseScoreboard, AxiBus.WriteResponse.Resp) ;\n\n      -- Signal Completion\n      increment(WriteResponseReceiveCount) ;\n      wait for 0 ns ;\n    end loop WriteResponseOperation ;\n  end process WriteResponseHandler ;\n\n\n  ------------------------------------------------------------\n  --  WriteResponseProtocolChecker\n  --    Error if Write Response BValid happens without a Write cycle\n  ------------------------------------------------------------\n  WriteResponseProtocolChecker : process\n  begin\n    wait on Clk until Clk = '1' and AxiBus.WriteResponse.Valid = '1' ;\n    AlertIf(ProtocolID, not WriteResponseActive,\n      \"Unexpected Write Response Cycle. \" &\n      \" BValid: \" & to_string(AxiBus.WriteResponse.Valid) &\n      \" BResp: \"  & to_string(AxiBus.WriteResponse.Resp) &\n      \"  Operation# \" & to_string(WriteResponseReceiveCount + 1),\n      FAILURE\n    ) ;\n  end process WriteResponseProtocolChecker ;\n\n  ------------------------------------------------------------\n  --  ReadAddressHandler\n  --    Execute Read Address Transactions\n  ------------------------------------------------------------\n  ReadAddressHandler : process\n    alias    AR : AxiBus.ReadAddress'subtype is AxiBus.ReadAddress ;\n\n    variable Local : AxiBus.ReadAddress'subtype ;\n\n    variable ReadAddressReadyTimeOut : integer ;\n  begin\n    -- AXI4 Lite Signaling\n    AR.Valid  <= '0' ;\n    AR.Addr   <= (Local.Addr'range   => '0') ;\n    AR.Prot   <= (Local.Prot'range   => '0') ;\n    -- AXI4 Full Signaling\n    AR.Len    <= (Local.Len'range    => '0') ;\n    AR.ID     <= (Local.ID'range     => '0') ;\n    AR.Size   <= (Local.Size'range   => '0') ;\n    AR.Burst  <= (Local.Burst'range  => '0') ;\n    AR.Lock   <= '0' ;\n    AR.Cache  <= (Local.Cache'range  => '0') ;\n    AR.QOS    <= (Local.QOS'range    => '0') ;\n    AR.Region <= (Local.Region'range => '0') ;\n    AR.User   <= (Local.User'range   => '0') ;\n    wait for 0 ns ; -- Allow ReadAddressFifo to initialize\n\n\n    AddressReadLoop : loop\n      -- Find Transaction\n      if Empty(ReadAddressFifo) then\n         WaitForToggle(ReadAddressRequestCount) ;\n      end if ;\n      (Local.Addr, Local.Len, Local.Prot, Local.ID, Local.Size, Local.Burst, Local.Lock, Local.Cache, Local.QOS, Local.Region, Local.User) := Pop(ReadAddressFifo) ;\n\n      WaitForClock(Clk, integer'(Params.Get(Axi4OptionsType'POS(READ_ADDRESS_VALID_DELAY_CYCLES)))) ; \n\n      -- Do Transaction\n      AR.Addr   <= Local.Addr   after tpd_Clk_ARAddr   ;\n      AR.Prot   <= Local.Prot   after tpd_clk_ARProt   ;\n      -- AXI4 Full\n      AR.Len    <= Local.Len    after tpd_clk_ARLen    ;\n      AR.ID     <= Local.ID     after tpd_clk_ARID     ;\n      AR.Size   <= Local.Size   after tpd_clk_ARSize   ;\n      AR.Burst  <= Local.Burst  after tpd_clk_ARBurst  ;\n      AR.Lock   <= Local.Lock   after tpd_clk_ARLock   ;\n      AR.Cache  <= Local.Cache  after tpd_clk_ARCache  ;\n      AR.QOS    <= Local.QOS    after tpd_clk_ARQOS    ;\n      AR.Region <= Local.Region after tpd_clk_ARRegion ;\n      AR.User   <= Local.User   after tpd_clk_ARUser   ;\n\n      Log(ModelID,\n        \"Read Address.\" &\n        \"  ARAddr: \"  & to_hxstring(Local.Addr) &\n        \"  ARProt: \"  & to_string( Local.Prot) &\n        \"  Operation# \" & to_string(ReadAddressDoneCount + 1),\n        INFO\n      ) ;\n\n      GetAxi4Parameter(Params, READ_ADDRESS_READY_TIME_OUT, ReadAddressReadyTimeOut) ;\n\n      ---------------------\n      DoAxiValidHandshake (\n      ---------------------\n        Clk            =>  Clk,\n        Valid          =>  AxiBus.ReadAddress.Valid,\n        Ready          =>  AxiBus.ReadAddress.Ready,\n        tpd_Clk_Valid  =>  tpd_Clk_ARValid,\n        AlertLogID     =>  BusFailedID,\n        TimeOutMessage =>  \"Read Address # \" & to_string(ReadAddressDoneCount + 1),\n        TimeOutPeriod  =>  ReadAddressReadyTimeOut * tperiod_Clk\n      ) ;\n\n      -- State after operation\n      AR.Addr   <= Local.Addr   + 4  after tpd_Clk_ARAddr   ;\n      AR.Prot   <= Local.Prot   + 1  after tpd_clk_ARProt   ;\n      -- AXI4 Full\n      AR.Len    <= Local.Len    + 1  after tpd_clk_ARLen    ;\n      AR.ID     <= Local.ID     + 1  after tpd_clk_ARID     ;\n      AR.Size   <= Local.Size   + 1  after tpd_clk_ARSize   ;\n      AR.Burst  <= Local.Burst  + 1  after tpd_clk_ARBurst  ;\n      AR.Lock   <= Local.Lock        after tpd_clk_ARLock   ;\n      AR.Cache  <= Local.Cache  + 1  after tpd_clk_ARCache  ;\n      AR.QOS    <= Local.QOS    + 1  after tpd_clk_ARQOS    ;\n      AR.Region <= Local.Region + 1  after tpd_clk_ARRegion ;\n      AR.User   <= Local.User   + 1  after tpd_clk_ARUser   ;\n\n      -- Signal completion\n      Increment(ReadAddressDoneCount) ;\n      wait for 0 ns;\n    end loop AddressReadLoop ;\n  end process ReadAddressHandler ;\n\n\n  ------------------------------------------------------------\n  --  ReadDataHandler\n  --    Receive Read Data Transactions\n  ------------------------------------------------------------\n  ReadDataHandler : process\n    variable ReadDataReadyBeforeValid : boolean ;\n    variable ReadDataReadyDelayCycles : integer ;\n    variable ReadDataValidTimeOut     : integer ;\n  begin\n    AxiBus.ReadData.Ready <= '0' ;\n    WaitForClock(Clk, 2) ;  -- Initialize\n\n    ReadDataOperation : loop\n      -- Find Expected Transaction\n      ReadDataActive <= FALSE ;\n      if ReadDataReceiveCount >= ReadDataExpectCount then\n        WaitForToggle(ReadDataExpectCount) ;\n      end if ;\n      ReadDataActive <= TRUE ;\n\n      GetAxi4Parameter(Params, READ_DATA_READY_BEFORE_VALID, ReadDataReadyBeforeValid) ;\n      GetAxi4Parameter(Params, READ_DATA_READY_DELAY_CYCLES, ReadDataReadyDelayCycles) ;\n      GetAxi4Parameter(Params, READ_DATA_VALID_TIME_OUT,     ReadDataValidTimeOut) ;\n\n      ---------------------\n      DoAxiReadyHandshake (\n      ---------------------\n        Clk                     => Clk,\n        Valid                   => AxiBus.ReadData.Valid,\n        Ready                   => AxiBus.ReadData.Ready,\n        ReadyBeforeValid        => ReadDataReadyBeforeValid,\n        ReadyDelayCycles        => ReadDataReadyDelayCycles * tperiod_Clk,\n        tpd_Clk_Ready           => tpd_Clk_RReady,\n        AlertLogID              => BusFailedID,\n        TimeOutMessage          => \"Read Data # \" & to_string(ReadDataReceiveCount + 1),\n        TimeOutPeriod           => ReadDataValidTimeOut * tperiod_Clk\n      ) ;\n\n      -- capture data\n      push(ReadDataFifo, AxiBus.ReadData.Data) ;\n      Check(ReadResponseScoreboard, AxiBus.ReadData.Resp) ;\n\n      increment(ReadDataReceiveCount) ;\n      wait for 0 ns ; -- Allow ReadDataReceiveCount to update\n    end loop ReadDataOperation ;\n  end process ReadDataHandler ;\n\n  ------------------------------------------------------------\n  --  ReadDataProtocolChecker\n  --    Receive Read Data Transactions\n  ------------------------------------------------------------\n  ReadDataProtocolChecker : process\n  begin\n    wait on Clk until Clk = '1' and AxiBus.ReadData.Valid = '1' ;\n    AlertIf(ProtocolID, not ReadDataActive,\n      \"Unexpected Read Data Cycle. \" &\n      \" RValid: \" & to_string (AxiBus.ReadData.Valid) &\n      \" RData: \"  & to_hxstring(AxiBus.ReadData.Data) &\n      \" RResp: \"  & to_string (AxiBus.ReadData.Resp) &\n      \"  Operation# \" & to_string(ReadDataReceiveCount + 1),\n      FAILURE\n    ) ;\n  end process ReadDataProtocolChecker ;\nend architecture AxiFull ;\n","lang":"vhdl"};
processSrcData(g_data);