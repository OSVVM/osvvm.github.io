var g_data = {"name":"C:/SynthWorks/Dev/_osvvm/OsvvmLibraries/DpRam/src/DpRamController_Blocking.vhd","src":"--\n--  File Name:         DpRamController.vhd\n--  Design Unit Name:  DpRamController\n--  Revision:          OSVVM MODELS STANDARD VERSION\n--\n--  Maintainer:        Jim Lewis      email:  jim@synthworks.com\n--  Contributor(s):\n--     Jim Lewis      jim@synthworks.com\n--\n--\n--  Description:\n--      DpRam manager verification component\n--\n--\n--  Developed by:\n--        SynthWorks Design Inc.\n--        VHDL Training Classes\n--        http://www.SynthWorks.com\n--\n--  Revision History:\n--    Date      Version    Description\n--    03/2022   2022.03    Initial revision\n--\n--\n--  This file is part of OSVVM.\n--\n--  Copyright (c) 2022 by SynthWorks Design Inc.\n--\n--  Licensed under the Apache License, Version 2.0 (the \"License\");\n--  you may not use this file except in compliance with the License.\n--  You may obtain a copy of the License at\n--\n--      https://www.apache.org/licenses/LICENSE-2.0\n--\n--  Unless required by applicable law or agreed to in writing, software\n--  distributed under the License is distributed on an \"AS IS\" BASIS,\n--  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n--  See the License for the specific language governing permissions and\n--  limitations under the License.\n--\nlibrary ieee ;\n  use ieee.std_logic_1164.all ;\n  use ieee.numeric_std.all ;\n  use ieee.numeric_std_unsigned.all ;\n  use ieee.math_real.all ;\n\nlibrary osvvm ;\n  context osvvm.OsvvmContext ;\n  use osvvm.ScoreboardPkg_slv.all ;\n\nlibrary osvvm_common ;\n  context osvvm_common.OsvvmCommonContext ;\n\nentity DpRamController is\ngeneric (\n  MODEL_ID_NAME    : string := \"\" ;\n  tperiod_Clk      : time   := 10 ns ;\n  \n  DEFAULT_DELAY    : time   := 1 ns ; \n\n  tpd_Clk_Address  : time   := DEFAULT_DELAY ;\n  tpd_Clk_Write    : time   := DEFAULT_DELAY ;\n  tpd_Clk_oData    : time   := DEFAULT_DELAY \n) ;\nport (\n  -- Globals\n  Clk         : In   std_logic ;\n  nReset      : In   std_logic ;\n\n  -- DpRam Functional Interface\n  Address     : Out  std_logic_vector ;\n  Write       : Out std_logic ;\n  oData       : Out std_logic_vector ;\n  iData       : In  std_logic_vector ;\n\n  -- Testbench Transaction Interface\n  TransRec    : InOut AddressBusRecType \n) ;\n\n  -- Derive ModelInstance label from path_name\n  constant MODEL_INSTANCE_NAME : string :=\n    -- use MODEL_ID_NAME Generic if set, otherwise use instance label (preferred if set as entityname_1)\n    IfElse(MODEL_ID_NAME /= \"\", MODEL_ID_NAME, to_lower(PathTail(DpRamController'PATH_NAME))) ;\n\nend entity DpRamController ;\narchitecture SimpleBlocking of DpRamController is\n  signal ModelID : AlertLogIDType ;\n\nbegin\n\n  ------------------------------------------------------------\n  --  Initialize alerts\n  ------------------------------------------------------------\n  Initialize : process\n    variable ID : AlertLogIDType ;\n  begin\n    -- Alerts\n    ID        := NewID(MODEL_INSTANCE_NAME) ;\n    ModelID   <= ID ;\n    wait ;\n  end process Initialize ;\n\n\n  ------------------------------------------------------------\n  --  Transaction Handler\n  --    Decodes Transactions and Handlers DUT Interface\n  ------------------------------------------------------------\n  TransactionHandler : process\n    alias Operation : AddressBusOperationType is TransRec.Operation ;\n    variable ExpectedData : iData'subtype ; \n  begin\n    -- Initialize Outputs\n    Address     <= (Address'range  => 'X') ; \n    Write       <= 'X' ; \n    oData       <= (oData'range => 'X') ; \n    \n    wait for 0 ns ; \n    \n    loop\n      WaitForTransaction(\n         Clk      => Clk,\n         Rdy      => TransRec.Rdy,\n         Ack      => TransRec.Ack\n      ) ;\n      \n--** see alias      Operation := TransRec.Operation ; \n      \n      case Operation is\n        -- Execute Standard Directive Transactions\n        when WAIT_FOR_TRANSACTION =>\n          wait for 0 ns ; \n\n        when WAIT_FOR_CLOCK =>\n          WaitForClock(Clk, TransRec.IntToModel) ;\n\n        when GET_ALERTLOG_ID =>\n          TransRec.IntFromModel <= integer(ModelID) ;\n\n        -- Model Transaction Dispatch\n        when WRITE_OP =>\n          Address <= SafeResize(TransRec.Address, Address'length)    after tpd_Clk_Address ;\n          oData   <= SafeResize(TransRec.DataToModel, oData'length)  after tpd_Clk_oData ;\n          Write   <= '1' after tpd_Clk_Write ; \n          WaitForClock(Clk) ; \n          \n          -- Write Operation Accepted at this clock edge\n          Log( ModelID,\n            \"Write Operation, Address: \" & to_hxstring(Address) &\n            \"  Data: \" & to_hxstring(oData) &\n            \"  Operation# \" & to_string (TransRec.Rdy),\n            INFO,\n            TransRec.StatusMsgOn\n          ) ;\n          Address <= not Address after tpd_Clk_Address ;\n          oData   <= not oData    after tpd_Clk_oData ;\n          Write   <= '0' after tpd_Clk_Write ; \n          \n        when READ_OP | READ_CHECK =>\n          Address <= SafeResize(TransRec.Address, Address'length)      after tpd_Clk_Address ;\n          Write   <= '0' after tpd_Clk_Write ; \n          WaitForClock(Clk) ; \n          \n          Address <= not Address after tpd_Clk_Address ;\n          WaitForClock(Clk) ; \n\n--! TODO: Add settings for read taking another clock          \n--          if ... then \n--            WaitForClock(Clk) ; \n--          end if ; \n          \n          TransRec.DataFromModel <= SafeResize(iData, TransRec.DataFromModel'length) ;\n\n          if IsReadCheck(Operation) then\n            ExpectedData  := SafeResize(TransRec.DataToModel, ExpectedData'length) ;\n            AffirmIfEqual(ModelID,\n              iData, ExpectedData,\n              \"Read Operation, Address: \" & to_hxstring(Address) &\n              \"  Operation# \" & to_string (TransRec.Rdy) & \n              \"  Data: \", \n              TransRec.StatusMsgOn or IsLogEnabled(ModelID, INFO)\n            ) ;\n          else\n            Log( ModelID,\n              \"Read Operation, Address: \" & to_hxstring(Address) &\n              \"  Data: \" & to_hxstring(iData) &\n              \"  Operation# \" & to_string (TransRec.Rdy),\n              INFO,\n              TransRec.StatusMsgOn\n            ) ;\n          end if ; \n          \n        when WRITE_AND_READ =>\n          Address <= SafeResize(TransRec.Address, Address'length)    after tpd_Clk_Address ;\n          oData   <= SafeResize(TransRec.DataToModel, oData'length)  after tpd_Clk_oData ;\n          Write   <= '1' after tpd_Clk_Write ; \n          \n          WaitForClock(Clk) ; \n          Log( ModelID,\n            \"Write Operation, Address: \" & to_hxstring(Address) &\n            \"  Data: \" & to_hxstring(oData) &\n            \"  Operation# \" & to_string (TransRec.Rdy),\n            INFO,\n            TransRec.StatusMsgOn\n          ) ;\n          Address <= not Address after tpd_Clk_Address ;\n          oData   <= not oData    after tpd_Clk_oData ;\n          Write   <= '0' after tpd_Clk_Write ; \n        \n          WaitForClock(Clk) ; \n--! TODO: Add settings for read taking another clock          \n--          if ... then \n--            WaitForClock(Clk) ; \n--          end if ; \n          \n          TransRec.DataFromModel <= SafeResize(iData, TransRec.DataFromModel'length) ;\n          \n          if IsReadCheck(Operation) then\n            ExpectedData  := SafeResize(TransRec.DataToModel, ExpectedData'length) ;\n            AffirmIfEqual(ModelID,\n              iData, ExpectedData,\n              \"Read Operation, Address: \" & to_hxstring(Address) &\n              \"  Operation# \" & to_string (TransRec.Rdy) & \n              \"  Data: \", \n              TransRec.StatusMsgOn or IsLogEnabled(ModelID, INFO)\n            ) ;\n          else\n            Log( ModelID,\n              \"Read Operation, Address: \" & to_hxstring(Address) &\n              \"  Data: \" & to_hxstring(iData) &\n              \"  Operation# \" & to_string (TransRec.Rdy),\n              INFO,\n              TransRec.StatusMsgOn\n            ) ;\n          end if ; \n          \n        when MULTIPLE_DRIVER_DETECT =>\n          Alert(ModelID, \"Multiple Drivers on Transaction Record.\" & \n                         \"  Transaction # \" & to_string(TransRec.Rdy), FAILURE) ;\n\n        when others =>\n          Alert(ModelID, \"Unimplemented Transaction: \" & to_string(Operation), FAILURE) ;\n\n      end case ;\n    end loop ;\n  end process TransactionHandler ;\n\n\nend architecture SimpleBlocking ;\n","lang":"vhdl"};
processSrcData(g_data);