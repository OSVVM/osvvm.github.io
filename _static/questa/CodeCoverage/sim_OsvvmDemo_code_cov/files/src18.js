var g_data = {"name":"C:/SynthWorks/Dev/_osvvm/OsvvmLibraries/osvvm/ScoreboardGenericPkg.vhd","src":"--\n--  File Name:         ScoreBoardGenericPkg.vhd\n--  Design Unit Name:  ScoreBoardGenericPkg\n--  Revision:          STANDARD VERSION\n--\n--  Maintainer:        Jim Lewis      email:  jim@synthworks.com\n--  Contributor(s):\n--     Jim Lewis          email:  jim@synthworks.com\n--\n--\n--  Description:\n--    Defines types and methods to implement a FIFO based Scoreboard\n--    Defines type ScoreBoardPType\n--    Defines methods for putting values the scoreboard\n--\n--  Developed for:\n--        SynthWorks Design Inc.\n--        VHDL Training Classes\n--        11898 SW 128th Ave.  Tigard, Or  97223\n--        http://www.SynthWorks.com\n--\n--  Revision History:\n--    Date      Version    Description\n--    02/2023   2023.02    Bug fix for Peek with a tag.\n--    01/2023   2023.01    OSVVM_OUTPUT_DIRECTORY replaced REPORTS_DIRECTORY \n--    11/2022   2022.11    Updated default search to PRIVATE_NAME\n--    10/2022   2022.10    Added Parent Name to YAML output.\n--    09/2022   2022.09    Added FifoCount to YAML output.\n--    03/2022   2022.03    Removed deprecated SetAlertLogID in Singleton API\n--    02/2022   2022.02    Added WriteScoreboardYaml and GotScoreboards.  Updated NewID with ParentID,\n--                         ReportMode, Search, PrintParent.   Supports searching for Scoreboard models..\n--    01/2022   2022.01    Added CheckExpected.  Added SetCheckCountZero to ScoreboardPType\n--    08/2021   2021.08    Removed SetAlertLogID from singleton public interface - set instead by NewID\n--    06/2021   2021.06    Updated Data Structure, IDs for new use model, and Wrapper Subprograms\n--    10/2020   2020.10    Added Peek\n--    05/2020   2020.05    Updated calls to IncAffirmCount\n--                         Overloaded Check with functions that return pass/fail (T/F)\n--                         Added GetFifoCount.   Added GetPushCount which is same as GetItemCount\n--    01/2020   2020.01    Updated Licenses to Apache\n--    04/2018   2018.04    Made Pop Functions Visible.   Prep for AlertLogIDType being a type.\n--    05/2017   2017.05    First print Actual then only print Expected if mis-match\n--    11/2016   2016.11    Released as part of OSVVM\n--    06/2015   2015.06    Added Alerts, SetAlertLogID, Revised LocalPush, GetDropCount,\n--                         Deprecated SetFinish and ReportMode - REPORT_NONE, FileOpen\n--                         Deallocate, Initialized, Function SetName\n--    09/2013   2013.09    Added file handling, Check Count, Finish Status\n--                         Find, Flush\n--    08/2013   2013.08    Generics:  to_string replaced write, Match replaced check\n--                         Added Tags - Experimental\n--                         Added Array of Scoreboards\n--    08/2012   2012.08    Added Type and Subprogram Generics\n--    05/2012   2012.05    Changed FIFO to store pointers to ExpectedType\n--                         Allows usage of unconstrained arrays\n--    08/2010   2010.08    Added Tailpointer\n--    12/2006   2006.12    Initial revision\n--\n--\n--\n--  This file is part of OSVVM.\n--\n--  Copyright (c) 2006 - 2023 by SynthWorks Design Inc.\n--\n--  Licensed under the Apache License, Version 2.0 (the \"License\");\n--  you may not use this file except in compliance with the License.\n--  You may obtain a copy of the License at\n--\n--      https://www.apache.org/licenses/LICENSE-2.0\n--\n--  Unless required by applicable law or agreed to in writing, software\n--  distributed under the License is distributed on an \"AS IS\" BASIS,\n--  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n--  See the License for the specific language governing permissions and\n--  limitations under the License.\n--\n\n\nuse std.textio.all ;\n\nlibrary ieee ;\n  use ieee.std_logic_1164.all ;\n  use ieee.numeric_std.all ;\n\n  use work.OsvvmScriptSettingsPkg.all ;\n  use work.TranscriptPkg.all ;\n  use work.TextUtilPkg.all ;\n  use work.AlertLogPkg.all ;\n  use work.NamePkg.all ;\n  use work.NameStorePkg.all ;\n  use work.ResolutionPkg.all ;\n\n\npackage ScoreboardGenericPkg is\n  generic (\n    type ExpectedType ;\n    type ActualType ;\n    function Match(Actual : ActualType ;                           -- defaults\n                   Expected : ExpectedType) return boolean ;       -- is \"=\" ;\n    function expected_to_string(A : ExpectedType) return string ;  -- is to_string ;\n    function actual_to_string  (A : ActualType) return string      -- is to_string ;\n  ) ;\n\n--   --  For a VHDL-2002 package, comment out the generics and\n--   --  uncomment the following, it replaces a generic instance of the package.\n--   --  As a result, you will have multiple copies of the entire package.\n--   --  Inconvenient, but ok as it still works the same.\n--   subtype ExpectedType is std_logic_vector ;\n--   subtype ActualType   is std_logic_vector ;\n--   alias Match is std_match [ActualType, ExpectedType return boolean] ;  -- for std_logic_vector\n--   alias expected_to_string is to_hstring [ExpectedType return string];  -- VHDL-2008\n--   alias actual_to_string is to_hstring [ActualType return string];  -- VHDL-2008\n\n  -- ScoreboardReportType is deprecated\n  -- Replaced by Affirmations.  ERROR is the default.  ALL turns on PASSED flag\n  type ScoreboardReportType is (REPORT_ERROR, REPORT_ALL, REPORT_NONE) ;   -- replaced by affirmations\n\n  type ScoreboardIdType is record\n    Id : integer_max ;\n  end record ScoreboardIdType ;\n  type ScoreboardIdArrayType  is array (integer range <>) of ScoreboardIdType ;\n  type ScoreboardIdMatrixType is array (integer range <>, integer range <>) of ScoreboardIdType ;\n\n  -- Preparation for refactoring - if that ever happens.\n  subtype FifoIdType       is ScoreboardIdType ;\n  subtype FifoIdArrayType  is ScoreboardIdArrayType ;\n  subtype FifoIdMatrixType is ScoreboardIdMatrixType ;\n\n  ------------------------------------------------------------\n  -- Used by Scoreboard Store\n  impure function NewID (\n    Name          : String ;\n    ParentID      : AlertLogIDType          := OSVVM_SCOREBOARD_ALERTLOG_ID ;\n    ReportMode    : AlertLogReportModeType  := ENABLED ;\n    Search        : NameSearchType          := PRIVATE_NAME ;\n    PrintParent   : AlertLogPrintParentType := PRINT_NAME_AND_PARENT\n  ) return ScoreboardIDType ;\n\n  ------------------------------------------------------------\n  -- Vector: 1 to Size\n  impure function NewID (\n    Name          : String ;\n    Size          : positive ;\n    ParentID      : AlertLogIDType          := OSVVM_SCOREBOARD_ALERTLOG_ID ;\n    ReportMode    : AlertLogReportModeType  := ENABLED ;\n    Search        : NameSearchType          := PRIVATE_NAME ;\n    PrintParent   : AlertLogPrintParentType := PRINT_NAME_AND_PARENT\n  ) return ScoreboardIDArrayType ;\n\n  ------------------------------------------------------------\n  -- Vector: X(X'Left) to X(X'Right)\n  impure function NewID (\n    Name          : String ;\n    X             : integer_vector ;\n    ParentID      : AlertLogIDType          := OSVVM_SCOREBOARD_ALERTLOG_ID ;\n    ReportMode    : AlertLogReportModeType  := ENABLED ;\n    Search        : NameSearchType          := PRIVATE_NAME ;\n    PrintParent   : AlertLogPrintParentType := PRINT_NAME_AND_PARENT\n  ) return ScoreboardIDArrayType ;\n\n  ------------------------------------------------------------\n  -- Matrix: 1 to X, 1 to Y\n  impure function NewID (\n    Name          : String ;\n    X, Y          : positive ;\n    ParentID      : AlertLogIDType          := OSVVM_SCOREBOARD_ALERTLOG_ID ;\n    ReportMode    : AlertLogReportModeType  := ENABLED ;\n    Search        : NameSearchType          := PRIVATE_NAME ;\n    PrintParent   : AlertLogPrintParentType := PRINT_NAME_AND_PARENT\n  ) return ScoreboardIdMatrixType ;\n\n  ------------------------------------------------------------\n  -- Matrix: X(X'Left) to X(X'Right), Y(Y'Left) to Y(Y'Right)\n  impure function NewID (\n    Name          : String ;\n    X, Y          : integer_vector ;\n    ParentID      : AlertLogIDType          := OSVVM_SCOREBOARD_ALERTLOG_ID ;\n    ReportMode    : AlertLogReportModeType  := ENABLED ;\n    Search        : NameSearchType          := PRIVATE_NAME ;\n    PrintParent   : AlertLogPrintParentType := PRINT_NAME_AND_PARENT\n  ) return ScoreboardIdMatrixType ;\n\n  ------------------------------------------------------------\n  -- Push items into the scoreboard/FIFO\n\n  -- Simple Scoreboard, no tag\n  procedure Push (\n    constant ID     : in  ScoreboardIDType ;\n    constant Item   : in  ExpectedType\n  ) ;\n\n  -- Simple Tagged Scoreboard\n  procedure Push (\n    constant ID     : in  ScoreboardIDType ;\n    constant Tag    : in  string ;\n    constant Item   : in  ExpectedType\n  ) ;\n\n  ------------------------------------------------------------\n  -- Check received item with item in the scoreboard/FIFO\n\n  -- Simple Scoreboard, no tag\n  procedure Check (\n    constant ID           : in  ScoreboardIDType ;\n    constant ActualData   : in ActualType\n  ) ;\n\n  -- Simple Tagged Scoreboard\n  procedure Check (\n    constant ID           : in  ScoreboardIDType ;\n    constant Tag          : in  string ;\n    constant ActualData   : in  ActualType\n  ) ;\n\n  -- Simple Scoreboard, no tag\n  impure function Check (\n    constant ID           : in  ScoreboardIDType ;\n    constant ActualData   : in ActualType\n  ) return boolean ;\n\n  -- Simple Tagged Scoreboard\n  impure function Check (\n    constant ID           : in  ScoreboardIDType ;\n    constant Tag          : in  string ;\n    constant ActualData   : in  ActualType\n  ) return boolean ;\n\n  ----------------------------------------------\n  -- Simple Scoreboard, no tag\n  procedure CheckExpected (\n    constant ID           : in  ScoreboardIDType ;\n    constant ExpectedData : in  ActualType\n  ) ;\n\n  -- Simple Tagged Scoreboard\n  procedure CheckExpected (\n    constant ID           : in  ScoreboardIDType ;\n    constant Tag          : in  string ;\n    constant ExpectedData : in  ActualType\n  ) ;\n\n  -- Simple Scoreboard, no tag\n  impure function CheckExpected (\n    constant ID           : in  ScoreboardIDType ;\n    constant ExpectedData : in  ActualType\n  ) return boolean ;\n\n  -- Simple Tagged Scoreboard\n  impure function CheckExpected (\n    constant ID           : in  ScoreboardIDType ;\n    constant Tag          : in  string ;\n    constant ExpectedData : in  ActualType\n  ) return boolean ;\n\n\n\n  ------------------------------------------------------------\n  -- Pop the top item (FIFO) from the scoreboard/FIFO\n\n  -- Simple Scoreboard, no tag\n  procedure Pop (\n    constant ID     : in  ScoreboardIDType ;\n    variable Item   : out  ExpectedType\n  ) ;\n\n  -- Simple Tagged Scoreboard\n  procedure Pop (\n    constant ID     : in  ScoreboardIDType ;\n    constant Tag    : in  string ;\n    variable Item   : out  ExpectedType\n  ) ;\n\n\n  ------------------------------------------------------------\n  -- Pop the top item (FIFO) from the scoreboard/FIFO\n  -- Caution:  this did not work in older simulators (@2013)\n\n  -- Simple Scoreboard, no tag\n  impure function Pop (\n    constant ID     : in  ScoreboardIDType\n  ) return ExpectedType ;\n\n  -- Simple Tagged Scoreboard\n  impure function Pop (\n    constant ID     : in  ScoreboardIDType ;\n    constant Tag    : in  string\n  ) return ExpectedType ;\n\n\n  ------------------------------------------------------------\n  -- Peek at the top item (FIFO) from the scoreboard/FIFO\n\n  -- Simple Tagged Scoreboard\n  procedure Peek (\n    constant ID     : in  ScoreboardIDType ;\n    constant Tag    : in  string ;\n    variable Item   : out ExpectedType\n  ) ;\n\n  -- Simple Scoreboard, no tag\n  procedure Peek (\n    constant ID     : in  ScoreboardIDType ;\n    variable Item   : out  ExpectedType\n  ) ;\n\n  ------------------------------------------------------------\n  -- Peek at the top item (FIFO) from the scoreboard/FIFO\n  -- Caution:  this did not work in older simulators (@2013)\n\n  -- Tagged Scoreboards\n  impure function Peek (\n    constant ID     : in  ScoreboardIDType ;\n    constant Tag    : in  string\n  ) return ExpectedType ;\n\n  -- Simple Scoreboard\n  impure function Peek (\n    constant ID     : in  ScoreboardIDType\n  ) return ExpectedType ;\n\n  ------------------------------------------------------------\n  -- Empty - check to see if scoreboard is empty\n  -- Simple\n  impure function ScoreboardEmpty (\n    constant ID     : in  ScoreboardIDType\n  ) return boolean ;\n  -- Tagged\n  impure function ScoreboardEmpty (\n    constant ID     : in  ScoreboardIDType ;\n    constant Tag    : in  string\n  ) return boolean ;                    -- Simple, Tagged\n\n  impure function Empty (\n    constant ID     : in  ScoreboardIDType\n  ) return boolean ;\n  -- Tagged\n  impure function Empty (\n    constant ID     : in  ScoreboardIDType ;\n    constant Tag    : in  string\n  ) return boolean ;                    -- Simple, Tagged\n\n--!!  ------------------------------------------------------------\n--!!  -- SetAlertLogID - associate an AlertLogID with a scoreboard to allow integrated error reporting\n--!!  procedure SetAlertLogID(\n--!!    constant ID              : in  ScoreboardIDType ;\n--!!    constant Name            : in  string ;\n--!!    constant ParentID        : in  AlertLogIDType := OSVVM_SCOREBOARD_ALERTLOG_ID ;\n--!!    constant CreateHierarchy : in  Boolean := TRUE ;\n--!!    constant DoNotReport     : in  Boolean := FALSE\n--!!  ) ;\n--!!\n--!!  -- Use when an AlertLogID is used by multiple items (Model or other Scoreboards).  See also AlertLogPkg.GetAlertLogID\n--!!  procedure SetAlertLogID (\n--!!    constant ID     : in  ScoreboardIDType ;\n--!!    constant A      : AlertLogIDType\n--!!  ) ;\n\n  impure function GetAlertLogID (\n    constant ID     : in  ScoreboardIDType\n  ) return AlertLogIDType ;\n\n\n  ------------------------------------------------------------\n  -- Scoreboard Introspection\n\n  -- Number of items put into scoreboard\n  impure function GetItemCount (\n    constant ID     : in  ScoreboardIDType\n  ) return integer ;   -- Simple, with or without tags\n\n  impure function GetPushCount (\n    constant ID     : in  ScoreboardIDType\n  ) return integer ;   -- Simple, with or without tags\n\n  -- Number of items removed from scoreboard by pop or check\n  impure function GetPopCount (\n    constant ID     : in  ScoreboardIDType\n  ) return integer ;\n\n  -- Number of items currently in the scoreboard (= PushCount - PopCount - DropCount)\n  impure function GetFifoCount (\n    constant ID     : in  ScoreboardIDType\n  ) return integer ;\n\n  -- Number of items checked by scoreboard\n  impure function GetCheckCount (\n    constant ID     : in  ScoreboardIDType\n  ) return integer ;  -- Simple, with or without tags\n\n  -- Number of items dropped by scoreboard.  See Find/Flush\n  impure function GetDropCount (\n    constant ID     : in  ScoreboardIDType\n  ) return integer ;   -- Simple, with or without tags\n\n  ------------------------------------------------------------\n  -- Find - Returns the ItemNumber for a value and tag (if applicable) in a scoreboard.\n  -- Find returns integer'left if no match found\n  -- Also See Flush.  Flush will drop items up through the ItemNumber\n\n  -- Simple Scoreboard\n  impure function Find (\n    constant ID          : in  ScoreboardIDType ;\n    constant ActualData  :  in  ActualType\n  ) return integer ;\n\n  -- Tagged Scoreboard\n  impure function Find (\n    constant ID          : in  ScoreboardIDType ;\n    constant Tag         :  in  string;\n    constant ActualData  :  in  ActualType\n  ) return integer ;\n\n  ------------------------------------------------------------\n  -- Flush - Remove elements in the scoreboard upto and including the one with ItemNumber\n  -- See Find to identify an ItemNumber of a particular value and tag (if applicable)\n\n  -- Simple Scoreboards\n  procedure Flush (\n    constant ID          : in  ScoreboardIDType ;\n    constant ItemNumber  :  in  integer\n  ) ;\n\n  -- Tagged Scoreboards - only removes items that also match the tag\n  procedure Flush (\n    constant ID          : in  ScoreboardIDType ;\n    constant Tag         :  in  string ;\n    constant ItemNumber  :  in  integer\n  ) ;\n\n  ------------------------------------------------------------\n  -- Writing YAML Reports\n  impure function GotScoreboards return boolean ;\n  procedure WriteScoreboardYaml (FileName : string := \"\"; OpenKind : File_Open_Kind := WRITE_MODE) ;\n\n  ------------------------------------------------------------\n  -- Generally these are not required.  When a simulation ends and\n  -- another simulation is started, a simulator will release all allocated items.\n  procedure Deallocate (\n    constant ID     : in  ScoreboardIDType\n  ) ;  -- Deletes all allocated items\n  procedure Initialize (\n    constant ID     : in  ScoreboardIDType\n  ) ;  -- Creates initial data structure if it was destroyed with Deallocate\n\n  ------------------------------------------------------------\n  -- Get error count\n  -- Deprecated, replaced by usage of Alerts\n  -- AlertFLow:      Instead use AlertLogPkg.ReportAlerts or AlertLogPkg.GetAlertCount\n  -- Not AlertFlow:  use GetErrorCount to get total error count\n\n  -- Scoreboards, with or without tag\n  impure function GetErrorCount(\n    constant ID     : in  ScoreboardIDType\n  ) return integer ;\n\n  ------------------------------------------------------------\n  procedure CheckFinish (\n  ------------------------------------------------------------\n    ID                 : ScoreboardIDType ;\n    FinishCheckCount   : integer ;\n    FinishEmpty        : boolean\n  ) ;\n\n  ------------------------------------------------------------\n  -- SetReportMode\n  -- Not AlertFlow\n  --     REPORT_ALL:     Replaced by AlertLogPkg.SetLogEnable(PASSED, TRUE)\n  --     REPORT_ERROR:   Replaced by AlertLogPkg.SetLogEnable(PASSED, FALSE)\n  --     REPORT_NONE:    Deprecated, do not use.\n  -- AlertFlow:\n  --     REPORT_ALL:     Replaced by AlertLogPkg.SetLogEnable(AlertLogID, PASSED, TRUE)\n  --     REPORT_ERROR:   Replaced by AlertLogPkg.SetLogEnable(AlertLogID, PASSED, FALSE)\n  --     REPORT_NONE:    Replaced by AlertLogPkg.SetAlertEnable(AlertLogID, ERROR, FALSE)\n  procedure SetReportMode (\n    constant ID           : in  ScoreboardIDType ;\n    constant ReportModeIn : in  ScoreboardReportType\n  ) ;\n  impure function GetReportMode (\n    constant ID           : in  ScoreboardIDType\n    ) return ScoreboardReportType ;\n\n  type ScoreBoardPType is protected\n\n    ------------------------------------------------------------\n    -- Used by Scoreboard Store\n    impure function NewID (\n      Name          : String ;\n      ParentID      : AlertLogIDType          := OSVVM_SCOREBOARD_ALERTLOG_ID ;\n      ReportMode    : AlertLogReportModeType  := ENABLED ;\n      Search        : NameSearchType          := PRIVATE_NAME ;\n      PrintParent   : AlertLogPrintParentType := PRINT_NAME_AND_PARENT\n    ) return ScoreboardIDType ;\n\n    ------------------------------------------------------------\n    -- Vector: 1 to Size\n    impure function NewID (\n      Name          : String ;\n      Size          : positive ;\n      ParentID      : AlertLogIDType          := OSVVM_SCOREBOARD_ALERTLOG_ID ;\n      ReportMode    : AlertLogReportModeType  := ENABLED ;\n      Search        : NameSearchType          := PRIVATE_NAME ;\n      PrintParent   : AlertLogPrintParentType := PRINT_NAME_AND_PARENT\n    ) return ScoreboardIDArrayType ;\n\n    ------------------------------------------------------------\n    -- Vector: X(X'Left) to X(X'Right)\n    impure function NewID (\n      Name          : String ;\n      X             : integer_vector ;\n      ParentID      : AlertLogIDType          := OSVVM_SCOREBOARD_ALERTLOG_ID ;\n      ReportMode    : AlertLogReportModeType  := ENABLED ;\n      Search        : NameSearchType          := PRIVATE_NAME ;\n      PrintParent   : AlertLogPrintParentType := PRINT_NAME_AND_PARENT\n    ) return ScoreboardIDArrayType ;\n\n    ------------------------------------------------------------\n    -- Matrix: 1 to X, 1 to Y\n    impure function NewID (\n      Name          : String ;\n      X, Y          : positive ;\n      ParentID      : AlertLogIDType          := OSVVM_SCOREBOARD_ALERTLOG_ID ;\n      ReportMode    : AlertLogReportModeType  := ENABLED ;\n      Search        : NameSearchType          := PRIVATE_NAME ;\n      PrintParent   : AlertLogPrintParentType := PRINT_NAME_AND_PARENT\n    ) return ScoreboardIdMatrixType ;\n\n    ------------------------------------------------------------\n    -- Matrix: X(X'Left) to X(X'Right), Y(Y'Left) to Y(Y'Right)\n    impure function NewID (\n      Name          : String ;\n      X, Y          : integer_vector ;\n      ParentID      : AlertLogIDType          := OSVVM_SCOREBOARD_ALERTLOG_ID ;\n      ReportMode    : AlertLogReportModeType  := ENABLED ;\n      Search        : NameSearchType          := PRIVATE_NAME ;\n      PrintParent   : AlertLogPrintParentType := PRINT_NAME_AND_PARENT\n    ) return ScoreboardIdMatrixType ;\n\n    ------------------------------------------------------------\n    -- Emulate arrays of scoreboards\n    procedure SetArrayIndex(L, R : integer) ;  -- supports integer indices\n    procedure SetArrayIndex(R : natural) ;     -- indicies 1 to R\n    impure function GetArrayIndex return integer_vector ;\n    impure function GetArrayLength return natural ;\n\n    ------------------------------------------------------------\n    -- Push items into the scoreboard/FIFO\n\n    -- Simple Scoreboard, no tag\n    procedure Push (Item   : in  ExpectedType) ;\n\n    -- Simple Tagged Scoreboard\n    procedure Push (\n      constant Tag    : in  string ;\n      constant Item   : in  ExpectedType\n    ) ;\n\n    -- Array of Scoreboards, no tag\n    procedure Push (\n      constant Index  : in  integer ;\n      constant Item   : in  ExpectedType\n    ) ;\n\n    -- Array of Tagged Scoreboards\n    procedure Push (\n      constant Index  : in  integer ;\n      constant Tag    : in  string ;\n      constant Item   : in  ExpectedType\n    ) ;\n\n--    ------------------------------------------------------------\n--    -- Push items into the scoreboard/FIFO\n--    -- Function form supports chaining of operations\n--    -- In 2013, this caused overloading issues in some simulators, will retest later\n--\n--      -- Simple Scoreboard, no tag\n--      impure function Push (Item : ExpectedType) return ExpectedType ;\n--\n--      -- Simple Tagged Scoreboard\n--      impure function Push (\n--        constant Tag    : in  string ;\n--        constant Item   : in  ExpectedType\n--      ) return ExpectedType ;\n--\n--      -- Array of Scoreboards, no tag\n--      impure function Push (\n--        constant Index  : in  integer ;\n--        constant Item   : in  ExpectedType\n--      ) return ExpectedType ;\n--\n--      -- Array of Tagged Scoreboards\n--      impure function Push (\n--        constant Index  : in  integer ;\n--        constant Tag    : in  string ;\n--        constant Item   : in  ExpectedType\n--      ) return ExpectedType ; -- for chaining of operations\n\n    ------------------------------------------------------------\n    -- Check received item with item in the scoreboard/FIFO\n\n    -- Simple Scoreboard, no tag\n    procedure Check (ActualData : ActualType) ;\n\n    -- Simple Tagged Scoreboard\n    procedure Check (\n      constant Tag          : in  string ;\n      constant ActualData   : in  ActualType\n    ) ;\n\n    -- Array of Scoreboards, no tag\n    procedure Check (\n      constant Index        : in  integer ;\n      constant ActualData   : in ActualType\n    ) ;\n\n    -- Array of Tagged Scoreboards\n    procedure Check (\n      constant Index        : in  integer ;\n      constant Tag          : in  string ;\n      constant ActualData   : in  ActualType\n    ) ;\n\n    -- Simple Scoreboard, no tag\n    impure function Check (ActualData : ActualType) return boolean ;\n\n    -- Simple Tagged Scoreboard\n    impure function Check (\n      constant Tag          : in  string ;\n      constant ActualData   : in  ActualType\n    ) return boolean ;\n\n    -- Array of Scoreboards, no tag\n    impure function Check (\n      constant Index        : in  integer ;\n      constant ActualData   : in ActualType\n    ) return boolean ;\n\n    -- Array of Tagged Scoreboards\n    impure function Check (\n      constant Index        : in  integer ;\n      constant Tag          : in  string ;\n      constant ActualData   : in  ActualType\n    ) return boolean ;\n\n    -------------------------------\n    -- Array of Tagged Scoreboards\n    impure function CheckExpected (\n      constant Index        : in  integer ;\n      constant Tag          : in  string ;\n      constant ExpectedData : in  ActualType\n    ) return boolean ;\n\n\n    ------------------------------------------------------------\n    -- Pop the top item (FIFO) from the scoreboard/FIFO\n\n    -- Simple Scoreboard, no tag\n    procedure Pop (variable Item : out  ExpectedType) ;\n\n    -- Simple Tagged Scoreboard\n    procedure Pop (\n      constant Tag    : in  string ;\n      variable Item   : out  ExpectedType\n    ) ;\n\n    -- Array of Scoreboards, no tag\n    procedure Pop (\n      constant Index : in   integer ;\n      variable Item : out  ExpectedType\n    ) ;\n\n    -- Array of Tagged Scoreboards\n    procedure Pop (\n      constant Index  : in  integer ;\n      constant Tag    : in  string ;\n      variable Item   : out  ExpectedType\n    ) ;\n\n    ------------------------------------------------------------\n    -- Pop the top item (FIFO) from the scoreboard/FIFO\n    -- Caution:  this did not work in older simulators (@2013)\n\n      -- Simple Scoreboard, no tag\n      impure function Pop return ExpectedType ;\n\n      -- Simple Tagged Scoreboard\n      impure function Pop (\n        constant Tag : in  string\n      ) return ExpectedType ;\n\n      -- Array of Scoreboards, no tag\n      impure function Pop (Index : integer) return ExpectedType ;\n\n      -- Array of Tagged Scoreboards\n      impure function Pop (\n        constant Index  : in  integer ;\n        constant Tag    : in  string\n      ) return ExpectedType ;\n\n\n    ------------------------------------------------------------\n    -- Peek at the top item (FIFO) from the scoreboard/FIFO\n\n    -- Array of Tagged Scoreboards\n    procedure Peek (\n      constant Index  : in  integer ;\n      constant Tag    : in  string ;\n      variable Item   : out ExpectedType\n    ) ;\n\n    -- Array of Scoreboards, no tag\n    procedure Peek (\n      constant Index  : in  integer ;\n      variable Item   : out  ExpectedType\n    ) ;\n\n    -- Simple Tagged Scoreboard\n    procedure Peek (\n      constant Tag    : in  string ;\n      variable Item   : out  ExpectedType\n    ) ;\n\n    -- Simple Scoreboard, no tag\n    procedure Peek (variable Item : out  ExpectedType) ;\n\n    ------------------------------------------------------------\n    -- Peek at the top item (FIFO) from the scoreboard/FIFO\n    -- Caution:  this did not work in older simulators (@2013)\n\n    -- Array of Tagged Scoreboards\n    impure function Peek (\n      constant Index  : in  integer ;\n      constant Tag    : in  string\n    ) return ExpectedType ;\n\n    -- Array of Scoreboards, no tag\n    impure function Peek (Index : integer) return ExpectedType ;\n\n    -- Simple Tagged Scoreboard\n    impure function Peek (\n      constant Tag : in  string\n    ) return ExpectedType ;\n\n    -- Simple Scoreboard, no tag\n    impure function Peek return ExpectedType ;\n\n    ------------------------------------------------------------\n    -- Empty - check to see if scoreboard is empty\n    impure function Empty return boolean ;                                   -- Simple\n    impure function Empty (Tag : String) return boolean ;                    -- Simple, Tagged\n    impure function Empty (Index  : integer) return boolean ;                -- Array\n    impure function Empty (Index  : integer; Tag : String) return boolean ;  -- Array, Tagged\n\n    ------------------------------------------------------------\n    -- SetAlertLogID - associate an AlertLogID with a scoreboard to allow integrated error reporting\n    -- ReportMode := ENABLED when not DoNotReport else DISABLED ;\n    procedure SetAlertLogID(Index : Integer; Name : string; ParentID : AlertLogIDType := OSVVM_SCOREBOARD_ALERTLOG_ID; CreateHierarchy : Boolean := TRUE; DoNotReport : Boolean := FALSE) ;\n    procedure SetAlertLogID(Name : string; ParentID : AlertLogIDType := OSVVM_SCOREBOARD_ALERTLOG_ID; CreateHierarchy : Boolean := TRUE; DoNotReport : Boolean := FALSE) ;\n    -- Use when an AlertLogID is used by multiple items (Model or other Scoreboards).  See also AlertLogPkg.GetAlertLogID\n    procedure SetAlertLogID (Index : Integer ; A : AlertLogIDType) ;\n    procedure SetAlertLogID (A : AlertLogIDType) ;\n    impure function GetAlertLogID(Index : Integer) return AlertLogIDType ;\n    impure function GetAlertLogID return AlertLogIDType ;\n\n    ------------------------------------------------------------\n    -- Set a scoreboard name.\n    -- Used when scoreboard AlertLogID is shared between different sources.\n    procedure SetName (Name : String) ;\n    impure function SetName (Name : String) return string ;\n    impure function GetName (DefaultName : string := \"Scoreboard\") return string ;\n\n\n    ------------------------------------------------------------\n    -- Scoreboard Introspection\n\n    -- Number of items put into scoreboard\n    impure function GetItemCount return integer ;                      -- Simple, with or without tags\n    impure function GetItemCount (Index  : integer) return integer ;   -- Arrays, with or without tags\n    impure function GetPushCount return integer ;                      -- Simple, with or without tags\n    impure function GetPushCount (Index  : integer) return integer ;   -- Arrays, with or without tags\n\n    -- Number of items removed from scoreboard by pop or check\n    impure function GetPopCount (Index  : integer) return integer ;\n    impure function GetPopCount return integer ;\n\n    -- Number of items currently in the scoreboard (= PushCount - PopCount - DropCount)\n    impure function GetFifoCount (Index  : integer) return integer ;\n    impure function GetFifoCount return integer ;\n\n    -- Number of items checked by scoreboard\n    impure function GetCheckCount return integer ;                     -- Simple, with or without tags\n    impure function GetCheckCount (Index  : integer) return integer ;  -- Arrays, with or without tags\n\n    -- Number of items dropped by scoreboard.  See Find/Flush\n    impure function GetDropCount return integer ;                      -- Simple, with or without tags\n    impure function GetDropCount (Index  : integer) return integer ;   -- Arrays, with or without tags\n\n    ------------------------------------------------------------\n    -- Find - Returns the ItemNumber for a value and tag (if applicable) in a scoreboard.\n    -- Find returns integer'left if no match found\n    -- Also See Flush.  Flush will drop items up through the ItemNumber\n\n    -- Simple Scoreboard\n    impure function Find (\n      constant ActualData  :  in  ActualType\n    ) return integer ;\n\n    -- Tagged Scoreboard\n    impure function Find (\n      constant Tag         :  in  string;\n      constant ActualData  :  in  ActualType\n    ) return integer ;\n\n    -- Array of Simple Scoreboards\n    impure function Find (\n      constant Index       :  in  integer ;\n      constant ActualData  :  in  ActualType\n    ) return integer ;\n\n    -- Array of Tagged Scoreboards\n    impure function Find (\n      constant Index       :  in  integer ;\n      constant Tag         :  in  string;\n      constant ActualData  :  in  ActualType\n    ) return integer ;\n\n    ------------------------------------------------------------\n    -- Flush - Remove elements in the scoreboard upto and including the one with ItemNumber\n    -- See Find to identify an ItemNumber of a particular value and tag (if applicable)\n\n    -- Simple Scoreboard\n    procedure Flush (\n      constant ItemNumber  :  in  integer\n    ) ;\n\n    -- Tagged Scoreboard - only removes items that also match the tag\n    procedure Flush (\n      constant Tag         :  in  string ;\n      constant ItemNumber  :  in  integer\n    ) ;\n\n    -- Array of Simple Scoreboards\n    procedure Flush (\n      constant Index       :  in  integer ;\n      constant ItemNumber  :  in  integer\n    ) ;\n\n    -- Array of Tagged Scoreboards - only removes items that also match the tag\n    procedure Flush (\n      constant Index       :  in  integer ;\n      constant Tag         :  in  string ;\n      constant ItemNumber  :  in  integer\n    ) ;\n\n    ------------------------------------------------------------\n    -- Writing YAML Reports\n    impure function GotScoreboards return boolean ;\n    procedure WriteScoreboardYaml (FileName : string := \"\"; OpenKind : File_Open_Kind := WRITE_MODE) ;\n\n    ------------------------------------------------------------\n    -- Generally these are not required.  When a simulation ends and\n    -- another simulation is started, a simulator will release all allocated items.\n    procedure Deallocate ;  -- Deletes all allocated items\n    procedure Initialize ;  -- Creates initial data structure if it was destroyed with Deallocate\n\n\n    ------------------------------------------------------------\n    ------------------------------------------------------------\n    -- Deprecated.  Use alerts directly instead.\n    -- AlertIF(SB.GetCheckCount < 10, ....) ;\n    -- AlertIf(Not SB.Empty, ...) ;\n    ------------------------------------------------------------\n    -- Set alerts if scoreboard not empty or if CheckCount <\n    -- Use if need to check empty or CheckCount for a specific scoreboard.\n\n    -- Simple Scoreboards, with or without tag\n    procedure CheckFinish (\n      FinishCheckCount   : integer ;\n      FinishEmpty        : boolean\n    ) ;\n\n    -- Array of Scoreboards, with or without tag\n    procedure CheckFinish (\n      Index              : integer ;\n      FinishCheckCount   : integer ;\n      FinishEmpty        : boolean\n    ) ;\n\n    ------------------------------------------------------------\n    -- Get error count\n    -- Deprecated, replaced by usage of Alerts\n    -- AlertFLow:      Instead use AlertLogPkg.ReportAlerts or AlertLogPkg.GetAlertCount\n    -- Not AlertFlow:  use GetErrorCount to get total error count\n\n    -- Simple Scoreboards, with or without tag\n    impure function GetErrorCount return integer ;\n\n    -- Array of Scoreboards, with or without tag\n    impure function GetErrorCount(Index : integer) return integer ;\n\n    ------------------------------------------------------------\n    -- Error count manipulation\n\n    -- IncErrorCount - not recommended, use alerts instead - may be deprecated in the future\n    procedure IncErrorCount ;                          -- Simple, with or without tags\n    procedure IncErrorCount (Index  : integer) ;       -- Arrays, with or without tags\n\n    -- Clear error counter.  Caution does not change AlertCounts, must also use AlertLogPkg.ClearAlerts\n    procedure SetErrorCountZero ;                      -- Simple, with or without tags\n    procedure SetErrorCountZero (Index  : integer) ;   -- Arrays, with or without tags\n    -- Clear check counter. Caution does not change AffirmationCounters\n    procedure SetCheckCountZero ;                      -- Simple, with or without tags\n    procedure SetCheckCountZero (Index  : integer) ;   -- Arrays, with or without tags\n\n    ------------------------------------------------------------\n    ------------------------------------------------------------\n    -- Deprecated.  Names changed.  Maintained for backward compatibility  - would prefer an alias\n    ------------------------------------------------------------\n    procedure FileOpen (FileName : string; OpenKind : File_Open_Kind ) ; -- Replaced by TranscriptPkg.TranscriptOpen\n    procedure PutExpectedData (ExpectedData : ExpectedType) ;            -- Replaced by push\n    procedure CheckActualData (ActualData : ActualType) ;                -- Replaced by Check\n    impure function GetItemNumber return integer ;                       -- Replaced by GetItemCount\n    procedure SetMessage (MessageIn : String) ;                          -- Replaced by SetName\n    impure function GetMessage return string ;                           -- Replaced by GetName\n\n    -- Deprecated and may be deleted in a future revision\n    procedure SetFinish (    -- Replaced by CheckFinish\n      Index       : integer ;\n      FCheckCount : integer ;\n      FEmpty      : boolean := TRUE;\n      FStatus     : boolean := TRUE\n    ) ;\n\n    procedure SetFinish (     -- Replaced by CheckFinish\n      FCheckCount : integer ;\n      FEmpty      : boolean := TRUE;\n      FStatus     : boolean := TRUE\n    ) ;\n\n    ------------------------------------------------------------\n    -- SetReportMode\n    -- Not AlertFlow\n    --     REPORT_ALL:     Replaced by AlertLogPkg.SetLogEnable(PASSED, TRUE)\n    --     REPORT_ERROR:   Replaced by AlertLogPkg.SetLogEnable(PASSED, FALSE)\n    --     REPORT_NONE:    Deprecated, do not use.\n    -- AlertFlow:\n    --     REPORT_ALL:     Replaced by AlertLogPkg.SetLogEnable(AlertLogID, PASSED, TRUE)\n    --     REPORT_ERROR:   Replaced by AlertLogPkg.SetLogEnable(AlertLogID, PASSED, FALSE)\n    --     REPORT_NONE:    Replaced by AlertLogPkg.SetAlertEnable(AlertLogID, ERROR, FALSE)\n    procedure SetReportMode (ReportModeIn : ScoreboardReportType) ;\n    impure function GetReportMode return ScoreboardReportType ;\n\n    ------------------------------------------------------------\n    ------------------------------------------------------------\n--    -- Deprecated Interface to NewID\n--    impure function NewID (Name : String; ParentAlertLogID : AlertLogIDType; DoNotReport : Boolean) return ScoreboardIDType ;\n--    -- Vector: 1 to Size\n--    impure function NewID (Name : String; Size : positive; ParentAlertLogID : AlertLogIDType; DoNotReport : Boolean) return ScoreboardIDArrayType ;\n--    -- Vector: X(X'Left) to X(X'Right)\n--    impure function NewID (Name : String; X : integer_vector; ParentAlertLogID : AlertLogIDType; DoNotReport : Boolean) return ScoreboardIDArrayType ;\n--    -- Matrix: 1 to X, 1 to Y\n--    impure function NewID (Name : String; X, Y : positive; ParentAlertLogID : AlertLogIDType; DoNotReport : Boolean) return ScoreboardIdMatrixType ;\n--    -- Matrix: X(X'Left) to X(X'Right), Y(Y'Left) to Y(Y'Right)\n--    impure function NewID (Name : String; X, Y : integer_vector; ParentAlertLogID : AlertLogIDType; DoNotReport : Boolean) return ScoreboardIdMatrixType ;\n\n\n  end protected ScoreBoardPType ;\n\n  ------------------------------------------------------------\n  -- Deprecated Interface to NewID\n  impure function NewID (Name : String; ParentAlertLogID : AlertLogIDType; DoNotReport : Boolean) return ScoreboardIDType ;\n  -- Vector: 1 to Size\n  impure function NewID (Name : String; Size : positive; ParentAlertLogID : AlertLogIDType; DoNotReport : Boolean) return ScoreboardIDArrayType ;\n  -- Vector: X(X'Left) to X(X'Right)\n  impure function NewID (Name : String; X : integer_vector; ParentAlertLogID : AlertLogIDType; DoNotReport : Boolean) return ScoreboardIDArrayType ;\n  -- Matrix: 1 to X, 1 to Y\n  impure function NewID (Name : String; X, Y : positive; ParentAlertLogID : AlertLogIDType; DoNotReport : Boolean) return ScoreboardIdMatrixType ;\n  -- Matrix: X(X'Left) to X(X'Right), Y(Y'Left) to Y(Y'Right)\n  impure function NewID (Name : String; X, Y : integer_vector; ParentAlertLogID : AlertLogIDType; DoNotReport : Boolean) return ScoreboardIdMatrixType ;\n\n\nend ScoreboardGenericPkg ;\n\n\n-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\npackage body ScoreboardGenericPkg is\n\n  type ScoreBoardPType is protected body\n    type ExpectedPointerType is access ExpectedType ;\n\n    type ListType ;\n    type ListPointerType is access ListType ;\n    type ListType is record\n      ItemNumber     : integer ;\n      TagPtr         : line ;\n      ExpectedPtr    : ExpectedPointerType ;\n      NextPtr        : ListPointerType ;\n    end record ;\n\n--!! Replace the following with\n--    type ScoreboardRecType is record\n--      HeadPointer    : ListPointerType ;\n--      TailPointer    : ListPointerType ;\n--      PopListPointer : ListPointerType ;\n--\n--      ErrCnt         : integer ;\n--      DropCount      : integer ;\n--      ItemNumber     : integer ;\n--      PopCount       : integer ;\n--      CheckCount     : integer ;\n--      AlertLogID     : AlertLogIDType ;\n--      Name           : NameStoreIDType ;\n--      ReportMode     : ScoreboardReportType ;\n--    end record ScoreboardRecType ;\n--\n--    type ScoreboardRecArrayType is array (integer range <>) of ScoreboardRecType ;\n--    type ScoreboardRecArrayPointerType is access ScoreboardRecArrayType ;\n--    variable ScoreboardPointer : ScoreboardRecArrayPointerType ;\n--\n--    -- Alas unfortunately aliases don't word as follows:\n--    -- alias HeadPointer(I) is ScoreboardPointer(I).HeadPointer ;\n\n    type ListArrayType is array (integer range <>) of ListPointerType ;\n    type ListArrayPointerType is access ListArrayType ;\n\n    variable ArrayLengthVar  : integer := 1 ;\n\n-- Original Code\n--    variable HeadPointer     : ListArrayPointerType := new ListArrayType(1 to 1) ;\n--    variable TailPointer     : ListArrayPointerType := new ListArrayType(1 to 1)  ;\n--    -- PopListPointer needed for Pop to be a function - alternately need 2019 features\n--    variable PopListPointer  : ListArrayPointerType := new ListArrayType(1 to 1) ;\n--\n-- Legal, but crashes simulator more thoroughly\n--    variable HeadPointer     : ListArrayPointerType := new ListArrayType'(1 => NULL) ;\n--    variable TailPointer     : ListArrayPointerType := new ListArrayType'(1 => NULL) ;\n--    -- PopListPointer needed for Pop to be a function - alternately need 2019 features\n--    variable PopListPointer  : ListArrayPointerType := new ListArrayType'(1 => NULL) ;\n-- Working work around for QS 2020.04 and 2021.02\n    variable Template : ListArrayType(1 to 1) ;  -- Work around for QS 2020.04 and 2021.02\n\n    variable HeadPointer     : ListArrayPointerType := new ListArrayType'(Template) ;\n    variable TailPointer     : ListArrayPointerType := new ListArrayType'(Template) ;\n    -- PopListPointer needed for Pop to be a function - alternately need 2019 features\n    variable PopListPointer  : ListArrayPointerType := new ListArrayType'(Template) ;\n\n    type IntegerArrayType is array (integer range <>) of Integer ;\n    type IntegerArrayPointerType is access IntegerArrayType ;\n    type AlertLogIDArrayType is array (integer range <>) of AlertLogIDType ;\n    type AlertLogIDArrayPointerType is access AlertLogIDArrayType ;\n\n    variable ErrCntVar       : IntegerArrayPointerType := new IntegerArrayType'(1 => 0) ;\n    variable DropCountVar    : IntegerArrayPointerType := new IntegerArrayType'(1 => 0) ;\n    variable ItemNumberVar   : IntegerArrayPointerType := new IntegerArrayType'(1 => 0) ;\n    variable PopCountVar     : IntegerArrayPointerType := new IntegerArrayType'(1 => 0) ;\n    variable CheckCountVar   : IntegerArrayPointerType := new IntegerArrayType'(1 => 0) ;\n    variable AlertLogIDVar   : AlertLogIDArrayPointerType := new AlertLogIDArrayType'(1 => OSVVM_SCOREBOARD_ALERTLOG_ID) ;\n\n    variable NameVar         : NamePType ;\n    variable ReportModeVar   : ScoreboardReportType ;\n    variable FirstIndexVar   : integer := 1 ;\n\n    variable PrintIndexVar   : boolean := TRUE ;\n\n    variable CalledNewID     : boolean := FALSE ;\n    variable LocalNameStore  : NameStorePType ;\n\n    ------------------------------------------------------------\n    -- Used by ScoreboardStore\n    variable NumItems       : integer := 0 ;\n    constant MIN_NUM_ITEMS  : integer := 4 ; -- Temporarily small for testing\n--    constant MIN_NUM_ITEMS      : integer := 32 ; -- Min amount to resize array\n\n    ------------------------------------------------------------\n    procedure SetPrintIndex (Enable : boolean := TRUE) is\n    ------------------------------------------------------------\n    begin\n      PrintIndexVar := Enable ;\n    end procedure SetPrintIndex ;\n\n    ------------------------------------------------------------\n    -- Package Local\n    function NormalizeArraySize( NewNumItems, MinNumItems : integer ) return integer is\n    ------------------------------------------------------------\n      variable NormNumItems : integer := NewNumItems ;\n      variable ModNumItems  : integer := 0;\n    begin\n      ModNumItems := NewNumItems mod MinNumItems ;\n      if ModNumItems > 0 then\n        NormNumItems := NormNumItems + (MinNumItems - ModNumItems) ;\n      end if ;\n      return NormNumItems ;\n    end function NormalizeArraySize ;\n\n    ------------------------------------------------------------\n    -- Package Local\n    procedure GrowNumberItems (\n    ------------------------------------------------------------\n      variable NumItems         : InOut integer ;\n      constant GrowAmount       : in integer ;\n      constant MinNumItems      : in integer\n    ) is\n      variable NewNumItems : integer ;\n    begin\n      NewNumItems := NumItems + GrowAmount ;\n      if NewNumItems > HeadPointer'length then\n        SetArrayIndex(1, NormalizeArraySize(NewNumItems, MinNumItems)) ;\n      end if ;\n      NumItems := NewNumItems ;\n    end procedure GrowNumberItems ;\n\n    ------------------------------------------------------------\n    -- Local/Private to package\n    impure function LocalNewID (\n      Name          : String ;\n      ParentID      : AlertLogIDType          := OSVVM_SCOREBOARD_ALERTLOG_ID ;\n      ReportMode    : AlertLogReportModeType  := ENABLED ;\n      Search        : NameSearchType          := PRIVATE_NAME ;\n      PrintParent   : AlertLogPrintParentType := PRINT_NAME_AND_PARENT\n    ) return ScoreboardIDType is\n    ------------------------------------------------------------\n      variable NameID              : integer ;\n    begin\n      NameID := LocalNameStore.find(Name, ParentID, Search) ;\n\n      -- Share the scoreboards if they match\n      if NameID /= ID_NOT_FOUND.ID then\n        return ScoreboardIDType'(ID => NameID) ;\n      else\n        -- Resize Data Structure as necessary\n        GrowNumberItems(NumItems, GrowAmount => 1, MinNumItems => MIN_NUM_ITEMS) ;\n        -- Create AlertLogID\n        AlertLogIDVar(NumItems) := NewID(Name, ParentID, ReportMode, PrintParent, CreateHierarchy => FALSE) ;\n        -- Add item to NameStore\n        NameID := LocalNameStore.NewID(Name, ParentID, Search) ;\n        AlertIfNotEqual(AlertLogIDVar(NumItems), NameID, NumItems, \"ScoreboardPkg: Index of LocalNameStore /= ScoreboardID\") ;\n        return ScoreboardIDType'(ID => NumItems) ;\n      end if ;\n    end function LocalNewID ;\n\n    ------------------------------------------------------------\n    -- Used by Scoreboard Store\n    impure function NewID (\n      Name          : String ;\n      ParentID      : AlertLogIDType          := OSVVM_SCOREBOARD_ALERTLOG_ID ;\n      ReportMode    : AlertLogReportModeType  := ENABLED ;\n      Search        : NameSearchType          := PRIVATE_NAME ;\n      PrintParent   : AlertLogPrintParentType := PRINT_NAME_AND_PARENT\n    ) return ScoreboardIDType is\n    ------------------------------------------------------------\n      variable ResolvedSearch      : NameSearchType ;\n      variable ResolvedPrintParent : AlertLogPrintParentType ;\n    begin\n      CalledNewID := TRUE ;\n      SetPrintIndex(FALSE) ;  -- historic, but needed\n\n      ResolvedSearch      := ResolveSearch     (ParentID /= OSVVM_SCOREBOARD_ALERTLOG_ID, Search) ;\n      ResolvedPrintParent := ResolvePrintParent(ParentID /= OSVVM_SCOREBOARD_ALERTLOG_ID, PrintParent) ;\n\n      return LocalNewID(Name, ParentID, ReportMode, ResolvedSearch, ResolvedPrintParent) ;\n\n    end function NewID ;\n\n    ------------------------------------------------------------\n    -- Vector. Assumes valid range (done by NewID)\n    impure function LocalNewID (\n      Name          : String ;\n      X             : integer_vector ;\n      ParentID      : AlertLogIDType          := OSVVM_SCOREBOARD_ALERTLOG_ID ;\n      ReportMode    : AlertLogReportModeType  := ENABLED ;\n      Search        : NameSearchType          := PRIVATE_NAME ;\n      PrintParent   : AlertLogPrintParentType := PRINT_NAME_AND_PARENT\n    ) return ScoreboardIDArrayType is\n    ------------------------------------------------------------\n      variable Result          : ScoreboardIDArrayType(X(X'left) to X(X'right)) ;\n      variable ResolvedSearch  : NameSearchType ;\n      variable ResolvedPrintParent : AlertLogPrintParentType ;\n--      variable ArrayParentID       : AlertLogIDType ;\n    begin\n      CalledNewID := TRUE ;\n      SetPrintIndex(FALSE) ;  -- historic, but needed\n\n      ResolvedSearch      := ResolveSearch     (ParentID /= OSVVM_SCOREBOARD_ALERTLOG_ID, Search) ;\n      ResolvedPrintParent := ResolvePrintParent(ParentID /= OSVVM_SCOREBOARD_ALERTLOG_ID, PrintParent) ;\n--      ArrayParentID       := NewID(Name, ParentID, ReportMode, ResolvedPrintParent, CreateHierarchy => FALSE) ;\n\n      for i in Result'range loop\n        Result(i) := LocalNewID(Name & \"(\" & to_string(i) & \")\", ParentID, ReportMode, ResolvedSearch, ResolvedPrintParent) ;\n      end loop ;\n      return Result ;\n    end function LocalNewID ;\n\n    ------------------------------------------------------------\n    -- Vector: 1 to Size\n    impure function NewID (\n      Name          : String ;\n      Size          : positive ;\n      ParentID      : AlertLogIDType          := OSVVM_SCOREBOARD_ALERTLOG_ID ;\n      ReportMode    : AlertLogReportModeType  := ENABLED ;\n      Search        : NameSearchType          := PRIVATE_NAME ;\n      PrintParent   : AlertLogPrintParentType := PRINT_NAME_AND_PARENT\n    ) return ScoreboardIDArrayType is\n    ------------------------------------------------------------\n    begin\n      return LocalNewID(Name, (1, Size) , ParentID, ReportMode, Search, PrintParent) ;\n    end function NewID ;\n\n    ------------------------------------------------------------\n    -- Vector: X(X'Left) to X(X'Right)\n    impure function NewID (\n      Name          : String ;\n      X             : integer_vector ;\n      ParentID      : AlertLogIDType          := OSVVM_SCOREBOARD_ALERTLOG_ID ;\n      ReportMode    : AlertLogReportModeType  := ENABLED ;\n      Search        : NameSearchType          := PRIVATE_NAME ;\n      PrintParent   : AlertLogPrintParentType := PRINT_NAME_AND_PARENT\n    ) return ScoreboardIDArrayType is\n    ------------------------------------------------------------\n    begin\n      AlertIf(ParentID, X'length /= 2, \"ScoreboardPkg.NewID Array parameter X has \" & to_string(X'length) & \"dimensions.  Required to be 2\", FAILURE) ;\n      AlertIf(ParentID, X(X'Left) > X(X'right), \"ScoreboardPkg.NewID Array parameter X(X'left): \" & to_string(X'Left) & \" must be <= X(X'right): \" & to_string(X(X'right)), FAILURE) ;\n      return LocalNewID(Name, X, ParentID, ReportMode, Search, PrintParent) ;\n    end function NewID ;\n\n    ------------------------------------------------------------\n    -- Matrix. Assumes valid indices (done by NewID)\n    impure function LocalNewID (\n      Name          : String ;\n      X, Y          : integer_vector ;\n      ParentID      : AlertLogIDType          := OSVVM_SCOREBOARD_ALERTLOG_ID ;\n      ReportMode    : AlertLogReportModeType  := ENABLED ;\n      Search        : NameSearchType          := PRIVATE_NAME ;\n      PrintParent   : AlertLogPrintParentType := PRINT_NAME_AND_PARENT\n    ) return ScoreboardIdMatrixType is\n    ------------------------------------------------------------\n      variable Result          : ScoreboardIdMatrixType(X(X'left) to X(X'right), Y(Y'left) to Y(Y'right)) ;\n      variable ResolvedSearch  : NameSearchType ;\n      variable ResolvedPrintParent : AlertLogPrintParentType ;\n--      variable ArrayParentID       : AlertLogIDType ;\n    begin\n      CalledNewID := TRUE ;\n      SetPrintIndex(FALSE) ;\n\n      ResolvedSearch      := ResolveSearch     (ParentID /= OSVVM_SCOREBOARD_ALERTLOG_ID, Search) ;\n      ResolvedPrintParent := ResolvePrintParent(ParentID /= OSVVM_SCOREBOARD_ALERTLOG_ID, PrintParent) ;\n--      ArrayParentID       := NewID(Name, ParentID, ReportMode, ResolvedPrintParent, CreateHierarchy => FALSE) ;\n\n      for i in X(X'left) to X(X'right) loop\n        for j in Y(Y'left) to Y(Y'right) loop\n          Result(i, j) := LocalNewID(Name & \"(\" & to_string(i) & \", \" & to_string(j) & \")\", ParentID, ReportMode, ResolvedSearch, ResolvedPrintParent) ;\n        end loop ;\n      end loop ;\n      return Result ;\n    end function LocalNewID ;\n\n    ------------------------------------------------------------\n    -- Matrix: 1 to X, 1 to Y\n    impure function NewID (\n      Name          : String ;\n      X, Y          : positive ;\n      ParentID      : AlertLogIDType          := OSVVM_SCOREBOARD_ALERTLOG_ID ;\n      ReportMode    : AlertLogReportModeType  := ENABLED ;\n      Search        : NameSearchType          := PRIVATE_NAME ;\n      PrintParent   : AlertLogPrintParentType := PRINT_NAME_AND_PARENT\n    ) return ScoreboardIdMatrixType is\n    ------------------------------------------------------------\n    begin\n      return LocalNewID(Name, (1,X), (1,Y), ParentID, ReportMode, Search, PrintParent) ;\n    end function NewID ;\n\n    ------------------------------------------------------------\n    -- Matrix: X(X'Left) to X(X'Right), Y(Y'Left) to Y(Y'Right)\n    impure function NewID (\n      Name          : String ;\n      X, Y          : integer_vector ;\n      ParentID      : AlertLogIDType          := OSVVM_SCOREBOARD_ALERTLOG_ID ;\n      ReportMode    : AlertLogReportModeType  := ENABLED ;\n      Search        : NameSearchType          := PRIVATE_NAME ;\n      PrintParent   : AlertLogPrintParentType := PRINT_NAME_AND_PARENT\n    ) return ScoreboardIdMatrixType is\n    ------------------------------------------------------------\n    begin\n      AlertIf(ParentID, X'length /= 2, \"ScoreboardPkg.NewID Matrix parameter X has \" & to_string(X'length) & \"dimensions.  Required to be 2\", FAILURE) ;\n      AlertIf(ParentID, Y'length /= 2, \"ScoreboardPkg.NewID Matrix parameter Y has \" & to_string(Y'length) & \"dimensions.  Required to be 2\", FAILURE) ;\n      AlertIf(ParentID, X(X'Left) > X(X'right), \"ScoreboardPkg.NewID Matrix parameter X(X'left): \" & to_string(X'Left) & \" must be <= X(X'right): \" & to_string(X(X'right)), FAILURE) ;\n      AlertIf(ParentID, Y(Y'Left) > Y(Y'right), \"ScoreboardPkg.NewID Matrix parameter Y(Y'left): \" & to_string(Y'Left) & \" must be <= Y(Y'right): \" & to_string(Y(Y'right)), FAILURE) ;\n      return LocalNewID(Name, X, Y, ParentID, ReportMode, Search, PrintParent) ;\n    end function NewID ;\n\n    ------------------------------------------------------------\n    procedure SetName (Name : String) is\n    ------------------------------------------------------------\n    begin\n      NameVar.Set(Name) ;\n    end procedure SetName ;\n\n    ------------------------------------------------------------\n    impure function SetName (Name : String) return string is\n    ------------------------------------------------------------\n    begin\n      NameVar.Set(Name) ;\n      return Name ;\n    end function SetName ;\n\n    ------------------------------------------------------------\n    impure function GetName (DefaultName : string := \"Scoreboard\") return string is\n    ------------------------------------------------------------\n    begin\n      return NameVar.Get(DefaultName) ;\n    end function GetName ;\n\n    ------------------------------------------------------------\n    procedure SetReportMode (ReportModeIn : ScoreboardReportType) is\n    ------------------------------------------------------------\n    begin\n      ReportModeVar := ReportModeIn ;\n      if ReportModeVar = REPORT_ALL then\n        Alert(OSVVM_SCOREBOARD_ALERTLOG_ID, \"ScoreboardGenericPkg.SetReportMode: To turn off REPORT_ALL, use osvvm.AlertLogPkg.SetLogEnable(PASSED, FALSE)\", WARNING) ;\n        for i in AlertLogIDVar'range loop\n          SetLogEnable(AlertLogIDVar(i), PASSED, TRUE) ;\n        end loop ;\n      end if ;\n      if ReportModeVar = REPORT_NONE then\n        Alert(OSVVM_SCOREBOARD_ALERTLOG_ID, \"ScoreboardGenericPkg.SetReportMode: ReportMode REPORT_NONE has been deprecated and will be removed in next revision.  Please contact OSVVM architect Jim Lewis if you need this capability.\", WARNING) ;\n      end if ;\n    end procedure SetReportMode ;\n\n    ------------------------------------------------------------\n    impure function GetReportMode return ScoreboardReportType is\n    ------------------------------------------------------------\n    begin\n      return ReportModeVar ;\n    end function GetReportMode ;\n\n    ------------------------------------------------------------\n    procedure SetArrayIndex(L, R : integer) is\n    ------------------------------------------------------------\n      variable OldHeadPointer, OldTailPointer, OldPopListPointer : ListArrayPointerType ;\n      variable OldErrCnt, OldDropCount, OldItemNumber, OldPopCount, OldCheckCount : IntegerArrayPointerType ;\n      variable OldAlertLogIDVar : AlertLogIDArrayPointerType ;\n      variable Min, Max, Len, OldLen, OldMax : integer ;\n    begin\n      Min := minimum(L, R) ;\n      Max := maximum(L, R) ;\n      OldLen := ArrayLengthVar ;\n      OldMax := Min + ArrayLengthVar - 1 ;\n      Len := Max - Min + 1 ;\n      ArrayLengthVar := Len ;\n      if Len >= OldLen then\n        FirstIndexVar := Min ;\n\n        OldHeadPointer := HeadPointer ;\n        HeadPointer := new ListArrayType(Min to Max) ;\n        if OldHeadPointer /= NULL then\n          HeadPointer(Min to OldMax) := OldHeadPointer.all ; -- (OldHeadPointer'range) ;\n          Deallocate(OldHeadPointer) ;\n        end if ;\n\n        OldTailPointer := TailPointer ;\n        TailPointer := new ListArrayType(Min to Max) ;\n        if OldTailPointer /= NULL then\n          TailPointer(Min to OldMax) := OldTailPointer.all ;\n          Deallocate(OldTailPointer) ;\n        end if ;\n\n        OldPopListPointer := PopListPointer ;\n        PopListPointer := new ListArrayType(Min to Max) ;\n        if OldPopListPointer /= NULL then\n          PopListPointer(Min to OldMax) := OldPopListPointer.all ;\n          Deallocate(OldPopListPointer) ;\n        end if ;\n\n        OldErrCnt := ErrCntVar ;\n        ErrCntVar := new IntegerArrayType'(Min to Max => 0) ;\n        if OldErrCnt /= NULL then\n          ErrCntVar(Min to OldMax) := OldErrCnt.all ;\n          Deallocate(OldErrCnt) ;\n        end if ;\n\n        OldDropCount := DropCountVar ;\n        DropCountVar := new IntegerArrayType'(Min to Max => 0) ;\n        if OldDropCount /= NULL then\n          DropCountVar(Min to OldMax) := OldDropCount.all ;\n          Deallocate(OldDropCount) ;\n        end if ;\n\n        OldItemNumber := ItemNumberVar ;\n        ItemNumberVar := new IntegerArrayType'(Min to Max => 0) ;\n        if OldItemNumber /= NULL then\n          ItemNumberVar(Min to OldMax) := OldItemNumber.all ;\n          Deallocate(OldItemNumber) ;\n        end if ;\n\n        OldPopCount := PopCountVar ;\n        PopCountVar := new IntegerArrayType'(Min to Max => 0) ;\n        if OldPopCount /= NULL then\n          PopCountVar(Min to OldMax) := OldPopCount.all ;\n          Deallocate(OldPopCount) ;\n        end if ;\n\n        OldCheckCount := CheckCountVar ;\n        CheckCountVar := new IntegerArrayType'(Min to Max => 0) ;\n        if OldCheckCount /= NULL then\n          CheckCountVar(Min to OldMax) := OldCheckCount.all ;\n          Deallocate(OldCheckCount) ;\n        end if ;\n\n        OldAlertLogIDVar := AlertLogIDVar ;\n        AlertLogIDVar := new AlertLogIDArrayType'(Min to Max => OSVVM_SCOREBOARD_ALERTLOG_ID) ;\n        if OldAlertLogIDVar /= NULL then\n          AlertLogIDVar(Min to OldMax) := OldAlertLogIDVar.all ;\n          Deallocate(OldAlertLogIDVar) ;\n        end if ;\n\n      elsif Len < OldLen then\n        report \"ScoreboardGenericPkg: SetArrayIndex, new array Length <= current array length\"\n        severity failure ;\n\n      end if ;\n    end procedure SetArrayIndex ;\n\n    ------------------------------------------------------------\n    procedure SetArrayIndex(R : natural) is\n    ------------------------------------------------------------\n    begin\n      SetArrayIndex(1, R) ;\n    end procedure SetArrayIndex ;\n\n    ------------------------------------------------------------\n    procedure Deallocate is\n    ------------------------------------------------------------\n      variable CurListPtr, LastListPtr : ListPointerType ;\n    begin\n      for Index in HeadPointer'range loop\n      -- Deallocate contents in the scoreboards\n        CurListPtr  := HeadPointer(Index) ;\n        while CurListPtr /= Null loop\n          deallocate(CurListPtr.TagPtr) ;\n          deallocate(CurListPtr.ExpectedPtr) ;\n          LastListPtr := CurListPtr ;\n          CurListPtr := CurListPtr.NextPtr ;\n          Deallocate(LastListPtr) ;\n        end loop ;\n      end loop ;\n\n      for Index in PopListPointer'range loop\n      -- Deallocate PopListPointer - only has single element\n        CurListPtr  := PopListPointer(Index) ;\n        if CurListPtr /= NULL then\n          deallocate(CurListPtr.TagPtr) ;\n          deallocate(CurListPtr.ExpectedPtr) ;\n          deallocate(CurListPtr) ;\n        end if ;\n      end loop ;\n\n      -- Deallocate arrays of pointers\n      Deallocate(HeadPointer) ;\n      Deallocate(TailPointer) ;\n      Deallocate(PopListPointer) ;\n\n      -- Deallocate supporting arrays\n      Deallocate(ErrCntVar) ;\n      Deallocate(DropCountVar) ;\n      Deallocate(ItemNumberVar) ;\n      Deallocate(PopCountVar) ;\n      Deallocate(CheckCountVar) ;\n      Deallocate(AlertLogIDVar) ;\n\n      -- Deallocate NameVar - NamePType\n      NameVar.Deallocate ;\n\n      ArrayLengthVar := 0 ;\n      NumItems       := 0 ;\n      CalledNewID    := FALSE ;\n    end procedure Deallocate ;\n\n    ------------------------------------------------------------\n    -- Construct initial data structure\n    procedure Initialize is\n    ------------------------------------------------------------\n    begin\n      SetArrayIndex(1, 1) ;\n    end procedure Initialize ;\n\n    ------------------------------------------------------------\n    impure function GetArrayIndex return integer_vector is\n    ------------------------------------------------------------\n    begin\n      return (1 => HeadPointer'left, 2 => HeadPointer'right) ;\n    end function GetArrayIndex ;\n\n    ------------------------------------------------------------\n    impure function GetArrayLength return natural is\n    ------------------------------------------------------------\n    begin\n      return ArrayLengthVar ;  -- HeadPointer'length ;\n    end function GetArrayLength ;\n\n    ------------------------------------------------------------\n    procedure SetAlertLogID (Index : Integer ; A : AlertLogIDType) is\n    ------------------------------------------------------------\n    begin\n      AlertLogIDVar(Index) := A ;\n    end procedure SetAlertLogID ;\n\n    ------------------------------------------------------------\n    procedure SetAlertLogID (A : AlertLogIDType) is\n    ------------------------------------------------------------\n    begin\n      AlertLogIDVar(FirstIndexVar) := A ;\n    end procedure SetAlertLogID ;\n\n    ------------------------------------------------------------\n    procedure SetAlertLogID(Index : Integer; Name : string; ParentID : AlertLogIDType := OSVVM_SCOREBOARD_ALERTLOG_ID; CreateHierarchy : Boolean := TRUE; DoNotReport : Boolean := FALSE) is\n    ------------------------------------------------------------\n      variable ReportMode : AlertLogReportModeType ;\n    begin\n      ReportMode := ENABLED when not DoNotReport else DISABLED ;\n      AlertLogIDVar(Index) := NewID(Name, ParentID, ReportMode => ReportMode, PrintParent => PRINT_NAME, CreateHierarchy => CreateHierarchy) ;\n    end procedure SetAlertLogID ;\n\n    ------------------------------------------------------------\n    procedure SetAlertLogID(Name : string; ParentID : AlertLogIDType := OSVVM_SCOREBOARD_ALERTLOG_ID; CreateHierarchy : Boolean := TRUE; DoNotReport : Boolean := FALSE) is\n    ------------------------------------------------------------\n      variable ReportMode : AlertLogReportModeType ;\n    begin\n      ReportMode := ENABLED when not DoNotReport else DISABLED ;\n      AlertLogIDVar(FirstIndexVar) := NewID(Name, ParentID, ReportMode => ReportMode, PrintParent => PRINT_NAME, CreateHierarchy => CreateHierarchy) ;\n    end procedure SetAlertLogID ;\n\n    ------------------------------------------------------------\n    impure function GetAlertLogID(Index : Integer) return AlertLogIDType is\n    ------------------------------------------------------------\n    begin\n      return AlertLogIDVar(Index) ;\n    end function GetAlertLogID ;\n\n    ------------------------------------------------------------\n    impure function GetAlertLogID return AlertLogIDType is\n    ------------------------------------------------------------\n    begin\n      return AlertLogIDVar(FirstIndexVar) ;\n    end function GetAlertLogID ;\n\n    ------------------------------------------------------------\n    impure function LocalOutOfRange(\n    ------------------------------------------------------------\n      constant Index : in integer ;\n      constant Name  : in string\n    ) return boolean is\n    begin\n      return AlertIf(OSVVM_SCOREBOARD_ALERTLOG_ID, Index < HeadPointer'Low or Index > HeadPointer'High,\n         GetName & \" \" & Name & \" Index: \" & to_string(Index) &\n               \"is not in the range (\" & to_string(HeadPointer'Low) &\n               \"to \" & to_string(HeadPointer'High) & \")\",\n         FAILURE ) ;\n    end function LocalOutOfRange ;\n\n    ------------------------------------------------------------\n    procedure LocalPush (\n    ------------------------------------------------------------\n      constant Index  : in  integer ;\n      constant Tag    : in  string ;\n      constant Item   : in  ExpectedType\n    ) is\n      variable ExpectedPtr : ExpectedPointerType ;\n      variable TagPtr : line ;\n    begin\n      if LocalOutOfRange(Index, \"Push\") then\n        return ; -- error reporting in LocalOutOfRange\n      end if ;\n\n      ItemNumberVar(Index)  := ItemNumberVar(Index) + 1 ;\n      ExpectedPtr := new ExpectedType'(Item) ;\n      TagPtr := new string'(Tag) ;\n\n      if HeadPointer(Index) = NULL then\n        -- 2015.05: allocation using ListTtype'(...) in a protected type does not work in some simulators\n        -- HeadPointer(Index) := new ListType'(ItemNumberVar(Index), TagPtr, ExpectedPtr, NULL) ;\n        HeadPointer(Index) := new ListType ;\n        HeadPointer(Index).ItemNumber  := ItemNumberVar(Index) ;\n        HeadPointer(Index).TagPtr      := TagPtr ;\n        HeadPointer(Index).ExpectedPtr := ExpectedPtr ;\n        HeadPointer(Index).NextPtr     := NULL ;\n        TailPointer(Index) := HeadPointer(Index) ;\n      else\n        -- 2015.05: allocation using ListTtype'(...) in a protected type does not work in some simulators\n        -- TailPointer(Index).NextPtr := new ListType'(ItemNumberVar(Index), TagPtr, ExpectedPtr, NULL) ;\n        TailPointer(Index).NextPtr := new ListType ;\n        TailPointer(Index).NextPtr.ItemNumber  := ItemNumberVar(Index) ;\n        TailPointer(Index).NextPtr.TagPtr      := TagPtr ;\n        TailPointer(Index).NextPtr.ExpectedPtr := ExpectedPtr ;\n        TailPointer(Index).NextPtr.NextPtr     := NULL ;\n        TailPointer(Index) := TailPointer(Index).NextPtr ;\n      end if ;\n    end procedure LocalPush ;\n\n    ------------------------------------------------------------\n    -- Array of Tagged Scoreboards\n    procedure Push (\n    ------------------------------------------------------------\n      constant Index  : in  integer ;\n      constant Tag    : in  string ;\n      constant Item   : in  ExpectedType\n    ) is\n      variable ExpectedPtr : ExpectedPointerType ;\n      variable TagPtr : line ;\n    begin\n      if LocalOutOfRange(Index, \"Push\") then\n        return ; -- error reporting in LocalOutOfRange\n      end if ;\n      LocalPush(Index, Tag, Item) ;\n    end procedure Push ;\n\n    ------------------------------------------------------------\n    -- Array of Scoreboards, no tag\n    procedure Push (\n    ------------------------------------------------------------\n      constant Index  : in  integer ;\n      constant Item   : in  ExpectedType\n    ) is\n    begin\n      if LocalOutOfRange(Index, \"Push\") then\n        return ; -- error reporting in LocalOutOfRange\n      end if ;\n      LocalPush(Index, \"\", Item) ;\n    end procedure Push ;\n\n    ------------------------------------------------------------\n    -- Simple Tagged Scoreboard\n    procedure Push (\n    ------------------------------------------------------------\n      constant Tag    : in  string ;\n      constant Item   : in  ExpectedType\n    ) is\n    begin\n      LocalPush(FirstIndexVar, Tag, Item) ;\n    end procedure Push ;\n\n    ------------------------------------------------------------\n    -- Simple Scoreboard, no tag\n    procedure Push (Item   : in  ExpectedType) is\n    ------------------------------------------------------------\n    begin\n      LocalPush(FirstIndexVar, \"\", Item) ;\n    end procedure Push ;\n\n    ------------------------------------------------------------\n    -- Array of Tagged Scoreboards\n    impure function Push (\n    ------------------------------------------------------------\n      constant Index  : in  integer ;\n      constant Tag    : in  string ;\n      constant Item   : in  ExpectedType\n    ) return ExpectedType is\n    begin\n      if LocalOutOfRange(Index, \"Push\") then\n        return Item ; -- error reporting in LocalOutOfRange\n      end if ;\n      LocalPush(Index, Tag, Item) ;\n      return Item ;\n    end function Push ;\n\n    ------------------------------------------------------------\n    -- Array of Scoreboards, no tag\n    impure function Push (\n    ------------------------------------------------------------\n      constant Index  : in  integer ;\n      constant Item   : in  ExpectedType\n    ) return ExpectedType is\n    begin\n      if LocalOutOfRange(Index, \"Push\") then\n        return Item ; -- error reporting in LocalOutOfRange\n      end if ;\n      LocalPush(Index, \"\", Item) ;\n      return Item ;\n    end function Push ;\n\n    ------------------------------------------------------------\n    -- Simple Tagged Scoreboard\n    impure function Push (\n    ------------------------------------------------------------\n      constant Tag    : in  string ;\n      constant Item   : in  ExpectedType\n    ) return ExpectedType is\n    begin\n      LocalPush(FirstIndexVar, Tag, Item) ;\n      return Item ;\n    end function Push ;\n\n    ------------------------------------------------------------\n    -- Simple Scoreboard, no tag\n    impure function Push (Item : ExpectedType) return ExpectedType is\n    ------------------------------------------------------------\n    begin\n      LocalPush(FirstIndexVar, \"\", Item) ;\n      return Item ;\n    end function Push ;\n\n    ------------------------------------------------------------\n    -- Local Only\n    -- Pops highest element matching Tag into PopListPointer(Index)\n    procedure LocalPop (Index : integer ; Tag : string; Name : string)  is\n    ------------------------------------------------------------\n      variable CurPtr : ListPointerType ;\n    begin\n      if LocalOutOfRange(Index, \"Pop/Check\") then\n        return ; -- error reporting in LocalOutOfRange\n      end if ;\n      if HeadPointer(Index) = NULL then\n        ErrCntVar(Index) := ErrCntVar(Index) + 1 ;\n        if tag'length > 0 then \n          Alert(AlertLogIDVar(Index), GetName & \" Empty during \" & Name & \",  tag: \" & Tag , FAILURE) ;\n        else\n          Alert(AlertLogIDVar(Index), GetName & \" Empty during \" & Name, FAILURE) ;\n        end if ; \n        return ;\n      end if ;\n      PopCountVar(Index) := PopCountVar(Index) + 1 ;\n      -- deallocate previous pointer\n      if PopListPointer(Index) /= NULL then\n        deallocate(PopListPointer(Index).TagPtr) ;\n        deallocate(PopListPointer(Index).ExpectedPtr) ;\n        deallocate(PopListPointer(Index)) ;\n      end if ;\n      -- Descend to find Tag field and extract\n      CurPtr := HeadPointer(Index) ;\n      if CurPtr.TagPtr.all = Tag then\n        -- Non-tagged scoreboards find this one.\n        PopListPointer(Index)  := HeadPointer(Index) ;\n        HeadPointer(Index)     := HeadPointer(Index).NextPtr ;\n      else\n        loop\n          if CurPtr.NextPtr = NULL then\n            ErrCntVar(Index) := ErrCntVar(Index) + 1 ;\n            Alert(AlertLogIDVar(Index), GetName & \" Pop/Check (\" & Name & \"), tag: \" & Tag & \" not found\", FAILURE) ;\n            exit ;\n          elsif CurPtr.NextPtr.TagPtr.all = Tag then\n            PopListPointer(Index) := CurPtr.NextPtr ;\n            CurPtr.NextPtr := CurPtr.NextPtr.NextPtr ;\n            if CurPtr.NextPtr = NULL then\n              TailPointer(Index) := CurPtr ;\n            end if ;\n            exit ;\n          else\n            CurPtr := CurPtr.NextPtr ;\n          end if ;\n        end loop ;\n      end if ;\n    end procedure LocalPop ;\n\n\n    ------------------------------------------------------------\n    -- Local Only\n    procedure LocalCheck (\n    ------------------------------------------------------------\n      constant Index          : in    integer ;\n      constant ActualData     : in    ActualType ;\n      variable FoundError     : inout boolean ;\n      constant ExpectedInFIFO : in    boolean := TRUE\n    ) is\n      variable ExpectedPtr    : ExpectedPointerType ;\n      variable CurrentItem  : integer ;\n      variable WriteBuf : line ;\n      variable PassedFlagEnabled : boolean ;\n    begin\n      CheckCountVar(Index) := CheckCountVar(Index) + 1 ;\n      ExpectedPtr := PopListPointer(Index).ExpectedPtr ;\n      CurrentItem := PopListPointer(Index).ItemNumber ;\n\n      PassedFlagEnabled := GetLogEnable(AlertLogIDVar(Index), PASSED) ;\n\n      if not Match(ActualData, ExpectedPtr.all) then\n        ErrCntVar(Index) := ErrCntVar(Index) + 1 ;\n        FoundError := TRUE ;\n        IncAffirmCount(AlertLogIDVar(Index)) ;\n      else\n        FoundError := FALSE ;\n        if not PassedFlagEnabled then\n          IncAffirmPassedCount(AlertLogIDVar(Index)) ;\n        end if ;\n      end if ;\n\n--      IncAffirmCount(AlertLogIDVar(Index)) ;\n\n--      if FoundError or ReportModeVar = REPORT_ALL then\n      if FoundError or PassedFlagEnabled then\n        if AlertLogIDVar(Index) = OSVVM_SCOREBOARD_ALERTLOG_ID  then\n          write(WriteBuf, GetName(DefaultName => \"Scoreboard\")) ;\n        else\n          write(WriteBuf, GetName(DefaultName => \"\")) ;\n        end if ;\n        if ArrayLengthVar > 1 and PrintIndexVar then\n          write(WriteBuf, \" (\" & to_string(Index) & \") \") ;\n        end if ;\n        if ExpectedInFIFO then\n          write(WriteBuf, \"   Received: \" & actual_to_string(ActualData)) ;\n          if FoundError then\n            write(WriteBuf, \"   Expected: \" & expected_to_string(ExpectedPtr.all)) ;\n          end if ;\n        else\n          write(WriteBuf, \"   Received: \" & expected_to_string(ExpectedPtr.all)) ;\n          if FoundError then\n            write(WriteBuf, \"   Expected: \" & actual_to_string(ActualData)) ;\n          end if ;\n        end if ;\n        if PopListPointer(Index).TagPtr.all /= \"\" then\n          write(WriteBuf, \"   Tag: \" & PopListPointer(Index).TagPtr.all) ;\n        end if;\n        write(WriteBuf, \"   Item Number: \" & to_string(CurrentItem)) ;\n        if FoundError then\n          if ReportModeVar /= REPORT_NONE then\n            -- Affirmation Failed\n            Alert(AlertLogIDVar(Index), WriteBuf.all, ERROR) ;\n          else\n            -- Affirmation Failed, but silent, unless in DEBUG mode\n            Log(AlertLogIDVar(Index), \"ERROR \" & WriteBuf.all, DEBUG) ;\n            IncAlertCount(AlertLogIDVar(Index)) ;  -- Silent Counted Alert\n          end if ;\n        else\n          -- Affirmation passed, PASSED flag increments AffirmCount\n          Log(AlertLogIDVar(Index), WriteBuf.all, PASSED) ;\n        end if ;\n        deallocate(WriteBuf) ;\n      end if ;\n    end procedure LocalCheck ;\n\n    ------------------------------------------------------------\n    -- Array of Tagged Scoreboards\n    procedure Check (\n    ------------------------------------------------------------\n      constant Index        : in  integer ;\n      constant Tag          : in  string ;\n      constant ActualData   : in  ActualType\n    ) is\n      variable FoundError   : boolean ;\n    begin\n      if LocalOutOfRange(Index, \"Check\") then\n        return ; -- error reporting in LocalOutOfRange\n      end if ;\n      LocalPop(Index, Tag, \"Check\") ;\n      LocalCheck(Index, ActualData, FoundError) ;\n    end procedure Check ;\n\n    ------------------------------------------------------------\n    -- Array of Scoreboards, no tag\n    procedure Check (\n    ------------------------------------------------------------\n      constant Index        : in  integer ;\n      constant ActualData   : in  ActualType\n    ) is\n      variable FoundError   : boolean ;\n    begin\n      if LocalOutOfRange(Index, \"Check\") then\n        return ; -- error reporting in LocalOutOfRange\n      end if ;\n      LocalPop(Index, \"\", \"Check\") ;\n      LocalCheck(Index, ActualData, FoundError) ;\n    end procedure Check ;\n\n    ------------------------------------------------------------\n    -- Simple Tagged Scoreboard\n    procedure Check (\n    ------------------------------------------------------------\n      constant Tag          : in  string ;\n      constant ActualData   : in  ActualType\n    ) is\n      variable FoundError   : boolean ;\n    begin\n      LocalPop(FirstIndexVar, Tag, \"Check\") ;\n      LocalCheck(FirstIndexVar, ActualData, FoundError) ;\n    end procedure Check ;\n\n    ------------------------------------------------------------\n    -- Simple Scoreboard, no tag\n    procedure Check (ActualData : ActualType) is\n    ------------------------------------------------------------\n      variable FoundError   : boolean ;\n    begin\n      LocalPop(FirstIndexVar, \"\", \"Check\") ;\n      LocalCheck(FirstIndexVar, ActualData, FoundError) ;\n    end procedure Check ;\n\n    ------------------------------------------------------------\n    -- Array of Tagged Scoreboards\n    impure function Check (\n    ------------------------------------------------------------\n      constant Index        : in  integer ;\n      constant Tag          : in  string ;\n      constant ActualData   : in  ActualType\n    ) return boolean is\n      variable FoundError   : boolean ;\n    begin\n      if LocalOutOfRange(Index, \"Function Check\") then\n        return FALSE ; -- error reporting in LocalOutOfRange\n      end if ;\n      LocalPop(Index, Tag, \"Check\") ;\n      LocalCheck(Index, ActualData, FoundError) ;\n      return not FoundError ;\n    end function Check ;\n\n    ------------------------------------------------------------\n    -- Array of Scoreboards, no tag\n    impure function Check (\n    ------------------------------------------------------------\n      constant Index        : in  integer ;\n      constant ActualData   : in  ActualType\n    ) return boolean is\n      variable FoundError   : boolean ;\n    begin\n      if LocalOutOfRange(Index, \"Function Check\") then\n        return FALSE ; -- error reporting in LocalOutOfRange\n      end if ;\n      LocalPop(Index, \"\", \"Check\") ;\n      LocalCheck(Index, ActualData, FoundError) ;\n      return not FoundError ;\n    end function Check ;\n\n    ------------------------------------------------------------\n    -- Simple Tagged Scoreboard\n    impure function Check (\n    ------------------------------------------------------------\n      constant Tag          : in  string ;\n      constant ActualData   : in  ActualType\n    ) return boolean is\n      variable FoundError   : boolean ;\n    begin\n      LocalPop(FirstIndexVar, Tag, \"Check\") ;\n      LocalCheck(FirstIndexVar, ActualData, FoundError) ;\n      return not FoundError ;\n    end function Check ;\n\n    ------------------------------------------------------------\n    -- Simple Scoreboard, no tag\n    impure function Check (ActualData : ActualType) return boolean is\n    ------------------------------------------------------------\n      variable FoundError   : boolean ;\n    begin\n      LocalPop(FirstIndexVar, \"\", \"Check\") ;\n      LocalCheck(FirstIndexVar, ActualData, FoundError) ;\n      return not FoundError ;\n    end function Check ;\n\n    ------------------------------------------------------------\n    -- Scoreboard Store.  Index. Tag.\n    impure function CheckExpected (\n    ------------------------------------------------------------\n      constant Index        : in  integer ;\n      constant Tag          : in  string ;\n      constant ExpectedData : in  ActualType\n    ) return boolean is\n      variable FoundError   : boolean ;\n    begin\n      if LocalOutOfRange(Index, \"Function Check\") then\n        return FALSE ; -- error reporting in LocalOutOfRange\n      end if ;\n      LocalPop(Index, Tag, \"Check\") ;\n      LocalCheck(Index, ExpectedData, FoundError, ExpectedInFIFO => FALSE) ;\n      return not FoundError ;\n    end function CheckExpected ;\n\n    ------------------------------------------------------------\n    -- Array of Tagged Scoreboards\n    procedure Pop (\n    ------------------------------------------------------------\n      constant Index  : in  integer ;\n      constant Tag    : in  string ;\n      variable Item   : out  ExpectedType\n    ) is\n    begin\n      if LocalOutOfRange(Index, \"Pop\") then\n        return ; -- error reporting in LocalOutOfRange\n      end if ;\n      LocalPop(Index, Tag, \"Pop\") ;\n      Item := PopListPointer(Index).ExpectedPtr.all ;\n    end procedure Pop ;\n\n    ------------------------------------------------------------\n    -- Array of Scoreboards, no tag\n    procedure Pop (\n    ------------------------------------------------------------\n      constant Index  : in  integer ;\n      variable Item   : out  ExpectedType\n    ) is\n    begin\n      if LocalOutOfRange(Index, \"Pop\") then\n        return ; -- error reporting in LocalOutOfRange\n      end if ;\n      LocalPop(Index, \"\", \"Pop\") ;\n      Item := PopListPointer(Index).ExpectedPtr.all ;\n    end procedure Pop ;\n\n    ------------------------------------------------------------\n    -- Simple Tagged Scoreboard\n    procedure Pop (\n    ------------------------------------------------------------\n      constant Tag    : in  string ;\n      variable Item   : out  ExpectedType\n    ) is\n    begin\n      LocalPop(FirstIndexVar, Tag, \"Pop\") ;\n      Item := PopListPointer(FirstIndexVar).ExpectedPtr.all ;\n    end procedure Pop ;\n\n    ------------------------------------------------------------\n    -- Simple Scoreboard, no tag\n    procedure Pop (variable Item : out  ExpectedType) is\n    ------------------------------------------------------------\n    begin\n      LocalPop(FirstIndexVar, \"\", \"Pop\") ;\n      Item := PopListPointer(FirstIndexVar).ExpectedPtr.all ;\n    end procedure Pop ;\n\n    ------------------------------------------------------------\n    -- Array of Tagged Scoreboards\n    impure function Pop (\n    ------------------------------------------------------------\n      constant Index  : in  integer ;\n      constant Tag    : in  string\n    ) return ExpectedType is\n    begin\n      if LocalOutOfRange(Index, \"Pop\") then\n        -- error reporting in LocalOutOfRange\n        return PopListPointer(FirstIndexVar).ExpectedPtr.all ;\n      end if ;\n      LocalPop(Index, Tag, \"Pop\") ;\n      return PopListPointer(Index).ExpectedPtr.all ;\n    end function Pop ;\n\n    ------------------------------------------------------------\n    -- Array of Scoreboards, no tag\n    impure function Pop (Index : integer) return ExpectedType is\n    ------------------------------------------------------------\n    begin\n      if LocalOutOfRange(Index, \"Pop\") then\n        -- error reporting in LocalOutOfRange\n        return PopListPointer(FirstIndexVar).ExpectedPtr.all ;\n      end if ;\n      LocalPop(Index, \"\", \"Pop\") ;\n      return PopListPointer(Index).ExpectedPtr.all ;\n    end function Pop ;\n\n    ------------------------------------------------------------\n    -- Simple Tagged Scoreboard\n    impure function Pop (\n    ------------------------------------------------------------\n      constant Tag : in  string\n    ) return ExpectedType is\n    begin\n      LocalPop(FirstIndexVar, Tag, \"Pop\") ;\n      return PopListPointer(FirstIndexVar).ExpectedPtr.all ;\n    end function Pop ;\n\n    ------------------------------------------------------------\n    -- Simple Scoreboard, no tag\n    impure function Pop return ExpectedType is\n    ------------------------------------------------------------\n    begin\n      LocalPop(FirstIndexVar, \"\", \"Pop\") ;\n      return PopListPointer(FirstIndexVar).ExpectedPtr.all ;\n    end function Pop ;\n\n    ------------------------------------------------------------\n    -- Local Only similar to LocalPop\n    -- Returns a pointer to the highest element matching Tag\n    impure function LocalPeek (Index : integer ; Tag : string) return ListPointerType is\n    ------------------------------------------------------------\n      variable CurPtr : ListPointerType ;\n    begin\n--!! LocalPeek does this, but so do each of the indexed calls\n--!!      if LocalOutOfRange(Index, \"Peek\") then\n--!!        return NULL ; -- error reporting in LocalOutOfRange\n--!!      end if ;\n      if HeadPointer(Index) = NULL then\n        ErrCntVar(Index) := ErrCntVar(Index) + 1 ;\n        Alert(AlertLogIDVar(Index), GetName & \" Empty during Peek\", FAILURE) ;\n        return NULL ;\n      end if ;\n      -- Descend to find Tag field and extract\n      CurPtr := HeadPointer(Index) ;\n      if CurPtr.TagPtr.all = Tag then\n        -- Non-tagged scoreboards find this one.\n        return CurPtr ;\n      else\n        loop\n          if CurPtr.NextPtr = NULL then\n            ErrCntVar(Index) := ErrCntVar(Index) + 1 ;\n            Alert(AlertLogIDVar(Index), GetName & \" Peek, tag: \" & Tag & \" not found\", FAILURE) ;\n            return NULL ;\n          elsif CurPtr.NextPtr.TagPtr.all = Tag then\n            return CurPtr.NextPtr ;\n          else\n            CurPtr := CurPtr.NextPtr ;\n          end if ;\n        end loop ;\n      end if ;\n    end function LocalPeek ;\n\n    ------------------------------------------------------------\n    -- Array of Tagged Scoreboards\n    procedure Peek (\n    ------------------------------------------------------------\n      constant Index  : in  integer ;\n      constant Tag    : in  string ;\n      variable Item   : out ExpectedType\n    ) is\n      variable CurPtr : ListPointerType ;\n    begin\n      if LocalOutOfRange(Index, \"Peek\") then\n        return ; -- error reporting in LocalOutOfRange\n      end if ;\n      CurPtr := LocalPeek(Index, Tag) ;\n      if CurPtr /= NULL then\n        Item := CurPtr.ExpectedPtr.all ;\n      end if ;\n    end procedure Peek ;\n\n    ------------------------------------------------------------\n    -- Array of Scoreboards, no tag\n    procedure Peek (\n    ------------------------------------------------------------\n      constant Index  : in  integer ;\n      variable Item   : out  ExpectedType\n    ) is\n      variable CurPtr : ListPointerType ;\n    begin\n      if LocalOutOfRange(Index, \"Peek\") then\n        return ; -- error reporting in LocalOutOfRange\n      end if ;\n      CurPtr := LocalPeek(Index, \"\") ;\n      if CurPtr /= NULL then\n        Item := CurPtr.ExpectedPtr.all ;\n      end if ;\n    end procedure Peek ;\n\n    ------------------------------------------------------------\n    -- Simple Tagged Scoreboard\n    procedure Peek (\n    ------------------------------------------------------------\n      constant Tag    : in  string ;\n      variable Item   : out  ExpectedType\n    ) is\n      variable CurPtr : ListPointerType ;\n    begin\n      CurPtr := LocalPeek(FirstIndexVar, Tag) ;\n      if CurPtr /= NULL then\n        Item := CurPtr.ExpectedPtr.all ;\n      end if ;\n    end procedure Peek ;\n\n    ------------------------------------------------------------\n    -- Simple Scoreboard, no tag\n    procedure Peek (variable Item : out  ExpectedType) is\n    ------------------------------------------------------------\n      variable CurPtr : ListPointerType ;\n    begin\n      CurPtr := LocalPeek(FirstIndexVar, \"\") ;\n      if CurPtr /= NULL then\n        Item := CurPtr.ExpectedPtr.all ;\n      end if ;\n    end procedure Peek ;\n\n    ------------------------------------------------------------\n    -- Array of Tagged Scoreboards\n    impure function Peek (\n    ------------------------------------------------------------\n      constant Index  : in  integer ;\n      constant Tag    : in  string\n    ) return ExpectedType is\n      variable CurPtr : ListPointerType ;\n    begin\n      if LocalOutOfRange(Index, \"Peek\") then\n        -- error reporting in LocalOutOfRange\n        return PopListPointer(FirstIndexVar).ExpectedPtr.all ;\n      end if ;\n      CurPtr := LocalPeek(Index, Tag) ;\n      if CurPtr /= NULL then\n        return CurPtr.ExpectedPtr.all ;\n      else\n        -- Already issued failure, continuing for debug only\n        return PopListPointer(FirstIndexVar).ExpectedPtr.all ;\n      end if ;\n    end function Peek ;\n\n    ------------------------------------------------------------\n    -- Array of Scoreboards, no tag\n    impure function Peek (Index : integer) return ExpectedType is\n    ------------------------------------------------------------\n      variable CurPtr : ListPointerType ;\n    begin\n      if LocalOutOfRange(Index, \"Peek\") then\n        -- error reporting in LocalOutOfRange\n        return PopListPointer(FirstIndexVar).ExpectedPtr.all ;\n      end if ;\n      CurPtr := LocalPeek(Index, \"\") ;\n      if CurPtr /= NULL then\n        return CurPtr.ExpectedPtr.all ;\n      else\n        -- Already issued failure, continuing for debug only\n        return PopListPointer(FirstIndexVar).ExpectedPtr.all ;\n      end if ;\n    end function Peek ;\n\n    ------------------------------------------------------------\n    -- Simple Tagged Scoreboard\n    impure function Peek (\n    ------------------------------------------------------------\n      constant Tag : in  string\n    ) return ExpectedType is\n      variable CurPtr : ListPointerType ;\n    begin\n      CurPtr := LocalPeek(FirstIndexVar, Tag) ;\n      if CurPtr /= NULL then\n        return CurPtr.ExpectedPtr.all ;\n      else\n        -- Already issued failure, continuing for debug only\n        return PopListPointer(FirstIndexVar).ExpectedPtr.all ;\n      end if ;\n    end function Peek ;\n\n    ------------------------------------------------------------\n    -- Simple Scoreboard, no tag\n    impure function Peek return ExpectedType is\n    ------------------------------------------------------------\n      variable CurPtr : ListPointerType ;\n    begin\n      CurPtr := LocalPeek(FirstIndexVar, \"\") ;\n      if CurPtr /= NULL then\n        return CurPtr.ExpectedPtr.all ;\n      else\n        -- Already issued failure, continuing for debug only\n        return PopListPointer(FirstIndexVar).ExpectedPtr.all ;\n      end if ;\n    end function Peek ;\n\n    ------------------------------------------------------------\n    -- Array of Tagged Scoreboards\n    impure function Empty (Index  : integer; Tag : String) return boolean is\n    ------------------------------------------------------------\n      variable CurPtr : ListPointerType ;\n    begin\n      CurPtr := HeadPointer(Index) ;\n      while CurPtr /= NULL loop\n        if CurPtr.TagPtr.all = Tag then\n          return FALSE ;   -- Found Tag\n        end if ;\n        CurPtr := CurPtr.NextPtr ;\n      end loop ;\n      return TRUE ;  -- Tag not found\n    end function Empty ;\n\n    ------------------------------------------------------------\n    -- Array of Scoreboards, no tag\n    impure function Empty (Index  : integer) return boolean is\n    ------------------------------------------------------------\n    begin\n      return HeadPointer(Index) = NULL ;\n    end function Empty ;\n\n    ------------------------------------------------------------\n    -- Simple Tagged Scoreboard\n    impure function Empty (Tag : String) return boolean is\n    ------------------------------------------------------------\n      variable CurPtr : ListPointerType ;\n    begin\n      return Empty(FirstIndexVar, Tag) ;\n    end function Empty ;\n\n    ------------------------------------------------------------\n    -- Simple Scoreboard, no tag\n    impure function Empty return boolean is\n    ------------------------------------------------------------\n    begin\n      return HeadPointer(FirstIndexVar) = NULL ;\n    end function Empty ;\n\n    ------------------------------------------------------------\n    procedure CheckFinish (\n    ------------------------------------------------------------\n      Index              : integer ;\n      FinishCheckCount   : integer ;\n      FinishEmpty        : boolean\n    ) is\n      variable EmptyError : Boolean ;\n      variable WriteBuf : line ;\n    begin\n      if AlertLogIDVar(Index) = OSVVM_SCOREBOARD_ALERTLOG_ID  then\n        write(WriteBuf, GetName(DefaultName => \"Scoreboard\")) ;\n      else\n        write(WriteBuf, GetName(DefaultName => \"\")) ;\n      end if ;\n      if ArrayLengthVar > 1 then\n        if WriteBuf.all /= \"\" then\n          swrite(WriteBuf, \" \") ;\n        end if ;\n        write(WriteBuf, \"Index(\" & to_string(Index) & \"),  \") ;\n      else\n        if WriteBuf.all /= \"\" then\n          swrite(WriteBuf, \",  \") ;\n        end if ;\n      end if ;\n      if FinishEmpty then\n        AffirmIf(AlertLogIDVar(Index), Empty(Index), WriteBuf.all & \"Checking Empty: \" & to_string(Empty(Index)) &\n                 \"  FinishEmpty: \" & to_string(FinishEmpty)) ;\n        if not Empty(Index) then\n          -- Increment internal count on FinishEmpty Error\n          ErrCntVar(Index) := ErrCntVar(Index) + 1 ;\n        end if ;\n      end if ;\n      AffirmIf(AlertLogIDVar(Index), CheckCountVar(Index) >= FinishCheckCount, WriteBuf.all &\n                 \"Checking CheckCount: \" & to_string(CheckCountVar(Index)) &\n                 \" >= Expected: \" & to_string(FinishCheckCount))  ;\n      if not (CheckCountVar(Index) >= FinishCheckCount) then\n        -- Increment internal count on FinishCheckCount Error\n        ErrCntVar(Index) := ErrCntVar(Index) + 1 ;\n      end if ;\n      deallocate(WriteBuf) ;\n    end procedure CheckFinish ;\n\n    ------------------------------------------------------------\n    procedure CheckFinish (\n    ------------------------------------------------------------\n      FinishCheckCount   : integer ;\n      FinishEmpty        : boolean\n    ) is\n    begin\n      for AlertLogID in AlertLogIDVar'range loop\n        CheckFinish(AlertLogID, FinishCheckCount, FinishEmpty) ;\n      end loop ;\n    end procedure CheckFinish ;\n\n    ------------------------------------------------------------\n    impure function GetErrorCount (Index : integer)  return integer is\n    ------------------------------------------------------------\n    begin\n      return ErrCntVar(Index) ;\n    end function GetErrorCount ;\n\n    ------------------------------------------------------------\n    impure function GetErrorCount return integer is\n    ------------------------------------------------------------\n      variable TotalErrorCount : integer := 0 ;\n    begin\n      for Index in AlertLogIDVar'range loop\n        TotalErrorCount := TotalErrorCount + GetErrorCount(Index) ;\n      end loop ;\n      return TotalErrorCount ;\n    end function GetErrorCount ;\n\n    ------------------------------------------------------------\n    procedure IncErrorCount (Index  : integer) is\n    ------------------------------------------------------------\n    begin\n      ErrCntVar(Index) := ErrCntVar(Index) + 1 ;\n      IncAlertCount(AlertLogIDVar(Index), ERROR) ;\n    end IncErrorCount ;\n\n    ------------------------------------------------------------\n    procedure IncErrorCount is\n    ------------------------------------------------------------\n    begin\n      ErrCntVar(FirstIndexVar) := ErrCntVar(FirstIndexVar) + 1 ;\n      IncAlertCount(AlertLogIDVar(FirstIndexVar), ERROR) ;\n    end IncErrorCount ;\n\n    ------------------------------------------------------------\n    procedure SetErrorCountZero (Index  : integer) is\n    ------------------------------------------------------------\n    begin\n      ErrCntVar(Index) := 0;\n    end procedure SetErrorCountZero ;\n\n    ------------------------------------------------------------\n    procedure SetErrorCountZero is\n    ------------------------------------------------------------\n    begin\n      ErrCntVar(FirstIndexVar) := 0 ;\n    end procedure SetErrorCountZero ;\n\n    ------------------------------------------------------------\n    procedure SetCheckCountZero (Index  : integer) is\n    ------------------------------------------------------------\n    begin\n      CheckCountVar(Index) := 0;\n    end procedure SetCheckCountZero ;\n\n    ------------------------------------------------------------\n    procedure SetCheckCountZero is\n    ------------------------------------------------------------\n    begin\n      CheckCountVar(FirstIndexVar) := 0;\n    end procedure SetCheckCountZero ;\n\n    ------------------------------------------------------------\n    impure function GetItemCount (Index  : integer) return integer is\n    ------------------------------------------------------------\n    begin\n      return ItemNumberVar(Index) ;\n    end function GetItemCount ;\n\n    ------------------------------------------------------------\n    impure function GetItemCount return integer is\n    ------------------------------------------------------------\n    begin\n      return ItemNumberVar(FirstIndexVar) ;\n    end function GetItemCount ;\n\n    ------------------------------------------------------------\n    impure function GetPushCount (Index  : integer) return integer is\n    ------------------------------------------------------------\n    begin\n      return ItemNumberVar(Index) ;\n    end function GetPushCount ;\n\n    ------------------------------------------------------------\n    impure function GetPushCount return integer is\n    ------------------------------------------------------------\n    begin\n      return ItemNumberVar(FirstIndexVar) ;\n    end function GetPushCount ;\n\n    ------------------------------------------------------------\n    impure function GetPopCount (Index  : integer) return integer is\n    ------------------------------------------------------------\n    begin\n      return PopCountVar(Index) ;\n    end function GetPopCount ;\n\n    ------------------------------------------------------------\n    impure function GetPopCount return integer is\n    ------------------------------------------------------------\n    begin\n      return PopCountVar(FirstIndexVar) ;\n    end function GetPopCount ;\n\n    ------------------------------------------------------------\n    impure function GetFifoCount (Index  : integer) return integer is\n    ------------------------------------------------------------\n    begin\n      return ItemNumberVar(Index) - PopCountVar(Index) - DropCountVar(Index) ;\n    end function GetFifoCount ;\n\n    ------------------------------------------------------------\n    impure function GetFifoCount return integer is\n    ------------------------------------------------------------\n    begin\n      return GetFifoCount(FirstIndexVar) ;\n    end function GetFifoCount ;\n\n    ------------------------------------------------------------\n    impure function GetCheckCount (Index  : integer) return integer is\n    ------------------------------------------------------------\n    begin\n      return CheckCountVar(Index) ;\n    end function GetCheckCount ;\n\n    ------------------------------------------------------------\n    impure function GetCheckCount return integer is\n    ------------------------------------------------------------\n    begin\n      return CheckCountVar(FirstIndexVar) ;\n    end function GetCheckCount ;\n\n    ------------------------------------------------------------\n    impure function GetDropCount (Index  : integer) return integer is\n    ------------------------------------------------------------\n    begin\n      return DropCountVar(Index) ;\n    end function GetDropCount ;\n\n    ------------------------------------------------------------\n    impure function GetDropCount return integer is\n    ------------------------------------------------------------\n    begin\n      return DropCountVar(FirstIndexVar) ;\n    end function GetDropCount ;\n\n    ------------------------------------------------------------\n    procedure SetFinish (\n    ------------------------------------------------------------\n      Index       : integer ;\n      FCheckCount : integer ;\n      FEmpty      : boolean := TRUE;\n      FStatus     : boolean := TRUE\n    ) is\n    begin\n      Alert(AlertLogIDVar(Index), \"OSVVM.ScoreboardGenericPkg.SetFinish: Deprecated and removed.  See CheckFinish\", ERROR) ;\n    end procedure SetFinish ;\n\n    ------------------------------------------------------------\n    procedure SetFinish (\n    ------------------------------------------------------------\n      FCheckCount : integer ;\n      FEmpty      : boolean := TRUE;\n      FStatus     : boolean := TRUE\n    ) is\n    begin\n      SetFinish(FirstIndexVar, FCheckCount, FEmpty, FStatus) ;\n    end procedure SetFinish ;\n\n    ------------------------------------------------------------\n    -- Array of Tagged Scoreboards\n    -- Find Element with Matching Tag and ActualData\n    -- Returns integer'left if no match found\n    impure function Find (\n    ------------------------------------------------------------\n      constant Index       :  in  integer ;\n      constant Tag         :  in  string;\n      constant ActualData  :  in  ActualType\n    ) return integer is\n      variable CurPtr : ListPointerType ;\n    begin\n      if LocalOutOfRange(Index, \"Find\") then\n        return integer'left ; -- error reporting in LocalOutOfRange\n      end if ;\n      CurPtr := HeadPointer(Index) ;\n      loop\n        if CurPtr = NULL then\n          -- Failed to find it\n          ErrCntVar(Index) := ErrCntVar(Index) + 1 ;\n          if Tag /= \"\" then\n            Alert(AlertLogIDVar(Index),\n                  GetName & \" Did not find Tag: \" & Tag & \" and Actual Data: \" & actual_to_string(ActualData),\n                  FAILURE ) ;\n          else\n            Alert(AlertLogIDVar(Index),\n                  GetName & \" Did not find Actual Data: \" & actual_to_string(ActualData),\n                  FAILURE ) ;\n          end if ;\n          return integer'left ;\n\n        elsif CurPtr.TagPtr.all = Tag and\n          Match(ActualData, CurPtr.ExpectedPtr.all) then\n          -- Found it.  Return Index.\n          return CurPtr.ItemNumber ;\n\n        else  -- Descend\n          CurPtr := CurPtr.NextPtr ;\n        end if ;\n      end loop ;\n    end function Find ;\n\n    ------------------------------------------------------------\n    -- Array of Simple Scoreboards\n    -- Find Element with Matching ActualData\n    impure function Find (\n    ------------------------------------------------------------\n      constant Index       :  in  integer ;\n      constant ActualData  :  in  ActualType\n    ) return integer is\n    begin\n      return Find(Index, \"\", ActualData) ;\n    end function Find ;\n\n    ------------------------------------------------------------\n    -- Tagged Scoreboard\n    -- Find Element with Matching ActualData\n    impure function Find (\n    ------------------------------------------------------------\n      constant Tag         :  in  string;\n      constant ActualData  :  in  ActualType\n    ) return integer is\n    begin\n      return Find(FirstIndexVar, Tag, ActualData) ;\n    end function Find ;\n\n    ------------------------------------------------------------\n    -- Simple Scoreboard\n    -- Find Element with Matching ActualData\n    impure function Find (\n    ------------------------------------------------------------\n      constant ActualData  :  in  ActualType\n    ) return integer is\n    begin\n      return Find(FirstIndexVar, \"\", ActualData) ;\n    end function Find ;\n\n    ------------------------------------------------------------\n    -- Array of Tagged Scoreboards\n    -- Flush Remove elements with tag whose itemNumber is <= ItemNumber parameter\n    procedure Flush (\n    ------------------------------------------------------------\n      constant Index       :  in  integer ;\n      constant Tag         :  in  string ;\n      constant ItemNumber  :  in  integer\n    ) is\n      variable CurPtr, RemovePtr, LastPtr : ListPointerType ;\n    begin\n      if LocalOutOfRange(Index, \"Flush\") then\n        return ; -- error reporting in LocalOutOfRange\n      end if ;\n      CurPtr  := HeadPointer(Index) ;\n      LastPtr := NULL ;\n      loop\n        if CurPtr = NULL then\n          -- Done\n          return ;\n        elsif CurPtr.TagPtr.all = Tag then\n          if ItemNumber >= CurPtr.ItemNumber then\n            -- remove it\n            RemovePtr := CurPtr ;\n            if CurPtr = TailPointer(Index) then\n              TailPointer(Index) := LastPtr ;\n            end if ;\n            if CurPtr = HeadPointer(Index) then\n              HeadPointer(Index) := CurPtr.NextPtr ;\n            else -- if LastPtr /= NULL then\n              LastPtr.NextPtr := LastPtr.NextPtr.NextPtr ;\n            end if ;\n            CurPtr := CurPtr.NextPtr ;\n            -- LastPtr := LastPtr ; -- no change\n            DropCountVar(Index) := DropCountVar(Index) + 1 ;\n            deallocate(RemovePtr.TagPtr) ;\n            deallocate(RemovePtr.ExpectedPtr) ;\n            deallocate(RemovePtr) ;\n          else\n            -- Done\n            return ;\n          end if ;\n        else\n          -- Descend\n          LastPtr := CurPtr ;\n          CurPtr  := CurPtr.NextPtr ;\n        end if ;\n      end loop ;\n    end procedure Flush ;\n\n    ------------------------------------------------------------\n    -- Tagged Scoreboard\n    -- Flush Remove elements with tag whose itemNumber is <= ItemNumber parameter\n    procedure Flush (\n    ------------------------------------------------------------\n      constant Tag         :  in  string ;\n      constant ItemNumber  :  in  integer\n    ) is\n    begin\n      Flush(FirstIndexVar, Tag, ItemNumber) ;\n    end procedure Flush ;\n\n    ------------------------------------------------------------\n    -- Array of Simple Scoreboards\n    -- Flush - Remove Elements upto and including the one with ItemNumber\n    procedure Flush (\n    ------------------------------------------------------------\n      constant Index       :  in  integer ;\n      constant ItemNumber  :  in  integer\n    ) is\n      variable CurPtr : ListPointerType ;\n    begin\n      if LocalOutOfRange(Index, \"Find\") then\n        return ; -- error reporting in LocalOutOfRange\n      end if ;\n      CurPtr  := HeadPointer(Index) ;\n      loop\n        if CurPtr = NULL then\n          -- Done\n          return ;\n        elsif ItemNumber >= CurPtr.ItemNumber then\n          -- Descend, Check Tail, Deallocate\n          HeadPointer(Index) := HeadPointer(Index).NextPtr ;\n          if CurPtr = TailPointer(Index) then\n            TailPointer(Index) := NULL ;\n          end if ;\n          DropCountVar(Index) := DropCountVar(Index) + 1 ;\n          deallocate(CurPtr.TagPtr) ;\n          deallocate(CurPtr.ExpectedPtr) ;\n          deallocate(CurPtr) ;\n          CurPtr := HeadPointer(Index) ;\n        else\n          -- Done\n          return ;\n        end if ;\n      end loop ;\n    end procedure Flush ;\n\n    ------------------------------------------------------------\n    -- Simple Scoreboard\n    -- Flush - Remove Elements upto and including the one with ItemNumber\n    procedure Flush (\n    ------------------------------------------------------------\n      constant ItemNumber  :  in  integer\n    ) is\n    begin\n      Flush(FirstIndexVar, ItemNumber) ;\n    end procedure Flush ;\n\n\n    ------------------------------------------------------------\n    impure function GotScoreboards return boolean is\n    ------------------------------------------------------------\n    begin\n      return CalledNewID ;\n    end function GotScoreboards ;\n\n\n    ------------------------------------------------------------\n    --  pt local\n    procedure WriteScoreboardYaml (Index : integer; file CovYamlFile : text) is\n    ------------------------------------------------------------\n      variable buf       : line ;\n      constant NAME_PREFIX : string := \"  \" ;\n    begin\n      write(buf, NAME_PREFIX & \"- Name:         \" & '\"' & string'(GetAlertLogName(AlertLogIDVar(Index))) & '\"' & LF) ;\n      write(buf, NAME_PREFIX & \"  ParentName:   \" & '\"' & string'(GetAlertLogName(GetAlertLogParentID(AlertLogIDVar(Index)))) & '\"' & LF) ;\n      write(buf, NAME_PREFIX & \"  ItemCount:    \" & '\"' & to_string(ItemNumberVar(Index))       & '\"' & LF) ;\n      write(buf, NAME_PREFIX & \"  ErrorCount:   \" & '\"' & to_string(ErrCntVar(Index))           & '\"' & LF) ;\n      write(buf, NAME_PREFIX & \"  ItemsChecked: \" & '\"' & to_string(CheckCountVar(Index))       & '\"' & LF) ;\n      write(buf, NAME_PREFIX & \"  ItemsPopped:  \" & '\"' & to_string(PopCountVar(Index))         & '\"' & LF) ;\n      write(buf, NAME_PREFIX & \"  ItemsDropped: \" & '\"' & to_string(DropCountVar(Index))        & '\"' & LF) ;\n      write(buf, NAME_PREFIX & \"  FifoCount: \"    & '\"' & to_string(GetFifoCount(Index))        & '\"' ) ;\n      writeline(CovYamlFile, buf) ;\n    end procedure WriteScoreboardYaml ;\n\n    ------------------------------------------------------------\n    procedure WriteScoreboardYaml (FileName : string := \"\"; OpenKind : File_Open_Kind := WRITE_MODE) is\n    ------------------------------------------------------------\n      constant RESOLVED_FILE_NAME : string := IfElse(FileName = \"\", OSVVM_OUTPUT_DIRECTORY & GetTestName & \"_sb.yml\", FileName) ;\n      file SbYamlFile : text open OpenKind is RESOLVED_FILE_NAME ;\n      variable buf : line ;\n    begin\n      if AlertLogIDVar = NULL or AlertLogIDVar'length <= 0 then\n        Alert(\"Scoreboard.WriteScoreboardYaml: no scoreboards defined \", ERROR) ;\n        return ;\n      end if ;\n\n      swrite(buf, \"Version: 1.1\" & LF) ;\n      swrite(buf, \"TestCase: \" & '\"' & GetAlertLogName & '\"' & LF) ;\n      swrite(buf, \"Scoreboards: \") ;\n      writeline(SbYamlFile, buf) ;\n      if CalledNewID then\n        -- Used by singleton\n        for i in 1 to NumItems loop\n          WriteScoreboardYaml(i, SbYamlFile) ;\n        end loop ;\n      else\n        -- Used by PT method, but not singleton\n        for i in AlertLogIDVar'range loop\n          WriteScoreboardYaml(i, SbYamlFile) ;\n        end loop ;\n      end if ;\n      file_close(SbYamlFile) ;\n    end procedure WriteScoreboardYaml ;\n\n    ------------------------------------------------------------\n    ------------------------------------------------------------\n    -- Remaining Deprecated.\n    ------------------------------------------------------------\n    ------------------------------------------------------------\n\n    ------------------------------------------------------------\n    -- Deprecated.  Maintained for backward compatibility.\n    -- Use TranscriptPkg.TranscriptOpen\n    procedure FileOpen (FileName : string; OpenKind : File_Open_Kind ) is\n    ------------------------------------------------------------\n    begin\n      -- WriteFileInit := TRUE ;\n      -- file_open( WriteFile , FileName , OpenKind );\n      TranscriptOpen(FileName, OpenKind) ;\n    end procedure FileOpen ;\n\n\n    ------------------------------------------------------------\n    -- Deprecated.  Maintained for backward compatibility.\n    procedure PutExpectedData (ExpectedData : ExpectedType) is\n    ------------------------------------------------------------\n    begin\n      Push(ExpectedData) ;\n    end procedure PutExpectedData ;\n\n    ------------------------------------------------------------\n    -- Deprecated.  Maintained for backward compatibility.\n    procedure CheckActualData (ActualData : ActualType) is\n    ------------------------------------------------------------\n    begin\n      Check(ActualData) ;\n    end procedure CheckActualData ;\n\n    ------------------------------------------------------------\n    -- Deprecated.  Maintained for backward compatibility.\n    impure function GetItemNumber return integer is\n    ------------------------------------------------------------\n    begin\n      return GetItemCount(FirstIndexVar) ;\n    end GetItemNumber ;\n\n    ------------------------------------------------------------\n    -- Deprecated.  Maintained for backward compatibility.\n    procedure SetMessage (MessageIn : String) is\n    ------------------------------------------------------------\n    begin\n      -- deallocate(Message) ;\n      -- Message := new string'(MessageIn) ;\n      SetName(MessageIn) ;\n    end procedure SetMessage ;\n\n    ------------------------------------------------------------\n    -- Deprecated.  Maintained for backward compatibility.\n    impure function GetMessage return string is\n    ------------------------------------------------------------\n    begin\n      -- return Message.all ;\n      return GetName(\"Scoreboard\") ;\n    end function GetMessage ;\n\n--!!    ------------------------------------------------------------\n--!!    -- Deprecated Call to NewID, refactored to call new version of NewID\n--!!    impure function NewID (Name : String ; ParentAlertLogID : AlertLogIDType; DoNotReport : Boolean) return ScoreboardIDType is\n--!!    ------------------------------------------------------------\n--!!      variable ReportMode : AlertLogReportModeType ;\n--!!    begin\n--!!      ReportMode := ENABLED when not DoNotReport else DISABLED ;\n--!!      return NewID(Name, ParentAlertLogID, ReportMode => ReportMode) ;\n--!!    end function NewID ;\n--!!\n--!!    ------------------------------------------------------------\n--!!    -- Deprecated Call to NewID, refactored to call new version of NewID\n--!!    -- Vector: 1 to Size\n--!!    impure function NewID (Name : String ; Size : positive ; ParentAlertLogID : AlertLogIDType; DoNotReport : Boolean) return ScoreboardIDArrayType is\n--!!    ------------------------------------------------------------\n--!!      variable ReportMode : AlertLogReportModeType ;\n--!!    begin\n--!!      ReportMode := ENABLED when not DoNotReport else DISABLED ;\n--!!      return NewID(Name, (1, Size) , ParentAlertLogID, ReportMode => ReportMode) ;\n--!!    end function NewID ;\n--!!\n--!!    ------------------------------------------------------------\n--!!    -- Deprecated Call to NewID, refactored to call new version of NewID\n--!!    -- Vector: X(X'Left) to X(X'Right)\n--!!    impure function NewID (Name : String ; X : integer_vector ; ParentAlertLogID : AlertLogIDType; DoNotReport : Boolean) return ScoreboardIDArrayType is\n--!!    ------------------------------------------------------------\n--!!      variable ReportMode     : AlertLogReportModeType ;\n--!!    begin\n--!!      ReportMode := ENABLED when not DoNotReport else DISABLED ;\n--!!      return NewID(Name, X, ParentAlertLogID, ReportMode => ReportMode) ;\n--!!    end function NewID ;\n--!!\n--!!    ------------------------------------------------------------\n--!!    -- Deprecated Call to NewID, refactored to call new version of NewID\n--!!    -- Matrix: 1 to X, 1 to Y\n--!!    impure function NewID (Name : String ; X, Y : positive ; ParentAlertLogID : AlertLogIDType; DoNotReport : Boolean) return ScoreboardIdMatrixType is\n--!!    ------------------------------------------------------------\n--!!      variable ReportMode     : AlertLogReportModeType ;\n--!!    begin\n--!!      ReportMode := ENABLED when not DoNotReport else DISABLED ;\n--!!      return NewID(Name, X, Y, ParentAlertLogID, ReportMode => ReportMode) ;\n--!!    end function NewID ;\n--!!\n--!!    ------------------------------------------------------------\n--!!    -- Deprecated Call to NewID, refactored to call new version of NewID\n--!!    -- Matrix: X(X'Left) to X(X'Right), Y(Y'Left) to Y(Y'Right)\n--!!    impure function NewID (Name : String ; X, Y : integer_vector ; ParentAlertLogID : AlertLogIDType; DoNotReport : Boolean) return ScoreboardIdMatrixType is\n--!!    ------------------------------------------------------------\n--!!      variable ReportMode     : AlertLogReportModeType ;\n--!!    begin\n--!!      ReportMode := ENABLED when not DoNotReport else DISABLED ;\n--!!      return NewID(Name, X, Y, ParentAlertLogID, ReportMode => ReportMode) ;\n--!!    end function NewID ;\n\n  end protected body ScoreBoardPType ;\n\n  shared variable ScoreboardStore : ScoreBoardPType ;\n\n  ------------------------------------------------------------\n  -- Used by Scoreboard Store\n  impure function NewID (\n    Name          : String ;\n    ParentID      : AlertLogIDType          := OSVVM_SCOREBOARD_ALERTLOG_ID ;\n    ReportMode    : AlertLogReportModeType  := ENABLED ;\n    Search        : NameSearchType          := PRIVATE_NAME ;\n    PrintParent   : AlertLogPrintParentType := PRINT_NAME_AND_PARENT\n  ) return ScoreboardIDType is\n  ------------------------------------------------------------\n  begin\n    return ScoreboardStore.NewID(Name, ParentID, ReportMode, Search, PrintParent) ;\n  end function NewID ;\n\n  ------------------------------------------------------------\n  -- Vector: 1 to Size\n  impure function NewID (\n    Name          : String ;\n    Size          : positive ;\n    ParentID      : AlertLogIDType          := OSVVM_SCOREBOARD_ALERTLOG_ID ;\n    ReportMode    : AlertLogReportModeType  := ENABLED ;\n    Search        : NameSearchType          := PRIVATE_NAME ;\n    PrintParent   : AlertLogPrintParentType := PRINT_NAME_AND_PARENT\n  ) return ScoreboardIDArrayType is\n  ------------------------------------------------------------\n  begin\n    return ScoreboardStore.NewID(Name, Size, ParentID, ReportMode, Search, PrintParent) ;\n  end function NewID ;\n\n  ------------------------------------------------------------\n  -- Vector: X(X'Left) to X(X'Right)\n  impure function NewID (\n    Name          : String ;\n    X             : integer_vector ;\n    ParentID      : AlertLogIDType          := OSVVM_SCOREBOARD_ALERTLOG_ID ;\n    ReportMode    : AlertLogReportModeType  := ENABLED ;\n    Search        : NameSearchType          := PRIVATE_NAME ;\n    PrintParent   : AlertLogPrintParentType := PRINT_NAME_AND_PARENT\n  ) return ScoreboardIDArrayType is\n  ------------------------------------------------------------\n  begin\n    return ScoreboardStore.NewID(Name, X, ParentID, ReportMode, Search, PrintParent) ;\n  end function NewID ;\n\n  ------------------------------------------------------------\n  -- Matrix: 1 to X, 1 to Y\n  impure function NewID (\n    Name          : String ;\n    X, Y          : positive ;\n    ParentID      : AlertLogIDType          := OSVVM_SCOREBOARD_ALERTLOG_ID ;\n    ReportMode    : AlertLogReportModeType  := ENABLED ;\n    Search        : NameSearchType          := PRIVATE_NAME ;\n    PrintParent   : AlertLogPrintParentType := PRINT_NAME_AND_PARENT\n  ) return ScoreboardIdMatrixType is\n  ------------------------------------------------------------\n  begin\n    return ScoreboardStore.NewID(Name, X, Y, ParentID, ReportMode, Search, PrintParent) ;\n  end function NewID ;\n\n  ------------------------------------------------------------\n  -- Matrix: X(X'Left) to X(X'Right), Y(Y'Left) to Y(Y'Right)\n  impure function NewID (\n    Name          : String ;\n    X, Y          : integer_vector ;\n    ParentID      : AlertLogIDType          := OSVVM_SCOREBOARD_ALERTLOG_ID ;\n    ReportMode    : AlertLogReportModeType  := ENABLED ;\n    Search        : NameSearchType          := PRIVATE_NAME ;\n    PrintParent   : AlertLogPrintParentType := PRINT_NAME_AND_PARENT\n  ) return ScoreboardIdMatrixType is\n  ------------------------------------------------------------\n  begin\n    return ScoreboardStore.NewID(Name, X, Y, ParentID, ReportMode, Search, PrintParent) ;\n  end function NewID ;\n\n\n\n  ------------------------------------------------------------\n  -- Push items into the scoreboard/FIFO\n\n  ------------------------------------------------------------\n  -- Simple Scoreboard, no tag\n  procedure Push (\n  ------------------------------------------------------------\n    constant ID     : in  ScoreboardIDType ;\n    constant Item   : in  ExpectedType\n  ) is\n  begin\n    ScoreboardStore.Push(ID.ID, Item) ;\n  end procedure Push ;\n\n  -- Simple Tagged Scoreboard\n  procedure Push (\n    constant ID     : in  ScoreboardIDType ;\n    constant Tag    : in  string ;\n    constant Item   : in  ExpectedType\n  ) is\n  begin\n    ScoreboardStore.Push(ID.ID, Tag, Item) ;\n  end procedure Push ;\n\n  ------------------------------------------------------------\n  -- Check received item with item in the scoreboard/FIFO\n\n  -- Simple Scoreboard, no tag\n  procedure Check (\n    constant ID           : in  ScoreboardIDType ;\n    constant ActualData   : in ActualType\n  ) is\n  begin\n    ScoreboardStore.Check(ID.ID, ActualData) ;\n  end procedure Check ;\n\n  -- Simple Tagged Scoreboard\n  procedure Check (\n    constant ID           : in  ScoreboardIDType ;\n    constant Tag          : in  string ;\n    constant ActualData   : in  ActualType\n  ) is\n  begin\n    ScoreboardStore.Check(ID.ID, Tag, ActualData) ;\n  end procedure Check ;\n\n  -- Simple Scoreboard, no tag\n  impure function Check (\n    constant ID           : in  ScoreboardIDType ;\n    constant ActualData   : in ActualType\n  ) return boolean is\n  begin\n    return ScoreboardStore.Check(ID.ID, ActualData) ;\n  end function Check ;\n\n  -- Simple Tagged Scoreboard\n  impure function Check (\n    constant ID           : in  ScoreboardIDType ;\n    constant Tag          : in  string ;\n    constant ActualData   : in  ActualType\n  ) return boolean is\n  begin\n    return ScoreboardStore.Check(ID.ID, Tag, ActualData) ;\n  end function Check ;\n\n  -------------\n  ----------------------------------------------\n  -- Simple Scoreboard, no tag\n  procedure CheckExpected (\n    constant ID           : in  ScoreboardIDType ;\n    constant ExpectedData : in  ActualType\n  ) is\n    variable Passed : boolean ;\n  begin\n    Passed := ScoreboardStore.CheckExpected(ID.ID, \"\", ExpectedData) ;\n  end procedure CheckExpected ;\n\n  -- Simple Tagged Scoreboard\n  procedure CheckExpected (\n    constant ID           : in  ScoreboardIDType ;\n    constant Tag          : in  string ;\n    constant ExpectedData : in  ActualType\n  ) is\n    variable Passed : boolean ;\n  begin\n    Passed := ScoreboardStore.CheckExpected(ID.ID, Tag, ExpectedData) ;\n  end procedure CheckExpected ;\n\n  -- Simple Scoreboard, no tag\n  impure function CheckExpected (\n    constant ID           : in  ScoreboardIDType ;\n    constant ExpectedData : in  ActualType\n  ) return boolean is\n  begin\n    return ScoreboardStore.CheckExpected(ID.ID, \"\", ExpectedData) ;\n  end function CheckExpected ;\n\n  -- Simple Tagged Scoreboard\n  impure function CheckExpected (\n    constant ID           : in  ScoreboardIDType ;\n    constant Tag          : in  string ;\n    constant ExpectedData : in  ActualType\n  ) return boolean is\n  begin\n    return ScoreboardStore.CheckExpected(ID.ID, Tag, ExpectedData) ;\n  end function CheckExpected ;\n\n  ------------------------------------------------------------\n  -- Pop the top item (FIFO) from the scoreboard/FIFO\n\n  -- Simple Scoreboard, no tag\n  procedure Pop (\n    constant ID     : in  ScoreboardIDType ;\n    variable Item   : out  ExpectedType\n  ) is\n  begin\n    ScoreboardStore.Pop(ID.ID, Item) ;\n  end procedure Pop ;\n\n  -- Simple Tagged Scoreboard\n  procedure Pop (\n    constant ID     : in  ScoreboardIDType ;\n    constant Tag    : in  string ;\n    variable Item   : out  ExpectedType\n  ) is\n  begin\n    ScoreboardStore.Pop(ID.ID, Tag, Item) ;\n  end procedure Pop ;\n\n\n  ------------------------------------------------------------\n  -- Pop the top item (FIFO) from the scoreboard/FIFO\n  -- Caution:  this did not work in older simulators (@2013)\n\n  -- Simple Scoreboard, no tag\n  impure function Pop (\n    constant ID     : in  ScoreboardIDType\n  ) return ExpectedType is\n  begin\n    return ScoreboardStore.Pop(ID.ID) ;\n  end function Pop ;\n\n  -- Simple Tagged Scoreboard\n  impure function Pop (\n    constant ID     : in  ScoreboardIDType ;\n    constant Tag    : in  string\n  ) return ExpectedType is\n  begin\n    return ScoreboardStore.Pop(ID.ID, Tag) ;\n  end function Pop ;\n\n\n  ------------------------------------------------------------\n  -- Peek at the top item (FIFO) from the scoreboard/FIFO\n\n  -- Simple Tagged Scoreboard\n  procedure Peek (\n    constant ID     : in  ScoreboardIDType ;\n    constant Tag    : in  string ;\n    variable Item   : out ExpectedType\n  ) is\n  begin\n    ScoreboardStore.Peek(ID.ID, Tag, Item) ;\n  end procedure Peek ;\n\n  -- Simple Scoreboard, no tag\n  procedure Peek (\n    constant ID     : in  ScoreboardIDType ;\n    variable Item   : out  ExpectedType\n  ) is\n  begin\n    ScoreboardStore.Peek(ID.ID, Item) ;\n  end procedure Peek ;\n\n  ------------------------------------------------------------\n  -- Peek at the top item (FIFO) from the scoreboard/FIFO\n  -- Caution:  this did not work in older simulators (@2013)\n\n  -- Tagged Scoreboards\n  impure function Peek (\n    constant ID     : in  ScoreboardIDType ;\n    constant Tag    : in  string\n  ) return ExpectedType is\n  begin\n--      return ScoreboardStore.Peek(Tag) ;\n--    log(\"Issues compiling return later\");\n    return ScoreboardStore.Peek(Index => ID.ID, Tag => Tag) ;\n  end function Peek ;\n\n  -- Simple Scoreboard\n  impure function Peek (\n    constant ID     : in  ScoreboardIDType\n  ) return ExpectedType is\n  begin\n    return ScoreboardStore.Peek(Index => ID.ID) ;\n  end function Peek ;\n\n  ------------------------------------------------------------\n  -- ScoreboardEmpty - check to see if scoreboard is empty\n  -- Simple\n  impure function ScoreboardEmpty (\n    constant ID     : in  ScoreboardIDType\n  ) return boolean is\n  begin\n    return ScoreboardStore.Empty(ID.ID) ;\n  end function ScoreboardEmpty ;\n\n  -- Tagged\n  impure function ScoreboardEmpty (\n    constant ID     : in  ScoreboardIDType ;\n    constant Tag    : in  string\n  ) return boolean is\n  begin\n    return ScoreboardStore.Empty(ID.ID, Tag) ;\n  end function ScoreboardEmpty ;\n\n  impure function Empty (\n    constant ID     : in  ScoreboardIDType\n  ) return boolean is\n  begin\n    return ScoreboardStore.Empty(ID.ID) ;\n  end function Empty ;\n\n  -- Tagged\n  impure function Empty (\n    constant ID     : in  ScoreboardIDType ;\n    constant Tag    : in  string\n  ) return boolean is\n  begin\n    return ScoreboardStore.Empty(ID.ID, Tag) ;\n  end function Empty ;\n\n--!!  ------------------------------------------------------------\n--!!  -- SetAlertLogID - associate an AlertLogID with a scoreboard to allow integrated error reporting\n--!!  procedure SetAlertLogID(\n--!!    constant ID              : in  ScoreboardIDType ;\n--!!    constant Name            : in  string ;\n--!!    constant ParentID        : in  AlertLogIDType := OSVVM_SCOREBOARD_ALERTLOG_ID ;\n--!!    constant CreateHierarchy : in  Boolean := TRUE ;\n--!!    constant DoNotReport     : in  Boolean := FALSE\n--!!  ) is\n--!!  begin\n--!!    ScoreboardStore.SetAlertLogID(ID.ID, Name, ParentID, CreateHierarchy, DoNotReport) ;\n--!!  end procedure SetAlertLogID ;\n--!!\n--!!  -- Use when an AlertLogID is used by multiple items (Model or other Scoreboards).  See also AlertLogPkg.GetAlertLogID\n--!!  procedure SetAlertLogID (\n--!!    constant ID     : in  ScoreboardIDType ;\n--!!    constant A      : AlertLogIDType\n--!!  ) is\n--!!  begin\n--!!    ScoreboardStore.SetAlertLogID(ID.ID, A) ;\n--!!  end procedure SetAlertLogID ;\n\n  impure function GetAlertLogID (\n    constant ID     : in  ScoreboardIDType\n  ) return AlertLogIDType is\n  begin\n    return ScoreboardStore.GetAlertLogID(ID.ID) ;\n  end function GetAlertLogID ;\n\n\n  ------------------------------------------------------------\n  -- Scoreboard Introspection\n\n  -- Number of items put into scoreboard\n  impure function GetItemCount (\n    constant ID     : in  ScoreboardIDType\n  ) return integer is\n  begin\n    return ScoreboardStore.GetItemCount(ID.ID) ;\n  end function GetItemCount ;\n\n  impure function GetPushCount (\n    constant ID     : in  ScoreboardIDType\n  ) return integer is\n  begin\n    return ScoreboardStore.GetPushCount(ID.ID) ;\n  end function GetPushCount ;\n\n  -- Number of items removed from scoreboard by pop or check\n  impure function GetPopCount (\n    constant ID     : in  ScoreboardIDType\n  ) return integer is\n  begin\n    return ScoreboardStore.GetPopCount(ID.ID) ;\n  end function GetPopCount ;\n\n  -- Number of items currently in the scoreboard (= PushCount - PopCount - DropCount)\n  impure function GetFifoCount (\n    constant ID     : in  ScoreboardIDType\n  ) return integer is\n  begin\n    return ScoreboardStore.GetFifoCount(ID.ID) ;\n  end function GetFifoCount ;\n\n  -- Number of items checked by scoreboard\n  impure function GetCheckCount (\n    constant ID     : in  ScoreboardIDType\n  ) return integer is\n  begin\n    return ScoreboardStore.GetCheckCount(ID.ID) ;\n  end function GetCheckCount ;\n\n  -- Number of items dropped by scoreboard.  See Find/Flush\n  impure function GetDropCount (\n    constant ID     : in  ScoreboardIDType\n  ) return integer is\n  begin\n    return ScoreboardStore.GetDropCount(ID.ID) ;\n  end function GetDropCount ;\n\n  ------------------------------------------------------------\n  -- Find - Returns the ItemNumber for a value and tag (if applicable) in a scoreboard.\n  -- Find returns integer'left if no match found\n  -- Also See Flush.  Flush will drop items up through the ItemNumber\n\n  -- Simple Scoreboard\n  impure function Find (\n    constant ID          : in  ScoreboardIDType ;\n    constant ActualData  : in  ActualType\n  ) return integer is\n  begin\n    return ScoreboardStore.Find(ID.ID, ActualData) ;\n  end function Find ;\n\n  -- Tagged Scoreboard\n  impure function Find (\n    constant ID          : in  ScoreboardIDType ;\n    constant Tag         : in  string;\n    constant ActualData  : in  ActualType\n  ) return integer is\n  begin\n    return ScoreboardStore.Find(ID.ID, Tag, ActualData) ;\n  end function Find ;\n\n  ------------------------------------------------------------\n  -- Flush - Remove elements in the scoreboard upto and including the one with ItemNumber\n  -- See Find to identify an ItemNumber of a particular value and tag (if applicable)\n\n  -- Simple Scoreboards\n  procedure Flush (\n    constant ID          :  in  ScoreboardIDType ;\n    constant ItemNumber  :  in  integer\n  ) is\n  begin\n    ScoreboardStore.Flush(ID.ID, ItemNumber) ;\n  end procedure Flush ;\n\n\n  -- Tagged Scoreboards - only removes items that also match the tag\n  procedure Flush (\n    constant ID          :  in  ScoreboardIDType ;\n    constant Tag         :  in  string ;\n    constant ItemNumber  :  in  integer\n  ) is\n  begin\n    ScoreboardStore.Flush(ID.ID, Tag, ItemNumber) ;\n  end procedure Flush ;\n\n\n  ------------------------------------------------------------\n  -- Scoreboard YAML Reports\n  impure function GotScoreboards return boolean is\n  begin\n    return ScoreboardStore.GotScoreboards ;\n  end function GotScoreboards ;\n\n  ------------------------------------------------------------\n  procedure WriteScoreboardYaml (FileName : string := \"\"; OpenKind : File_Open_Kind := WRITE_MODE) is\n  begin\n    ScoreboardStore.WriteScoreboardYaml(FileName, OpenKind) ;\n  end procedure WriteScoreboardYaml ;\n\n  ------------------------------------------------------------\n  -- Generally these are not required.  When a simulation ends and\n  -- another simulation is started, a simulator will release all allocated items.\n  procedure Deallocate (\n    constant ID     : in  ScoreboardIDType\n  ) is\n  begin\n    ScoreboardStore.Deallocate ;\n  end procedure Deallocate ;\n\n  procedure Initialize (\n    constant ID     : in  ScoreboardIDType\n  ) is\n  begin\n    ScoreboardStore.Initialize ;\n  end procedure Initialize ;\n\n  ------------------------------------------------------------\n  -- Get error count\n  -- Deprecated, replaced by usage of Alerts\n  -- AlertFLow:      Instead use AlertLogPkg.ReportAlerts or AlertLogPkg.GetAlertCount\n  -- Not AlertFlow:  use GetErrorCount to get total error count\n\n  -- Scoreboards, with or without tag\n  impure function GetErrorCount(\n    constant ID     : in  ScoreboardIDType\n  ) return integer is\n  begin\n    return GetAlertCount(ScoreboardStore.GetAlertLogID(ID.ID)) ;\n  end function GetErrorCount ;\n\n\n  ------------------------------------------------------------\n  procedure CheckFinish (\n  ------------------------------------------------------------\n    ID                 : ScoreboardIDType ;\n    FinishCheckCount   : integer ;\n    FinishEmpty        : boolean\n  ) is\n  begin\n    ScoreboardStore.CheckFinish(ID.ID, FinishCheckCount, FinishEmpty) ;\n  end procedure CheckFinish ;\n\n\n\n  ------------------------------------------------------------\n  -- SetReportMode\n  -- Not AlertFlow\n  --     REPORT_ALL:     Replaced by AlertLogPkg.SetLogEnable(PASSED, TRUE)\n  --     REPORT_ERROR:   Replaced by AlertLogPkg.SetLogEnable(PASSED, FALSE)\n  --     REPORT_NONE:    Deprecated, do not use.\n  -- AlertFlow:\n  --     REPORT_ALL:     Replaced by AlertLogPkg.SetLogEnable(AlertLogID, PASSED, TRUE)\n  --     REPORT_ERROR:   Replaced by AlertLogPkg.SetLogEnable(AlertLogID, PASSED, FALSE)\n  --     REPORT_NONE:    Replaced by AlertLogPkg.SetAlertEnable(AlertLogID, ERROR, FALSE)\n  procedure SetReportMode (\n    constant ID           : in  ScoreboardIDType ;\n    constant ReportModeIn : in  ScoreboardReportType\n  ) is\n  begin\n--    ScoreboardStore.SetReportMode(ID.ID, ReportModeIn) ;\n	ScoreboardStore.SetReportMode(ReportModeIn) ;\n  end procedure SetReportMode ;\n\n  impure function GetReportMode (\n    constant ID           : in  ScoreboardIDType\n  ) return ScoreboardReportType is\n  begin\n--    return ScoreboardStore.GetReportMode(ID.ID) ;\n	return ScoreboardStore.GetReportMode ;\n  end function GetReportMode ;\n\n  --==========================================================\n  --!! Deprecated Subprograms\n  --==========================================================\n\n  ------------------------------------------------------------\n  -- Deprecated interface to NewID\n  impure function NewID (Name : String ; ParentAlertLogID : AlertLogIDType; DoNotReport : Boolean) return ScoreboardIDType is\n  ------------------------------------------------------------\n    variable ReportMode : AlertLogReportModeType ;\n  begin\n    ReportMode := ENABLED when not DoNotReport else DISABLED ;\n    return ScoreboardStore.NewID(Name, ParentAlertLogID, ReportMode => ReportMode) ;\n  end function NewID ;\n\n  ------------------------------------------------------------\n  -- Vector: 1 to Size\n  impure function NewID (Name : String ; Size : positive ; ParentAlertLogID : AlertLogIDType; DoNotReport : Boolean) return ScoreboardIDArrayType is\n  ------------------------------------------------------------\n    variable ReportMode : AlertLogReportModeType ;\n  begin\n    ReportMode := ENABLED when not DoNotReport else DISABLED ;\n    return ScoreboardStore.NewID(Name, Size, ParentAlertLogID, ReportMode => ReportMode) ;\n  end function NewID ;\n\n  ------------------------------------------------------------\n  -- Vector: X(X'Left) to X(X'Right)\n  impure function NewID (Name : String ; X : integer_vector ; ParentAlertLogID : AlertLogIDType; DoNotReport : Boolean) return ScoreboardIDArrayType is\n  ------------------------------------------------------------\n    variable ReportMode : AlertLogReportModeType ;\n  begin\n    ReportMode := ENABLED when not DoNotReport else DISABLED ;\n    return ScoreboardStore.NewID(Name, X, ParentAlertLogID, ReportMode => ReportMode) ;\n  end function NewID ;\n\n  ------------------------------------------------------------\n  -- Matrix: 1 to X, 1 to Y\n  impure function NewID (Name : String ; X, Y : positive ; ParentAlertLogID : AlertLogIDType; DoNotReport : Boolean) return ScoreboardIdMatrixType is\n  ------------------------------------------------------------\n    variable ReportMode : AlertLogReportModeType ;\n  begin\n    ReportMode := ENABLED when not DoNotReport else DISABLED ;\n    return ScoreboardStore.NewID(Name, X, Y, ParentAlertLogID, ReportMode => ReportMode) ;\n  end function NewID ;\n\n  ------------------------------------------------------------\n  -- Matrix: X(X'Left) to X(X'Right), Y(Y'Left) to Y(Y'Right)\n  impure function NewID (Name : String ; X, Y : integer_vector ; ParentAlertLogID : AlertLogIDType; DoNotReport : Boolean) return ScoreboardIdMatrixType is\n  ------------------------------------------------------------\n    variable ReportMode : AlertLogReportModeType ;\n  begin\n    ReportMode := ENABLED when not DoNotReport else DISABLED ;\n    return ScoreboardStore.NewID(Name, X, Y, ParentAlertLogID, ReportMode => ReportMode) ;\n  end function NewID ;\n\n\nend ScoreboardGenericPkg ;","lang":"vhdl"};
processSrcData(g_data);