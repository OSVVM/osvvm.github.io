var g_data = {"name":"C:/SynthWorks/Dev/_osvvm/OsvvmLibraries/UART/src/UartTx.vhd","src":"--\n--  File Name:         UartTx.vhd\n--  Design Unit Name:  UartTx\n--  OSVVM Release:     OSVVM MODELS STANDARD VERSION\n--\n--  Maintainer:        Jim Lewis      email:  jim@synthworks.com\n--  Contributor(s):\n--     Jim Lewis      jim@synthworks.com\n--\n--\n--  Description:\n--      UART Transmitter Model\n--\n--\n--  Developed by:\n--        SynthWorks Design Inc.\n--        VHDL Training Classes\n--        http://www.SynthWorks.com\n--\n--  Revision History:\n--    Date      Version    Description\n--    10/2022   2022.10    Changed enum value PRIVATE to PRIVATE_NAME due to VHDL-2019 keyword conflict.   \n--    05/2022   2022.05    Updated FIFOs so they are Search => PRIVATE\n--                         Added MODEL_ID_NAME generic\n--    03/2022   2022.03    Updated to use singleton based FIFOs.  Updated calls for AlertLogIDs\n--    08/2021   2021.08    Initialized NumDataBits, ParityMode, and NumStopBits\n--    02/2021   2021.02    Updated for resizing Data and Param to/from TransRec\n--    10/2020   2020.10    Update for updates to stream MIT\n--    07/2020   2020.07    Converted transactions to stream MIT \n--    01/2020   2020.01    Updated license notice\n--    05/2019   2019.05    Updated for OSVVM public release\n--    1999      1999.00    Developed for SynthWorks' Advanced VHDL Testbenches and Verification Class\n--\n--\n--  This file is part of OSVVM.\n--\n--  Copyright (c) 1999 - 2021 by SynthWorks Design Inc.\n--\n--  Licensed under the Apache License, Version 2.0 (the \"License\");\n--  you may not use this file except in compliance with the License.\n--  You may obtain a copy of the License at\n--\n--      https://www.apache.org/licenses/LICENSE-2.0\n--\n--  Unless required by applicable law or agreed to in writing, software\n--  distributed under the License is distributed on an \"AS IS\" BASIS,\n--  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n--  See the License for the specific language governing permissions and\n--  limitations under the License.\n--\n\nlibrary ieee ;\n  use ieee.std_logic_1164.all ;\n  use ieee.numeric_std.all ;\n  use ieee.numeric_std_unsigned.all ;\n\nlibrary OSVVM ; \n  context OSVVM.OsvvmContext ; \n\nlibrary osvvm_common ; \n  context osvvm_common.OsvvmCommonContext ;  \n  use osvvm.ScoreboardPkg_slv.all ;\n\n  use work.UartTbPkg.all ;\n\nentity UartTx is \n  generic (\n    MODEL_ID_NAME           : string := \"\" ;\n    DEFAULT_BAUD            : time    := UART_BAUD_PERIOD_125K ;\n    DEFAULT_NUM_DATA_BITS   : integer := UARTTB_DATA_BITS_8 ; \n    DEFAULT_PARITY_MODE     : integer := UARTTB_PARITY_EVEN ; \n    DEFAULT_NUM_STOP_BITS   : integer := UARTTB_STOP_BITS_1  \n  ) ;\n  port (\n    TransRec          : InOut UartRecType ;\n    SerialDataOut     : Out   std_logic := '1' \n  ) ;\n  \n  -- Use MODEL_ID_NAME Generic if set, otherwise,\n  -- use model instance label (preferred if set as entityname_1)\n  constant MODEL_INSTANCE_NAME : string :=\n    IfElse(MODEL_ID_NAME'length > 0, MODEL_ID_NAME, \n      to_lower(PathTail(UartTx'PATH_NAME))) ;\n      \nend UartTx ;\narchitecture model of UartTx is\n\n  signal UartTxClk : std_logic := '0'  ;\n  \n  signal ModelID  : AlertLogIDType ;\n  \n  signal TransmitFifo : osvvm.ScoreboardPkg_slv.ScoreboardIDType ;  \n  signal TransmitRequestCount, TransmitDoneCount      : integer := 0 ;   \n\n  -- Set initial values for configurable modes\n  signal ParityMode  : integer := UARTTB_PARITY_EVEN ;\n  signal NumStopBits : integer := UARTTB_STOP_BITS_1 ;\n  signal NumDataBits : integer := UARTTB_DATA_BITS_8 ;\n  signal Baud        : time    := UART_BAUD_PERIOD_125K ; -- init for clock start\n\nbegin\n\n\n  ------------------------------------------------------------\n  --  Initialize alerts\n  ------------------------------------------------------------\n  Initialize : process\n    variable ID : AlertLogIDType ; \n  begin\n    ID             := NewID(MODEL_INSTANCE_NAME) ; \n    ModelID        <= ID ; \n    TransmitFifo   <= NewID(\"TransmitFifo\", ID, ReportMode => DISABLED, Search => PRIVATE_NAME) ; \n    wait ; \n  end process Initialize ;\n\n\n  ------------------------------------------------------------\n  --  Transaction Dispatcher\n  --    Dispatches transactions to\n  ------------------------------------------------------------\n  TransactionDispatcher : process\n    alias Operation : StreamOperationType is TransRec.Operation ;\n    variable WaitCycles : integer ;\n    variable TxStim : UartStimType ;\n  begin\n    wait for 0 ns ; -- Let ModelID get set\n    -- Initialize\n    ParityMode    <= CheckParityMode (ModelID, DEFAULT_PARITY_MODE,   FALSE) ; \n    NumStopBits   <= CheckNumStopBits(ModelID, DEFAULT_NUM_STOP_BITS, FALSE) ; \n    NumDataBits   <= CheckNumDataBits(ModelID, DEFAULT_NUM_DATA_BITS, FALSE) ; \n    Baud          <= CheckBaud(ModelID, DEFAULT_BAUD, FALSE) ;  \n\n    TransactionDispatcherLoop : loop \n      WaitForTransaction(\n         Clk      => UartTxClk,\n         Rdy      => TransRec.Rdy,\n         Ack      => TransRec.Ack\n      ) ;\n      \n--!      Operation := TransRec.Operation ;\n      \n      case Operation is\n        when SEND | SEND_ASYNC =>\n          TxStim.Data  := SafeResize(TransRec.DataToModel, TxStim.Data'length) ;\n          TxStim.Error := to_01(SafeResize(TransRec.ParamToModel, TxStim.Error'length)) ;\n--          if TxStim.Error(TxStim.Error'right) = '-' then \n--            TxStim.Error := (TxStim.Error'range => '0') ;\n--          end if ; \n          Push(TransmitFifo, TxStim.Data & TxStim.Error) ;\n          Log(ModelID, \n            \"SEND Queueing Transaction: \" & to_string(TxStim) & \n            \"  Operation # \" & to_string(TransmitRequestCount + 1),\n            INFO, Enable => TransRec.BoolToModel\n          ) ; \n          Increment(TransmitRequestCount) ;\n          wait for 0 ns ; \n          if Operation = SEND then\n            if TransmitRequestCount /= TransmitDoneCount then \n              wait until TransmitRequestCount = TransmitDoneCount ;\n            end if ; \n          end if ; \n        \n        when WAIT_FOR_TRANSACTION =>\n          if TransmitRequestCount /= TransmitDoneCount then \n            wait until TransmitRequestCount = TransmitDoneCount ;\n          end if ; \n\n        when WAIT_FOR_CLOCK =>\n          WaitCycles := TransRec.IntToModel ;\n          wait for (WaitCycles * Baud) - 1 ns ;\n          wait until UartTxClk = '1' ;\n          \n        when GET_ALERTLOG_ID =>\n          TransRec.IntFromModel <= ModelID ;\n\n        when GET_TRANSACTION_COUNT =>\n          TransRec.IntFromModel <= TransmitDoneCount ;\n\n        when SET_MODEL_OPTIONS =>\n          case TransRec.Options is\n            when UartOptionType'pos(SET_PARITY_MODE) => \n              ParityMode    <= CheckParityMode(ModelID, TransRec.IntToModel, TransRec.BoolToModel) ; \n            when UartOptionType'pos(SET_STOP_BITS) =>\n              NumStopBits   <= CheckNumStopBits(ModelID, TransRec.IntToModel, TransRec.BoolToModel) ; \n            when UartOptionType'pos(SET_DATA_BITS) =>      \n              NumDataBits   <= CheckNumDataBits(ModelID, TransRec.IntToModel, TransRec.BoolToModel) ; \n            when UartOptionType'pos(SET_BAUD) =>\n              Baud          <= CheckBaud(ModelID, TransRec.TimeToModel, TransRec.BoolToModel) ;  \n            when others =>              \n              Alert(ModelID, \"SetOptions, Unimplemented Option: \" & to_string(UartOptionType'val(TransRec.Options)), FAILURE) ;\n          end case ; \n\n        when MULTIPLE_DRIVER_DETECT =>\n          Alert(ModelID, \"Multiple Drivers on Transaction Record.\" & \n                         \"  Transaction # \" & to_string(TransRec.Rdy), FAILURE) ;\n\n        when others =>\n          Alert(ModelID, \"Unimplemented Transaction: \" & to_string(Operation), FAILURE) ;\n\n      end case ;\n    end loop TransactionDispatcherLoop ;\n  end process TransactionDispatcher ;\n\n\n  ------------------------------------------------------------\n  -- Uart Clock\n  --   Period = TransRec.Baud \n  ------------------------------------------------------------\n  UartTxClk <= not UartTxClk after Baud / 2 ; \n\n  ------------------------------------------------------------\n  -- Uart Transmit Functionality \n  --   Wait for Transaction\n  --   Serially transmit data from the record\n  --   Calculate and transmit parity\n  ------------------------------------------------------------\n  UartTransmitHandler : process\n    variable TxStim : UartStimType ;\n  begin\n    -- Initialize\n    SerialDataOut <= '1' ; \n    wait for 0 ns ; \n    \n    TransmitLoop : loop \n      -- Find Transaction\n      if Empty(TransmitFifo) then\n        WaitForToggle(TransmitRequestCount) ;\n      else \n        wait for 0 ns ; -- allow TransmitRequestCount to settle if both happen at same time.\n      end if ;\n      \n      (TxStim.Data, TxStim.Error) := Pop(TransmitFifo) ;\n      \n      Log(ModelID, \n        \"SEND Starting: \" & to_string(TxStim) & \n        \"  Operation # \" & to_string(TransmitRequestCount),\n        DEBUG\n      ) ; \n    \n      if TxStim.Error(UARTTB_BREAK_INDEX) = '0' then  \n        -- Normal Data Transmission\n        -- Drive Start Bit\n        SerialDataOut <= '0' ;\n        wait until UartTxClk = '1' ;\n\n        -- Drive Data Bits\n        for i in 0 to NumDataBits - 1 loop \n          SerialDataOut <= TxStim.Data(i) ; \n          wait until UartTxClk = '1' ;\n        end loop ;\n\n        -- Drive Parity \n        if ParityMode /= UARTTB_PARITY_NONE then\n          -- Drive Parity \n          if TxStim.Error(UARTTB_PARITY_INDEX) = '0' then  \n            SerialDataOut <= CalcParity(TxStim.Data, ParityMode) ;   \n          else \n            SerialDataOut <= not CalcParity(TxStim.Data, ParityMode) ; \n          end if ; \n          wait until UartTxClk = '1' ;\n        end if ; \n\n        -- Drive Stop Bit\n        for i in 1 to NumStopBits loop \n          if TxStim.Error(UARTTB_STOP_INDEX) = '1' then  \n            SerialDataOut <= '0' ;\n            wait until UartTxClk = '1' ;\n          else \n            SerialDataOut <= '1' ;\n            wait until UartTxClk = '1' ;\n          end if ; \n        end loop ;\n        -- if Stop Error, finish at '1'\n        if TxStim.Error(UARTTB_STOP_INDEX) = '1' then  \n          SerialDataOut <= '1' ;\n          wait until UartTxClk = '1' ;\n        end if ; \n        \n      else  \n\n        -- Break Handling\n        SerialDataOut <= '0' ;\n        wait for to_integer(TxStim.Data) * Baud - 1 ns ; \n        wait until UartTXClk = '1' ; \n        SerialDataOut <= '1' ;\n        wait until UartTXClk = '1' ; \n\n      end if ; \n    \n      -- Signal completion\n      Increment(TransmitDoneCount) ;\n    end loop TransmitLoop ; \n  end process UartTransmitHandler ; \n\nend model ;\n","lang":"vhdl"};
processSrcData(g_data);