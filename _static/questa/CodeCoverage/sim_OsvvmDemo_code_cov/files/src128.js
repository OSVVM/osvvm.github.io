var g_data = {"name":"C:/SynthWorks/Dev/_osvvm/OsvvmLibraries/AXI4/AxiStream/src/AxiStreamReceiver.vhd","src":"--\n--  File Name:         AxiStreamReceiver.vhd\n--  Design Unit Name:  AxiStreamReceiver\n--  Revision:          OSVVM MODELS STANDARD VERSION\n--\n--  Maintainer:        Jim Lewis      email:  jim@synthworks.com\n--  Contributor(s):\n--     Jim Lewis      jim@synthworks.com\n--\n--\n--  Description:\n--      AXI Stream Master Model\n--\n--\n--  Developed by:\n--        SynthWorks Design Inc.\n--        VHDL Training Classes\n--        http://www.SynthWorks.com\n--\n--  Revision History:\n--    Date      Version    Description\n--    05/2023   2023.05    Updated methods for Randomized delays \n--    04/2023   2023.04    Update delays on TReady to be randomized\n--    10/2022   2022.10    Changed enum value PRIVATE to PRIVATE_NAME due to VHDL-2019 keyword conflict.   \n--    05/2022   2022.05    Updated FIFOs so they are Search => PRIVATE\n--    03/2022   2022.03    Updated calls to NewID for AlertLogID and FIFOs\n--    02/2022   2022.02    WaitForGet, don't send TReady until have a Get transaction\n--                         Replaced to_hstring to to_hxstring\n--    01/2022   2022.01    Moved MODEL_INSTANCE_NAME and MODEL_NAME to entity declarative region\n--                         Added GotBurst transaction Y check for BurstLen vs Expected BurstLen in CheckBurst\n--    07/2021   2021.07    All FIFOs and Scoreboards now use the New Scoreboard/FIFO capability\n--    06/2021   2021.06    Updated Burst FIFOs.\n--    02/2021   2021.02    Added MultiDriver Detect.  Updated Generics.\n--    10/2020   2020.10    Added Bursting per updates to Model Independent Transactions\n--    07/2020   2020.07    Updated for Streaming Model Independent Transactions\n--    01/2020   2020.01    Updated license notice\n--    05/2019   2019.05    Removed generics for DEFAULT_ID, DEFAULT_DEST, DEFAULT_USER\n--    05/2018   2018.05    First Release\n--\n--\n--  This file is part of OSVVM.\n--\n--  Copyright (c) 2018 - 2023 by SynthWorks Design Inc.\n--\n--  Licensed under the Apache License, Version 2.0 (the \"License\");\n--  you may not use this file except in compliance with the License.\n--  You may obtain a copy of the License at\n--\n--      https://www.apache.org/licenses/LICENSE-2.0\n--\n--  Unless required by applicable law or agreed to in writing, software\n--  distributed under the License is distributed on an \"AS IS\" BASIS,\n--  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n--  See the License for the specific language governing permissions and\n--  limitations under the License.\n--\nlibrary ieee ;\n  use ieee.std_logic_1164.all ;\n  use ieee.numeric_std.all ;\n  use ieee.numeric_std_unsigned.all ;\n  use ieee.math_real.all ;\n\nlibrary osvvm ;\n  context osvvm.OsvvmContext ;\n  use osvvm.ScoreboardPkg_slv.all ;\n\nlibrary osvvm_common ;\n  context osvvm_common.OsvvmCommonContext ;\n\n  use work.AxiStreamOptionsPkg.all ;\n  use work.Axi4CommonPkg.all ;\n  use work.AxiStreamTbPkg.all ;\n\nentity AxiStreamReceiver is\n  generic (\n    MODEL_ID_NAME  : string :=\"\" ;\n    INIT_ID        : std_logic_vector := \"\" ;\n    INIT_DEST      : std_logic_vector := \"\" ;\n    INIT_USER      : std_logic_vector := \"\" ;\n    INIT_LAST      : natural := 0 ;\n    tperiod_Clk    : time := 10 ns ;\n\n    DEFAULT_DELAY  : time := 1 ns ;\n\n    tpd_Clk_TReady : time := DEFAULT_DELAY\n  ) ;\n  port (\n    -- Globals\n    Clk       : in  std_logic ;\n    nReset    : in  std_logic ;\n\n    -- AXI Receiver Functional Interface\n    TValid    : in  std_logic ;\n    TReady    : out std_logic ;\n    TID       : in  std_logic_vector ;\n    TDest     : in  std_logic_vector ;\n    TUser     : in  std_logic_vector ;\n    TData     : in  std_logic_vector ;\n    TStrb     : in  std_logic_vector ;\n    TKeep     : in  std_logic_vector ;\n    TLast     : in  std_logic ;\n\n    -- Testbench Transaction Interface\n    TransRec  : inout StreamRecType\n  ) ;\n\n  -- Derive AXI interface properties from interface signals\n  constant AXI_STREAM_DATA_WIDTH   : integer := TData'length ;\n\n  -- Use MODEL_ID_NAME Generic if set, otherwise,\n  -- use model instance label (preferred if set as entityname_1)\n  constant MODEL_INSTANCE_NAME : string :=\n    ifelse(MODEL_ID_NAME'length > 0, MODEL_ID_NAME,\n      to_lower(PathTail(AxiStreamReceiver'PATH_NAME))) ;\n\nend entity AxiStreamReceiver ;\narchitecture behavioral of AxiStreamReceiver is\n\n  signal ModelID, ProtocolID, DataCheckID, BusFailedID, BurstFifoID : AlertLogIDType ;\n  signal BurstCov : BurstCoverageIDType ;\n  \n  signal UseCoverageDelays : Boolean := FALSE ;\n\n  constant ID_LEN       : integer := TID'length ;\n  constant DEST_LEN     : integer := TDest'length ;\n  constant USER_LEN     : integer := TUser'length ;\n  constant PARAM_LENGTH : integer := ID_LEN + DEST_LEN + USER_LEN + 1 ;\n  constant USER_RIGHT   : integer := 1 ;\n  constant DEST_RIGHT   : integer := USER_RIGHT + USER_LEN ;\n  constant ID_RIGHT     : integer := DEST_RIGHT + DEST_LEN ;\n\n  signal ReceiveFifo : osvvm.ScoreboardPkg_slv.ScoreboardIDType ;\n\n  signal WordRequestCount, BurstRequestCount : integer := 0 ; \n  signal WordReceiveCount, BurstReceiveCount : integer := 0 ;\n  signal ReceiveByteCount, TransferByteCount : integer := 0 ;\n\n  -- Verification Component Configuration\n  signal ReceiveReadyBeforeValid : boolean := TRUE ;\n  signal ReceiveReadyDelayCycles : integer := 0 ;\n\n  signal ParamID           : std_logic_vector(TID'range)   := ifelse(INIT_ID'length > 0,   INIT_ID,   (TID'range => '0')) ;\n  signal ParamDest         : std_logic_vector(TDest'range) := ifelse(INIT_DEST'length > 0, INIT_DEST, (TDest'range => '0')) ;\n  signal ParamUser         : std_logic_vector(TUser'range) := ifelse(INIT_USER'length > 0, INIT_USER, (TUser'range => '0')) ;\n  signal ParamLast         : natural := INIT_LAST ;\n  signal LastOffsetCount   : integer := 0 ;\n  constant DEFAULT_BURST_MODE : StreamFifoBurstModeType := STREAM_BURST_WORD_MODE ;\n  signal   BurstFifoMode      : StreamFifoBurstModeType := DEFAULT_BURST_MODE ;\n  signal   BurstFifoByteMode  : boolean := (DEFAULT_BURST_MODE = STREAM_BURST_BYTE_MODE) ;\n  \n  signal WaitForGet : boolean := FALSE ;\nbegin\n\n\n  ------------------------------------------------------------\n  --  Initialize alerts\n  ------------------------------------------------------------\n  Initialize : process\n    variable ID : AlertLogIDType ;\n  begin\n    -- Alerts\n    ID            := NewID(MODEL_INSTANCE_NAME) ;\n    ModelID       <= ID ;\n--    ProtocolID    <= NewID(\"Protocol Error\", ID ) ;\n    DataCheckID   <= NewID(\"Data Check\", ID ) ;\n    BusFailedID   <= NewID(\"No response\", ID ) ;\n    ReceiveFifo   <= NewID(\"ReceiveFifo\", ID, ReportMode => DISABLED, Search => PRIVATE_NAME) ;\n    wait ;\n  end process Initialize ;\n\n\n  ------------------------------------------------------------\n  --  Transaction Dispatcher\n  --    Dispatches transactions to\n  ------------------------------------------------------------\n  TransactionDispatcher : process\n    alias Operation : StreamOperationType is TransRec.Operation ;\n    variable Data,  ExpectedData,  PopData  : std_logic_vector(TData'range) ;\n    variable Param, ExpectedParam, PopParam : std_logic_vector(PARAM_LENGTH-1 downto 0) ;\n    variable ExpectedUser : std_logic_vector(USER_LEN-1 downto 0) ;\n    variable TryWordWaiting, TryBurstWaiting : boolean ; \n    variable DispatcherReceiveCount : integer := 0 ;\n    variable BurstTransferCount     : integer := 0 ;\n    variable WordCount : integer ;\n    variable FifoWordCount, CheckWordCount : integer ;\n    variable BurstBoundary  : std_logic ;\n    variable DropUndriven   : boolean := FALSE ;\n    function param_to_string(Param : std_logic_vector) return string is\n      alias aParam : std_logic_vector(Param'length-1 downto 0) is Param ;\n      alias ID   : std_logic_vector(ID_LEN-1 downto 0)   is aParam(PARAM_LENGTH-1 downto PARAM_LENGTH-ID_LEN);\n      alias Dest : std_logic_vector(DEST_LEN-1 downto 0) is aParam(DEST_LEN+USER_LEN downto USER_LEN+1);\n      alias User : std_logic_vector(USER_LEN-1 downto 0) is aParam(USER_LEN downto 1) ;\n      alias Last : std_logic is Param(0) ;\n    begin\n      return\n        ifelse(ID_LEN > 0,   \"  TID: \"       & to_hxstring(ID),   \"\") &\n        ifelse(DEST_LEN > 0, \"  TDest: \"     & to_hxstring(Dest), \"\") &\n        ifelse(USER_LEN > 0, \"  TUser: \"     & to_hxstring(User), \"\") &\n        \"  TLast: \"     & to_string(Last) ;\n    end function param_to_string ;\n\n  begin\n    wait for 0 ns ;  -- Allow ModelID to initialize\n    TransRec.BurstFifo <= NewID(\"RxBurstFifo\", ModelID, Search => PRIVATE_NAME) ;\n    BurstCov           <= NewID(\"\", ModelID) ;\n    wait for 0 ns ;  -- Allow TransRec.BurstFifo to update.\n    BurstFifoID        <= GetAlertLogID(TransRec.BurstFifo) ;\n\n    DispatchLoop : loop\n      WaitForTransaction(\n         Clk      => Clk,\n         Rdy      => TransRec.Rdy,\n         Ack      => TransRec.Ack\n      ) ;\n\n      case Operation is\n        when WAIT_FOR_CLOCK =>\n          WaitForClock(Clk, TransRec.IntToModel) ;\n\n        when WAIT_FOR_TRANSACTION =>\n          -- Receiver either blocks or does \"try\" operations\n          -- There are no operations in flight\n          -- There can be values received but not Get yet.\n          -- Cannot block on those.\n          wait for 0 ns ;\n\n        when GET_TRANSACTION_COUNT =>\n  --!! This is GetTotalTransactionCount vs. GetPendingTransactionCount\n  --!!  Get Pending Get Count = GetFifoCount(ReceiveFifo)\n          TransRec.IntFromModel <= WordReceiveCount ;\n          wait for 0 ns ;\n\n        when GET_ALERTLOG_ID =>\n          TransRec.IntFromModel <= integer(ModelID) ;\n          wait for 0 ns ;\n\n        when SET_BURST_MODE =>\n          BurstFifoMode       <= TransRec.IntToModel ;\n          BurstFifoByteMode   <= (TransRec.IntToModel = STREAM_BURST_BYTE_MODE) ;\n\n        when GET_BURST_MODE =>\n          TransRec.IntFromModel <= BurstFifoMode ;\n\n        when GOT_BURST =>\n          -- Used with TryCheckBurst with Patterns VectorOfWords, Increment, Random\n          if not TryBurstWaiting then\n            increment(BurstRequestCount) ; \n          end if ;\n          TryBurstWaiting := TRUE ; \n          if (BurstReceiveCount - BurstTransferCount) = 0 then\n            TransRec.BoolFromModel  <= FALSE ;\n          else\n            TransRec.BoolFromModel <= TRUE ;\n          end if ;\n\n        when GET | TRY_GET | CHECK | TRY_CHECK =>\n          if Empty(ReceiveFifo) and  IsTry(Operation) then\n            if not TryWordWaiting then\n              increment(WordRequestCount) ; \n            end if ;\n            TryWordWaiting := TRUE ; \n            -- Return if no data\n            TransRec.BoolFromModel  <= FALSE ;\n            TransRec.DataFromModel  <= (TransRec.DataFromModel'range => '0') ;\n            TransRec.ParamFromModel <= (TransRec.ParamFromModel'range => '0') ;\n            wait for 0 ns ;\n          else\n            if not TryWordWaiting then\n              increment(WordRequestCount) ; \n            end if ;\n            TryWordWaiting := FALSE ; \n            DispatcherReceiveCount := DispatcherReceiveCount + 1 ;\n\n            -- Get data\n            TransRec.BoolFromModel <= TRUE ;\n            if Empty(ReceiveFifo) then\n              -- Wait for data\n              WaitForToggle(WordReceiveCount) ;\n            end if ;\n            -- Put Data and Parameters into record\n            (Data, Param, BurstBoundary) := pop(ReceiveFifo) ;\n            if BurstBoundary = '1' then\n              -- At BurstBoundary, there is always another word that\n              -- follows that triggered the Burst Boundary\n              (Data, Param, BurstBoundary) := pop(ReceiveFifo) ;\n              BurstTransferCount := BurstTransferCount + 1 ;\n            end if ;\n            TransRec.DataFromModel  <= SafeResize(Data, TransRec.DataFromModel'length) ;\n            TransRec.ParamFromModel <= SafeResize(Param, TransRec.ParamFromModel'length) ;\n\n            -- Param: (TID & TDest & TUser & TLast)\n            if Param(0) = '1' then\n              BurstTransferCount := BurstTransferCount + 1 ;\n            end if ;\n\n            if IsCheck(Operation) then\n              ExpectedData  := SafeResize(TransRec.DataToModel, ExpectedData'length) ;\n              ExpectedParam  := UpdateOptions(\n                          Param      => SafeResize(TransRec.ParamToModel, ExpectedParam'length),\n                          ParamID    => ParamID,\n                          ParamDest  => ParamDest,\n                          ParamUser  => ParamUser,\n                          ParamLast  => ParamLast,\n                          Count      => WordReceiveCount - LastOffsetCount\n                        ) ;\n              AffirmIf( DataCheckID,\n  --                (Data ?= ExpectedData and Param ?= ExpectedParam) = '1',\n                  (MetaMatch(Data, ExpectedData) and MetaMatch(Param, ExpectedParam)),\n                  \"Operation# \" & to_string (DispatcherReceiveCount) & \" \" &\n                  \" Received.  Data: \" & to_hxstring(Data) &         param_to_string(Param),\n                  \" Expected.  Data: \" & to_hxstring(ExpectedData) & param_to_string(ExpectedParam),\n                  TransRec.BoolToModel or IsLogEnabled(ModelID, INFO)\n                ) ;\n            else\n              Log(ModelID,\n                  \"Word Receive. \" &\n                  \" Operation# \" & to_string (DispatcherReceiveCount) &  \" \" &\n                  \" Data: \"     & to_hxstring(Data) & param_to_string(Param),\n                  INFO, TransRec.BoolToModel\n                ) ;\n            end if ;\n          end if ;\n\n        when GET_BURST | TRY_GET_BURST =>\n          if (BurstReceiveCount - BurstTransferCount) = 0 and IsTry(Operation) then\n            if not TryBurstWaiting then\n              increment(BurstRequestCount) ; \n            end if ;\n            TryBurstWaiting := TRUE ; \n            -- Return if no data\n            TransRec.BoolFromModel  <= FALSE ;\n            TransRec.DataFromModel  <= (TransRec.DataFromModel'range => '0') ;\n            TransRec.ParamFromModel <= (TransRec.ParamFromModel'range => '0') ;\n            wait for 0 ns ;\n          else\n            if not TryBurstWaiting then\n              increment(BurstRequestCount) ; \n            end if ;\n            TryBurstWaiting := FALSE ; \n            DispatcherReceiveCount := DispatcherReceiveCount + 1 ; -- Operation or #Words Transfered based?\n\n            -- Get data\n            TransRec.BoolFromModel <= TRUE ;\n            if (BurstReceiveCount - BurstTransferCount) = 0 then\n              -- Wait for data\n              WaitForToggle(BurstReceiveCount) ;\n            end if ;\n            -- ReceiveFIFO: (TData & TID & TDest & TUser & TLast)\n            FifoWordCount := 0 ;\n            WordCount := 0 ; \n            loop\n              (PopData, PopParam, BurstBoundary) := pop(ReceiveFifo) ;\n              -- BurstBoundary indication does not contain data for\n              -- this transaction so exit\n              exit when BurstBoundary = '1' ;\n              WordCount := WordCount + 1 ; \n              Data  := PopData ;\n              Param := PopParam ;\n              case BurstFifoMode is\n                when STREAM_BURST_BYTE_MODE =>\n                  PushWord(TransRec.BurstFifo, Data, DropUndriven) ;\n                  FifoWordCount := FifoWordCount + CountBytes(Data, DropUndriven) ;\n\n                when STREAM_BURST_WORD_MODE =>\n                  Push(TransRec.BurstFifo, Data) ;\n                  FifoWordCount := FifoWordCount + 1 ;\n\n                when STREAM_BURST_WORD_PARAM_MODE =>\n                  Push(TransRec.BurstFifo, Data & Param(USER_LEN downto 1)) ;\n                  FifoWordCount := FifoWordCount + 1 ;\n\n                when others =>\n                  Alert(ModelID, \"BurstFifoMode: Invalid Mode: \" & to_string(BurstFifoMode)) ;\n              end case ;\n              exit when Param(0) = '1' ;\n            end loop ;\n\n            -- Adjust WordRequestCount for the number of words consumed during the burst\n            WordRequestCount        <= Increment(WordRequestCount, WordCount) ; \n\n            BurstTransferCount      := BurstTransferCount + 1 ;\n            TransRec.IntFromModel   <= FifoWordCount ;\n            TransRec.DataFromModel  <= SafeResize(Data, TransRec.DataFromModel'length) ;\n            TransRec.ParamFromModel <= SafeResize(Param, TransRec.ParamFromModel'length) ;\n\n            Log(ModelID,\n              \"Burst Receive. \" &\n              \" Operation# \" & to_string (DispatcherReceiveCount) &  \" \" &\n              \" Last Data: \"     & to_hxstring(Data) & param_to_string(Param),\n              INFO, TransRec.BoolToModel or IsLogEnabled(ModelID, PASSED)\n            ) ;\n            wait for 0 ns ;\n          end if ;\n\n        when CHECK_BURST | TRY_CHECK_BURST =>\n          if (BurstReceiveCount - BurstTransferCount) = 0 and IsTry(Operation) then\n            if not TryBurstWaiting then\n              increment(BurstRequestCount) ; \n            end if ;\n            TryBurstWaiting := TRUE ; \n            -- Return if no data\n            TransRec.BoolFromModel  <= FALSE ;\n            TransRec.DataFromModel  <= (TransRec.DataFromModel'range => '0') ;\n            TransRec.ParamFromModel <= (TransRec.ParamFromModel'range => '0') ;\n            wait for 0 ns ;\n          else\n            if not TryBurstWaiting then\n              increment(BurstRequestCount) ; \n            end if ;\n            TryBurstWaiting := FALSE ; \n            DispatcherReceiveCount := DispatcherReceiveCount + 1 ; -- Operation or #Words Transfered based?\n            -- Get data\n            TransRec.BoolFromModel <= TRUE ;\n            if (BurstReceiveCount - BurstTransferCount) = 0 then\n              -- Wait for data\n              WaitForToggle(BurstReceiveCount) ;\n            end if ;\n            CheckWordCount := TransRec.IntToModel ;\n            FifoWordCount  := 0 ;\n            WordCount := 0 ; \n            loop\n             -- ReceiveFIFO: (TData & TID & TDest & TUser & TLast)\n             (PopData, PopParam, BurstBoundary) := pop(ReceiveFifo) ;\n              -- BurstBoundary indication does not contain data for\n              -- this transaction so exit\n              exit when BurstBoundary = '1' ;\n              WordCount := WordCount + 1 ; \n              Data  := PopData ;\n              Param := PopParam ;\n              case BurstFifoMode is\n                when STREAM_BURST_BYTE_MODE =>\n                  CheckWord(TransRec.BurstFifo, Data, DropUndriven) ;\n                  FifoWordCount := FifoWordCount + CountBytes(Data, DropUndriven) ;\n\n                when STREAM_BURST_WORD_MODE =>\n                  Check(TransRec.BurstFifo, Data) ;\n                  FifoWordCount := FifoWordCount + 1 ;\n\n                when STREAM_BURST_WORD_PARAM_MODE =>\n                  -- Checking done here to differentiate data from user\n                  (ExpectedData, ExpectedUser) := Pop(TransRec.BurstFifo) ;\n                  AffirmIfEqual(BurstFifoID, Data, ExpectedData, \"Data\") ;\n                  AffirmIfEqual(BurstFifoID, Param(USER_LEN downto 1), ExpectedUser, \"User\") ;\n  --                Check(TransRec.BurstFifo, Data & Param(USER_LEN downto 1)) ;\n                  FifoWordCount := FifoWordCount + 1 ;\n\n                when others =>\n                  Alert(ModelID, \"BurstFifoMode: Invalid Mode: \" & to_string(BurstFifoMode)) ;\n              end case ;\n              exit when Param(0) = '1' ;\n              exit when FifoWordCount >= CheckWordCount ;\n            end loop ;\n            \n            -- Adjust WordRequestCount for the number of words consumed during the burst\n            WordRequestCount        <= Increment(WordRequestCount, WordCount) ; \n\n            BurstTransferCount      := BurstTransferCount + 1 ;\n            TransRec.IntFromModel   <= FifoWordCount ;\n            TransRec.DataFromModel  <= SafeResize(Data, TransRec.DataFromModel'length) ;\n            TransRec.ParamFromModel <= SafeResize(Param, TransRec.ParamFromModel'length) ;\n\n            Log(ModelID,\n              \"Burst Check. \" &\n              \" Operation# \" & to_string (DispatcherReceiveCount) &  \" \" &\n              \" Last Data: \"     & to_hxstring(Data) & param_to_string(Param),\n              INFO, TransRec.BoolToModel or IsLogEnabled(ModelID, PASSED)\n            ) ;\n            if not (BurstBoundary = '1' or Param(0) = '1') then\n              Log(ModelID,\n                \"Burst Check finished without Last or BurstBoundary - normal when next word is burst boundary\",\n                DEBUG\n              ) ;\n            end if ;\n            AffirmIfEqual(ModelID, FifoWordCount, CheckWordCount, \"Burst Check WordCount\") ;\n            ExpectedParam  := UpdateOptions(\n                        Param      => SafeResize(TransRec.ParamToModel, ExpectedParam'length),\n                        ParamID    => ParamID,\n                        ParamDest  => ParamDest,\n                        ParamUser  => ParamUser,\n                        ParamLast  => 1,\n                        Count      => 0\n                      ) ;\n            -- ID, Dest, User, Last\n            if ID_LEN > 0 then\n              AffirmIfEqual(ModelID, Param(ID_RIGHT+ID_LEN-1 downto ID_RIGHT),\n                  ExpectedParam(ID_RIGHT+ID_LEN-1 downto ID_RIGHT), \"ID\") ;\n            end if ;\n            if DEST_LEN > 0 then\n              AffirmIfEqual(ModelID, Param(DEST_RIGHT+DEST_LEN-1 downto DEST_RIGHT),\n                  ExpectedParam(DEST_RIGHT+DEST_LEN-1 downto DEST_RIGHT), \"DEST\") ;\n            end if ;\n            if USER_LEN > 0 and BurstFifoMode /= STREAM_BURST_WORD_PARAM_MODE then\n              AffirmIfEqual(ModelID, Param(USER_RIGHT+USER_LEN-1 downto USER_RIGHT),\n                  ExpectedParam(USER_RIGHT+USER_LEN-1 downto USER_RIGHT), \"USER\") ;\n            end if ;\n            AffirmIfEqual(ModelID, Param(0) or BurstBoundary, ExpectedParam(0), \"Last\") ;\n\n            wait for 0 ns ;\n          end if ;\n\n        when SET_MODEL_OPTIONS =>\n\n          case AxiStreamOptionsType'val(TransRec.Options) is\n\n            when RECEIVE_READY_BEFORE_VALID =>\n              ReceiveReadyBeforeValid <= TransRec.BoolToModel ;\n              UseCoverageDelays <= FALSE ; \n\n            when RECEIVE_READY_DELAY_CYCLES =>\n              ReceiveReadyDelayCycles <= TransRec.IntToModel ;\n              UseCoverageDelays <= FALSE ; \n\n            when RECEIVE_READY_WAIT_FOR_GET =>\n              WaitForGet      <= TransRec.BoolToModel ;\n\n            when DROP_UNDRIVEN =>\n              DropUndriven    := TransRec.BoolToModel ;\n\n            when DEFAULT_ID =>\n              ParamID         <= SafeResize(TransRec.ParamToModel, ParamID'length) ;\n\n            when DEFAULT_DEST =>\n              ParamDest       <= SafeResize(TransRec.ParamToModel, ParamDest'length) ;\n\n            when DEFAULT_USER =>\n              ParamUser       <= SafeResize(TransRec.ParamToModel, ParamUser'length) ;\n\n            when DEFAULT_LAST =>\n              ParamLast       <= TransRec.IntToModel ;\n              LastOffsetCount <= WordReceiveCount ;\n\n            when BURST_COV =>\n              BurstCov          <= GetBurstCoverage(TransRec.IntToModel) ;\n              UseCoverageDelays <= TRUE ; \n\n            when others =>\n              Alert(ModelID, \"SetOptions, Unimplemented Option: \" & to_string(AxiStreamOptionsType'val(TransRec.Options)), FAILURE) ;\n              wait for 0 ns ;\n          end case ;\n\n        when GET_MODEL_OPTIONS =>\n          case AxiStreamOptionsType'val(TransRec.Options) is\n            when RECEIVE_READY_BEFORE_VALID =>\n              TransRec.BoolFromModel   <=  ReceiveReadyBeforeValid ;\n\n            when RECEIVE_READY_DELAY_CYCLES =>\n              TransRec.IntFromModel <= ReceiveReadyDelayCycles ;\n\n            when RECEIVE_READY_WAIT_FOR_GET =>\n              TransRec.BoolFromModel <= WaitForGet ;\n\n            when DROP_UNDRIVEN =>\n              TransRec.BoolFromModel <= DropUndriven ;\n\n            when DEFAULT_ID =>\n              TransRec.ParamFromModel <= SafeResize(ParamID, TransRec.ParamFromModel'length) ;\n\n            when DEFAULT_DEST =>\n              TransRec.ParamFromModel <= SafeResize(ParamDest, TransRec.ParamFromModel'length) ;\n\n            when DEFAULT_USER =>\n              TransRec.ParamFromModel <= SafeResize(ParamUser, TransRec.ParamFromModel'length) ;\n\n            when DEFAULT_LAST =>\n              TransRec.IntFromModel   <= ParamLast ;\n\n            when BURST_COV =>\n              TransRec.IntFromModel <= BurstCov.ID ;\n              UseCoverageDelays <= TRUE ; \n\n            when others =>\n              Alert(ModelID, \"GetOptions, Unimplemented Option: \" & to_string(AxiStreamOptionsType'val(TransRec.Options)), FAILURE) ;\n              wait for 0 ns ;\n          end case ;\n        -- The End -- Done\n\n        when MULTIPLE_DRIVER_DETECT =>\n          Alert(ModelID, \"Multiple Drivers on Transaction Record.\" & \n                         \"  Transaction # \" & to_string(TransRec.Rdy), FAILURE) ;\n\n        when others =>\n          Alert(ModelID, \"Unimplemented Transaction: \" & to_string(Operation), FAILURE) ;\n      end case ;\n\n      -- Wait for 1 delta cycle, required if a wait is not in all case branches above\n      wait for 0 ns ;\n    end loop DispatchLoop ;\n  end process TransactionDispatcher ;\n\n\n  ------------------------------------------------------------\n  --  ReceiveHandler\n  --    Execute Write Address Transactions\n  ------------------------------------------------------------\n  ReceiveHandler : process\n    variable Data           : std_logic_vector(TData'length-1 downto 0) ;\n    variable Last           : std_logic ;\n    variable BurstBoundary  : std_logic ;\n    variable LastID         : std_logic_vector(TID'range)   := (TID'range   => '-') ;\n    variable LastDest       : std_logic_vector(TDest'range) := (TDest'range => '-') ;\n    variable LastLast       : std_logic := '1' ;\n--    alias Strb : std_logic_vector(TStrb'length-1 downto 0) is TStrb ;\n--    alias Keep : std_logic_vector(TKeep'length-1 downto 0) is TKeep ;\n    variable Strb : std_logic_vector(TStrb'length-1 downto 0) ;\n    variable Keep : std_logic_vector(TKeep'length-1 downto 0) ;\n\n    variable ReadyBeforeValid, ReadyDelayCycles : integer ; \n    variable BurstLength : integer := 0 ; \n  begin\n    -- Initialize\n    TReady  <= '0' ;\n    wait for 0 ns ; -- Allow Cov models to initialize \n    wait for 0 ns ; -- Allow Cov models to initialize \n    -- Default settings for Burst Coverage\n    AddBins (BurstCov.BurstLengthCov,  GenBin(2,10,1)) ;\n    AddCross(BurstCov.BurstDelayCov,   GenBin(0,1,1), GenBin(2,5,1)) ;\n    AddCross(BurstCov.BeatDelayCov,    GenBin(0,1,1), GenBin(0,1,1)) ;\n\n    ReceiveLoop : loop\n\n      if WaitForGet then \n        -- if no request, wait until we have one\n        --!! Note:  > breaks when **RequestCount > 2**30 \n        if not ((BurstRequestCount > BurstReceiveCount) or (WordRequestCount > WordReceiveCount)) then \n          wait until (BurstRequestCount > BurstReceiveCount) or (WordRequestCount > WordReceiveCount) or not WaitForGet ; \n        end if ;\n      end if ; \n      \n      -- Delay between consecutive signaling of Ready\n      if UseCoverageDelays then \n        -- BurstCoverage Delays\n        (ReadyBeforeValid, ReadyDelayCycles)  := GetRandBurstDelay(BurstCov) ; \n      else\n        -- Deprecated static settings\n        ReadyBeforeValid := to_integer(not ReceiveReadyBeforeValid) ; \n        ReadyDelayCycles := ReceiveReadyDelayCycles ; \n      end if ; \n\n      ---------------------\n      DoAxiReadyHandshake (\n      ---------------------\n        Clk                     => Clk,\n        Valid                   => TValid,\n        Ready                   => TReady,\n        ReadyBeforeValid        => ReadyBeforeValid = 0,\n        ReadyDelayCycles        => ReadyDelayCycles * tperiod_Clk,\n        tpd_Clk_Ready           => tpd_Clk_TReady,\n        AlertLogID              => ModelID\n      ) ;\n\n      Data := to_x01(TData) ;\n      Last := to_01(TLast) ;\n      Strb := to_x01(TStrb) ;\n      Keep := to_x01(TKeep) ;\n      -- Either Strb or Keep can have a null range\n      -- Make Data a Z if Strb(i) is position byte\n      for i in Strb'range loop\n        if Strb(i) = '0' then\n          Data(i*8 + 7 downto i*8) := (others => 'W') ;\n        end if;\n      end loop ;\n      -- Make Data a U if Keep(i) is null byte\n      for i in Keep'range loop\n        if Keep(i) = '0' then\n          Data(i*8 + 7 downto i*8) := (others => 'U') ;\n        end if;\n      end loop ;\n      \n      if BurstFifoByteMode then \n        -- For ByteMode, we drop words with X\"--\"\n        -- For first Word in Transfer, Drop leading bytes until TKeep(i) = '1'\n        if LastLast = '1' then\n          for i in Keep'reverse_range loop\n            exit when Keep(i) /= '0' ;\n            Data(i*8 + 7 downto i*8) := (others => '-') ;\n          end loop ;\n        end if ;\n        -- For last Word in Transfer, Drop ending bytes until TKeep(i) = '1'\n        if Last = '1' then\n          for i in Keep'range loop\n            exit when Keep(i) /= '0' ;\n            Data(i*8 + 7 downto i*8) := (others => '-') ;\n          end loop ;\n        end if ;\n      end if ;\n\n      if (not MetaMatch(TID, LastID) or not MetaMatch(TDest, LastDest)) and LastLast /= '1' then\n        -- push a burst boundary word, only the Burst Boundary value matters\n        push(ReceiveFifo, Data & TID & TDest & TUser & Last & '1') ;\n        BurstReceiveCount <= BurstReceiveCount + 1 ;\n        if Last = '1' then\n          wait for 0 ns ;\n        end if ;\n      end if ;\n--      BurstBoundary := '1' when (not MetaMatch(TID, LastID) or not MetaMatch(TDest, LastDest)) and LastLast /= '1' else '0' ;\n      LastID   := TID ;\n      LastDest := TDest ;\n      LastLast := Last ;\n      -- capture this transaction\n      push(ReceiveFifo, Data & TID & TDest & TUser & Last & '0') ;\n      if Last = '1' then\n        BurstReceiveCount <= BurstReceiveCount + 1 ;\n      end if ;\n\n      -- Log this operation\n      Log(ModelID,\n        \"Axi Stream Receive.\" &\n        \"  TData: \"     & to_hxstring(TData) &\n        ifelse(TStrb'length > 0, \"  TStrb: \"     & to_string (TStrb), \"\") &\n        ifelse(TKeep'length > 0, \"  TKeep: \"     & to_string (TKeep), \"\") &\n        ifelse(TID'length > 0,   \"  TID: \"       & to_hxstring(TID),   \"\") &\n        ifelse(TDest'length > 0, \"  TDest: \"     & to_hxstring(TDest), \"\") &\n        ifelse(TUser'length > 0, \"  TUser: \"     & to_hxstring(TUser), \"\") &\n        \"  TLast: \"     & to_string (TLast) &\n        \"  Operation# \" & to_string (WordReceiveCount + 1),\n        DEBUG\n      ) ;\n\n      -- Signal completion\n      increment(WordReceiveCount) ;\n      wait for 0 ns ;\n    end loop ReceiveLoop ;\n  end process ReceiveHandler ;\nend architecture behavioral ;\n","lang":"vhdl"};
processSrcData(g_data);