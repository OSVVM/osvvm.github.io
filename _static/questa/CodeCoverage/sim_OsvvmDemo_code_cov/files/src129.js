var g_data = {"name":"C:/SynthWorks/Dev/_osvvm/OsvvmLibraries/AXI4/AxiStream/TestCases/TbStream_AxiBurstAsyncNoLast1.vhd","src":"--\n--  File Name:         TbStream_AxiBurstAsyncNoLast1.vhd\n--  Design Unit Name:  Architecture of TestCtrl\n--  Revision:          OSVVM MODELS STANDARD VERSION\n--\n--  Maintainer:        Jim Lewis      email:  jim@synthworks.com\n--  Contributor(s):\n--     Jim Lewis      jim@synthworks.com\n--\n--\n--  Description:\n--      GetBurst with no last, just ID and Dest changes\n--\n--\n--  Developed by:\n--        SynthWorks Design Inc.\n--        VHDL Training Classes\n--        http://www.SynthWorks.com\n--\n--  Revision History:\n--    Date      Version    Description\n--    10/2020   2020.10    Initial revision\n--\n--\n--  This file is part of OSVVM.\n--  \n--  Copyright (c) 2020 by SynthWorks Design Inc.  \n--  \n--  Licensed under the Apache License, Version 2.0 (the \"License\");\n--  you may not use this file except in compliance with the License.\n--  You may obtain a copy of the License at\n--  \n--      https://www.apache.org/licenses/LICENSE-2.0\n--  \n--  Unless required by applicable law or agreed to in writing, software\n--  distributed under the License is distributed on an \"AS IS\" BASIS,\n--  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n--  See the License for the specific language governing permissions and\n--  limitations under the License.\n--  \narchitecture AxiBurstAsyncNoLast1 of TestCtrl is\n\n  signal   TestDone : integer_barrier := 1 ;\n  \n \nbegin\n\n  ------------------------------------------------------------\n  -- ControlProc\n  --   Set up AlertLog and wait for end of test\n  ------------------------------------------------------------\n  ControlProc : process\n  begin\n    -- Initialization of test\n    SetTestName(\"TbStream_AxiBurstAsyncNoLast1\") ;\n    SetLogEnable(PASSED, TRUE) ;    -- Enable PASSED logs\n    SetLogEnable(INFO, TRUE) ;    -- Enable INFO logs\n\n    -- Wait for testbench initialization \n    wait for 0 ns ;  wait for 0 ns ;\n    TranscriptOpen ;\n    SetTranscriptMirror(TRUE) ; \n\n    -- Wait for Design Reset\n    wait until nReset = '1' ;  \n    ClearAlerts ;\n\n    -- Wait for test to finish\n    WaitForBarrier(TestDone, 5 ms) ;\n    AlertIf(now >= 5 ms, \"Test finished due to timeout\") ;\n    AlertIf(GetAffirmCount < 1, \"Test is not Self-Checking\");\n    \n    TranscriptClose ; \n    AffirmIfNotDiff(GetTranscriptName, OSVVM_VALIDATED_RESULTS_DIR & GetTranscriptName, \"\") ;   \n    \n    EndOfTestReports ; \n    std.env.stop ; \n    wait ; \n  end process ControlProc ; \n\n  \n  ------------------------------------------------------------\n  -- AxiTransmitterProc\n  --   Generate transactions for AxiTransmitter\n  ------------------------------------------------------------\n  AxiTransmitterProc : process\n    variable ID   : std_logic_vector(ID_LEN-1 downto 0) ;    -- 8\n    variable Dest : std_logic_vector(DEST_LEN-1 downto 0) ;  -- 4\n    variable User : std_logic_vector(USER_LEN-1 downto 0) ;  -- 4\n    variable Data : std_logic_vector(DATA_WIDTH-1 downto 0) ;  \n  begin\n    wait until nReset = '1' ;  \n    WaitForClock(StreamTxRec, 2) ; \n    SetBurstMode(StreamTxRec, STREAM_BURST_BYTE_MODE) ;\n    \n    ID   := to_slv(1, ID_LEN);\n    Dest := to_slv(2, DEST_LEN) ; \n    User := to_slv(3, USER_LEN) ; \n    Data := (others => '0') ; \n\n    for i in 0 to 6 loop \n      log(\"Transmit \" & to_string(32+5*i) & \" Bytes. Starting with \" & to_string(i*32)) ;\n      ID    := ID + i mod 2 ; \n      Dest  := Dest + (i+1) mod 2 ; \n      for j in 0 to 31+5*i loop \n        SendAsync(StreamTxRec, Data+(i*32+j), ID & Dest & User & '0') ;\n      end loop ;\n    end loop ; \n    \n    SendAsync(StreamTxRec, Data, (ID+2) & (Dest+2) & User & '0') ;\n\n    -- Wait for outputs to propagate and signal TestDone\n    WaitForClock(StreamTxRec, 2) ;\n    WaitForBarrier(TestDone) ;\n    wait ;\n  end process AxiTransmitterProc ;\n\n\n  ------------------------------------------------------------\n  -- AxiReceiverProc\n  --   Generate transactions for AxiReceiver\n  ------------------------------------------------------------\n  AxiReceiverProc : process\n    variable NumBytes : integer ; \n    constant PARAM_LEN : integer := ID_LEN + DEST_LEN + USER_LEN + 1 ; \n    variable RxParam : std_logic_vector(PARAM_LEN-1 downto 0) ;\n    alias RxID    : std_logic_vector(ID_LEN-1 downto 0) is RxParam(PARAM_LEN-1 downto PARAM_LEN-ID_LEN) ;\n    alias RxDest  : std_logic_vector(DEST_LEN-1 downto 0) is RxParam(DEST_LEN-1 + USER_LEN+1 downto USER_LEN+1) ;\n    alias RxUser  : std_logic_vector(USER_LEN-1 downto 0) is RxParam(USER_LEN downto 1) ;\n    variable ID   : std_logic_vector(ID_LEN-1 downto 0) ;    -- 8\n    variable Dest : std_logic_vector(DEST_LEN-1 downto 0) ;  -- 4\n    variable User : std_logic_vector(USER_LEN-1 downto 0) ;  -- 4\n    variable Data : std_logic_vector(DATA_WIDTH-1 downto 0) ;  \n    variable TryCount  : integer ; \n    variable Available : boolean ; \n  begin\n    WaitForClock(StreamRxRec, 2) ; \n    SetBurstMode(StreamRxRec, STREAM_BURST_WORD_MODE) ;\n    \n    ID   := to_slv(1, ID_LEN);\n    Dest := to_slv(2, DEST_LEN) ; \n    User := to_slv(3, USER_LEN) ; \n    Data := (others => '0') ; \n\n    for i in 0 to 6 loop \n--      log(\"Transmit \" & to_string(32+5*i) & \" Bytes. Starting with \" & to_string(i*32)) ;\n      TryCount := 0 ; \n      loop \n        TryGetBurst (StreamRxRec, NumBytes, RxParam, Available) ;\n        exit when Available ; \n        WaitForClock(StreamRxRec, 1) ; \n        TryCount := TryCount + 1 ;\n      end loop ;\n      AffirmIf(TryCount > 0, \"TryCount \" & to_string(TryCount)) ;\n      AffirmIfEqual(NumBytes, 32 + 5*i, \"Receiver: NumBytes Received\") ;\n      ID    := ID + i mod 2 ; \n      Dest  := Dest + (i+1) mod 2 ; \n      AffirmIfEqual(RxID,   ID,   \"Receiver, ID: \") ; \n      AffirmIfEqual(RxDest, Dest, \"Receiver, Dest: \") ; \n      AffirmIfEqual(RxUser, User, \"Receiver, User: \") ; \n      CheckBurstIncrement(RxBurstFifo, i*32, NumBytes, DATA_WIDTH) ;\n    end loop ; \n    \n    Check (StreamRxRec, Data, (ID+2) & (Dest+2) & User & '0') ;\n     \n    -- Wait for outputs to propagate and signal TestDone\n    WaitForClock(StreamRxRec, 2) ;\n    WaitForBarrier(TestDone) ;\n    wait ;\n  end process AxiReceiverProc ;\n\nend AxiBurstAsyncNoLast1 ;\n\nConfiguration TbStream_AxiBurstAsyncNoLast1 of TbStream is\n  for TestHarness\n    for TestCtrl_1 : TestCtrl\n      use entity work.TestCtrl(AxiBurstAsyncNoLast1) ; \n    end for ; \n  end for ; \nend TbStream_AxiBurstAsyncNoLast1 ; ","lang":"vhdl"};
processSrcData(g_data);