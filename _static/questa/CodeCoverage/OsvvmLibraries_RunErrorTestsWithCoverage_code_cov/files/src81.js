var g_data = {"name":"C:/OsvvmLibraries/Ethernet/src/xMiiMacReceiver.vhd","src":"--\n--  File Name:         xMiiMacReceiver.vhd\n--  Design Unit Name:  xMiiMacReceiver\n--  Revision:          OSVVM MODELS STANDARD VERSION\n--\n--  Maintainer:        Jim Lewis      email:  jim@synthworks.com\n--  Contributor(s):\n--     Jim Lewis      jim@synthworks.com\n--\n--\n--  Description:\n--      Ethernet GMII/RGMII/MII/RMII VC\n--      First target is to support PHY\n--      Later on need basis consider supporting MAC\n--\n--\n--  Developed by:\n--        SynthWorks Design Inc.\n--        VHDL Training Classes\n--        http://www.SynthWorks.com\n--\n--  Revision History:\n--    Date      Version    Description\n--    10/2022   2022.10    Initial Release\n--\n--\n--  This file is part of OSVVM.\n--\n--  Copyright (c) 2022 by SynthWorks Design Inc.\n--\n--  Licensed under the Apache License, Version 2.0 (the \"License\");\n--  you may not use this file except in compliance with the License.\n--  You may obtain a copy of the License at\n--\n--      https://www.apache.org/licenses/LICENSE-2.0\n--\n--  Unless required by applicable law or agreed to in writing, software\n--  distributed under the License is distributed on an \"AS IS\" BASIS,\n--  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n--  See the License for the specific language governing permissions and\n--  limitations under the License.\n--\n\nlibrary ieee ;\n  use ieee.std_logic_1164.all ;\n  use ieee.numeric_std.all ;\n  use ieee.numeric_std_unsigned.all ;\n  use ieee.math_real.all ;\n\nlibrary osvvm ;\n  context osvvm.OsvvmContext ;\n  use osvvm.ScoreboardPkg_slv.all ;\n  use osvvm.ScoreboardPkg_int.all ;\n\nlibrary osvvm_common ;\n  context osvvm_common.OsvvmCommonContext ;\n\n  use work.xMiiTbPkg.all ;\n\nentity xMiiMacReceiver is\n  generic (\n    MODEL_ID_NAME  : string := \"\" ;\n    DEFAULT_DELAY  : time := 1 ns ;\n    tpd            : time := DEFAULT_DELAY \n  ) ;\n  port (\n    -- Configured by MDIO - it can change during operation based on PHY negotiation\n    xMiiInterface : in xMiiInterfaceType := GMII ;\n    xMiiBps       : in xMiiBpsType       := BPS_1G ;\n    \n    -- xMiiMacTransmitter Receiver Interface\n    Rx_Clk        : in std_logic ; \n    RxD           : in std_logic_vector(0 to 7) ; \n    Rx_Dv         : in std_logic ; \n    Rx_Er         : in std_logic ; \n    Rx_Ctl        : in std_logic ; \n    Crs           : in std_logic ; \n    Col           : in std_logic ; \n\n    -- Testbench Transaction Interface\n    TransRec      : inout StreamRecType    -- Information inbound to this VC\n  ) ;\n\n  -- Use MODEL_ID_NAME Generic if set, otherwise,\n  -- use model instance label (preferred if set as entityname_1)\n  constant MODEL_INSTANCE_NAME : string :=\n    IfElse(MODEL_ID_NAME'length > 0, MODEL_ID_NAME, \n      to_lower(PathTail(xMiiMacReceiver'PATH_NAME))) ;\n\nend entity xMiiMacReceiver ;\narchitecture behavioral of xMiiMacReceiver is\n\n--  signal tperiod_xClk : time := CalcPeriod(BPS_1G, GMII) ; \n  signal iRxClk   : std_logic ;   \n  signal iRxD     : std_logic_vector(0 to 7) ; \n  signal iRx_Dv   : std_logic ; \n  signal iRx_Er   : std_logic ; \n  signal iRx_Ctl  : std_logic ; \n  signal iCrs     : std_logic ; \n  signal iCol     : std_logic ; \n  signal Enable       : std_logic ; \n\n  signal ModelID  : AlertLogIDType ;\n\n  signal DataFifo : osvvm.ScoreboardPkg_slv.ScoreboardIDType ;\n  signal MetaFifo : osvvm.ScoreboardPkg_int.ScoreboardIDType ;\n\n  signal PacketReceiveCount      : integer := 0 ;\n\nbegin\n\n  ------------------------------------------------------------\n  --  Initialize alerts\n  ------------------------------------------------------------\n  Initialize : process\n    variable ID : AlertLogIDType ;\n  begin\n    -- Alerts\n    ID           := NewID(MODEL_INSTANCE_NAME) ;\n    ModelID      <= ID ;\n    DataFifo     <= NewID(\"DataFifo\",  ID, ReportMode => DISABLED, Search => PRIVATE_NAME) ; \n    MetaFifo     <= NewID(\"MetaFifo\",  ID, ReportMode => DISABLED, Search => PRIVATE_NAME) ; \n    wait ;\n  end process Initialize ;\n\n\n--  ------------------------------------------------------------\n--  ClkProc : process\n--  ------------------------------------------------------------\n--  begin\n--    wait for 0 ns ;  -- calc init value on tperiod_xClk\n--    loop \n--      RefGtxClk <= not RefGtxClk after tperiod_xClk ; \n--      wait on RefGtxClk ; \n--    end loop ; \n--  end process ; \n--\n--  tperiod_xClk <= CalcPeriod(xMiiBps, xMiiInterface) ; \n\n  -- Internal timing reference - caution:  shifted by delta cycle\n  iRxClk <= Rx_Clk when xMiiInterface /= RMII else\n--!!TODO resolve source of RMII Clk\n            Rx_Clk ; -- Source of RMII\n  -- Since iRxClk is delayed, all input signals must be delayed \n  -- or RTL signals may not be sampled correctly.\n  iRxD     <= RxD   ; \n  iRx_Dv   <= Rx_Dv ;\n  iRx_Er   <= Rx_Er ;\n  iRx_Ctl  <= Rx_Ctl;\n  iCrs     <= Crs   ;\n  iCol     <= Col   ;\n\n\n  ------------------------------------------------------------\n  TransactionDispatcher : process\n  ------------------------------------------------------------\n    variable NumberTransfers     : integer ;\n    variable PacketTransferCount : integer := 0 ;\n  begin\n    wait for 0 ns ; \n    TransRec.BurstFifo <= NewID(\"BurstFifo\", ModelId, ReportMode => DISABLED, Search => PRIVATE_NAME) ;\n    \n    DispatchLoop : loop \n      WaitForTransaction(\n         Clk      => iRxClk,\n         Rdy      => TransRec.Rdy,\n         Ack      => TransRec.Ack\n      ) ;\n\n      case TransRec.Operation is\n        when WAIT_FOR_CLOCK =>\n          WaitForClock(iRxClk, TransRec.IntToModel) ;\n\n        when WAIT_FOR_TRANSACTION =>\n--!! TODO:  Does this wait until a transaction is received?\n--!!          if PacketTransferCount /= PacketReceiveCount then\n--!!            wait until PacketTransferCount = PacketReceiveCount ;\n--!!          end if ;\n\n        when GET_TRANSACTION_COUNT =>\n          TransRec.IntFromModel <= PacketReceiveCount ;\n          wait for 0 ns ;\n\n        when GET_ALERTLOG_ID =>\n          TransRec.IntFromModel <= integer(ModelId) ;\n          wait for 0 ns ;\n\n        when GET_BURST | TRY_GET_BURST =>\n          if (PacketReceiveCount - PacketTransferCount) = 0 and IsTry(TransRec.Operation) then\n            -- No data for TryGetBurst, so return\n            TransRec.BoolFromModel  <= FALSE ;\n            wait for 0 ns ;\n          else\n            -- Get data\n            TransRec.BoolFromModel <= TRUE ;\n            if (PacketReceiveCount - PacketTransferCount) = 0 then\n              -- Wait for data\n              WaitForToggle(PacketReceiveCount) ;\n            end if ;\n            NumberTransfers := Pop(MetaFifo) ; \n            TransRec.IntFromModel <= NumberTransfers ; \n-- Do we need a separate DataFifo or \n-- is it ok to put values directly into the BurstFifo?\n-- For now, could assign DataFifo to TransRec.BurstFifo \n            for i in 1 to NumberTransfers loop\n              Push(TransRec.BurstFifo, Pop(DataFifo)) ;\n            end loop ; \n            PacketTransferCount := Increment(PacketTransferCount) ; \n            \n            Log(ModelId,\n              \"Received Packet# \" & to_string (PacketTransferCount),\n              INFO, TransRec.BoolToModel or IsLogEnabled(ModelId, PASSED)\n            ) ;\n            wait for 0 ns ;\n          end if ;\n         \n        when SET_MODEL_OPTIONS | GET_MODEL_OPTIONS =>\n          Alert(ModelId, \"Configuration done via MDIO Interface.\" & \n                         \"  Transaction # \" & to_string(TransRec.Rdy), FAILURE) ;\n\n        when MULTIPLE_DRIVER_DETECT =>\n          Alert(ModelId, \"Multiple Drivers on Transaction Record.\" & \n                         \"  Transaction # \" & to_string(TransRec.Rdy), FAILURE) ;\n\n        -- The End -- Done\n        when others =>\n          Alert(ModelId, \"Unimplemented Transaction: \" & to_string(TransRec.Operation), FAILURE) ;\n      end case ;\n\n      -- Wait for 1 delta cycle, required if a wait is not in all case branches above\n      wait for 0 ns ;\n    end loop DispatchLoop ;\n  end process TransactionDispatcher ;\n\n  Enable <= xMiiEnable (\n              xMiiInterface => xMiiInterface, \n              iEnDv         => iRx_Dv, \n              iCtl          => iRx_Ctl ) ;\n\n  ------------------------------------------------------------\n  MacRxHandler : process\n  --  MAC receives data on receiver Interface\n  ------------------------------------------------------------\n    variable PacketLength : integer ; \n    variable ErrorLoc     : integer ; \n    variable oData        : std_logic_vector(0 to 7) ;\n    variable oDv, oEr     : std_logic ; \n    \n    procedure GetByte (\n      variable oData         : out std_logic_vector(0 to 7);  \n      variable oDv           : out std_logic ; \n      variable oEr           : out std_logic \n    ) is \n    begin\n      GetByte (\n        Clk           => iRxClk,\n        oData         => oData,  \n        oEnDv         => oDv,\n        oEr           => oEr,\n        Tpd           => Tpd,\n        xMiiInterface => xMiiInterface,\n        iData         => iRxD,  \n        iEnDv         => iRx_Dv,\n        iEr           => iRx_Er,\n        iCtl          => iRx_Ctl\n      ) ;\n    end procedure GetByte ;\n\n  begin\n    wait for 0 ns ; -- Allow DataFifo to initialize \n\n    GetLoop : loop\n    \n      wait on iRxClk until Enable = '1' and rising_edge(iRxClk) ;\n\n      -- Find SFD\n--      while oData /= X\"AB\" loop \n      loop \n        GetByte(oData, oDv, oEr) ;\n        if oDv /= '1' then\n          Alert(ModelId, \"Incomplete Preamble and SFD\") ;\n          next GetLoop ;\n        end if ; \n        exit when oData = X\"AB\" ;\n      end loop ; \n      \n      -- Get A Packet of Data\n      ErrorLoc     := 0 ; \n      PacketLength := MaxPacketLength ;\n      for i in 1 to MaxPacketLength loop \n        GetByte(oData, oDv, oEr) ;\n        if oEr = '1' then \n          ErrorLoc := i ; \n        end if ; \n        if oDv = '1' then \n          Push(DataFifo, oData) ; \n        else\n          PacketLength := i - 1 ; \n          exit ;\n        end if ;\n      end loop ;\n      Push(MetaFifo, PacketLength) ;\n      Increment(PacketReceiveCount) ;\n      \n      if PacketLength = MaxPacketLength then\n        GetByte(oData, oDv, oEr) ;\n        if oDv = '1' then \n          Alert(ModelId, \"PacketLength = \" & to_string(PacketLength) & \n              \".  Packet truncated due to exceeding maximum length = \" & \n              to_string(MaxPacketLength)) ; \n          while oDv = '1' loop\n            GetByte(oData, oDv, oEr) ;\n          end loop ;\n        end if ; \n      end if ; \n\n      wait for 0 ns ;\n    end loop GetLoop ;\n  end process MacRxHandler ;\nend architecture behavioral ;\n","lang":"vhdl"};
processSrcData(g_data);