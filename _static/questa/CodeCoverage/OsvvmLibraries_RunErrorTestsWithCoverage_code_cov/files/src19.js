var g_data = {"name":"C:/OsvvmLibraries/Common/src/ModelParametersPtPkg.vhd","src":"--\n--  File Name:         ModelParametersPkg.vhd\n--  Design Unit Name:  ModelParametersPkg\n--  Revision:          OSVVM MODELS STANDARD VERSION\n--\n--  Author:      Rob Gaddi  <rgaddi@highlandtechnology.com>\n--  Company      Highland Technology, Inc.\n--\n--  Contributor(s):\n--     Jim Lewis      jim@synthworks.com\n--\n--\n--  Description:\n--      Defines ModelParametersPType\n--\n--  Revision History:\n--    Date      Version    Description\n--    05/2020   NONE       Refactored from AbstractMmPkg.vhd\n--    05/2020   2020.05    Added handling to also store std_logic_vector values\n--                         Added AlertLogID for error handling\n--                      \n--\n--\n--  This file is part of OSVVM.\n--\n--  Copyright (c) 2020 by Highland Technology\n--  Copyright (c) 2020 by SynthWorks Design Inc.\n--\n--\n--  Licensed under the Apache License, Version 2.0 (the \"License\");\n--  you may not use this file except in compliance with the License.\n--  You may obtain a copy of the License at\n--\n--      https://www.apache.org/licenses/LICENSE-2.0\n--\n--  Unless required by applicable law or agreed to in writing, software\n--  distributed under the License is distributed on an \"AS IS\" BASIS,\n--  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n--  See the License for the specific language governing permissions and\n--  limitations under the License.\n--\n\nlibrary ieee;\nuse ieee.std_logic_1164.all;\nuse ieee.numeric_std.all;\nuse ieee.numeric_std_unsigned.all;\n\nlibrary osvvm;\ncontext osvvm.OsvvmContext ; \n\n\npackage ModelParametersPkg is\n	\n	type ModelParametersPType is protected\n-- Add SetAlertLogID(string, ID), SetAlertLogID(ID), GetAlertLogID\n\n		procedure Init(nparams : in positive);\n--		procedure Init(initvals : in integer_vector);\n		\n		procedure Set(Index: in natural; Data: in integer);\n		procedure Set(Data:  in integer_vector);\n		procedure Set(Index: in natural; Data: in integer; len: positive);\n		procedure Set(Index: in natural; Data: in boolean);\n		procedure Set(Index: in natural; Data: in std_logic_vector);\n		\n		impure function Get(Index: natural) return integer;\n		impure function Get(Index: natural) return boolean;\n		impure function Get(Index: natural) return std_logic_vector;\n		impure function Get(Index: natural; len: positive) return std_logic_vector;\n    \n    ------------------------------------------------------------\n    procedure SetAlertLogID (A : AlertLogIDType) ;\n    procedure SetAlertLogID (Name : string ; ParentID : AlertLogIDType := ALERTLOG_BASE_ID ; CreateHierarchy : Boolean := TRUE) ;    \n    impure function GetAlertLogID return AlertLogIDType ;\n	end protected ModelParametersPType;\n\nend package ModelParametersPkg;\n\npackage body ModelParametersPkg is\n	\n	type ModelParametersPType is protected body\n		type SlvPtrType is access std_logic_vector;\n    \n    type ParmTypeType is (NONE, eSLV, eINT) ; \n\n    type ParameterRecType is record \n      ParmType : ParmTypeType ; \n      IParm    : integer ; \n      SParm    : SlvPtrType ; \n    end record ParameterRecType ; \n    type ParameterRecArrayType is array (natural range <>) of ParameterRecType ; \n		type ParamPtrType is access ParameterRecArrayType ;\n		variable ParmPtrVar : ParamPtrType := NULL;\n    \n    variable AlertLogIDVar : AlertLogIDType := OSVVM_ALERTLOG_ID ;\n	\n    ------------------------------------------------------------\n    procedure Deallocate is\n    ------------------------------------------------------------\n    begin\n      for i in ParmPtrVar'range loop  \n        if ParmPtrVar(i).SParm /= NULL then \n          deallocate(ParmPtrVar(i).SParm) ;\n        end if ; \n      end loop ;\n      deallocate(ParmPtrVar);\n    end procedure Deallocate ; \n    \n    ------------------------------------------------------------\n		--	Create storage for nParams parameters\n		procedure Init(nparams : in positive) is\n    ------------------------------------------------------------\n		begin\n			if ParmPtrVar /= NULL then\n-- probably a mistake to do this\n-- Should instead do a resize of the structure like in ScoreboardPkg.\n        Deallocate; \n      end if; \n			ParmPtrVar := new ParameterRecArrayType(0 to nparams-1);\n			for i in ParmPtrVar'range loop\n				ParmPtrVar(i).IParm := 0;\n			end loop;\n		end procedure Init;\n		\n    ------------------------------------------------------------\n--		--	Initialize the parameters array from initvals.\n--		procedure Init(InitVals : in integer_vector) is\n    ------------------------------------------------------------\n--      alias aInitVals : integer_vector(0 to InitVals'length-1) ;\n--		begin\n--      Deallocate ; \n--			ParmPtrVar := new ParameterRecArrayType(0 to InitVals'length-1);\n--      for i in aInitVals'range loop \n--        ParmPtrVar(i).IsInit := TRUE ;\n--        ParmPtrVar(i).IParm  := aInitVals(i) ;\n--      end loop ; \n--		end procedure Init;\n		\n    ------------------------------------------------------------\n		procedure Set(Index: in natural; Data: in integer) is\n    ------------------------------------------------------------\n		begin\n      case ParmPtrVar(Index).ParmType is \n        when NONE | eINT =>\n          ParmPtrVar(Index).IParm     := Data;\n          ParmPtrVar(Index).ParmType  := eINT;\n        \n        when eSLV =>\n          ParmPtrVar(Index).SParm.all := std_logic_vector(to_signed(Data, ParmPtrVar(Index).SParm'length));\n          ParmPtrVar(Index).ParmType  := eSLV;\n      end case ; \n    end procedure Set;\n		\n    ------------------------------------------------------------\n		procedure Set(Data: in integer_vector) is\n    ------------------------------------------------------------\n		begin\n      for i in Data'range loop \n        Set(i, Data(i)) ; \n      end loop ;\n    end procedure Set ; \n		\n    ------------------------------------------------------------\n		procedure Set(Index: in natural; Data: in boolean) is\n    ------------------------------------------------------------\n		begin\n      case ParmPtrVar(Index).ParmType is \n        when NONE | eINT =>\n          ParmPtrVar(Index).IParm     := 1 when Data else 0 ;\n          ParmPtrVar(Index).ParmType  := eINT;\n        \n        when eSLV =>\n          ParmPtrVar(Index).SParm.all := (ParmPtrVar(Index).SParm'range => '0') ;\n          ParmPtrVar(Index).SParm(0) := '1' when Data else '0';\n          ParmPtrVar(Index).ParmType  := eSLV;\n      end case ; \n		end procedure Set;\n		\n    ------------------------------------------------------------\n		procedure Set(Index: in natural; Data: in integer; len: positive) is\n    ------------------------------------------------------------\n      -- to_signed correctly handles non-negative integers up len in length\n      constant SlvVal : std_logic_vector(len-1 downto 0) := std_logic_vector(to_signed(Data, len));\n		begin\n      case ParmPtrVar(Index).ParmType is \n        when NONE =>\n          ParmPtrVar(Index).SParm    := new std_logic_vector'(SlvVal);\n          ParmPtrVar(Index).ParmType := eSLV;\n\n        when eSLV  =>\n--? What if parameters do not match in size?\n          ParmPtrVar(Index).SParm.all := resize(SlvVal, ParmPtrVar(Index).SParm'length);\n        \n        when eINT =>\n          ParmPtrVar(Index).IParm    := Data;\n          ParmPtrVar(Index).ParmType := eINT;\n      end case ; \n		end procedure Set;\n\n    ------------------------------------------------------------\n		procedure Set(Index: in natural; Data: in std_logic_vector) is\n    ------------------------------------------------------------\n      alias aData : std_logic_vector(Data'length-1 downto 0) is Data ; \n		begin\n      case ParmPtrVar(Index).ParmType is \n        when NONE =>\n          ParmPtrVar(Index).SParm    := new std_logic_vector'(aData)  ;\n          ParmPtrVar(Index).ParmType := eSLV;\n        \n        when eSLV  =>\n--? What if parameters do not match in size?\n          ParmPtrVar(Index).SParm.all := resize(aData, ParmPtrVar(Index).SParm'length);\n\n        when eINT =>\n          ParmPtrVar(Index).IParm    := to_integer(signed(Data));\n          ParmPtrVar(Index).ParmType := eINT;\n      end case ; \n		end procedure Set;\n		\n    ------------------------------------------------------------\n		impure function Get(Index: natural) return integer is\n    ------------------------------------------------------------\n		begin\n      case ParmPtrVar(Index).ParmType is \n        when NONE =>\n          alert(AlertLogIDVar, \"ModelParametersPType.Get[natural, return integer] No value set\");\n          return integer'left;\n        \n        when eINT =>\n          return ParmPtrVar(Index).IParm;\n\n        when eSLV =>\n-- std_logic_vector values are unsigned\n          return to_integer(unsigned(ParmPtrVar(Index).SParm.all));\n      end case ; \n		end function Get;\n		\n    ------------------------------------------------------------\n		impure function Get(Index: natural) return boolean is\n    ------------------------------------------------------------\n		begin\n      case ParmPtrVar(Index).ParmType is \n        when NONE =>\n          alert(AlertLogIDVar, \"ModelParametersPType.Get[natural, return boolean] No value set\");\n          return boolean'left;\n        \n        when eINT =>\n          return (ParmPtrVar(Index).IParm /= 0);\n\n        when eSLV =>\n          return (ParmPtrVar(Index).SParm(0) /= '0');\n      end case ; \n		end function Get;\n		\n    ------------------------------------------------------------\n		impure function Get(Index: natural) return std_logic_vector is\n    ------------------------------------------------------------\n		begin\n      case ParmPtrVar(Index).ParmType is \n        when NONE =>\n          alert(AlertLogIDVar, \"ModelParametersPType.Get[natural, return std_logic_vector] No value set\");\n          return 32SB\"U\";\n        \n        when eINT =>\n          return std_logic_vector(to_signed(ParmPtrVar(Index).IParm, 32));\n\n        when eSLV =>\n          return ParmPtrVar(Index).SParm.all;\n      end case ; \n		end function Get;\n		\n    ------------------------------------------------------------\n		impure function Get(Index: natural; len: positive) return std_logic_vector is\n    ------------------------------------------------------------\n      constant AllU   : std_logic_vector(len-1 downto 0) := (others => 'U') ; \n      variable Result : signed(31 downto 0) ;\n		begin\n      case ParmPtrVar(Index).ParmType is \n        when NONE =>\n          alert(AlertLogIDVar, \"ModelParametersPType.Get[natural, positive return std_logic_vector] No value set\");\n          return AllU;\n        \n        when eINT =>\n          Result := to_signed(ParmPtrVar(Index).IParm, 32) ;\n          return std_logic_vector(Result(len-1 downto 0));\n\n        when eSLV =>\n          return resize(ParmPtrVar(Index).SParm.all, len);\n      end case ; \n		end function Get;\n    \n    ------------------------------------------------------------\n    procedure SetAlertLogID (A : AlertLogIDType) is\n    ------------------------------------------------------------\n    begin\n      AlertLogIDVar := A ;\n    end procedure SetAlertLogID ;\n\n    ------------------------------------------------------------\n    procedure SetAlertLogID(Name : string ; ParentID : AlertLogIDType := ALERTLOG_BASE_ID ; CreateHierarchy : Boolean := TRUE) is\n    ------------------------------------------------------------\n    begin\n      AlertLogIDVar := GetAlertLogID(Name, ParentID, CreateHierarchy) ;\n    end procedure SetAlertLogID ;\n    \n    ------------------------------------------------------------\n    impure function GetAlertLogID return AlertLogIDType is\n    ------------------------------------------------------------\n    begin\n      return AlertLogIDVar ; \n    end function GetAlertLogID ;\n    \n	end protected body ModelParametersPType;\n	\nend package body ModelParametersPkg;\n","lang":"vhdl"};
processSrcData(g_data);