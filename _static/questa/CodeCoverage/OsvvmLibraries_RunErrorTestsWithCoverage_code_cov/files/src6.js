var g_data = {"name":"C:/OsvvmLibraries/Common/src/AddressBusTransactionPkg.vhd","src":"--\n--  File Name:         AddressBusTransactionPkg.vhd\n--  Design Unit Name:  AddressBusTransactionPkg\n--  Revision:          OSVVM MODELS STANDARD VERSION\n--\n--  Maintainer:        Jim Lewis      email:  jim@synthworks.com\n--  Contributor(s):\n--     Jim Lewis      jim@synthworks.com\n--     Rob Gaddi      Highland Technology.    Wrote a similar package which inspired this one.\n--\n--\n--  Description:\n--    Defines the OSVVM Address Bus Model Independent Transaction\n--    Interface (AddressBusRecType) and transaction initiation \n--    procedures (Read, Write, ...), as well as supporting types,\n--    constants, and subprograms that are essential to both \n--    to Verification Components and testbenches (test \n--    harnesses and test sequencers) that use address bus type\n--    interfaces (such as Axi4 Full, Avalon, Wishbone, ...)\n--\n--\n--  Developed by:\n--        SynthWorks Design Inc.\n--        VHDL Training Classes\n--        http://www.SynthWorks.com\n--\n--  Revision History:\n--    Date      Version    Description\n--    09/2023   2023.09    Added ModelParametersIDType to Record, \n--                         Added OperationType ENUMs:  EXTEND_DIRECTIVE_OP, EXTEND_OP, EXTEND_WRITE_OP, EXTEND_READ_OP\n--    05/2023   2023.05    Added SetDelayCoverageID and GetDelayCoverageID\n--    11/2022   2022.11    Added AddressBusRecArrayType\n--    01/2022   2022.01    Burst patterns - Burst, BurstInc, BurstRandom\n--    06/2021   2021.06    Updated bursting \n--    12/2020   2020.12    Added SetBurstMode, updated parameter names for consistency\n--    09/2020   2020.09    Updating comments to serve as documentation\n--    07/2020   2020.07    Unified M/S packages - dropping M/S terminology\n--    02/2020   2020.02    Refactored from Axi4LiteMasterTransactionPkg\n--    01/2020   2020.01    Updated license notice\n--    09/2017   2017       Initial revision\n--\n--  This file is part of OSVVM.\n--  \n--  Copyright (c) 2017 - 2023 by SynthWorks Design Inc.  \n--  \n--  Licensed under the Apache License, Version 2.0 (the \"License\");\n--  you may not use this file except in compliance with the License.\n--  You may obtain a copy of the License at\n--  \n--      https://www.apache.org/licenses/LICENSE-2.0\n--  \n--  Unless required by applicable law or agreed to in writing, software\n--  distributed under the License is distributed on an \"AS IS\" BASIS,\n--  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n--  See the License for the specific language governing permissions and\n--  limitations under the License.\n--  \nlibrary ieee ;\n  use ieee.std_logic_1164.all ;\n  use ieee.numeric_std.all ;\n  use ieee.numeric_std_unsigned.all ;\n  use ieee.math_real.all ;\n\nlibrary osvvm ;\n  context osvvm.OsvvmContext ;\n  use osvvm.ScoreboardPkg_slv.all ; \n\n  use work.ModelParametersSingletonPkg.all ; \n  use work.FifoFillPkg_slv.all ; \n\npackage AddressBusTransactionPkg is\n\n  -- ========================================================\n  --  AddressBusOperationType \n  --  Enumeration type used to communication transaction type\n  --  to the model via the transaction interface\n  -- ========================================================\n  type UnresolvedAddressBusOperationType is (\n    -- Default. Used by resolution function for Multiple Driver Detection\n    NOT_DRIVEN,  \n    --\n    -- Model Directives\n    --\n    WAIT_FOR_CLOCK,\n    WAIT_FOR_TRANSACTION,\n    WAIT_FOR_WRITE_TRANSACTION, WAIT_FOR_READ_TRANSACTION, \n    GET_TRANSACTION_COUNT, \n    GET_WRITE_TRANSACTION_COUNT, GET_READ_TRANSACTION_COUNT,\n    GET_ALERTLOG_ID, \n    -- Delay Coverage ID\n    SET_USE_RANDOM_DELAYS,\n    GET_USE_RANDOM_DELAYS,\n    SET_DELAYCOV_ID,\n    GET_DELAYCOV_ID,\n    -- Burst FIFO Configuration\n    SET_BURST_MODE,\n    GET_BURST_MODE,\n    -- Model Options\n    SET_MODEL_OPTIONS, \n    GET_MODEL_OPTIONS,\n    -- VC Customization of Directives and Functional Operations\n    EXTEND_DIRECTIVE_OP,\n    EXTEND_OP,\n    -- Interrupt Return - used by InterruptHandler VC\n    INTERRUPT_RETURN,\n    --\n    --  bus operations                        Master                Responder\n    --                       --------------------------------------------------------\n    WRITE_OP,                -- Blocking     (Tx Addr & Data)      (Rx Addr & Data)\n    WRITE_ADDRESS,           -- Blocking     (Tx Addr)             (Rx Addr)\n    WRITE_DATA,              -- Blocking     (Tx Data)             (Rx Data)\n    ASYNC_WRITE,             -- Non-blocking (Tx Addr & Data)      (Rx Addr & Data)\n    ASYNC_WRITE_ADDRESS,     -- Non-blocking (Tx Addr)             (Rx Addr)\n    ASYNC_WRITE_DATA,        -- Non-blocking (Tx Data)             (Rx Data)\n    -- VC Customization of Write Operations\n    EXTEND_WRITE_OP,\n    \n    READ_OP,                 -- Blocking     (Tx Addr & Rx Data)   (Rx Addr & Tx Data)\n    READ_ADDRESS,            -- Blocking     (Tx Addr)             (Rx Addr)\n    READ_DATA,               -- Blocking     (Rx Data)             (Tx Data)\n    READ_CHECK,              -- Blocking     (Tx Addr & Tx Data)   \n    READ_DATA_CHECK,         -- Blocking     (Tx Data)             (Tx Data)\n    ASYNC_READ,              -- Non-blocking  --------             (Rx Addr, Tx Data)\n    ASYNC_READ_ADDRESS,      -- Non-blocking (Tx Addr)             (Rx Addr)\n    ASYNC_READ_DATA,         -- Non-blocking (Rx Data)             (Tx Data)\n    ASYNC_READ_DATA_CHECK,   -- Non-blocking (Tx Data)       \n    -- VC Customization of Read Operations\n    EXTEND_READ_OP,\n\n    WRITE_AND_READ,          -- Blocking     (Tx Addr & Data, Rx Addr & Data)      \n    ASYNC_WRITE_AND_READ,    -- Non-blocking (Tx Addr & Data, Rx Addr)      \n    --\n    --  burst operations\n    --                       ----------------------------\n    WRITE_BURST,             -- Blocking BURST (Tx Addr & Data)\n    ASYNC_WRITE_BURST,       -- Non-blocking BURST (Tx Addr & Data)\n-- Potential future expansion, but not implemented yet\n--    WRITE_BURST_ADDRESS,\n--    WRITE_BURST_DATA,\n--    ASYNC_WRITE_BURST_ADDRESS,\n--    ASYNC_WRITE_BURST_DATA,\n    \n    READ_BURST,              -- Blocking BURST (Tx Addr, Rx Data)\n-- Potential future expansion, but not implemented yet\n--    READ_BURST_ADDRESS,\n--    READ_BURST_DATA,\n--    ASYNC_READ_BURST_ADDRESS,\n--    ASYNC_READ_BURST_DATA,\n--    ASYNC_READ_BURST,  -- Master cannot do this - Address, but data not ready.  Responder?  \n\n    -- Resolution function detected Multiple drivers\n    MULTIPLE_DRIVER_DETECT  -- value used when multiple drivers are present\n  ) ;\n  \n  type UnresolvedAddressBusOperationVectorType is array (natural range <>) of UnresolvedAddressBusOperationType ;\n--  alias resolved_max is maximum[ UnresolvedAddressBusOperationVectorType return UnresolvedAddressBusOperationType] ;\n  -- Maximum is implicitly defined for any array type in VHDL-2008.   Function resolved_max is a fall back.\n  function resolved_max ( s : UnresolvedAddressBusOperationVectorType) return UnresolvedAddressBusOperationType ;\n  subtype AddressBusOperationType is resolved_max UnresolvedAddressBusOperationType ;\n\n\n  -- ========================================================\n  --  AddressBusRecType \n  --  Transaction interface between the test sequencer and the \n  --  verification component.   As such it is the primary channel \n  --  for information exchange between the two.\n  --  The types bit_max, std_logic_vector_max_c, integer_max, and \n  --  boolean_max are defined the OSVVM package, ResolutionPkg.  \n  --  These types allow the record to support multiple drivers and \n  --  use resolution functions based on function maximum (return largest value)\n  -- ========================================================\n  type AddressBusRecType is record\n    -- Handshaking controls\n    --   Used by RequestTransaction in the Transaction Procedures\n    --   Used by WaitForTransaction in the Verification Component\n    --   RequestTransaction and WaitForTransaction are in osvvm.TbUtilPkg\n    Rdy                : RdyType ;\n    Ack                : AckType ;\n    -- Transaction Type\n    Operation          : AddressBusOperationType ;\n    -- Address to verification component and its width\n    -- Width may be smaller than Address\n    Address            : std_logic_vector_max_c ;\n    AddrWidth          : integer_max ;\n    -- Data to and from the verification component and its width.\n    -- Width will be smaller than Data for byte operations\n    -- Width size requirements are enforced in the verification component\n    DataToModel        : std_logic_vector_max_c ;\n    DataFromModel      : std_logic_vector_max_c ;\n    DataWidth          : integer_max ;\n    -- Burst FIFOs\n    WriteBurstFifo     : ScoreboardIdType ; \n    ReadBurstFifo      : ScoreboardIdType ; \n--    UseCheckFifo       : boolean_max ; \n--    CheckFifo          : ScoreboardIdType ; \n    -- Parameters - internal settings for the VC in a singleton data structure   \n    Params             : ModelParametersIDType ;  \n    -- StatusMsgOn provides transaction messaging override.\n    -- When true, print transaction messaging independent of \n    -- other verification based based controls.\n    StatusMsgOn        : boolean_max ;\n    -- Verification Component Options Parameters - used by SetModelOptions\n    IntToModel         : integer_max ;\n    IntFromModel       : integer_max ; \n    BoolToModel        : boolean_max ; \n    BoolFromModel      : boolean_max ;\n    TimeToModel        : time_max ; \n    TimeFromModel      : time_max ; \n    -- Verification Component Options Type  \n    Options            : integer_max ;  \n  end record AddressBusRecType ;\n  \n  type AddressBusRecArrayType  is array (integer range <>) of AddressBusRecType ;\n\n  -- --------------------------------------------------------\n  -- Usage of the Transaction Interface (AddressBusRecType)\n  -- The Address and Data fields of AddressBusRecType are unconstrained.\n  -- Unconstrained objects may be used on component/entity interfaces.    \n  -- These fields will be sized when used as a record signal in the test harness \n  -- of the testbench.  Such a declaration is shown below:\n  --\n  --   signal AxiManagerRec : AddressBusRecType(\n  --           Address      (27 downto 0),\n  --           DataToModel  (31 downto 0),\n  --           DataFromModel(31 downto 0)\n  --         ) ;\n  -- --------------------------------------------------------\n  \n--!TODO add VHDL-2018 Interfaces\n\n\n  -- ========================================================\n  --  Types of Transactions\n  --  A transaction may be either a directive or an interface transaction.\n  --\n  --  Directive transactions interact with the verification component \n  --  without generating any transactions or interface waveforms.\n  --\n  --  An interface transaction results in interface signaling to the DUT.\n  --\n  --  A blocking transaction is an interface transaction that does not \n  --  does not return (complete) until the interface operation   \n  --  requested by the transaction has completed.\n  --\n  --  An asynchronous transaction is nonblocking interface transaction\n  --  that returns before the transaction has completed - typically \n  --  immediately and before the transaction has started. \n  --\n  --  A Try transaction is nonblocking interface transaction that \n  --  checks to see if transaction information is available, \n  --  such as read data, and if it is returns it.  \n  --\n  -- ========================================================\n\n\n  -- ========================================================\n  --  Directive Transactions  \n  --  Directive transactions interact with the verification component \n  --  without generating any transactions or interface waveforms.\n  --  Supported by all verification components\n  -- ========================================================\n  ------------------------------------------------------------\n  procedure WaitForTransaction (\n  --  Wait until pending transaction completes\n  ------------------------------------------------------------\n    signal   TransactionRec : InOut AddressBusRecType \n  ) ; \n\n  ------------------------------------------------------------\n  procedure WaitForWriteTransaction (\n  --  Wait until pending transaction completes\n  ------------------------------------------------------------\n    signal   TransactionRec : InOut AddressBusRecType \n  ) ; \n\n  ------------------------------------------------------------\n  procedure WaitForReadTransaction (\n  --  Wait until pending transaction completes\n  ------------------------------------------------------------\n    signal   TransactionRec : InOut AddressBusRecType \n  ) ;\n  \n  ------------------------------------------------------------\n  procedure WaitForClock (\n  -- Wait for NumberOfClocks number of clocks \n  -- relative to the verification component clock\n  ------------------------------------------------------------\n    signal   TransactionRec : InOut AddressBusRecType ;\n    constant NumberOfClocks : In    natural := 1\n  ) ;\n\n  alias NoOp is WaitForClock [AddressBusRecType, natural] ;\n\n  ------------------------------------------------------------\n  procedure GetTransactionCount (\n  -- Get the number of transactions handled by the model.  \n  ------------------------------------------------------------\n    signal   TransactionRec : InOut AddressBusRecType ;\n    variable Count          : Out   integer\n  ) ;\n\n  ------------------------------------------------------------\n  procedure GetWriteTransactionCount (\n  ------------------------------------------------------------\n    signal   TransactionRec : InOut AddressBusRecType ;\n    variable Count          : Out   integer\n  ) ;\n\n  ------------------------------------------------------------\n  procedure GetReadTransactionCount (\n  -- Get the number of read transactions handled by the model.  \n  ------------------------------------------------------------\n    signal   TransactionRec : InOut AddressBusRecType ;\n    variable Count          : Out   integer\n  ) ;\n\n  ------------------------------------------------------------\n  procedure GetAlertLogID (\n  -- Get the AlertLogID from the verification component.\n  ------------------------------------------------------------\n    signal   TransactionRec : InOut AddressBusRecType ;\n    variable AlertLogID     : Out   AlertLogIDType\n  ) ;\n\n  ------------------------------------------------------------\n  procedure GetErrorCount (\n  -- Error reporting for testbenches that do not use OSVVM AlertLogPkg\n  -- Returns error count.  If an error count /= 0, also print errors\n  ------------------------------------------------------------\n    signal   TransactionRec : InOut AddressBusRecType ;\n    variable ErrorCount     : Out   natural\n  ) ;\n\n  alias GetErrors is GetErrorCount [AddressBusRecType, natural] ;\n\n  -- ========================================================\n  --  Delay Coverage Transactions   \n  --  Get Delay Coverage ID to change delay coverage parameters.\n  -- ========================================================\n  ------------------------------------------------------------\n  procedure SetUseRandomDelays (\n  ------------------------------------------------------------\n    signal   TransactionRec : InOut AddressBusRecType ;\n    constant OptVal         : In    boolean := TRUE\n  ) ;\n  \n  ------------------------------------------------------------\n  procedure GetUseRandomDelays (\n  ------------------------------------------------------------\n    signal   TransactionRec : InOut AddressBusRecType ;\n    variable OptVal         : Out   boolean\n  ) ;\n\n  ------------------------------------------------------------\n  procedure SetDelayCoverageID (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout AddressBusRecType ;\n    constant  DelayCov         : in    DelayCoverageIdType ;\n    constant  Index            : in    integer := 1 \n  ) ;\n\n  ------------------------------------------------------------\n  procedure GetDelayCoverageID (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout AddressBusRecType ;\n    variable  DelayCov         : out   DelayCoverageIdType ;\n    constant  Index            : in    integer := 1 \n  ) ;\n\n  ------------------------------------------------------------\n  procedure SetDelayCoverageID (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout AddressBusRecType ;\n    constant  DelayCov         : in    DelayCoverageIdArrayType \n  ) ;\n\n  ------------------------------------------------------------\n  procedure GetDelayCoverageID (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout AddressBusRecType ;\n    variable  DelayCov         : out   DelayCoverageIdArrayType \n  ) ;\n\n  -- ========================================================\n  -- BurstFIFOs and Burst Mode Controls\n  -- The burst FIFOs hold bursts of data that is to be sent to \n  -- or was received from the interface.   The burst FIFO can be \n  -- configured in the modes defined for StreamFifoBurstModeType.\n  -- Currently these modes defined as a subtype of integer, shown below.\n  -- The intention of using integers is to facilitate model specific \n  -- extensions without the need to define separate transactions.\n  -- ========================================================\n  subtype AddressBusFifoBurstModeType is integer ;\n  \n  -- Word mode indicates the burst FIFO contains interface words.\n  -- The size of the word may either be interface specific (such as \n  -- a UART which supports up to 8 bits) or be interface instance specific \n  -- (such as AxiStream which supports interfaces sizes of 1, 2, 4, 8, \n  -- 16, ... bytes)\n  constant ADDRESS_BUS_BURST_WORD_MODE       : AddressBusFifoBurstModeType  := 0 ;\n  \n  -- Byte mode indicates that the burst FIFO contains bytes.  \n  -- The verification component assembles interface words from the bytes.\n  -- This allows transfers to be conceptualized in an interface independent \n  --manner.    \n  constant ADDRESS_BUS_BURST_BYTE_MODE       : AddressBusFifoBurstModeType  := 1 ; \n  \n  -- ========================================================\n  --  Set and Get Burst Mode   \n  --  Set Burst Mode for models that do bursting.\n  -- ========================================================\n  ------------------------------------------------------------\n  procedure SetBurstMode (\n  ------------------------------------------------------------\n    signal   TransactionRec : InOut AddressBusRecType ;\n    constant OptVal         : In    AddressBusFifoBurstModeType\n  ) ;\n\n  ------------------------------------------------------------\n  procedure GetBurstMode (\n  ------------------------------------------------------------\n    signal   TransactionRec : InOut AddressBusRecType ;\n    variable OptVal         : Out   AddressBusFifoBurstModeType\n  ) ;\n\n  ------------------------------------------------------------\n  function IsAddressBusBurstMode (\n  -----------------------------------------------------------\n    constant AddressBusFifoBurstMode : In AddressBusFifoBurstModeType\n  ) return boolean ;\n\n\n  -- ========================================================\n  --  Set and Get Model Options  \n  --  Model operations are directive transactions that are  \n  --  used to configure the verification component.  \n  --  They can either be used directly or with a model specific\n  --  wrapper around them - see AXI models for examples.\n  -- ========================================================\n  ------------------------------------------------------------\n  procedure SetModelOptions (\n  ------------------------------------------------------------\n    signal   TransactionRec : InOut AddressBusRecType ;\n    constant Option         : In    integer ;\n    constant OptVal         : In    boolean\n  ) ;\n\n  ------------------------------------------------------------\n  procedure SetModelOptions (\n  ------------------------------------------------------------\n    signal   TransactionRec : InOut AddressBusRecType ;\n    constant Option         : In    integer ;\n    constant OptVal         : In    integer\n  ) ;\n\n  ------------------------------------------------------------\n  procedure SetModelOptions (\n  ------------------------------------------------------------\n    signal   TransactionRec : InOut AddressBusRecType ;\n    constant Option         : In    integer ;\n    constant OptVal         : In    std_logic_vector\n  ) ;\n  \n  ------------------------------------------------------------\n  procedure SetModelOptions (\n  ------------------------------------------------------------\n    signal   TransactionRec : InOut AddressBusRecType ;\n    constant Option         : In    integer ;\n    constant OptVal         : In    time\n  ) ;\n\n  ------------------------------------------------------------\n  procedure GetModelOptions (\n  ------------------------------------------------------------\n    signal   TransactionRec : InOut AddressBusRecType ;\n    constant Option         : In    integer ;\n    variable OptVal         : Out   boolean\n  ) ;\n\n  ------------------------------------------------------------\n  procedure GetModelOptions (\n  ------------------------------------------------------------\n    signal   TransactionRec : InOut AddressBusRecType ;\n    constant Option         : In    integer ;\n    variable OptVal         : Out   integer\n  ) ;\n\n  ------------------------------------------------------------\n  procedure GetModelOptions (\n  ------------------------------------------------------------\n    signal   TransactionRec : InOut AddressBusRecType ;\n    constant Option         : In    integer ;\n    variable OptVal         : Out   std_logic_vector\n  ) ;\n\n  ------------------------------------------------------------\n  procedure GetModelOptions (\n  ------------------------------------------------------------\n    signal   TransactionRec : InOut AddressBusRecType ;\n    constant Option         : In    integer ;\n    variable OptVal         : Out   time\n  ) ;\n\n  ------------------------------------------------------------\n  procedure InterruptReturn (\n  ------------------------------------------------------------\n    signal   TransactionRec : InOut AddressBusRecType \n  ) ;\n\n\n  -- ========================================================\n  --  Master / Initiator Transactions  \n  -- ========================================================\n  -- ========================================================\n  --  Interface Independent Transactions\n  --  These transactions work independent of the interface.\n  --  Recommended for all tests that verify internal design functionality.\n  --  Many are blocking transactions which do not return (complete)\n  --  until the interface operation requested by the transaction  \n  --  has completed.\n  --  Some are asynchronous, which means they return before the\n  --  transaction is complete - typically even before it starts.\n  --  Supported by all verification components\n  -- ========================================================\n  ------------------------------------------------------------\n  procedure Write (\n  -- Blocking Write Transaction. \n  ------------------------------------------------------------\n    signal   TransactionRec : InOut AddressBusRecType ;\n             iAddr          : In    std_logic_vector ;\n             iData          : In    std_logic_vector ;\n             StatusMsgOn    : In    boolean := false\n  ) ;\n\n  ------------------------------------------------------------\n  procedure WriteAsync (\n  -- Asynchronous / Non-Blocking Write Transaction\n  ------------------------------------------------------------\n    signal   TransactionRec : InOut AddressBusRecType ;\n             iAddr          : In    std_logic_vector ;\n             iData          : In    std_logic_vector ;\n             StatusMsgOn    : In    boolean := false\n  ) ;\n\n  ------------------------------------------------------------\n  procedure Read (\n  -- Blocking Read Transaction.\n  ------------------------------------------------------------\n    signal   TransactionRec : InOut AddressBusRecType ;\n             iAddr          : In    std_logic_vector ;\n    variable oData          : Out   std_logic_vector ;\n             StatusMsgOn    : In    boolean := false\n  ) ;\n\n  ------------------------------------------------------------\n  procedure ReadCheck (\n  -- Blocking Read Transaction and check iData, rather than returning a value.\n  ------------------------------------------------------------\n    signal   TransactionRec : InOut AddressBusRecType ;\n             iAddr          : In    std_logic_vector ;\n             iData          : In    std_logic_vector ;\n             StatusMsgOn    : In    boolean := false\n  ) ;\n  \n  ------------------------------------------------------------\n  procedure ReadPoll (\n  -- Read location (iAddr) until Data(IndexI) = ValueI\n  -- WaitTime is the number of clocks to wait between reads.\n  -- oData is the value read.\n  ------------------------------------------------------------\n    signal   TransactionRec : InOut AddressBusRecType ;\n             iAddr          : In    std_logic_vector ;\n    variable oData          : Out   std_logic_vector ;\n             Index          : In    Integer ;\n             BitValue       : In    std_logic ;\n             StatusMsgOn    : In    boolean := false ;\n             WaitTime       : In    natural := 10\n  ) ;\n\n  ------------------------------------------------------------\n  procedure ReadPoll (\n  -- Read location (iAddr) until Data(IndexI) = ValueI\n  -- WaitTime is the number of clocks to wait between reads.\n  ------------------------------------------------------------\n    signal   TransactionRec : InOut AddressBusRecType ;\n             iAddr          : In    std_logic_vector ;\n             Index          : In    Integer ;\n             BitValue       : In    std_logic ;\n             StatusMsgOn    : In    boolean := false ;\n             WaitTime       : In    natural := 10\n  ) ;\n  \n  ------------------------------------------------------------\n  procedure WriteAndRead (\n  -- Write and Read Cycle that use same address and are dispatched together\n  ------------------------------------------------------------\n    signal   TransactionRec : InOut AddressBusRecType ;\n             iAddr          : In    std_logic_vector ;\n             iData          : In    std_logic_vector ;\n    variable oData          : Out   std_logic_vector ;\n             StatusMsgOn    : In    boolean := false\n  ) ;\n\n  ------------------------------------------------------------\n  procedure WriteAndReadAsync (\n  -- Dispatch Write Address and Data.  Do not wait for completion\n  -- Dispatch Read Address.  Do not wait for Read Data.  \n  -- Retrieve read data with ReadData or TryReadData\n  ------------------------------------------------------------\n    signal   TransactionRec : InOut AddressBusRecType ;\n             iAddr          : In    std_logic_vector ;\n             iData          : In    std_logic_vector ;\n             StatusMsgOn    : In    boolean := false\n  ) ;\n  \n  \n  -- ========================================================\n  --  Burst Transactions\n  --  Some interfaces support bursting, and some do not.  \n  --  Hence, support for burst transactions is optional.\n  --  However, for an interface that does not support bursting,  \n  --  it is appropriate to implement a burst as multiple single  \n  --  cycle operations.    \n  -- ========================================================\n  \n  ------------------------------------------------------------\n  procedure WriteBurst (\n  -- Blocking Write Burst.   \n  -- Data is provided separately via a WriteBurstFifo.   \n  -- NumFifoWords specifies the number of items from the FIFO to be transferred.\n  ------------------------------------------------------------\n    signal   TransactionRec : InOut AddressBusRecType ;\n             iAddr          : In    std_logic_vector ;\n             NumFifoWords   : In    integer ;\n             StatusMsgOn    : In    boolean := false\n  ) ;\n\n  ------------------------------------------------------------\n  procedure WriteBurstVector (\n  ------------------------------------------------------------\n    signal   TransactionRec : InOut AddressBusRecType ;\n             iAddr          : In    std_logic_vector ;\n             VectorOfWords  : In    slv_vector ;\n             StatusMsgOn    : In    boolean := false\n  ) ;\n  \n  ------------------------------------------------------------\n  procedure WriteBurstIncrement (\n  ------------------------------------------------------------\n    signal   TransactionRec : InOut AddressBusRecType ;\n             iAddr          : In    std_logic_vector ;\n             FirstWord      : In    std_logic_vector ;\n             NumFifoWords   : In    integer ;\n             StatusMsgOn    : In    boolean := false\n  ) ;\n\n  ------------------------------------------------------------\n  procedure WriteBurstRandom (\n  ------------------------------------------------------------\n    signal   TransactionRec : InOut AddressBusRecType ;\n             iAddr          : In    std_logic_vector ;\n             FirstWord      : In    std_logic_vector ;\n             NumFifoWords   : In    integer ;\n             StatusMsgOn    : In    boolean := false\n  ) ;\n\n  ------------------------------------------------------------\n  procedure WriteBurstRandom (\n  ------------------------------------------------------------\n    signal   TransactionRec : InOut AddressBusRecType ;\n             iAddr          : In    std_logic_vector ;\n             CoverID        : In    CoverageIDType ;\n             NumFifoWords   : In    integer ;\n             FifoWidth      : In    integer ;\n             StatusMsgOn    : In    boolean := false\n  ) ;\n\n  ------------------------------------------------------------\n  procedure WriteBurstAsync (\n  -- Asynchronous / Non-Blocking Write Burst.   \n  -- Data is provided separately via a WriteBurstFifo.   \n  -- NumFifoWords specifies the number of bytes to be transferred.\n  ------------------------------------------------------------\n    signal   TransactionRec : InOut AddressBusRecType ;\n             iAddr          : In    std_logic_vector ;\n             NumFifoWords   : In    integer ;\n             StatusMsgOn    : In    boolean := false\n  ) ;\n  \n------------------------------------------------------------\n  procedure WriteBurstVectorAsync (\n  ------------------------------------------------------------\n    signal   TransactionRec : InOut AddressBusRecType ;\n             iAddr          : In    std_logic_vector ;\n             VectorOfWords  : In    slv_vector ;\n             StatusMsgOn    : In    boolean := false\n  ) ;\n  \n  ------------------------------------------------------------\n  procedure WriteBurstIncrementAsync (\n  ------------------------------------------------------------\n    signal   TransactionRec : InOut AddressBusRecType ;\n             iAddr          : In    std_logic_vector ;\n             FirstWord      : In    std_logic_vector ;\n             NumFifoWords   : In    integer ;\n             StatusMsgOn    : In    boolean := false\n  ) ;\n\n  ------------------------------------------------------------\n  procedure WriteBurstRandomAsync (\n  ------------------------------------------------------------\n    signal   TransactionRec : InOut AddressBusRecType ;\n             iAddr          : In    std_logic_vector ;\n             FirstWord      : In    std_logic_vector ;\n             NumFifoWords   : In    integer ;\n             StatusMsgOn    : In    boolean := false\n  ) ;\n\n  ------------------------------------------------------------\n  procedure WriteBurstRandomAsync (\n  ------------------------------------------------------------\n    signal   TransactionRec : InOut AddressBusRecType ;\n             iAddr          : In    std_logic_vector ;\n             CoverID        : In    CoverageIDType ;\n             NumFifoWords   : In    integer ;\n             FifoWidth      : In    integer ;\n             StatusMsgOn    : In    boolean := false\n  ) ;\n\n  ------------------------------------------------------------\n  procedure ReadBurst (\n  -- Blocking Read Burst.\n  ------------------------------------------------------------\n    signal   TransactionRec : InOut AddressBusRecType ;\n             iAddr          : In    std_logic_vector ;\n             NumFifoWords   : In    integer ;\n             StatusMsgOn    : In    boolean := false\n  ) ;\n\n  ------------------------------------------------------------\n  procedure ReadCheckBurstVector (\n  ------------------------------------------------------------\n    signal   TransactionRec : InOut AddressBusRecType ;\n             iAddr          : In    std_logic_vector ;\n             VectorOfWords  : In    slv_vector ;\n             StatusMsgOn    : In    boolean := false\n  ) ;\n  \n  ------------------------------------------------------------\n  procedure ReadCheckBurstIncrement (\n  ------------------------------------------------------------\n    signal   TransactionRec : InOut AddressBusRecType ;\n             iAddr          : In    std_logic_vector ;\n             FirstWord      : In    std_logic_vector ;\n             NumFifoWords   : In    integer ;\n             StatusMsgOn    : In    boolean := false\n  ) ;\n\n  ------------------------------------------------------------\n  procedure ReadCheckBurstRandom (\n  ------------------------------------------------------------\n    signal   TransactionRec : InOut AddressBusRecType ;\n             iAddr          : In    std_logic_vector ;\n             FirstWord      : In    std_logic_vector ;\n             NumFifoWords   : In    integer ;\n             StatusMsgOn    : In    boolean := false\n  ) ;\n\n  ------------------------------------------------------------\n  procedure ReadCheckBurstRandom (\n  ------------------------------------------------------------\n    signal   TransactionRec : InOut AddressBusRecType ;\n             iAddr          : In    std_logic_vector ;\n             CoverID        : In    CoverageIDType ;\n             NumFifoWords   : In    integer ;\n             FifoWidth      : In    integer ;\n             StatusMsgOn    : In    boolean := false\n  ) ;\n\n  -- ========================================================\n  --  Interface Specific Transactions\n  --  Support split transaction interfaces - such as AXI which\n  --  independently operates the write address, write data, \n  --  write response, read address, and read data interfaces. \n  --  For split transaction interfaces, these transactions are \n  --  required to fully test the interface characteristics.  \n  --  Most of these transactions are asynchronous.  \n  -- ========================================================\n\n  ------------------------------------------------------------\n  procedure WriteAddressAsync (\n  -- Non-blocking Write Address \n  ------------------------------------------------------------\n    signal   TransactionRec : InOut AddressBusRecType ;\n             iAddr          : In    std_logic_vector ;\n             StatusMsgOn    : In    boolean := false\n  ) ;\n\n  ------------------------------------------------------------\n  procedure WriteDataAsync (\n  -- Non-blocking Write Data \n  ------------------------------------------------------------\n    signal   TransactionRec : InOut AddressBusRecType ;\n             iAddr          : In    std_logic_vector ;\n             iData          : In    std_logic_vector ;\n             StatusMsgOn    : In    boolean := false\n  ) ;\n\n  ------------------------------------------------------------\n  procedure WriteDataAsync (\n  -- Non-blocking Write Data.  iAddr = 0.  \n  ------------------------------------------------------------\n    signal   TransactionRec : InOut AddressBusRecType ;\n             iData          : In    std_logic_vector ;\n             StatusMsgOn    : In    boolean := false\n  ) ;\n  \n  ------------------------------------------------------------\n  procedure ReadAddressAsync (\n  -- Non-blocking Read Address\n  ------------------------------------------------------------\n    signal   TransactionRec : InOut AddressBusRecType ;\n             iAddr          : In    std_logic_vector ;\n             StatusMsgOn    : In    boolean := false\n  ) ;\n\n  ------------------------------------------------------------\n  procedure ReadData (\n  -- Blocking Read Data\n  ------------------------------------------------------------\n    signal   TransactionRec : InOut AddressBusRecType ;\n    variable oData          : Out   std_logic_vector ;\n             StatusMsgOn    : In    boolean := false\n  ) ;\n\n  ------------------------------------------------------------\n  procedure ReadCheckData (\n  -- Blocking Read data and check iData, rather than returning a value.\n  ------------------------------------------------------------\n    signal   TransactionRec : InOut AddressBusRecType ;\n             iData          : In    std_logic_vector ;\n             StatusMsgOn    : In    boolean := false\n  ) ;\n\n  ------------------------------------------------------------\n  procedure TryReadData (\n  -- Try (non-blocking) read data attempt.   \n  -- If data is available, get it and return available TRUE.\n  -- Otherwise Return Available FALSE.\n  ------------------------------------------------------------\n    signal   TransactionRec : InOut AddressBusRecType ;\n    variable oData          : Out   std_logic_vector ;\n    variable Available      : Out   boolean ;\n             StatusMsgOn    : In    boolean := false\n  ) ;\n\n  ------------------------------------------------------------\n  procedure TryReadCheckData (\n  -- Try (non-blocking) read data and check attempt.   \n  -- If data is available, check it and return available TRUE.\n  -- Otherwise Return Available FALSE.\n  ------------------------------------------------------------\n    signal   TransactionRec : InOut AddressBusRecType ;\n             iData          : In    std_logic_vector ;\n    variable Available      : Out   boolean ;\n             StatusMsgOn    : In    boolean := false\n  ) ;\n\n  -- ========================================================\n  --  Pseudo Transactions\n  --  Interact with the record only.\n  -- ========================================================\n  ------------------------------------------------------------\n  procedure ReleaseTransactionRecord (\n  --  Must run on same delta cycle as AcquireTransactionRecord\n  ------------------------------------------------------------\n    signal   TransactionRec : InOut AddressBusRecType \n  ) ; \n  \n  ------------------------------------------------------------\n  procedure AcquireTransactionRecord (\n  --  Must run on same delta cycle as ReleaseTransactionRecord\n  ------------------------------------------------------------\n    signal   TransactionRec : InOut AddressBusRecType \n  ) ; \n\n  -- ========================================================\n  --  Verification Component Support Functions\n  --  These help decode the operation value (AddressBusOperationType)  \n  --  to determine properties about the operation\n  -- ========================================================\n  ------------------------------------------------------------\n  function IsWriteAddress (\n  -- TRUE for a transaction includes write address\n  -----------------------------------------------------------\n    constant Operation      : In AddressBusOperationType\n  ) return boolean ;\n\n  ------------------------------------------------------------\n  function IsBlockOnWriteAddress (\n  -- TRUE for blocking transactions that include write address\n  -----------------------------------------------------------\n    constant Operation      : In AddressBusOperationType\n  ) return boolean ;\n\n  ------------------------------------------------------------\n  function IsTryWriteAddress (\n  -- TRUE for asynchronous or try transactions that include write address\n  -----------------------------------------------------------\n    constant Operation      : In AddressBusOperationType\n  ) return boolean ;\n\n  ------------------------------------------------------------\n  function IsWriteData (\n  -- TRUE for a transaction includes write data\n  -----------------------------------------------------------\n    constant Operation      : In AddressBusOperationType\n  ) return boolean ;\n\n  ------------------------------------------------------------\n  function IsBlockOnWriteData (\n  -- TRUE for a blocking transactions that include write data\n  -----------------------------------------------------------\n    constant Operation      : In AddressBusOperationType\n  ) return boolean ;\n\n  ------------------------------------------------------------\n  function IsTryWriteData (\n  -- TRUE for asynchronous or try transactions that include write data\n  -----------------------------------------------------------\n    constant Operation      : In AddressBusOperationType\n  ) return boolean ;\n\n  ------------------------------------------------------------\n  function IsReadAddress (\n  -- TRUE for a transaction includes read address\n  -----------------------------------------------------------\n    constant Operation      : In AddressBusOperationType\n  ) return boolean ;\n\n  ------------------------------------------------------------\n  function IsTryReadAddress (\n  -- TRUE for an asynchronous or try transactions that include read address\n  -----------------------------------------------------------\n    constant Operation      : In AddressBusOperationType\n  ) return boolean ;\n\n  ------------------------------------------------------------\n  function IsReadData (\n  -- TRUE for a transaction includes read data\n  -----------------------------------------------------------\n    constant Operation      : In AddressBusOperationType\n  ) return boolean ;\n\n  ------------------------------------------------------------\n  function IsBlockOnReadData (\n  -- TRUE for a blocking transactions that include read data\n  -----------------------------------------------------------\n    constant Operation      : In AddressBusOperationType\n  ) return boolean ;\n\n  ------------------------------------------------------------\n  function IsTryReadData (\n  -- TRUE for asynchronous or try transactions that include read data\n  -----------------------------------------------------------\n    constant Operation      : In AddressBusOperationType\n  ) return boolean ;\n\n  ------------------------------------------------------------\n  function IsReadCheck (\n  -- TRUE for a transaction includes check information for read data \n  -----------------------------------------------------------\n    constant Operation      : In AddressBusOperationType\n  ) return boolean ;\n\n  ------------------------------------------------------------\n  function IsBurst (\n  -- TRUE for a transaction includes read or write burst information\n  -----------------------------------------------------------\n    constant Operation      : In AddressBusOperationType\n  ) return boolean ;\n\n  ------------------------------------------------------------\n  function ClassifyUnimplementedOperation (\n  -----------------------------------------------------------\n    constant Operation        : In AddressBusOperationType ;\n    constant TransactionCount : in natural\n  ) return string ;\n  \nend package AddressBusTransactionPkg ;\n\n-- /////////////////////////////////////////////////////////////////////////////////////////\n-- /////////////////////////////////////////////////////////////////////////////////////////\n\npackage body AddressBusTransactionPkg is\n\n  function resolved_max ( s : UnresolvedAddressBusOperationVectorType) return UnresolvedAddressBusOperationType is\n    variable Result : UnresolvedAddressBusOperationType := NOT_DRIVEN ;\n  begin\n    for i in s'range loop \n      if s(i) /= NOT_DRIVEN then \n        if result = NOT_DRIVEN then \n          result := s(i) ;\n        else\n          result := MULTIPLE_DRIVER_DETECT ;\n        end if ; \n      end if ; \n    end loop ;\n    return result ; \n--    return maximum(s) ;\n  end function resolved_max ;\n\n  -- ========================================================\n  --  Directive Transactions\n  --  Interact with verification component but not interface.\n  -- ========================================================\n  ------------------------------------------------------------\n  procedure WaitForTransaction (\n  --  Wait until pending transaction completes\n  ------------------------------------------------------------\n    signal   TransactionRec : InOut AddressBusRecType \n  ) is\n  begin\n    TransactionRec.Operation     <= WAIT_FOR_TRANSACTION ;\n    RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ; \n  end procedure WaitForTransaction ; \n\n  ------------------------------------------------------------\n  procedure WaitForWriteTransaction (\n  --  Wait until pending transaction completes\n  ------------------------------------------------------------\n    signal   TransactionRec : InOut AddressBusRecType \n  ) is\n  begin\n    TransactionRec.Operation     <= WAIT_FOR_WRITE_TRANSACTION ;\n    RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ; \n  end procedure WaitForWriteTransaction ; \n\n  ------------------------------------------------------------\n  procedure WaitForReadTransaction (\n  --  Wait until pending transaction completes\n  ------------------------------------------------------------\n    signal   TransactionRec : InOut AddressBusRecType \n  ) is\n  begin\n    TransactionRec.Operation     <= WAIT_FOR_READ_TRANSACTION ;\n    RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ; \n  end procedure WaitForReadTransaction ; \n\n  ------------------------------------------------------------\n  procedure WaitForClock (\n  -- Directive:  Wait for NumberOfClocks number of clocks in the model\n  ------------------------------------------------------------\n    signal   TransactionRec : InOut AddressBusRecType ;\n    constant NumberOfClocks : In    natural := 1\n  ) is\n  begin\n    TransactionRec.Operation     <= WAIT_FOR_CLOCK ;\n    TransactionRec.IntToModel    <= NumberOfClocks ; \n    RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;\n  end procedure WaitForClock ;\n\n  ------------------------------------------------------------\n  procedure GetTransactionCount (\n  ------------------------------------------------------------\n    signal   TransactionRec : InOut AddressBusRecType ;\n    variable Count          : Out   integer\n  ) is\n  begin\n    TransactionRec.Operation     <= GET_TRANSACTION_COUNT ;\n    RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;\n\n    -- Return AlertLogID\n    Count := TransactionRec.IntFromModel ;\n--    Count := integer(TransactionRec.Rdy) ;\n  end procedure GetTransactionCount ;\n\n  ------------------------------------------------------------\n  procedure GetWriteTransactionCount (\n  ------------------------------------------------------------\n    signal   TransactionRec : InOut AddressBusRecType ;\n    variable Count          : Out   integer\n  ) is\n  begin\n    TransactionRec.Operation     <= GET_WRITE_TRANSACTION_COUNT ;\n    RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;\n\n    -- Return AlertLogID\n    Count := TransactionRec.IntFromModel ;\n  end procedure GetWriteTransactionCount ;\n\n  ------------------------------------------------------------\n  procedure GetReadTransactionCount (\n  ------------------------------------------------------------\n    signal   TransactionRec : InOut AddressBusRecType ;\n    variable Count          : Out   integer\n  ) is\n  begin\n    TransactionRec.Operation     <= GET_READ_TRANSACTION_COUNT ;\n    RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;\n\n    -- Return AlertLogID\n    Count := TransactionRec.IntFromModel ;\n  end procedure GetReadTransactionCount ;\n\n  ------------------------------------------------------------\n  procedure GetAlertLogID (\n  ------------------------------------------------------------\n    signal   TransactionRec : InOut AddressBusRecType ;\n    variable AlertLogID     : Out   AlertLogIDType\n  ) is\n  begin\n    TransactionRec.Operation     <= GET_ALERTLOG_ID ;\n    RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;\n\n    -- Return AlertLogID\n    AlertLogID := AlertLogIDType(TransactionRec.IntFromModel) ;\n  end procedure GetAlertLogID ;\n\n  ------------------------------------------------------------\n  procedure GetErrorCount (\n  -- Error reporting for testbenches that do not use AlertLogPkg\n  -- Returns error count.  If an error count /= 0, also print it\n  ------------------------------------------------------------\n    signal   TransactionRec : InOut AddressBusRecType ;\n    variable ErrorCount     : Out   natural\n  ) is\n    variable ModelID : AlertLogIDType ;\n  begin\n    GetAlertLogID(TransactionRec, ModelID) ;\n--    ReportNonZeroAlerts(AlertLogID => ModelID) ;\n    ErrorCount := GetAlertCount(AlertLogID => ModelID) ;\n  end procedure GetErrorCount ;\n\n  -- ========================================================\n  --  Delay Coverage Transactions   \n  --  Get Delay Coverage ID to change delay coverage parameters.\n  -- ========================================================\n  ------------------------------------------------------------\n  procedure SetUseRandomDelays (\n  ------------------------------------------------------------\n    signal   TransactionRec : InOut AddressBusRecType ;\n    constant OptVal         : In    boolean := TRUE\n  ) is\n  begin\n    TransactionRec.Operation     <= SET_USE_RANDOM_DELAYS ;\n    TransactionRec.BoolToModel   <= OptVal ;\n    RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;\n  end procedure SetUseRandomDelays ;\n\n  ------------------------------------------------------------\n  procedure GetUseRandomDelays (\n  ------------------------------------------------------------\n    signal   TransactionRec : InOut AddressBusRecType ;\n    variable OptVal         : Out   boolean\n  ) is\n  begin\n    TransactionRec.Operation     <= GET_USE_RANDOM_DELAYS ;\n    RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;\n    OptVal := TransactionRec.BoolFromModel    ;\n  end procedure GetUseRandomDelays ;\n  \n  ------------------------------------------------------------\n  procedure SetDelayCoverageID (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout AddressBusRecType ;\n    constant  DelayCov         : in    DelayCoverageIdType ;\n    constant  Index            : in    integer := 1 \n  ) is\n  begin\n    TransactionRec.Operation     <= SET_DELAYCOV_ID ;\n    TransactionRec.IntToModel    <= DelayCov.ID ;\n    TransactionRec.Options       <= Index ; \n    RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;\n  end procedure SetDelayCoverageID ;\n\n  ------------------------------------------------------------\n  procedure GetDelayCoverageID (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout AddressBusRecType ;\n    variable  DelayCov         : out   DelayCoverageIdType ;\n    constant  Index            : in    integer := 1 \n  ) is\n  begin\n    TransactionRec.Operation     <= GET_DELAYCOV_ID ;\n    TransactionRec.Options       <= Index ; \n    RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;\n    DelayCov := GetDelayCoverage(TransactionRec.IntFromModel) ; \n  end procedure GetDelayCoverageID ;\n\n  ------------------------------------------------------------\n  procedure SetDelayCoverageID (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout AddressBusRecType ;\n    constant  DelayCov         : in    DelayCoverageIdArrayType \n  ) is\n  begin\n    for i in DelayCov'range loop\n      SetDelayCoverageID(TransactionRec, DelayCov(i), i) ; \n    end loop ; \n  end procedure SetDelayCoverageID ;\n\n  ------------------------------------------------------------\n  procedure GetDelayCoverageID (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout AddressBusRecType ;\n    variable  DelayCov         : out   DelayCoverageIdArrayType \n  ) is\n  begin\n    for i in DelayCov'range loop\n      GetDelayCoverageID(TransactionRec, DelayCov(i), i) ; \n    end loop ; \n  end procedure GetDelayCoverageID ;\n\n  -- ========================================================\n  --  Set and Get Burst Mode   \n  --  Set Burst Mode for models that do bursting.\n  -- ========================================================\n  ------------------------------------------------------------\n  procedure SetBurstMode (\n  ------------------------------------------------------------\n    signal   TransactionRec : InOut AddressBusRecType ;\n    constant OptVal         : In    AddressBusFifoBurstModeType\n  ) is\n  begin\n    TransactionRec.Operation     <= SET_BURST_MODE ;\n    TransactionRec.IntToModel    <= OptVal ;\n    RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;\n  end procedure SetBurstMode ;\n\n  ------------------------------------------------------------\n  procedure GetBurstMode (\n  ------------------------------------------------------------\n    signal   TransactionRec : InOut AddressBusRecType ;\n    variable OptVal         : Out   AddressBusFifoBurstModeType\n  ) is\n  begin\n    TransactionRec.Operation     <= GET_BURST_MODE ;\n    RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;\n    OptVal := TransactionRec.IntFromModel ; \n  end procedure GetBurstMode ;\n\n  ------------------------------------------------------------\n  function IsAddressBusBurstMode (\n  -----------------------------------------------------------\n    constant AddressBusFifoBurstMode : In AddressBusFifoBurstModeType\n  ) return boolean is\n  begin\n    return\n      (AddressBusFifoBurstMode = ADDRESS_BUS_BURST_WORD_MODE) or\n      (AddressBusFifoBurstMode = ADDRESS_BUS_BURST_BYTE_MODE) ;\n  end function IsAddressBusBurstMode ;\n\n  --\n  --  Extensions to support model customizations\n  -- \n  ------------------------------------------------------------\n  procedure SetModelOptions (\n  ------------------------------------------------------------\n    signal   TransactionRec : InOut AddressBusRecType ;\n    constant Option         : In    integer ;\n    constant OptVal         : In    boolean\n  ) is\n  begin\n    TransactionRec.Operation     <= SET_MODEL_OPTIONS ;\n    TransactionRec.Options       <= Option ;\n    TransactionRec.BoolToModel   <= OptVal ;\n    RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;\n  end procedure SetModelOptions ;\n\n  ------------------------------------------------------------\n  procedure SetModelOptions (\n  ------------------------------------------------------------\n    signal   TransactionRec : InOut AddressBusRecType ;\n    constant Option         : In    integer ;\n    constant OptVal         : In    integer\n  ) is\n  begin\n    TransactionRec.Operation     <= SET_MODEL_OPTIONS ;\n    TransactionRec.Options       <= Option ;\n    TransactionRec.IntToModel    <= OptVal ;\n    RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;\n  end procedure SetModelOptions ;\n\n  ------------------------------------------------------------\n  procedure SetModelOptions (\n  ------------------------------------------------------------\n    signal   TransactionRec : InOut AddressBusRecType ;\n    constant Option         : In    integer ;\n    constant OptVal         : In    std_logic_vector\n  ) is\n  begin\n    TransactionRec.Operation     <= SET_MODEL_OPTIONS ;\n    TransactionRec.Options       <= Option ;\n    TransactionRec.IntToModel    <= to_integer(OptVal) ;\n    RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;\n  end procedure SetModelOptions ;\n\n  ------------------------------------------------------------\n  procedure SetModelOptions (\n  ------------------------------------------------------------\n    signal   TransactionRec : InOut AddressBusRecType ;\n    constant Option         : In    integer ;\n    constant OptVal         : In    time\n  ) is\n  begin\n    TransactionRec.Operation     <= SET_MODEL_OPTIONS ;\n    TransactionRec.Options       <= Option ;\n    TransactionRec.TimeToModel   <= OptVal ;\n    RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;\n  end procedure SetModelOptions ;\n  \n  ------------------------------------------------------------\n  procedure GetModelOptions (\n  ------------------------------------------------------------\n    signal   TransactionRec : InOut AddressBusRecType ;\n    constant Option         : In    integer ;\n    variable OptVal         : Out   boolean\n  ) is\n  begin\n    TransactionRec.Operation     <= GET_MODEL_OPTIONS ;\n    TransactionRec.Options       <= Option ;\n    RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;\n    OptVal := TransactionRec.BoolFromModel    ;\n  end procedure GetModelOptions ;\n\n  ------------------------------------------------------------\n  procedure GetModelOptions (\n  ------------------------------------------------------------\n    signal   TransactionRec : InOut AddressBusRecType ;\n    constant Option         : In    integer ;\n    variable OptVal         : Out   integer\n  ) is\n  begin\n    TransactionRec.Operation     <= GET_MODEL_OPTIONS ;\n    TransactionRec.Options       <= Option ;\n    RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;\n    OptVal := TransactionRec.IntFromModel ; \n  end procedure GetModelOptions ;\n\n  ------------------------------------------------------------\n  procedure GetModelOptions (\n  ------------------------------------------------------------\n    signal   TransactionRec : InOut AddressBusRecType ;\n    constant Option         : In    integer ;\n    variable OptVal         : Out   std_logic_vector\n  ) is\n  begin\n    TransactionRec.Operation     <= GET_MODEL_OPTIONS ;\n    TransactionRec.Options       <= Option ;\n    RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;\n    OptVal := to_slv(TransactionRec.IntFromModel, OptVal'length) ; \n  end procedure GetModelOptions ;\n\n  ------------------------------------------------------------\n  procedure GetModelOptions (\n  ------------------------------------------------------------\n    signal   TransactionRec : InOut AddressBusRecType ;\n    constant Option         : In    integer ;\n    variable OptVal         : Out   time\n  ) is\n  begin\n    TransactionRec.Operation     <= GET_MODEL_OPTIONS ;\n    TransactionRec.Options       <= Option ;\n    RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;\n    OptVal := TransactionRec.TimeFromModel ; \n  end procedure GetModelOptions ;\n\n  ------------------------------------------------------------\n  procedure InterruptReturn (\n  ------------------------------------------------------------\n    signal   TransactionRec : InOut AddressBusRecType \n  ) is\n  begin\n    TransactionRec.Operation     <= INTERRUPT_RETURN ;\n    RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;\n  end procedure InterruptReturn ;\n\n  ------------------------------------------------------------\n  procedure Write (\n  -- do CPU Write Cycle\n  ------------------------------------------------------------\n    signal   TransactionRec : InOut AddressBusRecType ;\n             iAddr          : In    std_logic_vector ;\n             iData          : In    std_logic_vector ;\n             StatusMsgOn    : In    boolean := false\n  ) is\n  begin\n    -- Put values in record\n    TransactionRec.Operation     <= WRITE_OP ;\n    TransactionRec.Address       <= SafeResize(iAddr, TransactionRec.Address'length) ;\n    TransactionRec.AddrWidth     <= iAddr'length ;\n    TransactionRec.DataToModel   <= SafeResize(iData, TransactionRec.DataToModel'length) ;\n    TransactionRec.DataWidth     <= iData'length ;\n    TransactionRec.StatusMsgOn   <= StatusMsgOn ;\n    -- Start Transaction\n    RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;\n  end procedure Write ;\n\n  ------------------------------------------------------------\n  procedure WriteAsync (\n  -- dispatch CPU Write Cycle\n  ------------------------------------------------------------\n    signal   TransactionRec : InOut AddressBusRecType ;\n             iAddr          : In    std_logic_vector ;\n             iData          : In    std_logic_vector ;\n             StatusMsgOn    : In    boolean := false\n  ) is\n  begin\n    -- Put values in record\n    TransactionRec.Operation     <= ASYNC_WRITE ;\n    TransactionRec.Address       <= SafeResize(iAddr, TransactionRec.Address'length) ;\n    TransactionRec.AddrWidth     <= iAddr'length ;\n    TransactionRec.DataToModel   <= SafeResize(iData, TransactionRec.DataToModel'length) ;\n    TransactionRec.DataWidth     <= iData'length ;\n    TransactionRec.StatusMsgOn   <= StatusMsgOn ;\n    -- Start Transaction\n    RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;\n  end procedure WriteAsync ;\n\n  ------------------------------------------------------------\n  procedure WriteAddressAsync (\n  -- dispatch CPU Write Address Cycle\n  ------------------------------------------------------------\n    signal   TransactionRec : InOut AddressBusRecType ;\n             iAddr          : In    std_logic_vector ;\n             StatusMsgOn    : In    boolean := false\n  ) is\n  begin\n    -- Put values in record\n    TransactionRec.Operation     <= ASYNC_WRITE_ADDRESS ;\n    TransactionRec.Address       <= SafeResize(iAddr, TransactionRec.Address'length) ;\n    TransactionRec.AddrWidth     <= iAddr'length ;\n    TransactionRec.DataWidth     <= 0 ;\n    TransactionRec.StatusMsgOn   <= StatusMsgOn ;\n    -- Start Transaction\n    RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;\n  end procedure WriteAddressAsync ;\n\n  ------------------------------------------------------------\n  procedure WriteDataAsync (\n  -- dispatch CPU Write Data Cycle\n  ------------------------------------------------------------\n    signal   TransactionRec : InOut AddressBusRecType ;\n             iAddr          : In    std_logic_vector ;\n             iData          : In    std_logic_vector ;\n             StatusMsgOn    : In    boolean := false\n  ) is\n  begin\n    -- Put values in record\n    TransactionRec.Operation     <= ASYNC_WRITE_DATA ;\n    TransactionRec.Address       <= SafeResize(iAddr, TransactionRec.Address'length) ;\n    TransactionRec.AddrWidth     <= iAddr'length ;\n    TransactionRec.DataToModel   <= SafeResize(iData, TransactionRec.DataToModel'length) ;\n    TransactionRec.DataWidth     <= iData'length ;\n    TransactionRec.StatusMsgOn   <= StatusMsgOn ;\n    -- Start Transaction\n    RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;\n  end procedure WriteDataAsync ;\n  \n  ------------------------------------------------------------\n  procedure WriteDataAsync (\n  ------------------------------------------------------------\n    signal   TransactionRec : InOut AddressBusRecType ;\n             iData          : In    std_logic_vector ;\n             StatusMsgOn    : In    boolean := false\n  ) is\n  begin\n    WriteDataAsync(TransactionRec, X\"00\", iData, StatusMsgOn) ;\n  end procedure WriteDataAsync ;\n\n  ------------------------------------------------------------\n  procedure Read (\n  -- do CPU Read Cycle and return data\n  ------------------------------------------------------------\n    signal   TransactionRec : InOut AddressBusRecType ;\n             iAddr          : In    std_logic_vector ;\n    variable oData          : Out   std_logic_vector ;\n             StatusMsgOn    : In    boolean := false\n  ) is\n  begin\n    -- Put values in record\n    TransactionRec.Operation     <= READ_OP ;\n    TransactionRec.Address       <= SafeResize(iAddr, TransactionRec.Address'length) ;\n    TransactionRec.AddrWidth     <= iAddr'length ;\n    TransactionRec.DataWidth     <= oData'length ;\n    TransactionRec.StatusMsgOn   <= StatusMsgOn ;\n    -- Start Transaction\n    RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;\n    -- Return Results\n    oData  := SafeResize(TransactionRec.DataFromModel, oData'length) ;\n  end procedure Read ;\n\n  ------------------------------------------------------------\n  procedure ReadCheck (\n  -- do CPU Read Cycle and check supplied data\n  ------------------------------------------------------------\n    signal   TransactionRec : InOut AddressBusRecType ;\n             iAddr          : In    std_logic_vector ;\n             iData          : In    std_logic_vector ;\n             StatusMsgOn    : In    boolean := false\n  ) is\n  begin\n    -- Put values in record\n    TransactionRec.Operation     <= READ_CHECK ;\n    TransactionRec.Address       <= SafeResize(iAddr, TransactionRec.Address'length) ;\n    TransactionRec.AddrWidth     <= iAddr'length ;\n    TransactionRec.DataToModel   <= SafeResize(iData, TransactionRec.DataToModel'length) ;\n    TransactionRec.DataWidth     <= iData'length ;\n    TransactionRec.StatusMsgOn   <= StatusMsgOn ;\n    -- Start Transaction\n    RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;\n  end procedure ReadCheck ;\n\n  ------------------------------------------------------------\n  procedure ReadAddressAsync (\n  -- dispatch CPU Read Address Cycle\n  ------------------------------------------------------------\n    signal   TransactionRec : InOut AddressBusRecType ;\n             iAddr          : In    std_logic_vector ;\n             StatusMsgOn    : In    boolean := false\n  ) is\n  begin\n    -- Put values in record\n    TransactionRec.Operation     <= ASYNC_READ_ADDRESS ;\n    TransactionRec.Address       <= SafeResize(iAddr, TransactionRec.Address'length) ;\n    TransactionRec.AddrWidth     <= iAddr'length ;\n    TransactionRec.DataToModel   <= (TransactionRec.DataToModel'range => 'X') ;\n    TransactionRec.DataWidth     <= 0 ;\n    TransactionRec.StatusMsgOn   <= StatusMsgOn ;\n    -- Start Transaction\n    RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;\n  end procedure ReadAddressAsync ;\n\n  ------------------------------------------------------------\n  procedure ReadData (\n  -- Do CPU Read Data Cycle\n  ------------------------------------------------------------\n    signal   TransactionRec : InOut AddressBusRecType ;\n    variable oData          : Out   std_logic_vector ;\n             StatusMsgOn    : In    boolean := false\n  ) is\n  begin\n    -- Put values in record\n    TransactionRec.Operation     <= READ_DATA ;\n    TransactionRec.Address       <= (TransactionRec.Address'range => 'X') ;\n    TransactionRec.DataWidth     <= oData'length ;\n    TransactionRec.StatusMsgOn   <= StatusMsgOn ;\n    -- Start Transaction\n    RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;\n    -- Return Results\n    oData  := SafeResize(TransactionRec.DataFromModel, oData'length) ;\n  end procedure ReadData ;\n\n  ------------------------------------------------------------\n  procedure ReadCheckData (\n  -- Do CPU Read Data Cycle and check received Data\n  ------------------------------------------------------------\n    signal   TransactionRec : InOut AddressBusRecType ;\n             iData          : In    std_logic_vector ;\n             StatusMsgOn    : In    boolean := false\n  ) is\n  begin\n    -- Put values in record\n    TransactionRec.Operation     <= READ_DATA_CHECK ;\n    TransactionRec.Address       <= (TransactionRec.Address'range => 'X') ;\n    TransactionRec.DataToModel   <= SafeResize(iData, TransactionRec.DataToModel'length) ;\n    TransactionRec.DataWidth     <= iData'length ;\n    TransactionRec.StatusMsgOn   <= StatusMsgOn ;\n    -- Start Transaction\n    RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;\n  end procedure ReadCheckData ;\n\n  ------------------------------------------------------------\n  procedure TryReadData (\n  -- Try to Get CPU Read Data Cycle\n  -- If data is available, get it and return available TRUE.\n  -- Otherwise Return Available FALSE.\n  ------------------------------------------------------------\n    signal   TransactionRec : InOut AddressBusRecType ;\n    variable oData          : Out   std_logic_vector ;\n    variable Available      : Out   boolean ;\n             StatusMsgOn    : In    boolean := false\n  ) is\n  begin\n    -- Put values in record\n    TransactionRec.Operation     <= ASYNC_READ_DATA ;\n    TransactionRec.Address       <= (TransactionRec.Address'range => 'X') ;\n    TransactionRec.DataWidth     <= oData'length ;\n    TransactionRec.StatusMsgOn   <= StatusMsgOn ;\n    -- Start Transaction\n    RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;\n    -- Return Results\n    oData  := SafeResize(TransactionRec.DataFromModel, oData'length) ;\n    Available := TransactionRec.BoolFromModel ;\n  end procedure TryReadData ;\n\n  ------------------------------------------------------------\n  procedure TryReadCheckData (\n  -- Try to Get CPU Read Data Cycle\n  -- If data is available, check it and return available TRUE.\n  -- Otherwise Return Available FALSE.\n  ------------------------------------------------------------\n    signal   TransactionRec : InOut AddressBusRecType ;\n             iData          : In    std_logic_vector ;\n    variable Available      : Out   boolean ;\n             StatusMsgOn    : In    boolean := false\n  ) is\n  begin\n    -- Put values in record\n    TransactionRec.Operation     <= ASYNC_READ_DATA_CHECK ;\n    TransactionRec.Address       <= (TransactionRec.Address'range => 'X') ;\n    TransactionRec.DataToModel   <= SafeResize(iData, TransactionRec.DataToModel'length) ;\n    TransactionRec.DataWidth     <= iData'length ;\n    TransactionRec.StatusMsgOn   <= StatusMsgOn ;\n    -- Start Transaction\n    RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;\n    Available := TransactionRec.BoolFromModel ;\n  end procedure TryReadCheckData ;\n\n  ------------------------------------------------------------\n  procedure ReadPoll (\n  -- Read location (iAddr) until Data(IndexI) = ValueI\n  ------------------------------------------------------------\n    signal   TransactionRec : InOut AddressBusRecType ;\n             iAddr          : In    std_logic_vector ;\n    variable oData          : Out   std_logic_vector ;\n             Index          : In    Integer ;\n             BitValue       : In    std_logic ;\n             StatusMsgOn    : In    boolean := false ;\n             WaitTime       : In    natural := 10\n  ) is\n    variable vData    : std_logic_vector(oData'length-1 downto 0) ;\n    variable ModelID  : AlertLogIDType ;\n  begin\n    loop\n      WaitForClock(TransactionRec, WaitTime) ;\n      Read (TransactionRec, iAddr, vData) ;\n      exit when vData(Index) = BitValue ;\n    end loop ;\n\n    GetAlertLogID(TransactionRec, ModelID) ;\n    Log(ModelID, \"CpuPoll: address\" & to_hstring(iAddr) &\n      \"  Data: \" & to_hstring(vData), INFO, StatusMsgOn) ;\n    oData := vData ;\n  end procedure ReadPoll ;\n\n  ------------------------------------------------------------\n  procedure ReadPoll (\n  -- Read location (iAddr) until Data(IndexI) = ValueI\n  ------------------------------------------------------------\n    signal   TransactionRec : InOut AddressBusRecType ;\n             iAddr          : In    std_logic_vector ;\n             Index          : In    Integer ;\n             BitValue       : In    std_logic ;\n             StatusMsgOn    : In    boolean := false ;\n             WaitTime       : In    natural := 10\n  ) is\n    variable vData    : std_logic_vector(TransactionRec.DataFromModel'range) ;\n  begin\n    ReadPoll(TransactionRec, iAddr, vData, Index, BitValue, StatusMsgOn, WaitTime) ;\n  end procedure ReadPoll ;\n\n  ------------------------------------------------------------\n  procedure WriteAndRead (\n  -- Write and Read Cycle that use same address and are dispatched together\n  ------------------------------------------------------------\n    signal   TransactionRec : InOut AddressBusRecType ;\n             iAddr          : In    std_logic_vector ;\n             iData          : In    std_logic_vector ;\n    variable oData          : Out   std_logic_vector ;\n             StatusMsgOn    : In    boolean := false\n  ) is\n  begin\n    -- Put values in record\n    TransactionRec.Operation     <= WRITE_AND_READ ;\n    TransactionRec.Address       <= SafeResize(iAddr, TransactionRec.Address'length) ;\n    TransactionRec.AddrWidth     <= iAddr'length ;\n    TransactionRec.DataToModel   <= SafeResize(iData, TransactionRec.DataToModel'length) ;\n    TransactionRec.DataWidth     <= iData'length ;\n    TransactionRec.StatusMsgOn   <= StatusMsgOn ;\n    -- Start Transaction\n    RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;\n    -- Return Results\n    oData  := SafeResize(TransactionRec.DataFromModel, oData'length) ;  \n  end procedure WriteAndRead ;\n\n  ------------------------------------------------------------\n  procedure WriteAndReadAsync (\n  -- Dispatch Write Address and Data.  Do not wait for completion\n  -- Dispatch Read Address.  Do not wait for Read Data.  \n  -- Retrieve read data with ReadData or TryReadData\n  ------------------------------------------------------------\n    signal   TransactionRec : InOut AddressBusRecType ;\n             iAddr          : In    std_logic_vector ;\n             iData          : In    std_logic_vector ;\n             StatusMsgOn    : In    boolean := false\n  ) is\n  begin\n    -- Put values in record\n    TransactionRec.Operation     <= ASYNC_WRITE_AND_READ ;\n    TransactionRec.Address       <= SafeResize(iAddr, TransactionRec.Address'length) ;\n    TransactionRec.AddrWidth     <= iAddr'length ;\n    TransactionRec.DataToModel   <= SafeResize(iData, TransactionRec.DataToModel'length) ;\n    TransactionRec.DataWidth     <= iData'length ;\n    TransactionRec.StatusMsgOn   <= StatusMsgOn ;\n    -- Start Transaction\n    RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;\n  end procedure WriteAndReadAsync ;\n  \n  -- ========================================================\n  --  Burst Transactions\n  -- ========================================================\n\n  ------------------------------------------------------------\n  procedure WriteBurst (\n  -- do CPU Write Cycle\n  ------------------------------------------------------------\n    signal   TransactionRec : InOut AddressBusRecType ;\n             iAddr          : In    std_logic_vector ;\n             NumFifoWords   : In    integer ;\n             StatusMsgOn    : In    boolean := false\n  ) is\n  begin\n    -- Put values in record\n    TransactionRec.Operation     <= WRITE_BURST ;\n    TransactionRec.Address       <= SafeResize(iAddr, TransactionRec.Address'length) ;\n    TransactionRec.AddrWidth     <= iAddr'length ;\n--    TransactionRec.DataToModel   <= (TransactionRec.DataToModel'range => 'X') ;\n    TransactionRec.DataWidth     <= NumFifoWords ;\n    TransactionRec.StatusMsgOn   <= StatusMsgOn ;\n    -- Start Transaction\n    RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;\n  end procedure WriteBurst ;\n  \n  ------------------------------------------------------------\n  procedure WriteBurstVector (\n  ------------------------------------------------------------\n    signal   TransactionRec : InOut AddressBusRecType ;\n             iAddr          : In    std_logic_vector ;\n             VectorOfWords  : In    slv_vector ;\n             StatusMsgOn    : In    boolean := false\n  ) is\n  begin\n    PushBurstVector(TransactionRec.WriteBurstFifo, VectorOfWords) ; \n    WriteBurst(TransactionRec, iAddr, VectorOfWords'length, StatusMsgOn) ; \n  end procedure WriteBurstVector ;\n  \n  ------------------------------------------------------------\n  procedure WriteBurstIncrement (\n  ------------------------------------------------------------\n    signal   TransactionRec : InOut AddressBusRecType ;\n             iAddr          : In    std_logic_vector ;\n             FirstWord      : In    std_logic_vector ;\n             NumFifoWords   : In    integer ;\n             StatusMsgOn    : In    boolean := false\n  ) is\n  begin\n    PushBurstIncrement(TransactionRec.WriteBurstFifo, FirstWord, NumFifoWords) ; \n    WriteBurst(TransactionRec, iAddr, NumFifoWords, StatusMsgOn) ; \n  end procedure WriteBurstIncrement ;\n\n  ------------------------------------------------------------\n  procedure WriteBurstRandom (\n  ------------------------------------------------------------\n    signal   TransactionRec : InOut AddressBusRecType ;\n             iAddr          : In    std_logic_vector ;\n             FirstWord      : In    std_logic_vector ;\n             NumFifoWords   : In    integer ;\n             StatusMsgOn    : In    boolean := false\n  ) is\n  begin\n    PushBurstRandom(TransactionRec.WriteBurstFifo, FirstWord, NumFifoWords) ; \n    WriteBurst(TransactionRec, iAddr, NumFifoWords, StatusMsgOn) ; \n  end procedure WriteBurstRandom ;\n\n  ------------------------------------------------------------\n  procedure WriteBurstRandom (\n  ------------------------------------------------------------\n    signal   TransactionRec : InOut AddressBusRecType ;\n             iAddr          : In    std_logic_vector ;\n             CoverID        : In    CoverageIDType ;\n             NumFifoWords   : In    integer ;\n             FifoWidth      : In    integer ;\n             StatusMsgOn    : In    boolean := false\n  ) is\n  begin\n    PushBurstRandom(TransactionRec.WriteBurstFifo, CoverID, NumFifoWords, FifoWidth) ; \n    WriteBurst(TransactionRec, iAddr, NumFifoWords, StatusMsgOn) ; \n  end procedure WriteBurstRandom ;\n\n  ------------------------------------------------------------\n  procedure WriteBurstAsync (\n  -- dispatch CPU Write Cycle\n  ------------------------------------------------------------\n    signal   TransactionRec : InOut AddressBusRecType ;\n             iAddr          : In    std_logic_vector ;\n             NumFifoWords   : In    integer ;\n             StatusMsgOn    : In    boolean := false\n  ) is\n  begin\n    -- Put values in record\n    TransactionRec.Operation     <= ASYNC_WRITE_BURST ;\n    TransactionRec.Address       <= SafeResize(iAddr, TransactionRec.Address'length) ;\n    TransactionRec.AddrWidth     <= iAddr'length ;\n--    TransactionRec.DataToModel   <= (TransactionRec.DataToModel'range => 'X') ;\n    TransactionRec.DataWidth     <= NumFifoWords ;\n    TransactionRec.StatusMsgOn   <= StatusMsgOn ;\n    -- Start Transaction\n    RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;\n  end procedure WriteBurstAsync ;\n  \n  ------------------------------------------------------------\n  procedure WriteBurstVectorAsync (\n  ------------------------------------------------------------\n    signal   TransactionRec : InOut AddressBusRecType ;\n             iAddr          : In    std_logic_vector ;\n             VectorOfWords  : In    slv_vector ;\n             StatusMsgOn    : In    boolean := false\n  ) is\n  begin\n    PushBurstVector(TransactionRec.WriteBurstFifo, VectorOfWords) ; \n    WriteBurstAsync(TransactionRec, iAddr, VectorOfWords'length, StatusMsgOn) ; \n  end procedure WriteBurstVectorAsync ;\n  \n  ------------------------------------------------------------\n  procedure WriteBurstIncrementAsync (\n  ------------------------------------------------------------\n    signal   TransactionRec : InOut AddressBusRecType ;\n             iAddr          : In    std_logic_vector ;\n             FirstWord      : In    std_logic_vector ;\n             NumFifoWords   : In    integer ;\n             StatusMsgOn    : In    boolean := false\n  ) is\n  begin\n    PushBurstIncrement(TransactionRec.WriteBurstFifo, FirstWord, NumFifoWords) ; \n    WriteBurstAsync(TransactionRec, iAddr, NumFifoWords, StatusMsgOn) ; \n  end procedure WriteBurstIncrementAsync ;\n\n  ------------------------------------------------------------\n  procedure WriteBurstRandomAsync (\n  ------------------------------------------------------------\n    signal   TransactionRec : InOut AddressBusRecType ;\n             iAddr          : In    std_logic_vector ;\n             FirstWord      : In    std_logic_vector ;\n             NumFifoWords   : In    integer ;\n             StatusMsgOn    : In    boolean := false\n  ) is\n  begin\n    PushBurstRandom(TransactionRec.WriteBurstFifo, FirstWord, NumFifoWords) ; \n    WriteBurstAsync(TransactionRec, iAddr, NumFifoWords, StatusMsgOn) ; \n  end procedure WriteBurstRandomAsync ;  \n  \n  ------------------------------------------------------------\n  procedure WriteBurstRandomAsync (\n  ------------------------------------------------------------\n    signal   TransactionRec : InOut AddressBusRecType ;\n             iAddr          : In    std_logic_vector ;\n             CoverID        : In    CoverageIDType ;\n             NumFifoWords   : In    integer ;\n             FifoWidth      : In    integer ;\n             StatusMsgOn    : In    boolean := false\n  ) is\n  begin\n    PushBurstRandom(TransactionRec.WriteBurstFifo, CoverID, NumFifoWords, FifoWidth) ; \n    WriteBurstAsync(TransactionRec, iAddr, NumFifoWords, StatusMsgOn) ; \n  end procedure WriteBurstRandomAsync ;\n\n  ------------------------------------------------------------\n  procedure ReadBurst (\n  -- do CPU Read Cycle and return data\n  ------------------------------------------------------------\n    signal   TransactionRec : InOut AddressBusRecType ;\n             iAddr          : In    std_logic_vector ;\n             NumFifoWords   : In    integer ;\n             StatusMsgOn    : In    boolean := false\n  ) is\n  begin\n    -- Put values in record\n    TransactionRec.Operation     <= READ_BURST ;\n    TransactionRec.Address       <= SafeResize(iAddr, TransactionRec.Address'length) ;\n    TransactionRec.AddrWidth     <= iAddr'length ;\n    TransactionRec.DataWidth     <= NumFifoWords ;\n--??    TransactionRec.DataWidth     <= 0 ;\n    TransactionRec.StatusMsgOn   <= StatusMsgOn ;\n    -- Start Transaction\n    RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;\n--??    -- Return Results\n--??    NumFifoWords := TransactionRec.IntFromModel ;\n  end procedure ReadBurst ;\n  \n  ------------------------------------------------------------\n  procedure ReadCheckBurstVector (\n  ------------------------------------------------------------\n    signal   TransactionRec : InOut AddressBusRecType ;\n             iAddr          : In    std_logic_vector ;\n             VectorOfWords  : In    slv_vector ;\n             StatusMsgOn    : In    boolean := false\n  ) is\n  begin\n    ReadBurst(TransactionRec, iAddr, VectorOfWords'length, StatusMsgOn) ; \n    CheckBurstVector(TransactionRec.ReadBurstFifo, VectorOfWords) ;\n  end procedure ReadCheckBurstVector ;\n  \n  ------------------------------------------------------------\n  procedure ReadCheckBurstIncrement (\n  ------------------------------------------------------------\n    signal   TransactionRec : InOut AddressBusRecType ;\n             iAddr          : In    std_logic_vector ;\n             FirstWord      : In    std_logic_vector ;\n             NumFifoWords   : In    integer ;\n             StatusMsgOn    : In    boolean := false\n  ) is\n  begin\n    ReadBurst(TransactionRec, iAddr, NumFifoWords, StatusMsgOn) ; \n    CheckBurstIncrement(TransactionRec.ReadBurstFifo, FirstWord, NumFifoWords) ; \n  end procedure ReadCheckBurstIncrement ;\n\n  ------------------------------------------------------------\n  procedure ReadCheckBurstRandom (\n  ------------------------------------------------------------\n    signal   TransactionRec : InOut AddressBusRecType ;\n             iAddr          : In    std_logic_vector ;\n             FirstWord      : In    std_logic_vector ;\n             NumFifoWords   : In    integer ;\n             StatusMsgOn    : In    boolean := false\n  ) is\n  begin\n    ReadBurst(TransactionRec, iAddr, NumFifoWords, StatusMsgOn) ; \n    CheckBurstRandom(TransactionRec.ReadBurstFifo, FirstWord, NumFifoWords) ; \n  end procedure ReadCheckBurstRandom ;\n\n  ------------------------------------------------------------\n  procedure ReadCheckBurstRandom (\n  ------------------------------------------------------------\n    signal   TransactionRec : InOut AddressBusRecType ;\n             iAddr          : In    std_logic_vector ;\n             CoverID        : In    CoverageIDType ;\n             NumFifoWords   : In    integer ;\n             FifoWidth      : In    integer ;\n             StatusMsgOn    : In    boolean := false\n  ) is\n  begin\n    ReadBurst(TransactionRec, iAddr, NumFifoWords, StatusMsgOn) ; \n    CheckBurstRandom(TransactionRec.ReadBurstFifo, CoverID, NumFifoWords, FifoWidth) ; \n  end procedure ReadCheckBurstRandom ;\n\n  -- ========================================================\n  --  Pseudo Transactions\n  --  Interact with the record only.\n  -- ========================================================\n  ------------------------------------------------------------\n  procedure ReleaseTransactionRecord (\n  --  Must run on same delta cycle as AcquireTransactionRecord\n  ------------------------------------------------------------\n    signal   TransactionRec : InOut AddressBusRecType \n  ) is\n  begin\n    -- Set everything driven by TestCtrl to type'left (except Rdy)\n    TransactionRec.Rdy           <= RdyType'left ;   \n    TransactionRec.Operation     <= NOT_DRIVEN ;\n    TransactionRec.Address       <= (TransactionRec.Address'range => 'U') ;\n    TransactionRec.AddrWidth     <= integer'left ; \n    TransactionRec.DataToModel   <= (TransactionRec.DataToModel'range => 'U') ;\n    TransactionRec.DataWidth     <= integer'left ; \n    TransactionRec.StatusMsgOn   <= boolean'left ; \n    TransactionRec.IntToModel    <= integer'left ; \n    TransactionRec.BoolToModel   <= boolean'left ;  \n    TransactionRec.Options       <= integer'left ;    \n  end procedure ReleaseTransactionRecord ; \n  \n  ------------------------------------------------------------\n  procedure AcquireTransactionRecord (\n  --  Must run on same delta cycle as ReleaseTransactionRecord\n  ------------------------------------------------------------\n    signal   TransactionRec : InOut AddressBusRecType \n  ) is\n  begin\n    -- Start Driving Rdy on next delta cycle with the current value.  \n    TransactionRec.Rdy           <= TransactionRec.Rdy ; \n  end procedure AcquireTransactionRecord ; \n    \n\n  -- ========================================================\n  --  Verification Component Support\n  -- ========================================================\n  ------------------------------------------------------------\n  function IsWriteAddress (\n  -----------------------------------------------------------\n    constant Operation      : In AddressBusOperationType\n  ) return boolean is\n  begin\n    return\n      (Operation = WRITE_OP) \n      or (Operation = WRITE_ADDRESS) \n      or (Operation = ASYNC_WRITE) \n      or (Operation = ASYNC_WRITE_ADDRESS)  \n      or (Operation = WRITE_BURST) \n      or (Operation = ASYNC_WRITE_BURST) ; \n--    or (Operation = WRITE_BURST_ADDRESS)  \n--    or  (Operation = ASYNC_WRITE_BURST_ADDRESS) ;\n  end function IsWriteAddress ;\n\n  ------------------------------------------------------------\n  function IsBlockOnWriteAddress (\n  -----------------------------------------------------------\n    constant Operation      : In AddressBusOperationType\n  ) return boolean is\n  begin\n    return\n      (Operation = WRITE_OP) \n      or (Operation = WRITE_ADDRESS) \n      or (Operation = WRITE_BURST) ; \n--      (Operation = WRITE_BURST_ADDRESS) ;\n  end function IsBlockOnWriteAddress ;\n\n  ------------------------------------------------------------\n  function IsTryWriteAddress (\n  -----------------------------------------------------------\n    constant Operation      : In AddressBusOperationType\n  ) return boolean is\n  begin\n    return\n      (Operation = ASYNC_WRITE) \n      or (Operation = ASYNC_WRITE_ADDRESS)  \n      or (Operation = ASYNC_WRITE_BURST) ; \n--      (Operation = ASYNC_WRITE_BURST_ADDRESS) ;\n  end function IsTryWriteAddress ;\n\n  ------------------------------------------------------------\n  function IsWriteData (\n  -----------------------------------------------------------\n    constant Operation      : In AddressBusOperationType\n  ) return boolean is\n  begin\n    return\n      (Operation = WRITE_OP) \n      or (Operation = WRITE_DATA)\n      or (Operation = ASYNC_WRITE)\n      or (Operation = ASYNC_WRITE_DATA) \n      or (Operation = WRITE_BURST) \n      or (Operation = ASYNC_WRITE_BURST) ; \n--      or (Operation = WRITE_BURST_DATA) \n--      or (Operation = ASYNC_WRITE_BURST_DATA) ;\n  end function IsWriteData ;\n\n  ------------------------------------------------------------\n  function IsBlockOnWriteData (\n  -----------------------------------------------------------\n    constant Operation      : In AddressBusOperationType\n  ) return boolean is\n  begin\n    return \n      (Operation = WRITE_OP)\n      or (Operation = WRITE_DATA)\n      or (Operation = WRITE_BURST) ;\n--      or (Operation = WRITE_BURST_DATA) ;\n  end function IsBlockOnWriteData ;\n\n  ------------------------------------------------------------\n  function IsTryWriteData (\n  -----------------------------------------------------------\n    constant Operation      : In AddressBusOperationType\n  ) return boolean is\n  begin\n    return\n      (Operation = ASYNC_WRITE)\n      or (Operation = ASYNC_WRITE_DATA)\n      or (Operation = ASYNC_WRITE_BURST) ;\n--      or (Operation = ASYNC_WRITE_BURST_DATA) ;\n  end function IsTryWriteData ;\n\n  ------------------------------------------------------------\n  function IsReadAddress (\n  -----------------------------------------------------------\n    constant Operation      : In AddressBusOperationType\n  ) return boolean is\n  begin\n    return\n      (Operation = READ_OP)\n      or (Operation = READ_ADDRESS)\n      or (Operation = READ_CHECK)\n      or (Operation = ASYNC_READ)\n      or (Operation = ASYNC_READ_ADDRESS)\n      or (Operation = READ_BURST) ;\n--      or (Operation = READ_BURST_ADDRESS)\n--      or (Operation = ASYNC_READ_BURST_ADDRESS) ;\n  end function IsReadAddress ;\n\n  ------------------------------------------------------------\n  function IsTryReadAddress (\n  -----------------------------------------------------------\n    constant Operation      : In AddressBusOperationType\n  ) return boolean is\n  begin\n    return\n      (Operation = ASYNC_READ)\n      or (Operation = ASYNC_READ_ADDRESS) ;\n--      or (Operation = ASYNC_READ_BURST)\n--      or (Operation = ASYNC_READ_BURST_ADDRESS) ;\n  end function IsTryReadAddress ;\n  \n  ------------------------------------------------------------\n  function IsReadData (\n  -----------------------------------------------------------\n    constant Operation      : In AddressBusOperationType\n  ) return boolean is\n  begin\n    return\n      (Operation = READ_OP)\n      or (Operation = READ_DATA)\n      or (Operation = READ_CHECK)\n      or (Operation = READ_DATA_CHECK)\n      or (Operation = ASYNC_READ)\n      or (Operation = ASYNC_READ_DATA)\n      or (Operation = ASYNC_READ_DATA_CHECK)\n      or (Operation = READ_BURST) ;\n--      or (Operation = READ_BURST_DATA)\n--      or (Operation = ASYNC_READ_BURST)\n--       or(Operation = ASYNC_READ_BURST_DATA) ;\n  end function IsReadData ;\n\n  ------------------------------------------------------------\n  function IsBlockOnReadData (\n  -----------------------------------------------------------\n    constant Operation      : In AddressBusOperationType\n  ) return boolean is\n  begin\n    return\n      (Operation = READ_OP)\n      or (Operation = READ_DATA)\n      or (Operation = READ_CHECK)\n      or (Operation = READ_DATA_CHECK)\n      or (Operation = READ_BURST) ;\n--      or (Operation = READ_BURST_DATA) ;\n  end function IsBlockOnReadData ;\n\n  ------------------------------------------------------------\n  function IsTryReadData (\n  -----------------------------------------------------------\n    constant Operation      : In AddressBusOperationType\n  ) return boolean is\n  begin\n    return \n      (Operation = ASYNC_READ)\n      or (Operation = ASYNC_READ_DATA)\n      or (Operation = ASYNC_READ_DATA_CHECK) ;\n--      or (Operation = ASYNC_READ_BURST)\n--      or (Operation = ASYNC_READ_BURST_DATA) ;\n  end function IsTryReadData ;\n\n  ------------------------------------------------------------\n  function IsReadCheck (\n  -----------------------------------------------------------\n    constant Operation      : In AddressBusOperationType\n  ) return boolean is\n  begin\n    return\n      (Operation = READ_CHECK) or\n      (Operation = READ_DATA_CHECK) or\n      (Operation = ASYNC_READ_DATA_CHECK) ;\n  end function IsReadCheck ;\n\n  ------------------------------------------------------------\n  function IsBurst (\n  -----------------------------------------------------------\n    constant Operation      : In AddressBusOperationType\n  ) return boolean is\n  begin\n    return\n      (Operation = WRITE_BURST)\n      or (Operation = ASYNC_WRITE_BURST)\n--      or (Operation = WRITE_BURST_ADDRESS)\n--      or (Operation = WRITE_BURST_DATA)\n--      or (Operation = ASYNC_WRITE_BURST_ADDRESS)\n--      or (Operation = ASYNC_WRITE_BURST_DATA)\n      or (Operation = READ_BURST) ;\n--      or (Operation = READ_BURST_ADDRESS)\n--      or (Operation = READ_BURST_DATA)\n--      or (Operation = ASYNC_READ_BURST_ADDRESS)\n--      or (Operation = ASYNC_READ_BURST_DATA) ;\n  end function IsBurst ;\n  \n  ------------------------------------------------------------\n  function ClassifyUnimplementedOperation (\n  -----------------------------------------------------------\n    constant Operation        : In AddressBusOperationType ;\n    constant TransactionCount : in natural\n  ) return string is\n  begin\n    if Operation = MULTIPLE_DRIVER_DETECT then\n      return \"Multiple Drivers on Transaction Record.\" & \n             \"  Transaction # \" & to_string(TransactionCount) ;\n    else\n      return \"Unimplemented Transaction: \" & to_string(Operation) & \n             \"  Transaction # \" & to_string(TransactionCount) ;\n    end if ; \n  end function ClassifyUnimplementedOperation ;\n\n\nend package body AddressBusTransactionPkg ;","lang":"vhdl"};
processSrcData(g_data);