var g_data = {"name":"C:/OsvvmLibraries/AXI4/Axi4/TestCases/TbAxi4_DemoErrorMemoryReadWrite1.vhd","src":"--\n--  File Name:         TbAxi4_DemoErrorMemoryReadWrite1.vhd\n--  Design Unit Name:  Architecture of TestCtrl\n--  Revision:          OSVVM MODELS STANDARD VERSION\n--\n--  Maintainer:        Jim Lewis      email:  jim@synthworks.com\n--  Contributor(s):\n--     Jim Lewis      jim@synthworks.com\n--\n--\n--  Description:\n--      Testing of Burst Features in AXI Model\n--\n--\n--  Developed by:\n--        SynthWorks Design Inc.\n--        VHDL Training Classes\n--        http://www.SynthWorks.com\n--\n--  Revision History:\n--    Date      Version    Description\n--    05/2023   2023.05    Initial revision - Derived from TbAxi4_DemoMemoryReadWrite1.vhd\n--\n--\n--  This file is part of OSVVM.\n--\n--  Copyright (c) 2023 by SynthWorks Design Inc.\n--\n--  Licensed under the Apache License, Version 2.0 (the \"License\");\n--  you may not use this file except in compliance with the License.\n--  You may obtain a copy of the License at\n--\n--      https://www.apache.org/licenses/LICENSE-2.0\n--\n--  Unless required by applicable law or agreed to in writing, software\n--  distributed under the License is distributed on an \"AS IS\" BASIS,\n--  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n--  See the License for the specific language governing permissions and\n--  limitations under the License.\n--\n\narchitecture DemoErrorMemoryReadWrite1 of TestCtrl is\n\n  signal TestDone, WriteDone : integer_barrier := 1 ;\n  constant BURST_MODE : AddressBusFifoBurstModeType := ADDRESS_BUS_BURST_WORD_MODE ;\n--  constant BURST_MODE : AddressBusFifoBurstModeType := ADDRESS_BUS_BURST_BYTE_MODE ;\n  constant DATA_WIDTH : integer := IfElse(BURST_MODE = ADDRESS_BUS_BURST_BYTE_MODE, 8, AXI_DATA_WIDTH)  ;\n  signal TbAlertID : AlertLogIDType ; \n\nbegin\n\n  ------------------------------------------------------------\n  -- ControlProc\n  --   Set up AlertLog and wait for end of test\n  ------------------------------------------------------------\n  ControlProc : process\n  begin\n    -- Initialization of test\n    SetTestName(\"TbAxi4_DemoErrorMemoryReadWrite1\") ;\n    SetLogEnable(PASSED, TRUE) ;   -- Enable PASSED logs\n    SetLogEnable(INFO, TRUE) ;     -- Enable INFO logs\n    -- SetLogEnable(DEBUG, TRUE) ;    -- Enable INFO logs\n    TbAlertID <= NewID(\"Testbench\") ; \n\n    -- Wait for testbench initialization\n    wait for 0 ns ;  wait for 0 ns ;\n    TranscriptOpen(OSVVM_RESULTS_DIR & \"TbAxi4_DemoErrorMemoryReadWrite1.txt\") ;\n    SetTranscriptMirror(TRUE) ;\n    SetAlertLogOptions(WriteTimeLast => FALSE) ; \n    SetAlertLogOptions(TimeJustifyAmount => 15) ; \n    SetAlertLogJustify ; \n\n    -- Wait for Design Reset\n    wait until nReset = '1' ;\n    ClearAlerts ;\n\n    -- Wait for test to finish\n    WaitForBarrier(TestDone, 1 ms) ;\n    AlertIf(now >= 1 ms, \"Test finished due to timeout\") ;\n    AlertIf(GetAffirmCount < 1, \"Test is not Self-Checking\");\n\n    TranscriptClose ;\n    -- Printing differs in different simulators due to differences in process order execution\n    -- AlertIfDiff(\"./results/TbAxi4_DemoErrorMemoryReadWrite1.txt\", \"../AXI4/Axi4/testbench/validated_results/TbAxi4_DemoErrorMemoryReadWrite1.txt\", \"\") ;\n\n    EndOfTestReports ;\n    std.env.stop ;\n    wait ;\n  end process ControlProc ;\n\n  ------------------------------------------------------------\n  -- ManagerProc\n  --   Generate transactions for AxiManager\n  ------------------------------------------------------------\n  ManagerProc : process\n    variable BurstVal  : AddressBusFifoBurstModeType ;\n    variable RxData    : std_logic_vector(31 downto 0) ;\n    constant DATA_ZERO : std_logic_vector := (DATA_WIDTH - 1 downto 0 => '0') ;\n    variable CoverID1, CoverID2 : CoverageIdType ;\n    variable slvBurstVector : slv_vector(1 to 5)(31 downto 0) ;\n    variable intBurstVector : integer_vector(1 to 5) ;\n  begin\n    wait until nReset = '1' ;\n    WaitForClock(ManagerRec, 2) ;\n\n    GetBurstMode(ManagerRec, BurstVal) ;\n    AffirmIf(TbAlertID, BurstVal = ADDRESS_BUS_BURST_WORD_MODE, \"Default BurstMode is ADDRESS_BUS_BURST_WORD_MODE \" & to_string(BurstVal)) ;\n    SetBurstMode(ManagerRec, BURST_MODE) ;\n    GetBurstMode(ManagerRec, BurstVal) ;\n    AffirmIfEqual(TbAlertID, BurstVal, BURST_MODE, \"BurstMode\") ;\n\n-- Write and Read\n    log(TbAlertID, \"Write and Read. Addr = 0000.  16 words\") ;\n    for I in 1 to 16 loop\n      Write( ManagerRec, X\"0000_0000\" + 16*I, X\"0000_0000\" + I ) ;\n    end loop ;\n\n    for I in 1 to 16 loop\n      Read ( ManagerRec, X\"0000_0000\" + 16*I, RxData) ;\n      AffirmIfEqual(TbAlertID, RxData, X\"0000_0000\" + I, \"Read Data \" ) ;\n    end loop ;\n\n-- Write and ReadCheck\n    log(\"Write and ReadCheck. Addr = 1000.  16 words\") ;\n    for I in 1 to 16 loop\n      Write( ManagerRec, X\"0000_1000\" + 16*I, X\"0000_1000\" + I ) ;\n    end loop ;\n\n    for I in 1 to 15 loop\n      ReadCheck ( ManagerRec, X\"0000_1000\" + 16*I, X\"0000_1000\" + I ) ;\n    end loop ;\n\n--!!! Intentional Error\n    ReadCheck ( ManagerRec, X\"0000_1000\" + 16*15, X\"0000_1000\" + 16 ) ; -- Data actual is X0000_100F, Expected is X0000_1010\n\n-- WriteBurst and ReadBurst\n    log(\"WriteBurst and ReadBurst.  Addr = 2000.  16 words\") ;\n    for I in 1 to 16 loop\n      Push( ManagerRec.WriteBurstFifo, X\"0000_2000\" + I  ) ;\n    end loop ;\n    WriteBurst(ManagerRec, X\"0000_2000\", 16) ;\n\n    ReadBurst(ManagerRec, X\"0000_2000\", 16) ;\n    for I in 1 to 15 loop\n      CheckExpected( ManagerRec.ReadBurstFifo, X\"0000_2000\" + I  ) ;\n    end loop ;\n\n--!!! Intentional Error\n    CheckExpected( ManagerRec.ReadBurstFifo, X\"0000_2000\" + 17  ) ;  -- Data actual is X0000_1010, Expected is X0000_1011\n\n-- Burst Vector\n    log(TbAlertID, \"Burst Vector.  Addr = 3000, 13 Words -- unaligned\") ;\n    WriteBurstVector(ManagerRec, X\"0000_3000\",\n        (X\"0001_UUUU\", DATA_ZERO+3,  DATA_ZERO+5,  DATA_ZERO+7,  DATA_ZERO+9,\n        DATA_ZERO+11,  DATA_ZERO+13, DATA_ZERO+15, DATA_ZERO+17, DATA_ZERO+19,\n        DATA_ZERO+21,  DATA_ZERO+23, DATA_ZERO+25) ) ;\n\n    ReadCheckBurstVector(ManagerRec, X\"0000_3000\",\n        (X\"0001_----\", DATA_ZERO+3,  DATA_ZERO+5,  DATA_ZERO+7,  DATA_ZERO+9,\n        DATA_ZERO+11,  DATA_ZERO+13, DATA_ZERO+15, DATA_ZERO+17, DATA_ZERO+19,\n        DATA_ZERO+21,  DATA_ZERO+23, DATA_ZERO+25) ) ;\n\n-- Burst Increment\n    log(TbAlertID, \"Burst Increment.  Addr = 4000, 12 Words -- word aligned\") ;\n    WriteBurstIncrement    (ManagerRec, X\"0000_4000\", X\"0000_4000\"+3, 12) ;\n\n    ReadCheckBurstIncrement(ManagerRec, X\"0000_4000\", X\"0000_4000\"+3, 12) ;\n\n-- Burst Random\n    log(TbAlertID, \"Burst Random. Addr = 5001, 13 Words -- unaligned\") ;\n    WriteBurstRandom    (ManagerRec, X\"0000_5001\", X\"A015_2800\", 13) ;\n\n    ReadCheckBurstRandom(ManagerRec, X\"0000_5001\", X\"A015_28UU\", 13) ;\n\n -- Burst Coverage Driven Random\n     log(TbAlertID, \"Burst Coverage Driven Random. Addr = 6000, 12 Words\") ;\n     CoverID1 := NewID(\"Cov1\", TbAlertID, ReportMode => DISABLED) ;\n     SetItemBinNames(CoverID1, \"Generate\") ;\n     \n     InitSeed(CoverID1, 5) ; -- Start Write and Read with the same seed value\n     AddBins (CoverID1, \"Small\",   3, GenBin(0,7,1) ) ;\n     AddBins (CoverID1, \"Medium1\", 3, GenBin(32,39,1)) ;\n     AddBins (CoverID1, \"Medium2\", 3, GenBin(64,71,1)) ;\n     AddBins (CoverID1, \"Large\",   3, GenBin(96,103,1)) ;\n     WriteBurstRandom(ManagerRec, X\"0000_6000\", CoverID1, 12, DATA_WIDTH) ;\n     \n     CoverID2 := NewID(\"Cov2\", TbAlertID, ReportMode => DISABLED) ;\n     SetItemBinNames(CoverID2, \"Observed\") ;\n     InitSeed(CoverID2, 5) ; -- Start Write and Read with the same seed value\n     AddBins (CoverID2, \"Small\",   3, GenBin(0,7,1) ) ;\n     AddBins (CoverID2, \"Medium1\", 3, GenBin(32,39,1)) ;\n     AddBins (CoverID2, \"Medium2\", 3, GenBin(64,71,1)) ;\n     AddBins (CoverID2, \"Large\",   3, GenBin(96,103,1)) ;\n     ReadCheckBurstRandom(ManagerRec, X\"0000_6000\", CoverID2, 12, DATA_WIDTH) ;\n\n-- Burst Combining Patterns\n    log(TbAlertID, \"Combining Patterns:  Vector, Increment, Random, Intelligent Coverage\") ;\n    PushBurstVector(ManagerRec.WriteBurstFifo,\n        (X\"0000_B001\", X\"0000_B003\", X\"0000_B005\", X\"0000_B007\", X\"0000_B009\",\n         X\"0000_B011\", X\"0000_B013\", X\"0000_B015\", X\"0000_B017\", X\"0000_B019\") ) ;\n    PushBurstIncrement(ManagerRec.WriteBurstFifo, X\"0000_B100\", 10) ;\n    PushBurstRandom(ManagerRec.WriteBurstFifo, X\"0000_B200\", 6) ;\n--    CoverID1 := NewID(\"Cov1b\") ;\n--    InitSeed(CoverID1, 5) ; -- Start Write and Read with the same seed value\n--    AddBins(CoverID1, 1,\n--        GenBin(16#B300#, 16#B307#) & GenBin(16#B310#, 16#B317#) &\n--        GenBin(16#B320#, 16#B327#) & GenBin(16#B330#, 16#B337#)) ;\n--    PushBurstRandom(ManagerRec.WriteBurstFifo, CoverID1, 16, 32) ;\n    WriteBurst(ManagerRec, X\"0000_B000\", 26) ;\n\n    ReadBurst (ManagerRec, X\"0000_B000\", 26) ;\n    CheckBurstVector(ManagerRec.ReadBurstFifo,\n        (X\"0000_B001\", X\"0000_B003\", X\"0000_B005\", X\"0000_B007\", X\"0000_B009\",\n         X\"0000_B011\", X\"0000_B013\", X\"0000_B015\", X\"0000_B017\", X\"0000_B019\") ) ;\n    CheckBurstIncrement(ManagerRec.ReadBurstFifo, X\"0000_B100\", 10) ;\n    CheckBurstRandom(ManagerRec.ReadBurstFifo, X\"0000_B200\", 6) ;\n--    CoverID2 := NewID(\"Cov2b\") ;\n--    InitSeed(CoverID2, 5) ; -- Start Write and Read with the same seed value\n--    AddBins(CoverID2, 1,\n--        GenBin(16#B300#, 16#B307#) & GenBin(16#B310#, 16#B317#) &\n--        GenBin(16#B320#, 16#B327#) & GenBin(16#B330#, 16#B337#)) ;\n--    CheckBurstRandom(ManagerRec.ReadBurstFifo, CoverID2, 16, 32) ;\n\n-- WriteBurstVector - PopBurstVector slv_vector\n    log(TbAlertID, \"WriteBurstVector 5 word burst\") ;\n    WriteBurstVector(ManagerRec, X\"0000_C000\",\n        (X\"0000_C001\", X\"0000_C003\", X\"0000_C005\", X\"0000_C007\", X\"0000_C009\") ) ;\n\n    ReadBurst(ManagerRec, X\"0000_C000\", 5) ;\n    PopBurstVector(ManagerRec.ReadBurstFifo, slvBurstVector) ;\n    AffirmIf(TbAlertID, slvBurstVector =\n        (X\"0000_C001\", X\"0000_C003\", X\"0000_C005\", X\"0000_C007\", X\"0000_C009\"),\n        \"slvBurstVector = C001, C003, C005, C007, C009\") ; --  & to_string(slvBurstVector)) ; -- to_string in 2019\n\n-- SendBurstVector - PopBurstVector integer_vector\n    log(\"SendBurstVector 5 word burst\") ;\n    PushBurstVector(ManagerRec.WriteBurstFifo,\n        (16#D001#, 16#D003#, 16#D005#, 16#D007#, 16#D009#), 32 ) ;\n    WriteBurst(ManagerRec, X\"0000_D000\", 5) ;\n\n    ReadBurst(ManagerRec, X\"0000_D000\", 5) ;\n    PopBurstVector(ManagerRec.ReadBurstFifo, intBurstVector) ;\n    AffirmIf(TbAlertID, intBurstVector =\n        (16#D001#, 16#D003#, 16#D005#, 16#D007#, 16#D009#),\n        \"slvBurstVector = D001, D003, D005, D007, D009\") ; -- & to_string(slvBurstVector)) ; -- to_string in 2019\n\n    -- Wait for outputs to propagate and signal TestDone\n    WaitForClock(ManagerRec, 2) ;\n    WaitForBarrier(TestDone) ;\n    wait ;\n  end process ManagerProc ;\n\n\n  ------------------------------------------------------------\n  -- MemoryProc\n  --   Generate transactions for AxiSubordinate\n  ------------------------------------------------------------\n  MemoryProc : process\n    variable Addr : std_logic_vector(AXI_ADDR_WIDTH-1 downto 0) ;\n    variable Data : std_logic_vector(AXI_DATA_WIDTH-1 downto 0) ;\n  begin\n    WaitForClock(SubordinateRec, 2) ;\n\n\n    -- Wait for outputs to propagate and signal TestDone\n    WaitForClock(SubordinateRec, 2) ;\n    WaitForBarrier(TestDone) ;\n    wait ;\n  end process MemoryProc ;\n\n\nend DemoErrorMemoryReadWrite1 ;\n\nConfiguration TbAxi4_DemoErrorMemoryReadWrite1 of TbAxi4Memory is\n  for TestHarness\n    for TestCtrl_1 : TestCtrl\n      use entity work.TestCtrl(DemoErrorMemoryReadWrite1) ;\n    end for ;\n--!!    for Subordinate_1 : Axi4Subordinate\n--!!      use entity OSVVM_AXI4.Axi4Memory ;\n--!!    end for ;\n  end for ;\nend TbAxi4_DemoErrorMemoryReadWrite1 ;","lang":"vhdl"};
processSrcData(g_data);