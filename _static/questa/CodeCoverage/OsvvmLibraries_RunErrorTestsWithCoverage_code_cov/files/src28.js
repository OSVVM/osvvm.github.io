var g_data = {"name":"C:/OsvvmLibraries/osvvm/RandomBasePkg.vhd","src":"--\n--  File Name:         RandomBasePkg.vhd\n--  Design Unit Name:  RandomBasePkg\n--  Revision:          STANDARD VERSION\n--\n--  Maintainer:        Jim Lewis      email:  jim@synthworks.com\n--  Contributor(s):\n--     Jim Lewis      jim@synthworks.com\n--\n--\n--  Description:\n--        Defines Base randomization, seed definition, seed generation,\n--        and seed IO functionality for RandomPkg.vhd\n--        Defines:\n--          Procedure Uniform - baseline randomization \n--          Type RandomSeedType - the seed as a single object\n--          function GenRandSeed from integer_vector, integer, or string\n--          IO function to_string, & procedures write, read\n--\n--        In revision 2.0 these types and functions are included by package reference.\n--        Long term these will be passed as generics to RandomGenericPkg\n--\n--\n--  Developed for:\n--        SynthWorks Design Inc.\n--        VHDL Training Classes\n--        11898 SW 128th Ave.  Tigard, Or  97223\n--        http://www.SynthWorks.com\n--\n--  Revision History:\n--    Date       Version    Description\n--    01/2023    2023.01    Added functions for SetRandomSalt to support setting in declaration regions\n--    10/2022    2022.10    Added SetRandomSalt(string or integer), GetRandomSalt (integer), \n--                          RandomSalt is added to all versions of GenRandSeed\n--    06/2021    2021.06    Updated GenRandSeed hash to DJBX33A \n--    01/2020    2020.01    Updated Licenses to Apache\n--    6/2015     2015.06    Changed GenRandSeed to impure\n--    1/2015     2015.01    Changed Assert/Report to Alert\n--    5/2013     2013.05    No Changes\n--    4/2013     2013.04    No Changes\n--    03/01/2011 2.0        STANDARD VERSION\n--                          Fixed abstraction by moving RandomParmType to RandomPkg.vhd \n--    02/25/2009 1.1        Replaced reference to std_2008 with a reference \n--                          to ieee_proposed.standard_additions.all ;\n--    02/2009:   1.0        First Public Released Version\n--    01/2008:   0.1        Initial revision\n--                          Numerous revisions for VHDL Testbenches and Verification\n--\n--\n--  This file is part of OSVVM.\n--  \n--  Copyright (c) 2008 - 2023 by SynthWorks Design Inc.  \n--  \n--  Licensed under the Apache License, Version 2.0 (the \"License\");\n--  you may not use this file except in compliance with the License.\n--  You may obtain a copy of the License at\n--  \n--      https://www.apache.org/licenses/LICENSE-2.0\n--  \n--  Unless required by applicable law or agreed to in writing, software\n--  distributed under the License is distributed on an \"AS IS\" BASIS,\n--  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n--  See the License for the specific language governing permissions and\n--  limitations under the License.\n--  \n\nlibrary ieee ;\nuse ieee.math_real.all ;\nuse std.textio.all ;\n\nuse work.OsvvmGlobalPkg.all ; \nuse work.AlertLogPkg.all ; \nuse work.SortListPkg_int.all ;\n\n-- comment out following 2 lines with VHDL-2008.  Leave in for VHDL-2002 \n-- library ieee_proposed ;						          -- remove with VHDL-2008\n-- use ieee_proposed.standard_additions.all ;   -- remove with VHDL-2008\n\n\npackage RandomBasePkg is\n\n  constant OSVVM_RANDOM_ALERTLOG_ID : AlertLogIDType := OSVVM_ALERTLOG_ID ;\n\n  -----------------------------------------------------------------\n  -- note NULL_RANGE_TYPE should probably be in std.standard\n  subtype NULL_RANGE_TYPE is integer range 0 downto 1 ;\n  constant NULL_INTV : integer_vector (NULL_RANGE_TYPE) := (others => 0) ;\n\n  -----------------------------------------------------------------\n  -- RandomSeedType - Abstract the type for randomization\n  type RandomSeedType is array (1 to 2) of integer ;\n  \n  -----------------------------------------------------------------\n  -- Uniform\n  --   Generate a random number with a Uniform distribution\n  --   Required by RandomPkg.  All randomization is derived from here.\n  --   Value produced must be either: \n  --     0 <= Value < 1  or  0 < Value < 1\n  --\n  --   Current version uses ieee.math_real.Uniform\n  --   This abstraction allows higher precision version \n  --   of a uniform distribution to be used provided\n  --\n  procedure Uniform (Result : out real ;  Seed : inout RandomSeedType) ;\n\n  -----------------------------------------------------------------\n  --  GenRandSeed\n  --    Generate / hash a seed from a value that is integer_vector, String, Time, or Integer to RandomSeedType\n  --    Used by RandomPkg.InitSeed\n  --    GenRandSeed makes sure all values are in a valid range\n  impure function  GenRandSeed   (IV : integer_vector) return RandomSeedType ;\n  impure function  OldGenRandSeed(IV : integer_vector) return RandomSeedType ;\n  impure function  GenRandSeed   (I  : integer) return RandomSeedType ;\n  impure function  OldGenRandSeed(I  : integer) return RandomSeedType ;\n  impure function  GenRandSeed   (S  : string)  return RandomSeedType ;\n  impure function  OldGenRandSeed(S  : string)  return RandomSeedType ;\n  procedure SetRandomSalt (I : integer) ; \n  impure function SetRandomSalt (I : integer) return boolean ; \n  impure function SetRandomSalt (I : integer) return integer ; \n  procedure SetRandomSalt (S : string) ; \n  impure function SetRandomSalt (S : string) return boolean ;\n  impure function SetRandomSalt (S : string) return string ;\n  impure function GetRandomSalt return integer ; \n  \n  -----------------------------------------------------------------\n  --- RandomSeedType IO\n  function  to_string(A : RandomSeedType; Separator : string := \" \") return string ;\n  procedure write(variable L: inout line ; A : RandomSeedType ) ;\n  procedure read (variable L: inout line ; A : out RandomSeedType ; good : out boolean ) ;\n  procedure read (variable L: inout line ; A : out RandomSeedType ) ;\n\n  -----------------------------------------------------------------\n  --- Distribution Types and read/write procedures\n  type RandomDistType is (NONE, UNIFORM, FAVOR_SMALL, FAVOR_BIG, NORMAL, POISSON) ;\n\n  type RandomParmType is record\n    Distribution : RandomDistType ;\n    Mean         : Real ; -- also used as probability of success\n    StdDeviation : Real ; -- also used as number of trials for binomial\n  end record ;\n\n  -----------------------------------------------------------------\n  -- RandomParm IO\n  function to_string(A : RandomDistType) return string ;\n  procedure write(variable L : inout line ; A : RandomDistType ) ;\n  procedure read (variable L : inout line ; A : out RandomDistType ; good : out boolean ) ;\n  procedure read (variable L : inout line ; A : out RandomDistType ) ;\n  function to_string(A : RandomParmType) return string ;\n  procedure write(variable L : inout line ; A : RandomParmType ) ;\n  procedure read (variable L : inout line ; A : out RandomParmType ; good : out boolean ) ;\n  procedure read (variable L : inout line ; A : out RandomParmType ) ;\n\n  -----------------------------------------------------------------\n  ---  Randomization Support\n  ---    Scale                - Scale a value to be within a given range\n  ---    FavorSmall, FavorBig - Distribution Support\n  ---    RemoveExclude \n  function Scale (A, Min, Max : real) return real ;\n  function Scale (A : real ; Min, Max : integer) return integer ;\n\n  function FavorSmall (A : real) return real ;\n  function FavorBig   (A : real) return real ;\n  \n  function to_time_vector    (A : integer_vector ; Unit : time) return time_vector ;\n  function to_integer_vector (A : time_vector ; Unit : time) return integer_vector ;\n  procedure RemoveExclude    (A, Exclude : integer_vector ; variable NewA : out integer_vector ; variable NewALength : inout natural ) ;\n  function inside            (A : real ; Exclude : real_vector) return boolean ;\n  procedure RemoveExclude    (A, Exclude : real_vector ; variable NewA : out real_vector ; variable NewALength : inout natural ) ;\n  function inside            (A : time ; Exclude : time_vector) return boolean ;\n  procedure RemoveExclude    (A, Exclude : time_vector ; variable NewA : out time_vector ; variable NewALength : inout natural ) ;\nend RandomBasePkg ;\n\n--- ///////////////////////////////////////////////////////////////////////////\n--- ///////////////////////////////////////////////////////////////////////////\n--- ///////////////////////////////////////////////////////////////////////////\n\npackage body RandomBasePkg is\n  -----------------------------------------------------------------\n  -- Uniform\n  --   Generate a random number with a Uniform distribution\n  --   Required by RandomPkg.  All randomization is derived from here.\n  --   Value produced must be either: \n  --     0 <= Value < 1  or  0 < Value < 1\n  --\n  --   Current version uses ieee.math_real.Uniform\n  --   This abstraction allows higher precision version \n  --   of a uniform distribution to be used provided\n  --\n  -----------------------------------------------------------------\n  procedure Uniform (\n  -----------------------------------------------------------------\n    Result : out   real ;\n    Seed   : inout RandomSeedType \n  ) is\n  begin\n    ieee.math_real.Uniform (Seed(Seed'left), Seed(Seed'right), Result) ;\n  end procedure Uniform ;\n\n\n  -----------------------------------------------------------------\n  --  GenRandSeed\n  --    Convert integer_vector to RandomSeedType\n  --    Uniform requires two seed values of the form:\n  --        1 <= SEED1 <= 2147483562; 1 <= SEED2 <= 2147483398\n  --\n  --    if 2 seed values are passed to GenRandSeed and they are \n  --    in the above range, then they must remain unmodified.\n  ------------------------------------------------------------\n  impure function GenRandSeed(IV : integer_vector) return RandomSeedType is\n  ------------------------------------------------------------\n    alias iIV : integer_vector(1 to IV'length) is IV ;\n    variable Seed1 : integer ;\n    variable Seed2 : integer ;\n    constant SEED1_MAX : integer := 2147483562 ;\n    constant SEED2_MAX : integer := 2147483398 ;\n  begin\n    if iIV'Length <= 0 then  -- no seed\n      Alert(OSVVM_ALERTLOG_ID, \"RandomBasePkg.GenRandSeed received NULL integer_vector\", FAILURE) ; \n      return GenRandSeed(integer_vector'(3, 17)) ;  -- if continue seed = (3, 17)\n\n    elsif iIV'Length = 1 then  -- one seed value\n      -- inefficient handling, but condition is unlikely\n      return GenRandSeed(iIV(1)) ;  -- generate a seed\n\n    else  -- only use the left two values\n      -- mod returns 0 to MAX-1, the -1 adjusts legal values, +1 adjusts them back\n      -- 1 <= SEED1 <= 2147483562\n      Seed1 := ((iIV(1)-1 + GetRandomSalt) mod SEED1_MAX) + 1 ;\n     -- 1 <= SEED2 <= 2147483398\n      Seed2 := ((iIV(2)-1) mod SEED2_MAX) + 1 ;\n      return (Seed1, Seed2) ;\n    end if ;\n  end function GenRandSeed ;\n\n  ------------------------------------------------------------\n  impure function OldGenRandSeed(IV : integer_vector) return RandomSeedType is\n  ------------------------------------------------------------\n    alias iIV : integer_vector(1 to IV'length) is IV ;\n    variable Seed1 : integer ;\n    variable Seed2 : integer ;\n    constant SEED1_MAX : integer := 2147483562 ;\n    constant SEED2_MAX : integer := 2147483398 ;\n  begin\n    if iIV'Length <= 0 then  -- no seed\n      Alert(OSVVM_ALERTLOG_ID, \"RandomBasePkg.GenRandSeed received NULL integer_vector\", FAILURE) ; \n      return OldGenRandSeed(integer_vector'(3, 17)) ;  -- if continue seed = (3, 17)\n\n    elsif iIV'Length = 1 then  -- one seed value\n      -- inefficient handling, but condition is unlikely\n      return OldGenRandSeed(iIV(1)) ;  -- generate a seed\n\n    else  -- only use the left two values\n      -- mod returns 0 to MAX-1, the -1 adjusts legal values, +1 adjusts them back\n      -- 1 <= SEED1 <= 2147483562\n      Seed1 := ((iIV(1)-1 + GetRandomSalt) mod SEED1_MAX) + 1 ;\n      -- 1 <= SEED2 <= 2147483398\n      Seed2 := ((iIV(2)-1) mod SEED2_MAX) + 1 ;\n      return (Seed1, Seed2) ;\n    end if ;\n  end function OldGenRandSeed ;\n\n\n  -----------------------------------------------------------------\n  --  GenRandSeed - Integer\n  impure function GenRandSeed(I : integer) return RandomSeedType is\n  -----------------------------------------------------------------\n    variable result : RandomSeedType ;\n  begin\n    result(1) := integer((real(I + GetRandomSalt) * 5381.0 + 313.0) mod 2.0 ** 30) ;\n    result(2) := integer((real(I) * 313.0 + 5381.0) mod 2.0 ** 30) ; \n    return result ; -- make value ranges legal\n  end function GenRandSeed ;\n\n  -----------------------------------------------------------------\n  impure function OldGenRandSeed(I : integer) return RandomSeedType is\n  -----------------------------------------------------------------\n    variable result : integer_vector(1 to 2) ;\n  begin\n    result(1) := I ;\n    result(2) := I/3 + 1 ;\n    return OldGenRandSeed(result) ; -- make value ranges legal\n  end function OldGenRandSeed ;\n\n  -----------------------------------------------------------------\n  --  GenRandSeed - String\n  --    usage:  RV.GenRandSeed(RV'instance_path));\n  --    hash based on DJBX33A\n  impure function  GenRandSeed(S : string) return RandomSeedType is\n  -----------------------------------------------------------------\n    constant LEN : integer := S'length ;\n    constant HALF_LEN : integer := LEN/2 ;\n    alias revS : string(LEN downto 1) is S ;\n    variable result : RandomSeedType ;\n    variable temp : real := 5381.0 ;\n  begin\n    for i in 1 to HALF_LEN loop\n      temp := (temp*33.0 + real(character'pos(revS(i)))) mod (2.0**30) ;\n    end loop ;\n    result(1) := (integer(temp) + GetRandomSalt) mod (2**30) ;\n    for i in HALF_LEN + 1 to LEN loop\n      temp := (temp*33.0 + real(character'pos(revS(i)))) mod (2.0**30) ;\n    end loop ;\n    result(2) := integer(temp) ;\n    return result ;  \n  end function GenRandSeed ;\n  \n  -----------------------------------------------------------------\n  impure function OldGenRandSeed(S : string) return RandomSeedType is\n  -----------------------------------------------------------------\n    constant LEN : integer := S'length ;\n    constant HALF_LEN : integer := LEN/2 ;\n    alias revS : string(LEN downto 1) is S ;\n    variable result : integer_vector(1 to 2) ;\n    variable temp : integer := 0 ;\n  begin\n    for i in 1 to HALF_LEN loop\n      temp := (temp + character'pos(revS(i))) mod (integer'right - 2**8) ;\n    end loop ;\n    result(1) := (temp + GetRandomSalt) mod (integer'right - 2**8)  ;\n    for i in HALF_LEN + 1 to LEN loop\n      temp := (temp + character'pos(revS(i))) mod (integer'right - 2**8) ;\n    end loop ;\n    result(2) := temp ;\n    return OldGenRandSeed(result) ;  -- make value ranges legal\n  end function OldGenRandSeed ;\n\n  -----------------------------------------------------------------\n  type LocalIntegerPType is protected \n  -----------------------------------------------------------------\n    procedure Set (A : Integer) ; \n    impure function get return Integer ; \n  end protected LocalIntegerPType ; \n  type LocalIntegerPType is protected body\n    variable SettingsVar : Integer := 0 ; \n    procedure Set (A : Integer) is\n    begin\n       SettingsVar := A ; \n    end procedure Set ; \n    impure function get return Integer is\n    begin\n      return SettingsVar ; \n    end function get ; \n  end protected body LocalIntegerPType ; \n  \n  shared variable RandomSalt : LocalIntegerPType ; \n\n  -----------------------------------------------------------------\n  procedure SetRandomSalt (I : integer) is\n  -----------------------------------------------------------------\n  begin \n    RandomSalt.Set(I) ; \n  end procedure SetRandomSalt ; \n  \n  -----------------------------------------------------------------\n  impure function  SetRandomSalt (I : integer) return boolean is\n  -----------------------------------------------------------------\n  begin \n    SetRandomSalt(I) ; \n    return TRUE ; \n  end function SetRandomSalt ; \n  \n  -----------------------------------------------------------------\n  impure function  SetRandomSalt (I : integer) return integer is\n  -----------------------------------------------------------------\n  begin \n    SetRandomSalt(I) ; \n    return I ; \n  end function SetRandomSalt ; \n  \n  -----------------------------------------------------------------\n  procedure SetRandomSalt (S : string) is\n  -----------------------------------------------------------------\n    variable temp : real := 5381.0 ;\n  begin\n    for i in S'reverse_range loop\n      temp := (temp*33.0 + real(character'pos(S(i)))) mod (2.0**31 - 2.0**8 - 1.0) ;\n    end loop ;\n    RandomSalt.Set(integer(temp)) ; \n  end procedure SetRandomSalt ; \n\n  -----------------------------------------------------------------\n  impure function  SetRandomSalt (S : string) return boolean is\n  -----------------------------------------------------------------\n  begin \n    SetRandomSalt(S) ; \n    return TRUE ; \n  end function SetRandomSalt ; \n  \n  -----------------------------------------------------------------\n  impure function  SetRandomSalt (S : string) return string is\n  -----------------------------------------------------------------\n  begin \n    SetRandomSalt(S) ; \n    return S ; \n  end function SetRandomSalt ; \n  \n  -----------------------------------------------------------------\n  impure function GetRandomSalt return integer is \n  -----------------------------------------------------------------\n  begin \n    return RandomSalt.Get ; \n  end function GetRandomSalt ; \n\n  -----------------------------------------------------------------\n  --  RandomSeedType IO\n  -- \n  -----------------------------------------------------------------\n  function to_string(A : RandomSeedType; Separator : string := \" \") return string is\n  -----------------------------------------------------------------\n  begin\n    return to_string(A(A'left)) & Separator & to_string(A(A'right)) ;\n  end function to_string ;\n\n  -----------------------------------------------------------------\n  procedure write(variable L: inout line ; A : RandomSeedType ) is\n  -----------------------------------------------------------------\n  begin\n    write(L, to_string(A)) ;\n  end procedure ;\n\n  -----------------------------------------------------------------\n  procedure read(variable L: inout line ; A : out RandomSeedType ; good : out boolean ) is\n  -----------------------------------------------------------------\n    variable iReadValid : boolean ;\n  begin\n    for i in A'range loop\n      read(L, A(i), iReadValid) ;\n      exit when not iReadValid ;\n    end loop ;\n    good := iReadValid ;\n  end procedure read ;\n\n  -----------------------------------------------------------------\n  procedure read(variable L: inout line ; A : out RandomSeedType ) is\n  -----------------------------------------------------------------\n    variable ReadValid : boolean ;\n  begin\n      read(L, A, ReadValid) ;\n      AlertIfNot(ReadValid, OSVVM_ALERTLOG_ID, \"RandomBasePkg.read[line, RandomSeedType] failed\", FAILURE) ;  \n  end procedure read ;\n  \n  -----------------------------------------------------------------\n  --  RandomParmType IO\n  -- \n  -----------------------------------------------------------------\n  function to_string(A : RandomDistType) return string is\n  -----------------------------------------------------------------\n  begin\n    return RandomDistType'image(A) ;\n  end function to_string ;\n\n  -----------------------------------------------------------------\n  procedure write(variable L : inout line ; A : RandomDistType ) is\n  -----------------------------------------------------------------\n  begin\n    write(L, to_string(A)) ;\n  end procedure write ;\n\n  -----------------------------------------------------------------\n  procedure read(variable L : inout line ; A : out RandomDistType ; good : out boolean ) is\n  -----------------------------------------------------------------\n    variable strval : string(1 to 40) ;\n    variable len    : natural ;\n  begin\n    -- procedure SREAD (L : inout LINE ; VALUE : out STRING ; STRLEN : out NATURAL) ;\n    sread(L, strval, len) ;\n    A := RandomDistType'value(strval(1 to len)) ;\n    good := len > 0 ;\n  end procedure read ;\n\n  -----------------------------------------------------------------\n  procedure read(variable L : inout line ; A : out RandomDistType ) is\n  -----------------------------------------------------------------\n    variable ReadValid : boolean ;\n  begin\n      read(L, A, ReadValid) ;\n      AlertIfNot( OSVVM_ALERTLOG_ID, ReadValid, \"RandomPkg.read[line, RandomDistType] failed\", FAILURE) ;\n  end procedure read ;\n\n  -----------------------------------------------------------------\n  function to_string(A : RandomParmType) return string is\n  -----------------------------------------------------------------\n  begin\n    return RandomDistType'image(A.Distribution) & \" \" &\n           to_string(A.Mean, 2) & \" \" & to_string(A.StdDeviation, 2) ;\n  end function to_string ;\n\n  -----------------------------------------------------------------\n  procedure write(variable L : inout line ; A : RandomParmType ) is\n  -----------------------------------------------------------------\n  begin\n    write(L, to_string(A)) ;\n  end procedure write ;\n\n  -----------------------------------------------------------------\n  procedure read(variable L : inout line ; A : out RandomParmType ; good : out boolean ) is\n  -----------------------------------------------------------------\n    variable strval : string(1 to 40) ;\n    variable len    : natural ;\n    variable igood  : boolean ;\n  begin\n    loop\n      -- procedure SREAD (L : inout LINE ; VALUE : out STRING ; STRLEN : out NATURAL) ;\n      sread(L, strval, len) ;\n      A.Distribution := RandomDistType'value(strval(1 to len)) ;\n      igood := len > 0 ;\n      exit when not igood ;\n\n      read(L, A.Mean, igood) ;\n      exit when not igood ;\n\n      read(L, A.StdDeviation, igood) ;\n      exit ;\n    end loop ;\n    good := igood ;\n  end procedure read ;\n\n  -----------------------------------------------------------------\n  procedure read(variable L : inout line ; A : out RandomParmType ) is\n  -----------------------------------------------------------------\n    variable ReadValid : boolean ;\n  begin\n      read(L, A, ReadValid) ;\n      AlertIfNot( OSVVM_ALERTLOG_ID, ReadValid, \"RandomPkg.read[line, RandomParmType] failed\", FAILURE) ; \n  end procedure read ;\n\n\n  -----------------------------------------------------------------\n  --  Randomization Support\n  --    Scale                - Scale a value to be within a given range\n  --    FavorSmall, FavorBig - Distribution Support\n  --    RemoveExclude \n  --   \n  -----------------------------------------------------------------\n  --  Scale - Scale a value to be within a given range\n  function Scale (A, Min, Max : real) return real is\n  -----------------------------------------------------------------\n    variable ValRange : Real ;\n  begin\n    ValRange := Max - Min ;\n    return A * ValRange + Min ;\n--!!    -- Already done checked and failed if error.\n--!!    -- If continuing this calculation is no worse than returning real'left\n--!!    if Max >= Min then\n--!!      ValRange := Max - Min ;\n--!!      return A * ValRange + Min ;\n--!!    else\n--!!      return real'left ;\n--!!    end if ;\n  end function Scale ;\n\n  -----------------------------------------------------------------\n  function Scale (A : real ; Min, Max : integer) return integer is\n  -----------------------------------------------------------------\n    variable ValRange : real ;\n    variable rMin, rMax : real ;\n  begin\n    rMin := real(Min) - 0.5 ;\n    rMax := real(Max) + 0.5 ;\n    ValRange := rMax - rMin ;\n    return integer(round(A * ValRange + rMin)) ;\n--!!    -- Already done checked and failed if error.\n--!!    -- If continuing this calculation is no worse than returning real'left\n--!!    if Max >= Min then\n--!!      rMin := real(Min) - 0.5 ;\n--!!      rMax := real(Max) + 0.5 ;\n--!!      ValRange := rMax - rMin ;\n--!!      return integer(round(A * ValRange + rMin)) ;\n--!!    else\n--!!      return integer'left ;\n--!!    end if ;\n  end function Scale ;\n\n  -----------------------------------------------------------------\n  -- FavorSmall - create more smaller values\n  function FavorSmall (A : real) return real is\n  -----------------------------------------------------------------\n  begin\n    return 1.0 - sqrt(A) ;\n  end FavorSmall ;\n\n  -----------------------------------------------------------------\n  -- FavorBig - create more larger values\n  -- alias FavorBig is sqrt[real return real] ;\n  function FavorBig   (A : real) return real is\n  -----------------------------------------------------------------\n  begin\n    return sqrt(A) ;\n  end FavorBig ;\n\n  -----------------------------------------------------------------\n  -- local.\n  function to_time_vector (A : integer_vector ; Unit : time) return time_vector is\n  -----------------------------------------------------------------\n    variable result : time_vector(A'range) ;\n  begin\n    for i in A'range loop\n      result(i) := A(i) * Unit ;\n    end loop ;\n    return result ;\n  end function to_time_vector ;\n\n  -----------------------------------------------------------------\n  -- local\n  function to_integer_vector (A : time_vector ; Unit : time) return integer_vector is\n  -----------------------------------------------------------------\n    variable result : integer_vector(A'range) ;\n  begin\n    for i in A'range loop\n      result(i) := A(i) / Unit ;\n    end loop ;\n    return result ;\n  end function to_integer_vector ;\n\n  -----------------------------------------------------------------\n  -- Remove the exclude list from the list - integer_vector\n  procedure RemoveExclude(A, Exclude : integer_vector ; variable NewA : out integer_vector ; variable NewALength : inout natural ) is\n  -----------------------------------------------------------------\n    alias norm_NewA : integer_vector(1 to NewA'length) is NewA ;\n  begin\n    NewALength := 0 ;\n    for i in A'range loop\n      if not inside(A(i), Exclude) then\n        NewALength := NewALength + 1 ;\n        norm_NewA(NewALength) := A(i) ;\n      end if ;\n    end loop ;\n  end procedure RemoveExclude ;\n\n  -----------------------------------------------------------------\n  -- Inside - real_vector\n  function inside(A : real ; Exclude : real_vector) return boolean is\n  -----------------------------------------------------------------\n  begin\n    for i in Exclude'range loop\n      if A = Exclude(i) then\n        return TRUE ;\n      end if ;\n    end loop ;\n    return FALSE ;\n  end function inside ;\n\n  -----------------------------------------------------------------\n  -- Remove the exclude list from the list - real_vector\n  procedure RemoveExclude(A, Exclude : real_vector ; variable NewA : out real_vector ; variable NewALength : inout natural ) is\n  -----------------------------------------------------------------\n    alias norm_NewA : real_vector(1 to NewA'length) is NewA ;\n  begin\n    NewALength := 0 ;\n    for i in A'range loop\n      if not inside(A(i), Exclude) then\n        NewALength := NewALength + 1 ;\n        norm_NewA(NewALength) := A(i) ;\n      end if ;\n    end loop ;\n  end procedure RemoveExclude ;\n\n  -----------------------------------------------------------------\n  -- Inside - time_vector\n  function inside(A : time ; Exclude : time_vector) return boolean is\n  -----------------------------------------------------------------\n  begin\n    for i in Exclude'range loop\n      if A = Exclude(i) then\n        return TRUE ;\n      end if ;\n    end loop ;\n    return FALSE ;\n  end function inside ;\n\n  -----------------------------------------------------------------\n  -- Remove the exclude list from the list - time_vector\n  procedure RemoveExclude(A, Exclude : time_vector ; variable NewA : out time_vector ; variable NewALength : inout natural ) is\n  -----------------------------------------------------------------\n    alias norm_NewA : time_vector(1 to NewA'length) is NewA ;\n  begin\n    NewALength := 0 ;\n    for i in A'range loop\n      if not inside(A(i), Exclude) then\n        NewALength := NewALength + 1 ;\n        norm_NewA(NewALength) := A(i) ;\n      end if ;\n    end loop ;\n  end procedure RemoveExclude ;\n\nend RandomBasePkg ;","lang":"vhdl"};
processSrcData(g_data);