var g_data = {"name":"C:/OsvvmLibraries/osvvm/SortListPkg_int.vhd","src":"--\n--  File Name:         SortListPkg_int.vhd\n--  Design Unit Name:  SortListPkg_int\n--  Revision:          STANDARD VERSION\n--\n--  Maintainer:        Jim Lewis      email:  jim@synthworks.com\n--  Contributor(s):\n--     Jim Lewis      jim@synthworks.com\n--\n--  Description:\n--      Sorting utility for array of scalars\n--        Uses protected type so as to shrink and expand the data structure\n--\n--  Developed for:\n--        SynthWorks Design Inc.\n--        VHDL Training Classes\n--        11898 SW 128th Ave.  Tigard, Or  97223\n--        http://www.SynthWorks.com\n--\n--  Revision History:\n--    Date       Version    Description\n--    06/2008:   0.1        Initial revision\n--                          Numerous revisions for VHDL Testbenches and Verification\n--    02/2009:   1.0        First Public Released Version\n--    02/25/2009 1.1        Replaced reference to std_2008 with a reference to\n--                          ieee_proposed.standard_additions.all ;\n--    06/16/2010 1.2        Added EraseList parameter to to_array\n--    3/2011     2.0        added inside as non protected type\n--    6/2011     2.1        added sort as non protected type\n--    4/2013     2013.04    No Changes\n--    5/2013     2013.05    No changes of substance. \n--                          Deleted extra variable declaration in procedure remove\n--    1/2014     2014.01    Added RevSort.  Added AllowDuplicate paramter to Add procedure\n--    1/2015     2015.01    Changed Assert/Report to Alert\n--    11/2016    2016.11    Revised Add.  When AllowDuplicate, add a matching value last.\n--    01/2020    2020.01    Updated Licenses to Apache\n--\n--\n--  This file is part of OSVVM.\n--  \n--  Copyright (c) 2008 - 2020 by SynthWorks Design Inc.  \n--  \n--  Licensed under the Apache License, Version 2.0 (the \"License\");\n--  you may not use this file except in compliance with the License.\n--  You may obtain a copy of the License at\n--  \n--      https://www.apache.org/licenses/LICENSE-2.0\n--  \n--  Unless required by applicable law or agreed to in writing, software\n--  distributed under the License is distributed on an \"AS IS\" BASIS,\n--  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n--  See the License for the specific language governing permissions and\n--  limitations under the License.\n--  \n\nuse work.OsvvmGlobalPkg.all ; \nuse work.AlertLogPkg.all ; \nuse std.textio.all ;\n\nlibrary ieee ;\nuse ieee.std_logic_1164.all ;\nuse ieee.numeric_std.all ;\nuse ieee.std_logic_textio.all ;\n\n-- comment out following 2 lines with VHDL-2008.  Leave in for VHDL-2002 \n-- library ieee_proposed ;						          -- remove with VHDL-2008\n-- use ieee_proposed.standard_additions.all ;   -- remove with VHDL-2008\n\n\npackage SortListPkg_int is\n  -- with VHDL-2008, convert package to generic package\n  -- convert subtypes ElementType and ArrayofElementType to generics\n  -- package SortListGenericPkg is\n  subtype ElementType is integer ;\n  subtype ArrayofElementType is integer_vector ;\n\n  impure function inside (constant E : ElementType; constant A : in ArrayofElementType) return boolean ;\n  impure function sort (constant A : in ArrayofElementType) return ArrayofElementType ;\n  impure function revsort (constant A : in ArrayofElementType) return ArrayofElementType ;\n\n  type SortListPType is protected\n    procedure add ( constant A : in ElementType ; constant AllowDuplicate : Boolean := FALSE ) ;\n    procedure add ( constant A : in ArrayofElementType ) ;\n    procedure add ( constant A : in ArrayofElementType ; Min, Max : ElementType ) ;\n    procedure add ( variable A : inout SortListPType ) ;\n    -- Count items in list\n    impure function  count return integer ;\n    impure function  find_index ( constant A : ElementType) return integer ;\n    impure function inside (constant A : ElementType) return boolean ;\n    procedure insert ( constant A : in ElementType; constant index : in integer := 1 ) ;\n    impure function get ( constant index : in integer := 1 ) return ElementType ;\n    procedure erase  ;\n    impure function Empty return boolean ;\n    procedure print ;\n\n    procedure remove ( constant A : in ElementType ) ;\n    procedure remove ( constant A : in ArrayofElementType ) ;\n    procedure remove ( variable A : inout SortListPType ) ;\n\n    impure function to_array (constant EraseList : boolean := FALSE) return ArrayofElementType ;\n    impure function to_rev_array (constant EraseList : boolean := FALSE) return ArrayofElementType ;\n  end protected SortListPType ;\n\nend SortListPkg_int ;\n\n--- ///////////////////////////////////////////////////////////////////////////\n--- ///////////////////////////////////////////////////////////////////////////\n--- ///////////////////////////////////////////////////////////////////////////\n\npackage body SortListPkg_int is\n\n  impure function inside (constant E : ElementType; constant A : in ArrayofElementType) return boolean is\n  begin\n    for i in A'range loop\n      if E = A(i) then\n        return TRUE ;\n      end if ;\n    end loop ;\n    return FALSE ;\n  end function inside ;\n  \n  type SortListPType is protected body\n    type ListType ;\n    type ListPointerType is access ListType ;\n    type ListType is record\n      A           : ElementType ;\n      -- item_num    : integer ;\n      NextPtr     : ListPointerType ;\n      -- PrevPtr     : ListPointerType ;\n    end record ;\n    variable HeadPointer : ListPointerType := NULL ;\n    -- variable TailPointer : ListPointerType := NULL ;\n\n    procedure add ( constant A : in ElementType ; constant AllowDuplicate : Boolean := FALSE ) is\n      variable CurPtr, tempPtr : ListPointerType ;\n    begin\n      if HeadPointer = NULL then\n        HeadPointer  := new ListType'(A, NULL) ;\n      elsif A = HeadPointer.A then -- ignore duplicates\n        if AllowDuplicate then\n          tempPtr := HeadPointer ;\n          HeadPointer   := new ListType'(A, tempPtr) ;\n        end if ; \n      elsif A < HeadPointer.A  then\n        tempPtr := HeadPointer ;\n        HeadPointer   := new ListType'(A, tempPtr) ;\n      else\n        CurPtr := HeadPointer ;\n        AddLoop : loop\n          exit AddLoop when CurPtr.NextPtr = NULL ;\n          exit AddLoop when A < CurPtr.NextPtr.A  ;\n          if A = CurPtr.NextPtr.A then \n--            if AllowDuplicate then  -- changed s.t. insert at after match rather than before\n--              exit AddLoop ;    -- insert \n--            else\n            if not AllowDuplicate then \n              return ;  -- return without insert\n            end if; \n          end if ; \n          CurPtr := CurPtr.NextPtr ;\n        end loop AddLoop ;\n        tempPtr := CurPtr.NextPtr ;\n        CurPtr.NextPtr := new ListType'(A, tempPtr) ;\n      end if ;\n    end procedure add ;\n    \n    procedure add ( constant A : in ArrayofElementType ) is\n    begin\n      for i in A'range loop\n        add(A(i)) ;\n      end loop ;\n    end procedure add ;\n\n    procedure add ( constant A : in ArrayofElementType ; Min, Max : ElementType ) is\n    begin\n      for i in A'range loop\n        if A(i) >= Min and A(i) <= Max then\n          add(A(i)) ;\n        end if ;\n      end loop ;\n    end procedure add ;\n\n    procedure add ( variable A : inout SortListPType ) is\n    begin\n      for i in 1 to A.Count loop\n        add(A.Get(i)) ;\n      end loop ;\n    end procedure add ;\n\n    -- Count items in list\n    impure function count return integer is\n      variable result : positive := 1 ;\n      variable CurPtr : ListPointerType ;\n    begin\n      if HeadPointer = NULL then\n        return 0 ;\n      else\n        CurPtr := HeadPointer ;\n        loop\n          exit when CurPtr.NextPtr = NULL ;\n          result := result + 1 ;\n          CurPtr := CurPtr.NextPtr ;\n        end loop ;\n        return result ;\n      end if ;\n    end function count ;\n\n    impure function find_index (constant A : ElementType) return integer is\n      variable result : positive := 2 ;\n      variable CurPtr : ListPointerType ;\n    begin\n      if HeadPointer = NULL then\n        return 0 ;\n      elsif A <= HeadPointer.A then\n        return 1 ;\n      else\n        CurPtr := HeadPointer ;\n        loop\n          exit when CurPtr.NextPtr = NULL ;\n          exit when A <= CurPtr.NextPtr.A ;\n          result := result + 1 ;\n          CurPtr := CurPtr.NextPtr ;\n        end loop ;\n        return result ;\n      end if ;\n    end function find_index ;\n\n    impure function inside (constant A : ElementType) return boolean is\n      variable CurPtr : ListPointerType ;\n    begin\n      if HeadPointer = NULL then\n        return FALSE ;\n      end if ;\n      if A = HeadPointer.A then\n        return TRUE ;\n      else\n        CurPtr := HeadPointer ;\n        loop\n          exit when CurPtr.NextPtr = NULL ;\n          exit when A < CurPtr.NextPtr.A  ;\n          if A = CurPtr.NextPtr.A then\n            return TRUE ;  -- exit\n          end if;\n          CurPtr := CurPtr.NextPtr ;\n        end loop ;\n      end if ;\n      return FALSE ;\n    end function inside ;\n\n\n    procedure insert( constant A : in ElementType; constant index : in integer := 1 ) is\n      variable CurPtr, tempPtr : ListPointerType ;\n    begin\n      if index <= 1 then\n        tempPtr := HeadPointer ;\n        HeadPointer   := new ListType'(A, tempPtr) ;\n      else\n        CurPtr := HeadPointer ;\n        for i in 3 to index loop\n          exit when CurPtr.NextPtr = NULL ; -- end of list\n          CurPtr := CurPtr.NextPtr ;\n        end loop ;\n        tempPtr := CurPtr.NextPtr ;\n        CurPtr.NextPtr := new ListType'(A, tempPtr) ;\n      end if;\n    end procedure insert ;\n\n    impure function get ( constant index : in integer := 1 ) return ElementType is\n      variable CurPtr : ListPointerType ;\n    begin\n      if index > Count then\n        Alert(OSVVM_ALERTLOG_ID, \"SortLIstPkg_int.get index out of range\", FAILURE) ;\n        return ElementType'left ;\n      elsif HeadPointer = NULL then\n        return ElementType'left ;\n      elsif index <= 1 then\n        return HeadPointer.A ;\n      else\n        CurPtr := HeadPointer ;\n        for i in 2 to index loop\n          CurPtr := CurPtr.NextPtr ;\n        end loop ;\n        return CurPtr.A ;\n      end if;\n    end function get ;\n\n\n    procedure erase (variable CurPtr : inout ListPointerType ) is\n    begin\n      if CurPtr.NextPtr /= NULL then\n        erase (CurPtr.NextPtr) ;\n      end if ;\n      deallocate (CurPtr) ;\n    end procedure erase ;\n\n    procedure erase is\n    begin\n      if HeadPointer /= NULL then\n        erase(HeadPointer) ;\n        -- deallocate (HeadPointer) ;\n        HeadPointer := NULL ;\n      end if;\n    end procedure erase ;\n\n    impure function Empty return boolean is\n    begin\n      return HeadPointer = NULL ;\n    end Empty ;\n\n    procedure print is\n      variable buf : line ;\n      variable CurPtr : ListPointerType ;\n    begin\n      if HeadPointer = NULL then\n        write (buf, string'(\"( )\")) ;\n      else\n        CurPtr := HeadPointer ;\n        write (buf, string'(\"(\")) ;\n        loop\n          write (buf, CurPtr.A) ;\n          exit when CurPtr.NextPtr = NULL ;\n          write (buf, string'(\", \")) ;\n          CurPtr := CurPtr.NextPtr ;\n        end loop ;\n        write (buf, string'(\")\")) ;\n      end if ;\n      writeline(OUTPUT, buf) ;\n    end procedure print ;\n\n    procedure remove ( constant A : in ElementType ) is\n      variable CurPtr, tempPtr : ListPointerType ;\n    begin\n      if HeadPointer = NULL then\n        return ;\n      elsif A = HeadPointer.A then\n        tempPtr := HeadPointer ;\n        HeadPointer := HeadPointer.NextPtr ;\n        deallocate (tempPtr) ;\n      else\n        CurPtr := HeadPointer ;\n        loop\n          exit when CurPtr.NextPtr = NULL ;\n          if A = CurPtr.NextPtr.A then\n            tempPtr := CurPtr.NextPtr ;\n            CurPtr.NextPtr := CurPtr.NextPtr.NextPtr ;\n            deallocate (tempPtr) ;\n            exit ;\n          end if ;\n          exit when A < CurPtr.NextPtr.A ;\n          CurPtr := CurPtr.NextPtr ;\n        end loop ;\n      end if ;\n    end procedure remove ;\n\n    procedure remove ( constant A : in ArrayofElementType ) is\n    begin\n      for i in A'range loop\n        remove(A(i)) ;\n      end loop ;\n    end procedure remove ;\n\n    procedure remove ( variable A : inout SortListPType ) is\n    begin\n      for i in 1 to A.Count loop\n        remove(A.Get(i)) ;\n      end loop ;\n    end procedure remove ;\n\n    impure function to_array (constant EraseList : boolean := FALSE) return ArrayofElementType is\n      variable result : ArrayofElementType(1 to Count) ;\n    begin\n      for i in 1 to Count loop\n        result(i) := Get(i) ;\n      end loop ;\n      if EraseList then\n        erase ;\n      end if ;\n      return result ;\n    end function to_array ;\n\n    impure function to_rev_array (constant EraseList : boolean := FALSE) return ArrayofElementType is\n      variable result : ArrayofElementType(Count downto 1) ;\n    begin\n      for i in 1 to Count loop\n        result(i) := Get(i) ;\n      end loop ;\n      if EraseList then\n        erase ;\n      end if ;\n      return result ;\n    end function to_rev_array ;\n\n    end protected body SortListPType ;\n \n \n  impure function sort (constant A : in ArrayofElementType) return ArrayofElementType is\n    variable Result : SortListPType ;\n  begin\n    for i in A'range loop \n      Result.Add(A(i), TRUE) ;\n    end loop ;\n    return Result.to_array(EraseList => TRUE)  ; \n  end function sort ;\n\n  impure function revsort (constant A : in ArrayofElementType) return ArrayofElementType is\n    variable Result : SortListPType ;\n  begin\n    for i in A'range loop \n      Result.Add(A(i), TRUE) ;\n    end loop ;\n    return Result.to_rev_array(EraseList => TRUE)  ; \n  end function revsort ;\nend SortListPkg_int ;\n\n","lang":"vhdl"};
processSrcData(g_data);