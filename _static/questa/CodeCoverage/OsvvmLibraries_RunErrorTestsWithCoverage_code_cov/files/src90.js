var g_data = {"name":"C:/OsvvmLibraries/UART/src/UartRx.vhd","src":"--\n--  File Name:         UartRx.vhd\n--  Design Unit Name:  UartRx\n--  OSVVM Release:     OSVVM MODELS STANDARD VERSION\n--\n--  Maintainer:        Jim Lewis      email:  jim@synthworks.com\n--  Contributor(s):\n--     Jim Lewis      jim@synthworks.com\n--\n--\n--  Description:\n--      UART Receiver Model - 16X Clock based sampling\n--\n--\n--  Developed by:\n--        SynthWorks Design Inc.\n--        VHDL Training Classes\n--        http://www.SynthWorks.com\n--\n--  Revision History:\n--    Date      Version    Description\n--    03/2024   2024.03    Updated SafeResize to use ModelID\n--    10/2022   2022.10    Changed enum value PRIVATE to PRIVATE_NAME due to VHDL-2019 keyword conflict.   \n--    05/2022   2022.05    Updated FIFOs so they are Search => PRIVATE\n--                         Added MODEL_ID_NAME generic\n--    03/2022   2022.03    Updated to use singleton based FIFOs.  Updated calls for AlertLogIDs\n--    02/2022   2022.02    Replaced to_hstring with to_hxstring\n--    08/2021   2021.08    Initialized NumDataBits, ParityMode, and NumStopBits\n--    02/2021   2021.02    Updated for resizing Data and Param to/from TransRec\n--    10/2020   2020.10    Update for updates to stream MIT\n--    07/2020   2020.07    Converted transactions to stream MIT \n--    01/2020   2020.01    Updated license notice\n--    05/2019   2019.05    Updated for OSVVM public release\n--    1999      1999.00    Developed for SynthWorks' Advanced VHDL Testbenches and Verification Class\n--\n--\n--  This file is part of OSVVM.\n--\n--  Copyright (c) 1999 - 2021 by SynthWorks Design Inc.\n--\n--  Licensed under the Apache License, Version 2.0 (the \"License\");\n--  you may not use this file except in compliance with the License.\n--  You may obtain a copy of the License at\n--\n--      https://www.apache.org/licenses/LICENSE-2.0\n--\n--  Unless required by applicable law or agreed to in writing, software\n--  distributed under the License is distributed on an \"AS IS\" BASIS,\n--  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n--  See the License for the specific language governing permissions and\n--  limitations under the License.\n--\n\nlibrary ieee ;\n  use ieee.std_logic_1164.all ;\n  use ieee.numeric_std.all ;\n  use ieee.numeric_std_unsigned.all ;\n\n  use std.textio.all ;\n\nlibrary OSVVM ;\n  context OSVVM.OsvvmContext ; \n--  use osvvm.ScoreboardPkg_slv.all ;\n--!! GHDL\n  use osvvm.ScoreboardPkg_slv.NewID ;\n  use osvvm.ScoreboardPkg_slv.Empty ;\n  use osvvm.ScoreboardPkg_slv.Push ;\n  use osvvm.ScoreboardPkg_slv.Pop ;\n\nlibrary osvvm_common ; \n  context osvvm_common.OsvvmCommonContext ;  \n\n  use work.UartTbPkg.all ;\n\nentity UartRx is\n  generic (\n    MODEL_ID_NAME           : string := \"\" ;\n    DEFAULT_BAUD            : time    := UART_BAUD_PERIOD_125K ;\n    DEFAULT_NUM_DATA_BITS   : integer := UARTTB_DATA_BITS_8 ; \n    DEFAULT_PARITY_MODE     : integer := UARTTB_PARITY_EVEN ; \n    DEFAULT_NUM_STOP_BITS   : integer := UARTTB_STOP_BITS_1  \n  ) ;\n  port (\n    TransRec         : InOut UartRecType ;\n    SerialDataIn     : In    std_logic\n  ) ;\n  -- Use MODEL_ID_NAME Generic if set, otherwise,\n  -- use model instance label (preferred if set as entityname_1)\n  constant MODEL_INSTANCE_NAME : string :=\n    IfElse(MODEL_ID_NAME'length > 0, MODEL_ID_NAME, \n      to_lower(PathTail(UartRx'PATH_NAME))) ;\n\nend UartRx ;\narchitecture model of UartRx is\n\n  -- Clock Generation\n  signal Uart16XClk        : std_logic := '0' ;\n  \n  -- SerialDataIn preprocessing\n  signal iSerialDataIn   : std_logic ;\n\n  -- Sample Bit Signaling\n  signal SampleBitCount  : unsigned(3 downto 0) := \"0110\" ;\n  signal SampleBit       : std_logic := '0' ;\n\n  -- Statemachine Type and State Signal declarations\n  type RxStateType is (RX_IDLE, RX_HUNT, RX_DATA, RX_PARITY, RX_STOP, RX_BREAK) ;\n  signal RxState : RxStateType := RX_IDLE ;\n\n  signal DataBitCount : integer := 0;\n  signal LastDataBit : std_logic ;\n\n  signal ModelID  : AlertLogIDType ;\n\n  signal ReceiveFifo : osvvm.ScoreboardPkg_slv.ScoreboardIDType ;\n\n  signal ReceiveCount : integer := 0 ;   \n  \n  -- Set initial values for configurable modes\n  signal ParityMode  : integer := UARTTB_PARITY_EVEN;\n  signal NumStopBits : integer := UARTTB_STOP_BITS_1 ;\n  signal NumDataBits : integer := UARTTB_DATA_BITS_8 ;\n  signal Baud        : time    := UART_BAUD_PERIOD_125K ; -- init for clock start\n\nbegin\n\n  ------------------------------------------------------------\n  --  Initialize alerts\n  ------------------------------------------------------------\n  InitializeAlerts : process\n    variable ID : AlertLogIDType ;\n  begin\n    ID            := NewID(MODEL_INSTANCE_NAME) ;\n    ModelID       <= ID ; \n    ReceiveFifo   <= NewID(\"ReceiveFifo\", ID, ReportMode => DISABLED, Search => PRIVATE_NAME) ;\n    wait ;\n  end process InitializeAlerts ;\n  \n  \n  ------------------------------------------------------------\n  --  Transaction Dispatcher\n  --    Dispatches transactions to\n  ------------------------------------------------------------\n  TransactionDispatcher : process\n    alias Operation : StreamOperationType is TransRec.Operation ;\n    variable WaitCycles : integer ;\n    variable RxStim, ExpectedStim : UartStimType ;\n  begin\n    wait for 0 ns ; -- Let ModelID get set\n    -- Initialize defaults\n    ParityMode    <= CheckParityMode (ModelID, DEFAULT_PARITY_MODE,   FALSE) ; \n    NumStopBits   <= CheckNumStopBits(ModelID, DEFAULT_NUM_STOP_BITS, FALSE) ; \n    NumDataBits   <= CheckNumDataBits(ModelID, DEFAULT_NUM_DATA_BITS, FALSE) ; \n    Baud          <= CheckBaud(ModelID, DEFAULT_BAUD, FALSE) ;  \n\n    TransactionDispatcherLoop : loop \n      WaitForTransaction(\n         Clk      => Uart16XClk,\n         Rdy      => TransRec.Rdy,\n         Ack      => TransRec.Ack\n      ) ;\n      \n--**      Operation := TransRec.Operation ;\n      \n      case Operation is\n        when GET | TRY_GET | CHECK | TRY_CHECK =>\n          if Empty(ReceiveFifo) and IsTry(Operation) then\n            -- Return if no data\n            TransRec.BoolFromModel <= FALSE ; \n          else\n            -- Get data\n            TransRec.BoolFromModel <= TRUE ; \n            if Empty(ReceiveFifo) then \n              -- Wait for data\n              WaitForToggle(ReceiveCount) ;\n            else \n              -- Settling for when not Empty at current time, but ReceiveCount not updated yet\n              -- ReceiveCount used in reporting below.\n              wait for 0 ns ; \n            end if ; \n            -- Put Data and Parameters into record\n            (RxStim.Data, RxStim.Error) := pop(ReceiveFifo) ;\n            TransRec.DataFromModel   <= SafeResize(ModelID, RxStim.Data,  TransRec.DataFromModel'length) ; \n            TransRec.ParamFromModel  <= SafeResize(ModelID, RxStim.Error, TransRec.ParamFromModel'length); \n            \n            if IsCheck(Operation) then\n              ExpectedStim := \n                (Data  => SafeResize(ModelID, TransRec.DataToModel, ExpectedStim.Data'length), \n                 Error => to_01(SafeResize(ModelID, TransRec.ParamToModel, ExpectedStim.Error'length))) ;\n              if Match(RxStim, ExpectedStim) then\n                AffirmPassed(ModelID,\n                  \"Received: \" & to_string(RxStim) & \n                  \".  Operation # \" & to_string(ReceiveCount),\n                  TransRec.BoolToModel or IsLogEnabled(ModelID, INFO) ) ;\n              else\n                AffirmError(ModelID,\n                  \"Received: \" & to_string(RxStim) & \n                  \".  Expected: \" & to_string(ExpectedStim) & \n                  \".  Operation # \" & to_string(ReceiveCount) ) ;\n              end if ; \n            else\n              Log(ModelID, \n                \"Received: \" & to_string(RxStim) & \n                \".  Operation # \" & to_string(ReceiveCount),\n                INFO, Enable => TransRec.BoolToModel\n              ) ; \n            end if ;\n          end if ; \n          \n        when WAIT_FOR_TRANSACTION =>\n          if Empty(ReceiveFifo) then \n            WaitForToggle(ReceiveCount) ;\n          end if ; \n\n        when WAIT_FOR_CLOCK =>\n          WaitCycles := TransRec.IntToModel ;\n          -- Log(ModelID, \n          --   \"WaitForClock:  WaitCycles = \" & to_string(WaitCycles),\n          --   INFO\n          -- ) ; \n          wait for (WaitCycles * Baud) - 1 ns ;\n          wait until Uart16XClk = '1' ;\n          \n        when GET_ALERTLOG_ID =>\n          TransRec.IntFromModel <= ModelID ;\n\n        when GET_TRANSACTION_COUNT =>\n          TransRec.IntFromModel <= ReceiveCount ;\n\n        when SET_MODEL_OPTIONS =>\n          case TransRec.Options is\n            when UartOptionType'pos(SET_PARITY_MODE) => \n              ParityMode    <= CheckParityMode(ModelID, TransRec.IntToModel, TransRec.BoolToModel) ; \n            when UartOptionType'pos(SET_STOP_BITS) =>\n              NumStopBits   <= CheckNumStopBits(ModelID, TransRec.IntToModel, TransRec.BoolToModel) ; \n            when UartOptionType'pos(SET_DATA_BITS) =>      \n              NumDataBits   <= CheckNumDataBits(ModelID, TransRec.IntToModel, TransRec.BoolToModel) ; \n            when UartOptionType'pos(SET_BAUD) =>\n              Baud          <= CheckBaud(ModelID, TransRec.TimeToModel, TransRec.BoolToModel) ;  \n            when others =>     \n              Alert(ModelID, \"SetOptions, Unimplemented Option: \" & to_string(UartOptionType'val(TransRec.Options)), FAILURE) ;\n          end case ; \n        \n        when MULTIPLE_DRIVER_DETECT =>\n          Alert(ModelID, \"Multiple Drivers on Transaction Record.\" & \n                         \"  Transaction # \" & to_string(TransRec.Rdy), FAILURE) ;\n\n        when others =>\n          Alert(ModelID, \"Unimplemented Transaction: \" & to_string(Operation), FAILURE) ;\n          \n      end case ;\n    end loop TransactionDispatcherLoop ;\n  end process TransactionDispatcher ;\n  \n  \n  ------------------------------------------------------------\n  --  Generate 16X Baud Clock\n  ------------------------------------------------------------\n  Uart16XClkProc : process\n  begin\n    wait for Baud / 16 ;\n    Uart16XClk <= '0', '1' after Baud / 32 ;\n  end process ;\n\n\n  ------------------------------------------------------------\n  --  Pre-Process Inputs\n  ------------------------------------------------------------\n  iSerialDataIn <= to_X01(SerialDataIn) ;\n\n\n  ------------------------------------------------------------\n  -- UART Receiver Statemachine\n  --    Note for testbench, no reset needed, initial value = power on reset value\n  ------------------------------------------------------------\n  UartRxStateProc : process\n  begin\n    -- Aldec enum RxStateType CURRENT=RxState\n    -- Aldec enum RxStateType STATES=RX_IDLE,RX_HUNT,RX_DATA,RX_PARITY,RX_STOP,RX_BREAK\n    wait until Uart16XClk = '1' ;\n\n    case RxState is\n      when RX_IDLE =>\n        if iSerialDataIn = '0' then\n          RxState <= RX_HUNT ;\n        end if ;\n\n      when RX_HUNT =>\n        if iSerialDataIn /= '0' then\n          RxState <= RX_IDLE ;\n        elsif SampleBit = '1' then\n          RxState <= RX_DATA ;\n        end if ;\n\n      when RX_DATA =>\n        if SampleBit = '1' and LastDataBit = '1' then\n          if ParityMode = UARTTB_PARITY_NONE then\n            RxState <= RX_STOP ; \n          else \n            RxState <= RX_PARITY ; \n          end if ; \n        end if ;\n\n      when RX_PARITY =>\n        if SampleBit = '1' then\n          RxState <= RX_STOP ;\n        end if ;\n\n      when RX_STOP =>\n        if SampleBit = '1' then\n          if iSerialDataIn = '1' then\n            RxState <= RX_IDLE ;\n          else\n            RxState <= RX_BREAK ;\n          end if ;\n        end if ;\n\n      when RX_BREAK =>\n        if SampleBit = '1' then\n          if iSerialDataIn = '1' then\n            RxState <= RX_IDLE ;\n          else\n            RxState <= RX_BREAK ;\n          end if ;\n        end if ;\n    end case ;\n  end process ;\n\n\n  ------------------------------------------------------------\n  -- Data Capture Logic\n  --    Separate from statemachine for readability\n  --    For a one process statemachine, this can be coded with the statemachine\n  ------------------------------------------------------------\n  UartDataHandler : process\n    variable RxData    : std_logic_vector(7 downto 0) ;\n    variable RxParity  : std_logic ;\n    variable ErrorMode : std_logic_vector(TransRec.ParamFromModel'range) ;\n  begin\n    wait on Uart16XClk until Uart16XClk = '1' and SampleBit = '1' ;\n    case RxState is\n\n      when RX_DATA =>\n        RxData(DataBitCount) := iSerialDataIn ;\n        DataBitCount <= DataBitCount + 1 ;\n\n      when RX_PARITY =>\n        RxParity := iSerialDataIn ;\n\n      when RX_STOP =>\n        ErrorMode(UARTTB_PARITY_INDEX) := CalcParity(RxData, ParityMode) ?/= RxParity ;\n        ErrorMode(UARTTB_STOP_INDEX)   := not to_01(iSerialDataIn) ;\n        if ParityMode /= UARTTB_PARITY_NONE then\n          ErrorMode(UARTTB_BREAK_INDEX)  := not (iSerialDataIn or RxParity or (or RxData)) ;\n        else\n          ErrorMode(UARTTB_BREAK_INDEX)  := not (iSerialDataIn or (or RxData)) ;\n        end if;\n        if ErrorMode(UARTTB_BREAK_INDEX) = '1' then \n          Log(ModelID, \"UartRx  Break Detected\", INFO) ;\n        end if ; \n        \n        -- Hand off values to Transaction Handler\n        push(ReceiveFifo, RxData & ErrorMode) ;\n        increment(ReceiveCount) ;\n        \n        -- Log at interface at DEBUG level\n        Log(ModelID, \n          \"Received:\" & \n          \" Data = \" & to_hxstring(RxData) & \n          \", Parity = \" & to_string(RxParity) & \n          \", Stop = \" & to_string(iSerialDataIn) & \n          \", Parity Error = \" & to_string(ErrorMode(UARTTB_PARITY_INDEX)) & \n          \", Stop Error = \" & to_string(ErrorMode(UARTTB_STOP_INDEX)) & \n          \", Break Error = \" & to_string(ErrorMode(UARTTB_BREAK_INDEX)) & \n          \",  Operation # \" & to_string(ReceiveCount),\n          DEBUG\n        ) ;\n        \n      when others =>\n        DataBitCount <= 0 ;\n        RxData       := (others => '0') ;   -- %% Tb2 Lab 10.1.5\n        RxParity := '-'  ; -- No Parity\n        ErrorMode := (others => '0') ;\n\n    end case ;\n  end process UartDataHandler ;\n\n  LastDataBit <= '1' when DataBitCount = (NumDataBits - 1) else '0' ;\n\n\n  ------------------------------------------------------------\n  -- Sample Bit Signaling\n  ------------------------------------------------------------\n  SampleBitCntProc : process\n  begin\n    wait until Uart16XClk = '1' ;\n    if RxState = RX_IDLE then\n      SampleBitCount <= \"0110\" ;\n\n    else\n      SampleBitCount <= SampleBitCount - 1 ;\n\n    end if ;\n  end process ;\n\n  SampleBit <= '1' when SampleBitCount = 0 else '0' ;\n\n\nend model ;\n\n\n\n","lang":"vhdl"};
processSrcData(g_data);