var g_data = {"name":"C:/OsvvmLibraries/Common/src/StreamTransactionPkg.vhd","src":"--\n--  File Name:         StreamTransactionPkg.vhd\n--  Design Unit Name:  StreamTransactionPkg\n--  Revision:          OSVVM MODELS STANDARD VERSION\n--\n--  Maintainer:        Jim Lewis      email:  jim@synthworks.com\n--  Contributor(s):\n--     Jim Lewis      jim@synthworks.com\n--\n--\n--  Description:\n--    Defines the OSVVM Stream Model Independent Transaction\n--    Interface (StreamRecType) and transaction initiation \n--    procedures (Send, Get, ...), as well as supporting types,\n--    constants, and subprograms that are essential to both \n--    to Verification Components and testbenches (test \n--    harnesses and test sequencers) that use streaming type\n--    interfaces (such as UART, AxiStream, ...)\n--\n--\n--  Developed by:\n--        SynthWorks Design Inc.\n--        VHDL Training Classes\n--        http://www.SynthWorks.com\n--\n--  Revision History:\n--    Date      Version    Description\n--    09/2023   2023.09    Added ModelParametersIDType to Record, \n--                         Added SendAndGet and SendAndGetBurst,\n--                         Added OperationType ENUMs:  EXTEND_DIRECTIVE_OP, EXTEND_OP, EXTEND_TX_OP, EXTEND_RX_OP\n--                         Added ClassifyUnimplementedOperation, ClassifyUnimplementedTransmitterOperation, ClassifyUnimplementedReceiverOperation\n--    05/2023   2023.05    Added SetDelayCoverageID and GetDelayCoverageID\n--    11/2022   2022.11    Added StreamRecArrayType\n--    01/2022   2022.01    Burst patterns - Burst, BurstInc, BurstRandom\n--    06/2021   2021.06    Updated bursting \n--    10/2020   2020.10    Added bursting to stream transactions\n--    09/2020   2020.09    Updating comments to serve as documentation\n--    07/2020   2020.07    Updated\n--    01/2020   2020.01    Updated license notice\n--    07/2019   2019.07    Refactored from UartTbPkg and AxiStreamTransactionPkg\n--\n--\n--  This file is part of OSVVM.\n--  \n--  Copyright (c) 2019 - 2023 by SynthWorks Design Inc.  \n--  \n--  Licensed under the Apache License, Version 2.0 (the \"License\");\n--  you may not use this file except in compliance with the License.\n--  You may obtain a copy of the License at\n--  \n--      https://www.apache.org/licenses/LICENSE-2.0\n--  \n--  Unless required by applicable law or agreed to in writing, software\n--  distributed under the License is distributed on an \"AS IS\" BASIS,\n--  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n--  See the License for the specific language governing permissions and\n--  limitations under the License.\n--  \n\nlibrary ieee ;\n  use ieee.std_logic_1164.all ;\n  use ieee.numeric_std.all ;\n  use ieee.numeric_std_unsigned.all ;\n\n  use std.textio.all ;\n\nlibrary osvvm ; \n  context osvvm.OsvvmContext ;  \n  use osvvm.ScoreboardPkg_slv.all ; \n  \n  use work.ModelParametersSingletonPkg.all ; \n  use work.FifoFillPkg_slv.all ; \n\npackage StreamTransactionPkg is \n\n  -- ========================================================\n  --  StreamOperationType \n  --  Enumeration type used to communication transaction type\n  --  to the model via the transaction interface\n  -- ========================================================\n  type StreamUnresolvedOperationType is (\n    -- Default. Used by resolution function for Multiple Driver Detection\n    NOT_DRIVEN,  \n    -- Directives\n    WAIT_FOR_CLOCK, \n    WAIT_FOR_TRANSACTION,\n    GET_TRANSACTION_COUNT,\n    GET_ALERTLOG_ID,\n    -- Delay Coverage ID\n    SET_USE_RANDOM_DELAYS,\n    GET_USE_RANDOM_DELAYS,\n    SET_DELAYCOV_ID,\n    GET_DELAYCOV_ID,\n    -- Burst FIFO Configuration\n    SET_BURST_MODE,\n    GET_BURST_MODE,\n    -- Check to see if Read Burst is available\n    GOT_BURST, \n    -- Model Options\n    SET_MODEL_OPTIONS,\n    GET_MODEL_OPTIONS,\n    -- VC Customization of Directives and Functional Operations\n    EXTEND_DIRECTIVE_OP,\n    EXTEND_OP,\n    --  Transmitter\n    START_OF_TX_OPS,\n    SEND, \n    SEND_ASYNC,\n    SEND_BURST,\n    SEND_BURST_ASYNC,\n    -- VC Customization of TX Operations\n    EXTEND_TX_OP,\n    -- Receiver\n    START_OF_RX_OPS,\n    GET,             \n    TRY_GET,\n    GET_BURST,\n    TRY_GET_BURST,\n    CHECK,\n    TRY_CHECK,\n    CHECK_BURST,\n    TRY_CHECK_BURST,\n    -- VC Customization of RX Operations\n    EXTEND_RX_OP,\n    -- Send and Get\n    SEND_AND_GET, \n    SEND_AND_GET_BURST, \n\n    -- Resolution function detected Multiple drivers\n    MULTIPLE_DRIVER_DETECT \n  ) ;\n  type StreamUnresolvedOperationVectorType is array (natural range <>) of StreamUnresolvedOperationType ;\n  -- Maximum is implicitly defined for any array type in VHDL-2008.   \n  -- alias resolved_max is maximum[ StreamUnresolvedOperationVectorType return StreamUnresolvedOperationType] ;\n  -- Function resolved_max is a fall back.\n  function resolved_max ( s : StreamUnresolvedOperationVectorType) return StreamUnresolvedOperationType ;\n  subtype StreamOperationType is resolved_max StreamUnresolvedOperationType ;\n\n  -- ========================================================\n  --  Stream Transaction Interface (StreamRecType) \n  --  The Stream Transaction Interface (StreamRecType) defines the \n  --  transaction interface between the test sequencer and the \n  --  verification component.   As such, it is the primary channel for \n  --  information exchange between the two.   It is defined as follows.\n  --\n  --  The record element types, bit_max, std_logic_vector_max_c, \n  --  integer_max, time_max, and boolean_max, are defined in the\n  --  OSVVM package ResolutionPkg.  These types allow the record to \n  --  support multiple drivers and use resolution functions based on \n  --  function maximum (return largest value). \n  -- ========================================================\n  type StreamRecType is record\n    -- Handshaking controls\n    --   Used by RequestTransaction in the Transaction Procedures\n    --   Used by WaitForTransaction in the Verification Component\n    --   RequestTransaction and WaitForTransaction are in osvvm.TbUtilPkg\n    Rdy             : RdyType ;\n    Ack             : AckType ;\n    -- Transaction Type\n    Operation       : StreamOperationType ;\n    -- Data and Transaction Parameter to and from verification component \n    DataToModel     : std_logic_vector_max_c ; \n    ParamToModel    : std_logic_vector_max_c ; \n    DataFromModel   : std_logic_vector_max_c ; \n    ParamFromModel  : std_logic_vector_max_c ; \n    -- BurstFifo\n    BurstFifo       : ScoreboardIdType ; \n--    UseCheckFifo    : boolean_max ; \n--    CheckFifo       : ScoreboardIdType ; \n    -- Parameters - internal settings for the VC in a singleton data structure   \n    Params          : ModelParametersIDType ;  \n    -- Verification Component Options Parameters - used by SetModelOptions\n    IntToModel      : integer_max ;\n    IntFromModel    : integer_max ; \n    BoolToModel     : boolean_max ; \n    BoolFromModel   : boolean_max ;\n    TimeToModel     : time_max ; \n    TimeFromModel   : time_max ; \n    -- Verification Component Options Type \n    Options         : integer_max ; \n  end record StreamRecType ; \n\n  type StreamRecArrayType  is array (integer range <>) of StreamRecType ;\n\n\n  -- --------------------------------------------------------\n  -- Usage of the Transaction Interface (StreamRecType)\n  -- The Data and Parameter fields of StreamRecType are unconstrained.\n  -- Unconstrained objects may be used on component/entity interfaces.    \n  -- The record fields will be sized by the record signal that is mapped\n  -- as the actual in the test harness of the testbench.  \n  -- Such a declaration is shown below:\n  --\n  --   signal StreamTxRec, StreamRxRec : StreamRecType(\n  --         DataToModel   (AXI_DATA_WIDTH-1  downto 0),\n  --         ParamToModel  (AXI_PARAM_WIDTH-1 downto 0),\n  --         DataFromModel (AXI_DATA_WIDTH-1  downto 0),\n  --         ParamFromModel(AXI_PARAM_WIDTH-1 downto 0)\n  --       ) ; \n  --\n  -- --------------------------------------------------------\n  \n\n--!TODO add VHDL-2019 Interfaces\n\n\n  -- ========================================================\n  --  Types of Transactions\n  --  A transaction may be either a directive or an interface transaction.\n  --\n  --  Directive transactions interact with the verification component \n  --  without generating any transactions or interface waveforms.\n  --\n  --  An interface transaction results in interface signaling to the DUT.\n  --  An interface transaction may be either blocking (such as Send or Get)\n  --  or non-blocking (such as SendAsync or TryGet).\n  --\n  --  A blocking transaction is an interface transaction that does not \n  --  does not return (complete) until the interface operation   \n  --  requested by the transaction has completed.\n  --\n  --  An asynchronous transaction is nonblocking interface transaction\n  --  that returns before the transaction has completed - typically \n  --  immediately and before the transaction has started.   \n  --  An asynchronous transaction has \"Async\" as part of its name.\n  --\n  --  A Try transaction is nonblocking interface transaction that \n  --  checks to see if transaction information is available, \n  --  such as read data, and if it is returns it.  \n  --  A Try transaction has \"Try\" as part of its name.\n  --\n  -- ========================================================\n\n\n  -- ========================================================\n  --  Directive Transactions  \n  --  Directive transactions interact with the verification component \n  --  without generating any transactions or interface waveforms.\n  --  Supported by all verification components\n  -- ========================================================\n  ------------------------------------------------------------\n  procedure WaitForTransaction (\n  --  Wait until pending (transmit) or next (receive) transaction(s) complete\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType \n  ) ; \n\n  ------------------------------------------------------------\n  procedure WaitForClock (\n  -- Wait for NumberOfClocks number of clocks \n  -- relative to the verification component clock\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  WaitCycles       : in    natural := 1\n  ) ; \n  \n alias NoOp is WaitForClock [StreamRecType, natural] ;\n\n  ------------------------------------------------------------\n  procedure GetTransactionCount (\n  -- Get the number of transactions handled by the model.  \n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    variable  TransactionCount : out   integer \n  ) ; \n\n  ------------------------------------------------------------\n  procedure GetAlertLogID (\n  -- Get the AlertLogID from the verification component.\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    variable  AlertLogID       : out   AlertLogIDType \n  ) ; \n  \n  ------------------------------------------------------------\n  procedure GetErrorCount (\n  -- Error reporting for testbenches that do not use OSVVM AlertLogPkg\n  -- Returns error count.  If an error count /= 0, also print errors\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    variable  ErrorCount       : out   natural\n  ) ; \n\n  -- ========================================================\n  --  Delay Coverage Transactions   \n  --  Get Delay Coverage ID to change delay coverage parameters.\n  -- ========================================================\n  ------------------------------------------------------------\n  procedure SetUseRandomDelays (\n  ------------------------------------------------------------\n    signal   TransactionRec : InOut StreamRecType ;\n    constant OptVal         : In    boolean := TRUE\n  ) ;\n  \n  ------------------------------------------------------------\n  procedure GetUseRandomDelays (\n  ------------------------------------------------------------\n    signal   TransactionRec : InOut StreamRecType ;\n    variable OptVal         : Out   boolean\n  ) ;\n\n  alias SetUseDelayCoverage is SetUseRandomDelays[StreamRecType, boolean] ; \n  alias GetUseDelayCoverage is GetUseRandomDelays[StreamRecType, boolean] ; \n\n\n  ------------------------------------------------------------\n  procedure SetDelayCoverageID (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  DelayCov         : in    DelayCoverageIdType \n--    constant  Index            : in    integer := 1 \n  ) ;\n\n  ------------------------------------------------------------\n  procedure GetDelayCoverageID (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    variable  DelayCov         : out   DelayCoverageIdType \n--    constant  Index            : in    integer := 1 \n  ) ;\n\n  -- ========================================================\n  -- BurstFIFOs and Burst Mode Controls\n  -- The burst FIFOs hold bursts of data that is to be sent to \n  -- or was received from the interface.   The burst FIFO can be \n  -- configured in the modes defined for StreamFifoBurstModeType.\n  -- Currently these modes defined as a subtype of integer, shown below.\n  -- The intention of using integers is to facilitate model specific \n  -- extensions without the need to define separate transactions.\n  -- ========================================================\n  subtype StreamFifoBurstModeType is integer ;\n  \n  -- Word mode indicates the burst FIFO contains interface words.\n  -- The size of the word may either be interface specific (such as \n  -- a UART which supports up to 8 bits) or be interface instance specific \n  -- (such as AxiStream which supports interfaces sizes of 1, 2, 4, 8, \n  -- 16, ... bytes)\n  constant STREAM_BURST_WORD_MODE       : StreamFifoBurstModeType  := 0 ;\n  \n  -- Word + Param mode indicates the burst FIFO contains interface \n  -- words plus a parameter.   The size of the parameter is also either\n  -- interface specific (such as the OSVVM UART, which uses 3 bits - \n  -- one bit for each of parity, stop, and break error injection) or\n  -- interface instance specific (such as AxiStream which uses the Param\n  -- field to hold TUser).  AxiStream TUser may be different size for\n  -- different applications.\n  constant STREAM_BURST_WORD_PARAM_MODE : StreamFifoBurstModeType  := 1 ;\n  \n  -- Byte mode indicates that the burst FIFO contains bytes.  \n  -- The verification component assembles interface words from the bytes.\n  -- This allows transfers to be conceptualized in an interface independent \n  --manner.    \n  constant STREAM_BURST_BYTE_MODE       : StreamFifoBurstModeType  := 2 ; \n    \n  ------------------------------------------------------------\n  --  SetBurstMode and GetBurstMode\n  --  are directive transactions that configure the burst mode \n  --  into one of the modes defined for StreamFifoBurstModeType\n  ------------------------------------------------------------\n  ------------------------------------------------------------\n  procedure SetBurstMode (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  OptVal           : in    StreamFifoBurstModeType\n  ) ;\n\n  ------------------------------------------------------------\n  procedure GetBurstMode (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    variable  OptVal           : out   StreamFifoBurstModeType\n  ) ;\n\n  ------------------------------------------------------------\n  --  GotBurst   \n  --  Check to see if Read Burst is available\n  ------------------------------------------------------------\n  ------------------------------------------------------------\n  procedure GotBurst (\n  --  Do not refactor. Required by Co-Sim interface \n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  NumFifoWords     : in    integer ;\n    variable  Available        : out   boolean\n  ) ;\n\n  -- ========================================================\n  --  Set and Get Model Options  \n  --  Model operations are directive transactions that are  \n  --  used to configure the verification component.  \n  --  They can either be used directly or with a model specific\n  --  wrapper around them - see AXI models for examples.\n  -- ========================================================\n  ------------------------------------------------------------\n  procedure SetModelOptions (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  Option           : in    integer ;\n    constant  OptVal           : in    boolean\n  ) ;\n\n  ------------------------------------------------------------\n  procedure SetModelOptions (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  Option           : in    integer ;\n    constant  OptVal           : in    integer\n  ) ;\n\n  ------------------------------------------------------------\n  procedure SetModelOptions (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  Option           : in    integer ;\n    constant  OptVal           : in    std_logic_vector\n  ) ;\n  \n  ------------------------------------------------------------\n  procedure SetModelOptions (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  Option           : in    integer ;\n    constant  OptVal           : in    time\n  ) ;\n  \n  ------------------------------------------------------------\n  procedure SetModelOptions (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  Option           : in    integer \n  ) ;\n  \n  ------------------------------------------------------------\n  procedure GetModelOptions (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  Option           : in    integer ;\n    variable  OptVal           : out   boolean\n  ) ;\n\n  ------------------------------------------------------------\n  procedure GetModelOptions (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  Option           : in    integer ;\n    variable  OptVal           : out   integer\n  ) ;\n\n  ------------------------------------------------------------\n  procedure GetModelOptions (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  Option           : in    integer ;\n    variable  OptVal           : out   std_logic_vector\n  ) ;\n  \n  ------------------------------------------------------------\n  procedure GetModelOptions (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  Option           : in    integer ;\n    variable  OptVal           : out   time\n  ) ;\n  \n  ------------------------------------------------------------\n  procedure GetModelOptions (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  Option           : in    integer \n  ) ;\n\n\n  -- ========================================================\n  --  Transmitter Transactions\n  -- ========================================================\n\n  -- ========================================================\n  -- Send\n  -- Blocking Send Transaction. \n  -- Param, when present, is an extra parameter used by the verification component\n  -- The UART verification component uses Param for error injection.\n  -- ========================================================\n  \n  ------------------------------------------------------------\n  procedure Send (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  Data             : in    std_logic_vector ;\n    constant  Param            : in    std_logic_vector ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) ; \n\n  ------------------------------------------------------------\n  procedure Send (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  Data             : in    std_logic_vector ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) ; \n  \n\n  -- ========================================================\n  -- SendAsync\n  -- Asynchronous / Non-Blocking Send Transaction\n  -- Param, when present, is an extra parameter used by the verification component\n  -- The UART verification component uses Param for error injection. \n  -- ========================================================\n\n  ------------------------------------------------------------\n  procedure SendAsync (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  Data             : in    std_logic_vector ;\n    constant  Param            : in    std_logic_vector ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) ; \n\n  ------------------------------------------------------------\n  procedure SendAsync (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  Data             : in    std_logic_vector ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) ; \n\n\n  -- ========================================================\n  -- SendBurst\n  -- Blocking Send Burst Transaction. \n  -- Param, when present, is an extra parameter used by the verification component\n  -- The UART verification component uses Param for error injection.\n  -- ========================================================\n\n  ------------------------------------------------------------\n  procedure SendBurst (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  NumFifoWords     : in    integer ;\n    constant  Param            : in    std_logic_vector ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) ; \n\n  ------------------------------------------------------------\n  procedure SendBurst (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  NumFifoWords     : in    integer ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) ; \n  \n  ------------------------------------------------------------\n  procedure SendBurstVector (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  VectorOfWords    : in    slv_vector ;\n    constant  Param            : in    std_logic_vector ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) ;\n  \n  ------------------------------------------------------------\n  procedure SendBurstVector (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  VectorOfWords    : in    slv_vector ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) ;\n  \n--  alias SendBurst is SendBurstVector[StreamRecType, slv_vector, std_logic_vector, boolean] ; \n--  alias SendBurst is SendBurstVector[StreamRecType, slv_vector, boolean] ; \n\n  ------------------------------------------------------------\n  procedure SendBurstVector (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  VectorOfWords    : in    integer_vector ;\n    constant  Param            : in    std_logic_vector ;\n    constant  FifoWidth        : in    integer ; \n    constant  StatusMsgOn      : in    boolean := false\n  ) ;\n  \n  ------------------------------------------------------------\n  procedure SendBurstVector (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  VectorOfWords    : in    integer_vector ;\n    constant  FifoWidth        : in    integer ; \n    constant  StatusMsgOn      : in    boolean := false\n  ) ;\n  \n  ------------------------------------------------------------\n  procedure SendBurstIncrement (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  FirstWord        : in    std_logic_vector ;\n    constant  NumFifoWords     : in    integer ;\n    constant  Param            : in    std_logic_vector ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) ;\n\n  ------------------------------------------------------------\n  procedure SendBurstIncrement (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  FirstWord        : in    std_logic_vector ;\n    constant  NumFifoWords     : in    integer ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) ;\n\n  ------------------------------------------------------------\n  procedure SendBurstRandom (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  FirstWord        : in    std_logic_vector ;\n    constant  NumFifoWords     : in    integer ;\n    constant  Param            : in    std_logic_vector ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) ;\n\n  ------------------------------------------------------------\n  procedure SendBurstRandom (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  FirstWord        : in    std_logic_vector ;\n    constant  NumFifoWords     : in    integer ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) ;\n\n  ------------------------------------------------------------\n  procedure SendBurstRandom (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  CoverID          : in    CoverageIDType ;\n    constant  NumFifoWords     : in    integer ;\n    constant  FifoWidth        : in    integer ;\n    constant  Param            : in    std_logic_vector ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) ;\n\n  ------------------------------------------------------------\n  procedure SendBurstRandom (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  CoverID          : in    CoverageIDType ;\n    constant  NumFifoWords     : in    integer ;\n    constant  FifoWidth        : in    integer ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) ;\n\n  -- ========================================================\n  -- SendBurstAsync\n  -- Asynchronous / Non-Blocking Send Transaction\n  -- Param, when present, is an extra parameter used by the verification component\n  -- The UART verification component uses Param for error injection. \n  -- ========================================================\n\n  ------------------------------------------------------------\n  procedure SendBurstAsync (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  NumFifoWords     : in    integer ;\n    constant  Param            : in    std_logic_vector ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) ; \n\n  ------------------------------------------------------------\n  procedure SendBurstAsync (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  NumFifoWords     : in    integer ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) ; \n  \n  ------------------------------------------------------------\n  procedure SendBurstVectorAsync (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  VectorOfWords    : in    slv_vector ;\n    constant  Param            : in    std_logic_vector ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) ;\n  \n  ------------------------------------------------------------\n  procedure SendBurstVectorAsync (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  VectorOfWords    : in    slv_vector ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) ;\n  \n--  alias SendBurstAsync is SendBurstVectorAsync[StreamRecType, slv_vector, std_logic_vector, boolean] ; \n--  alias SendBurstAsync is SendBurstVectorAsync[StreamRecType, slv_vector, boolean] ; \n\n  ------------------------------------------------------------\n  procedure SendBurstVectorAsync (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  VectorOfWords    : in    integer_vector ;\n    constant  Param            : in    std_logic_vector ;\n    constant  FifoWidth        : in    integer ; \n    constant  StatusMsgOn      : in    boolean := false\n  ) ;\n  \n  ------------------------------------------------------------\n  procedure SendBurstVectorAsync (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  VectorOfWords    : in    integer_vector ;\n    constant  FifoWidth        : in    integer ; \n    constant  StatusMsgOn      : in    boolean := false\n  ) ;\n  \n  ------------------------------------------------------------\n  procedure SendBurstIncrementAsync (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  FirstWord        : in    std_logic_vector ;\n    constant  NumFifoWords     : in    integer ;\n    constant  Param            : in    std_logic_vector ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) ;\n\n  ------------------------------------------------------------\n  procedure SendBurstIncrementAsync (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  FirstWord        : in    std_logic_vector ;\n    constant  NumFifoWords     : in    integer ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) ;\n\n  ------------------------------------------------------------\n  procedure SendBurstRandomAsync (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  FirstWord        : in    std_logic_vector ;\n    constant  NumFifoWords     : in    integer ;\n    constant  Param            : in    std_logic_vector ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) ;\n\n  ------------------------------------------------------------\n  procedure SendBurstRandomAsync (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  FirstWord        : in    std_logic_vector ;\n    constant  NumFifoWords     : in    integer ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) ;\n  \n  ------------------------------------------------------------\n  procedure SendBurstRandomAsync (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  CoverID          : in    CoverageIDType ;\n    constant  NumFifoWords     : in    integer ;\n    constant  FifoWidth        : in    integer ;\n    constant  Param            : in    std_logic_vector ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) ;\n\n  ------------------------------------------------------------\n  procedure SendBurstRandomAsync (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  CoverID          : in    CoverageIDType ;\n    constant  NumFifoWords     : in    integer ;\n    constant  FifoWidth        : in    integer ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) ;\n\n  -- ========================================================\n  --  Receiver Transactions\n  -- ========================================================\n\n  -- ========================================================\n  -- Get\n  -- Blocking Get Transaction. \n  -- Param, when present, is an extra parameter used by the verification component\n  -- The UART verification component uses Param for received error status.\n  -- ========================================================\n\n  ------------------------------------------------------------\n  procedure Get (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    variable  Data             : out   std_logic_vector ;\n    variable  Param            : out   std_logic_vector ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) ; \n\n  ------------------------------------------------------------\n  procedure Get (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    variable  Data             : out   std_logic_vector ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) ; \n\n\n  -- ========================================================\n  -- TryGet\n  -- Try Get Transaction\n  -- If Data is available, get it and return available TRUE,\n  -- otherwise Return Available FALSE.\n  -- Param, when present, is an extra parameter used by the verification component\n  -- The UART verification component uses Param for received error status.\n  -- ========================================================\n\n  ------------------------------------------------------------\n  procedure TryGet (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    variable  Data             : out   std_logic_vector ;\n    variable  Available        : out   boolean ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) ; \n  \n  ------------------------------------------------------------\n  procedure TryGet (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    variable  Data             : out   std_logic_vector ;\n    variable  Param            : out   std_logic_vector ;\n    variable  Available        : out   boolean ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) ;  \n\n\n  -- ========================================================\n  -- GetBurst\n  -- Blocking Get Burst Transaction. \n  -- Param, when present, is an extra parameter from the verification component\n  -- The UART verification component uses Param for received error status.\n  -- ========================================================\n\n  ------------------------------------------------------------\n  procedure GetBurst (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    variable  NumFifoWords     : inout integer ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) ; \n  \n  ------------------------------------------------------------\n  procedure GetBurst (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    variable  NumFifoWords     : inout integer ;\n    variable  Param            : out   std_logic_vector ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) ;  \n\n  -- ========================================================\n  -- TryGetBurst\n  -- Try Get Burst Transaction\n  -- If Data is available, get it and return available TRUE,\n  -- otherwise Return Available FALSE.\n  -- Param, when present, is an extra parameter used by the verification component\n  -- The UART verification component uses Param for received error status.\n  -- ========================================================\n\n  ------------------------------------------------------------\n  procedure TryGetBurst (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    variable  NumFifoWords     : inout integer ;\n    variable  Available        : out   boolean ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) ; \n  \n  ------------------------------------------------------------\n  procedure TryGetBurst (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    variable  NumFifoWords     : inout integer ;\n    variable  Param            : out   std_logic_vector ;\n    variable  Available        : out   boolean ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) ;  \n\n\n  -- ========================================================\n  -- Check\n  -- Blocking Check Transaction. \n  -- Data is the expected value to be received.\n  -- Param, when present, is an extra parameter used by the verification component\n  -- The UART verification component uses Param for received error status.\n  -- ========================================================\n\n  ------------------------------------------------------------\n  procedure Check (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  Data             : in    std_logic_vector ;\n    constant  Param            : in    std_logic_vector ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) ; \n\n  ------------------------------------------------------------\n  procedure Check (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  Data             : in    std_logic_vector ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) ; \n\n\n  -- ========================================================\n  -- TryCheck\n  -- Try Check Transaction\n  -- If Data is available, check it and return available TRUE,\n  -- otherwise Return Available FALSE.\n  -- Param, when present, is an extra parameter used by the verification component\n  -- The UART verification component uses Param for received error status.\n  -- ========================================================\n\n  ------------------------------------------------------------\n  procedure TryCheck (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  Data             : in    std_logic_vector ;\n    constant  Param            : in    std_logic_vector ;\n    variable  Available        : out   boolean ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) ; \n\n  ------------------------------------------------------------\n  procedure TryCheck (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  Data             : in    std_logic_vector ;\n    variable  Available        : out   boolean ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) ; \n\n  -- ========================================================\n  -- CheckBurst\n  -- Blocking Check Burst Transaction. \n  -- Param, when present, is an extra parameter used by the verification component\n  -- The UART verification component uses Param for checking error injection.\n  -- ========================================================\n  ------------------------------------------------------------\n  procedure CheckBurst (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  NumFifoWords     : in    integer ;\n    constant  Param            : in    std_logic_vector ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) ; \n\n  ------------------------------------------------------------\n  procedure CheckBurst (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  NumFifoWords     : in    integer ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) ; \n\n  ------------------------------------------------------------\n  procedure CheckBurstVector (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  VectorOfWords    : in    slv_vector ;\n    constant  Param            : in    std_logic_vector ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) ;\n  \n  ------------------------------------------------------------\n  procedure CheckBurstVector (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  VectorOfWords    : in    slv_vector ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) ;\n  \n--  alias CheckBurst is CheckBurstVector[StreamRecType, slv_vector, std_logic_vector, boolean] ; \n--  alias CheckBurst is CheckBurstVector[StreamRecType, slv_vector, boolean] ; \n\n  ------------------------------------------------------------\n  procedure CheckBurstVector (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  VectorOfWords    : in    integer_vector ;\n    constant  Param            : in    std_logic_vector ;\n    constant  FifoWidth        : in    integer ; \n    constant  StatusMsgOn      : in    boolean := false\n  ) ;\n  \n  ------------------------------------------------------------\n  procedure CheckBurstVector (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  VectorOfWords    : in    integer_vector ;\n    constant  FifoWidth        : in    integer ; \n    constant  StatusMsgOn      : in    boolean := false\n  ) ;\n  \n  ------------------------------------------------------------\n  procedure CheckBurstIncrement (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  FirstWord        : in    std_logic_vector ;\n    constant  NumFifoWords     : in    integer ;\n    constant  Param            : in    std_logic_vector ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) ;\n\n  ------------------------------------------------------------\n  procedure CheckBurstIncrement (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  FirstWord        : in    std_logic_vector ;\n    constant  NumFifoWords     : in    integer ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) ;\n\n  ------------------------------------------------------------\n  procedure CheckBurstRandom (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  FirstWord        : in    std_logic_vector ;\n    constant  NumFifoWords     : in    integer ;\n    constant  Param            : in    std_logic_vector ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) ;\n\n  ------------------------------------------------------------\n  procedure CheckBurstRandom (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  FirstWord        : in    std_logic_vector ;\n    constant  NumFifoWords     : in    integer ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) ;\n\n  ------------------------------------------------------------\n  procedure CheckBurstRandom (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  CoverID          : in    CoverageIDType ;\n    constant  NumFifoWords     : in    integer ;\n    constant  FifoWidth        : in    integer ;\n    constant  Param            : in    std_logic_vector ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) ;  \n\n  ------------------------------------------------------------\n  procedure CheckBurstRandom (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  CoverID          : in    CoverageIDType ;\n    constant  NumFifoWords     : in    integer ;\n    constant  FifoWidth        : in    integer ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) ;  \n\n  -- ========================================================\n  -- TryCheckBurst\n  -- Try / Non-Blocking Check Burst Transaction\n  -- Param, when present, is an extra parameter used by the verification component\n  -- The UART verification component uses Param for error injection. \n  -- ========================================================\n\n  ------------------------------------------------------------\n  procedure TryCheckBurst (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  NumFifoWords     : in    integer ;\n    constant  Param            : in    std_logic_vector ;\n    variable  Available        : out   boolean ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) ; \n  \n  ------------------------------------------------------------\n  procedure TryCheckBurst (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  NumFifoWords     : in    integer ;\n    variable  Available        : out   boolean ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) ; \n  \n  ------------------------------------------------------------\n  procedure TryCheckBurstVector (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  VectorOfWords    : in    slv_vector ;\n    constant  Param            : in    std_logic_vector ;\n    variable  Available        : out   boolean ;\n    constant  StatusMsgOn      : in    boolean := false\n  )  ;\n  \n  ------------------------------------------------------------\n  procedure TryCheckBurstVector (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  VectorOfWords    : in    slv_vector ;\n    variable  Available        : out   boolean ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) ;\n\n--  alias TryCheckBurst is TryCheckBurstVector[StreamRecType, slv_vector, std_logic_vector, boolean, boolean] ; \n--  alias TryCheckBurst is TryCheckBurstVector[StreamRecType, slv_vector, boolean, boolean] ; \n  \n  ------------------------------------------------------------\n  procedure TryCheckBurstVector (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  VectorOfWords    : in    integer_vector ;\n    constant  Param            : in    std_logic_vector ;\n    variable  Available        : out   boolean ;\n    constant  FifoWidth        : in    integer ; \n    constant  StatusMsgOn      : in    boolean := false\n  ) ;\n    \n  ------------------------------------------------------------\n  procedure TryCheckBurstVector (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  VectorOfWords    : in    integer_vector ;\n    variable  Available        : out   boolean ;\n    constant  FifoWidth        : in    integer ; \n    constant  StatusMsgOn      : in    boolean := false\n  ) ;\n  \n  ------------------------------------------------------------\n  procedure TryCheckBurstIncrement (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  FirstWord        : in    std_logic_vector ;\n    constant  NumFifoWords     : in    integer ;\n    constant  Param            : in    std_logic_vector ;\n    variable  Available        : out   boolean ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) ;\n\n  ------------------------------------------------------------\n  procedure TryCheckBurstIncrement (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  FirstWord        : in    std_logic_vector ;\n    constant  NumFifoWords     : in    integer ;\n    variable  Available        : out   boolean ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) ;\n\n  ------------------------------------------------------------\n  procedure TryCheckBurstRandom (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  FirstWord        : in    std_logic_vector ;\n    constant  NumFifoWords     : in    integer ;\n    constant  Param            : in    std_logic_vector ;\n    variable  Available        : out   boolean ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) ;\n\n  ------------------------------------------------------------\n  procedure TryCheckBurstRandom (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  FirstWord        : in    std_logic_vector ;\n    constant  NumFifoWords     : in    integer ;\n    variable  Available        : out   boolean ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) ;\n\n  ------------------------------------------------------------\n  procedure TryCheckBurstRandom (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  CoverID          : in    CoverageIDType ;\n    constant  NumFifoWords     : in    integer ;\n    constant  FifoWidth        : in    integer ;\n    constant  Param            : in    std_logic_vector ;\n    variable  Available        : out   boolean ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) ;  \n\n  ------------------------------------------------------------\n  procedure TryCheckBurstRandom (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  CoverID          : in    CoverageIDType ;\n    constant  NumFifoWords     : in    integer ;\n    constant  FifoWidth        : in    integer ;\n    variable  Available        : out   boolean ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) ;  \n\n  -- ========================================================\n  --  Send And Get Transactions\n  -- \n  -- ========================================================\n  ------------------------------------------------------------\n  procedure SendAndGet (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  iData            : in    std_logic_vector ;\n    constant  iParam           : in    std_logic_vector ;\n    variable  oData            : out   std_logic_vector ;\n    variable  oParam           : out   std_logic_vector ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) ;  \n\n  ------------------------------------------------------------\n  procedure SendAndGet (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  iData            : in    std_logic_vector ;\n    variable  oData            : out   std_logic_vector ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) ;  \n\n  ------------------------------------------------------------\n  procedure SendAndGetBurst (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  iNumFifoWords    : in    integer ;\n    constant  iParam           : in    std_logic_vector ;\n    variable  oNumFifoWords    : out   integer ;\n    variable  oParam           : out   std_logic_vector ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) ; \n\n  ------------------------------------------------------------\n  procedure SendAndGetBurst (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  iNumFifoWords    : in    integer ;\n    variable  oNumFifoWords    : out   integer ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) ; \n\n  -- ========================================================\n  --  Pseudo Transactions\n  --  Interact with the record only.\n  -- ========================================================\n  ------------------------------------------------------------\n  procedure ReleaseTransactionRecord (\n  --  Must run on same delta cycle as AcquireTransactionRecord\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType \n  ) ; \n  \n  ------------------------------------------------------------\n  procedure AcquireTransactionRecord (\n  --  Must run on same delta cycle as ReleaseTransactionRecord\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType \n  ) ; \n\n  -- ========================================================\n  --  Verification Component Support Functions\n  --  These help decode the operation value (StreamOperationType)  \n  --  to determine properties about the operation\n  -- ========================================================\n  ------------------------------------------------------------\n  function IsBlocking (\n  -----------------------------------------------------------\n    constant  Operation        : in StreamOperationType\n  ) return boolean ;\n  \n  ------------------------------------------------------------\n  function IsTry (\n  -- True when this transaction is an asynchronous or try transaction.\n  -----------------------------------------------------------\n    constant  Operation        : in StreamOperationType\n  ) return boolean ;\n\n  ------------------------------------------------------------\n  function IsCheck (\n  -- True when this transaction is a check transaction.\n  -----------------------------------------------------------\n    constant  Operation        : in StreamOperationType\n  ) return boolean ;\n\n  ------------------------------------------------------------\n  function IsTransmitterOperation (\n  -----------------------------------------------------------\n    constant  Operation        : in StreamOperationType\n  ) return boolean  ;\n\n  ------------------------------------------------------------\n  function IsReceiverOperation (\n  -----------------------------------------------------------\n    constant  Operation        : in StreamOperationType\n  ) return boolean ;\n\n  ------------------------------------------------------------\n  function ClassifyUnimplementedOperation (\n  -----------------------------------------------------------\n    constant  Operation        : in StreamOperationType;\n    constant  TransactionCount : in natural\n  ) return string ;\n\n  ------------------------------------------------------------\n  function ClassifyUnimplementedTransmitterOperation (\n  -----------------------------------------------------------\n    constant  Operation        : in StreamOperationType;\n    constant  TransactionCount : in natural\n  ) return string ;\n  \n  ------------------------------------------------------------\n  function ClassifyUnimplementedReceiverOperation (\n  -----------------------------------------------------------\n    constant  Operation        : in StreamOperationType ;\n    constant  TransactionCount : in natural\n  ) return string ;\n\nend StreamTransactionPkg ;\n\npackage body StreamTransactionPkg is \n\n  ------------------------------------------------------------\n  function resolved_max ( s : StreamUnresolvedOperationVectorType) return StreamUnresolvedOperationType is\n  ------------------------------------------------------------\n    variable Result : StreamUnresolvedOperationType := NOT_DRIVEN ;\n  begin\n    for i in s'range loop \n      if s(i) /= NOT_DRIVEN then \n        if result = NOT_DRIVEN then \n          result := s(i) ;\n        else\n          result := MULTIPLE_DRIVER_DETECT ;\n        end if ; \n      end if ; \n    end loop ;\n    return result ; \n--    return maximum(s) ;\n  end function resolved_max ; \n  \n--    ------------------------------------------------------------\n--    function FillParam (TransactionRec : StreamRecType; Param : std_logic_vector) return std_logic_vector is\n--    ------------------------------------------------------------\n--      variable LocalParam : std_logic_vector(TransactionRec.ParamToModel'range) := (others => '-') ;\n--    begin\n--      LocalParam(Param'length-1 downto 0) := Param ; \n--      return Param ;\n--    end function FillParam ; \n\n  -- ========================================================\n  --  Directive Transactions  \n  --  Directive transactions interact with the verification component \n  --  without generating any transactions or interface waveforms.\n  --  Supported by all verification components\n  -- ========================================================\n  ------------------------------------------------------------\n  procedure WaitForTransaction (\n  --  Wait until pending (transmit) or next (receive) transaction(s) complete\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType \n  ) is\n  begin\n    TransactionRec.Operation   <= WAIT_FOR_TRANSACTION ;\n    RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ; \n  end procedure WaitForTransaction ; \n\n  ------------------------------------------------------------\n  procedure WaitForClock (\n  -- Wait for NumberOfClocks number of clocks \n  -- relative to the verification component clock\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  WaitCycles       : in    natural := 1\n  ) is\n  begin\n    TransactionRec.Operation   <= WAIT_FOR_CLOCK ;\n    TransactionRec.IntToModel  <= WaitCycles ; \n    RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ; \n  end procedure WaitForClock ; \n\n  ------------------------------------------------------------\n  procedure GetTransactionCount (\n  -- Get the number of transactions handled by the model.  \n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    variable  TransactionCount  : out   integer \n  ) is\n  begin\n    TransactionRec.Operation   <= GET_TRANSACTION_COUNT ;\n    RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ; \n    TransactionCount := TransactionRec.IntFromModel ; \n  end procedure GetTransactionCount ; \n\n  ------------------------------------------------------------\n  procedure GetAlertLogID (\n  -- Get the AlertLogID from the verification component.\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    variable  AlertLogID       : out   AlertLogIDType \n  ) is\n  begin\n    TransactionRec.Operation   <= GET_ALERTLOG_ID ;\n    RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ; \n    AlertLogID := AlertLogIDType(TransactionRec.IntFromModel) ; \n  end procedure GetAlertLogID ; \n  \n  ------------------------------------------------------------\n  procedure GetErrorCount (\n  -- Error reporting for testbenches that do not use OSVVM AlertLogPkg\n  -- Returns error count.  If an error count /= 0, also print errors\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    variable  ErrorCount       : out   natural\n  ) is\n    variable  AlertLogID : AlertLogIDType ;\n  begin\n    GetAlertLogID(TransactionRec, AlertLogID) ;\n--    ReportNonZeroAlerts(AlertLogID => AlertLogID) ;\n    ErrorCount := GetAlertCount(AlertLogID => AlertLogID) ;\n  end procedure GetErrorCount ; \n\n  -- ========================================================\n  --  Delay Coverage Transactions   \n  --  Get Delay Coverage ID to change delay coverage parameters.\n  -- ========================================================\n  ------------------------------------------------------------\n  procedure SetUseRandomDelays (\n  ------------------------------------------------------------\n    signal   TransactionRec : InOut StreamRecType ;\n    constant OptVal         : In    boolean := TRUE\n  ) is\n  begin\n    TransactionRec.Operation     <= SET_USE_RANDOM_DELAYS ;\n    TransactionRec.BoolToModel   <= OptVal ;\n    RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;\n  end procedure SetUseRandomDelays ;\n\n  ------------------------------------------------------------\n  procedure GetUseRandomDelays (\n  ------------------------------------------------------------\n    signal   TransactionRec : InOut StreamRecType ;\n    variable OptVal         : Out   boolean\n  ) is\n  begin\n    TransactionRec.Operation     <= GET_USE_RANDOM_DELAYS ;\n    RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;\n    OptVal := TransactionRec.BoolFromModel    ;\n  end procedure GetUseRandomDelays ;\n\n  ------------------------------------------------------------\n  procedure SetDelayCoverageID (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  DelayCov         : in    DelayCoverageIdType \n--    constant  Index            : in    integer := 0 \n  ) is\n  begin\n    TransactionRec.Operation     <= SET_DELAYCOV_ID ;\n    TransactionRec.IntToModel    <= DelayCov.ID ;\n--    TransactionRec.Options       <= Index ; \n    RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;\n  end procedure SetDelayCoverageID ;\n\n  ------------------------------------------------------------\n  procedure GetDelayCoverageID (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    variable  DelayCov         : out   DelayCoverageIdType \n--    constant  Index            : in    integer := 0 \n  ) is\n  begin\n    TransactionRec.Operation     <= GET_DELAYCOV_ID ;\n--    TransactionRec.Options       <= Index ; \n    RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;\n    DelayCov := GetDelayCoverage(TransactionRec.IntFromModel) ; \n  end procedure GetDelayCoverageID ;\n\n  -- ========================================================\n  --  Set and Get Burst Mode   \n  --  Set Burst Mode for models that do bursting.\n  -- ========================================================\n  ------------------------------------------------------------\n  procedure SetBurstMode (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  OptVal           : in    StreamFifoBurstModeType\n  ) is\n  begin\n    TransactionRec.Operation     <= SET_BURST_MODE ;\n    TransactionRec.IntToModel    <= OptVal ;\n    RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;\n  end procedure SetBurstMode ;\n\n  ------------------------------------------------------------\n  procedure GetBurstMode (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    variable  OptVal           : out   StreamFifoBurstModeType\n  ) is\n  begin\n    TransactionRec.Operation     <= GET_BURST_MODE ;\n    RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;\n    OptVal := TransactionRec.IntFromModel ; \n  end procedure GetBurstMode ;\n\n  ------------------------------------------------------------\n  --  GotBurst   \n  --  Check to see if a Burst is available\n  ------------------------------------------------------------\n  ------------------------------------------------------------\n  procedure GotBurst (\n  --  Do not refactor. Required by Co-Sim interface \n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  NumFifoWords     : in    integer ;\n    variable  Available        : out   boolean\n  ) is\n  begin\n    TransactionRec.Operation   <= GOT_BURST ;\n    -- NumFifoWords not used in all implementations - needed when interface has no burst capability\n    TransactionRec.IntToModel  <= NumFifoWords ; \n    RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;\n    Available := TransactionRec.BoolFromModel ; \n  end procedure GotBurst ;\n\n  -- ========================================================\n  --  Set and Get Model Options  \n  --  Model operations are directive transactions that are  \n  --  used to configure the verification component.  \n  --  They can either be used directly or with a model specific\n  --  wrapper around them - see AXI models for examples.\n  -- ========================================================\n  ------------------------------------------------------------\n  procedure SetModelOptions (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  Option           : in    integer ;\n    constant  OptVal           : in    boolean\n  ) is\n  begin\n    TransactionRec.Operation     <= SET_MODEL_OPTIONS ;\n    TransactionRec.Options       <= Option ;\n    TransactionRec.BoolToModel   <= OptVal ;\n    RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;\n  end procedure SetModelOptions ;\n\n  ------------------------------------------------------------\n  procedure SetModelOptions (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  Option           : in    integer ;\n    constant  OptVal           : in    integer\n  ) is\n  begin\n    TransactionRec.Operation     <= SET_MODEL_OPTIONS ;\n    TransactionRec.Options       <= Option ;\n    TransactionRec.IntToModel    <= OptVal ;\n    RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;\n  end procedure SetModelOptions ;\n\n  ------------------------------------------------------------\n  procedure SetModelOptions (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  Option           : in    integer ;\n    constant  OptVal           : in    std_logic_vector\n  ) is\n  begin\n    TransactionRec.Operation     <= SET_MODEL_OPTIONS ;\n    TransactionRec.Options       <= Option ;\n    TransactionRec.IntToModel    <= to_integer(OptVal) ;\n    RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;\n  end procedure SetModelOptions ;\n  \n  ------------------------------------------------------------\n  procedure SetModelOptions (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  Option           : in    integer ;\n    constant  OptVal           : in    time\n  ) is\n  begin\n    TransactionRec.Operation     <= SET_MODEL_OPTIONS ;\n    TransactionRec.Options       <= Option ;\n    TransactionRec.TimeToModel   <= OptVal ;\n    RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;\n  end procedure SetModelOptions ;\n\n  ------------------------------------------------------------\n  procedure SetModelOptions (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  Option           : in    integer \n  ) is\n  begin\n    TransactionRec.Operation     <= SET_MODEL_OPTIONS ;\n    TransactionRec.Options       <= Option ;\n    -- OptVal handled by Model Specific Package\n    -- TransactionRec.IntToModel    <= to_integer(OptVal) ;\n    RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;\n  end procedure SetModelOptions ;\n\n  ------------------------------------------------------------\n  procedure GetModelOptions (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  Option           : in    integer ;\n    variable  OptVal           : out   boolean\n  ) is\n  begin\n    TransactionRec.Operation     <= GET_MODEL_OPTIONS ;\n    TransactionRec.Options       <= Option ;\n    RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;\n    OptVal := TransactionRec.BoolFromModel    ;\n  end procedure GetModelOptions ;\n\n  ------------------------------------------------------------\n  procedure GetModelOptions (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  Option           : in    integer ;\n    variable  OptVal           : out   integer\n  ) is\n  begin\n    TransactionRec.Operation     <= GET_MODEL_OPTIONS ;\n    TransactionRec.Options       <= Option ;\n    RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;\n    OptVal := TransactionRec.IntFromModel ; \n  end procedure GetModelOptions ;\n\n  ------------------------------------------------------------\n  procedure GetModelOptions (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  Option           : in    integer ;\n    variable  OptVal           : out   std_logic_vector\n  ) is\n  begin\n    TransactionRec.Operation     <= GET_MODEL_OPTIONS ;\n    TransactionRec.Options       <= Option ;\n    RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;\n    OptVal := to_slv(TransactionRec.IntFromModel, OptVal'length) ; \n  end procedure GetModelOptions ;\n  \n  ------------------------------------------------------------\n  procedure GetModelOptions (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  Option           : in    integer ;\n    variable  OptVal           : out   time\n  ) is\n  begin\n    TransactionRec.Operation     <= GET_MODEL_OPTIONS ;\n    TransactionRec.Options       <= Option ;\n    RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;\n    OptVal := TransactionRec.TimeFromModel ; \n  end procedure GetModelOptions ;\n\n  ------------------------------------------------------------\n  procedure GetModelOptions (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  Option           : in    integer \n  ) is\n  begin\n    TransactionRec.Operation     <= GET_MODEL_OPTIONS ;\n    TransactionRec.Options       <= Option ;\n    RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ;\n    -- OptVal handled by Model Specific layer overloading\n    -- OptVal := TransactionRec.TimeFromModel ; \n  end procedure GetModelOptions ;\n\n\n  -- ========================================================\n  --  Transmitter Transactions\n  -- ========================================================\n  \n  -- ========================================================\n  -- Send\n  -- Blocking Send Transaction. \n  -- Param, when present, is an extra parameter used by the verification component\n  -- The UART verification component uses Param for error injection.\n  -- ========================================================\n  ------------------------------------------------------------\n  procedure LocalSend (\n  -- Package Local - simplifies the other calls to Send\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  Operation        : in    StreamOperationType ;\n    constant  Data             : in    std_logic_vector ;\n    constant  Param            : in    std_logic_vector ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) is \n    variable LocalParam : std_logic_vector(TransactionRec.ParamToModel'length -1 downto 0) := (others => '-') ;\n  begin\n    LocalParam(Param'length-1 downto 0) := Param ; \n    TransactionRec.Operation     <= Operation ;\n    TransactionRec.DataToModel   <= SafeResize(Data, TransactionRec.DataToModel'length) ; \n    TransactionRec.ParamToModel  <= SafeResize(LocalParam, TransactionRec.ParamToModel'length) ; \n    TransactionRec.IntToModel    <= Data'length ;\n    TransactionRec.BoolToModel   <= StatusMsgOn ; \n    RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ; \n  end procedure LocalSend ; \n\n  ------------------------------------------------------------\n  procedure Send (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  Data             : in    std_logic_vector ;\n    constant  Param            : in    std_logic_vector ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) is \n  begin\n    LocalSend(TransactionRec, SEND, Data, Param, StatusMsgOn) ;\n  end procedure Send ; \n\n  ------------------------------------------------------------\n  procedure Send (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  Data             : in    std_logic_vector ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) is \n  begin\n    LocalSend(TransactionRec, SEND, Data, \"\", StatusMsgOn);\n  end procedure Send ; \n\n  -- ========================================================\n  -- SendAsync\n  -- Asynchronous / Non-Blocking Send Transaction\n  -- Param, when present, is an extra parameter used by the verification component\n  -- The UART verification component uses Param for error injection. \n  -- ========================================================\n\n  ------------------------------------------------------------\n  procedure SendAsync (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  Data             : in    std_logic_vector ;\n    constant  Param            : in    std_logic_vector ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) is \n  begin\n    LocalSend(TransactionRec, SEND_ASYNC, Data, Param, StatusMsgOn) ;\n  end procedure SendAsync ; \n\n  ------------------------------------------------------------\n  procedure SendAsync (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  Data             : in    std_logic_vector ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) is \n  begin\n    LocalSend(TransactionRec, SEND_ASYNC, Data, \"\", StatusMsgOn);\n  end procedure SendAsync ; \n\n\n  -- ========================================================\n  -- SendBurst\n  -- Blocking Send Burst Transaction. \n  -- Param, when present, is an extra parameter used by the verification component\n  -- The UART verification component uses Param for error injection.\n  -- ========================================================\n  ------------------------------------------------------------\n  procedure LocalSendBurst (\n  -- Package Local - simplifies the other calls to Send\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  Operation        : in    StreamOperationType ;\n    constant  NumFifoWords     : in    integer ;\n    constant  Param            : in    std_logic_vector ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) is \n    variable LocalParam : std_logic_vector(TransactionRec.ParamToModel'length -1 downto 0) := (others => '-') ;\n  begin\n    LocalParam(Param'length-1 downto 0) := Param ; \n    TransactionRec.Operation     <= Operation ;\n    TransactionRec.IntToModel    <= NumFifoWords ; \n    TransactionRec.ParamToModel  <= SafeResize(LocalParam, TransactionRec.ParamToModel'length) ; \n    TransactionRec.BoolToModel   <= StatusMsgOn ; \n    RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ; \n  end procedure LocalSendBurst ; \n\n  ------------------------------------------------------------\n  procedure SendBurst (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  NumFifoWords     : in    integer ;\n    constant  Param            : in    std_logic_vector ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) is \n  begin\n    LocalSendBurst(TransactionRec, SEND_BURST, NumFifoWords, Param, StatusMsgOn) ;\n  end procedure SendBurst ; \n\n  ------------------------------------------------------------\n  procedure SendBurst (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  NumFifoWords     : in    integer ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) is \n  begin\n    LocalSendBurst(TransactionRec, SEND_BURST, NumFifoWords, \"\", StatusMsgOn) ;\n  end procedure SendBurst ; \n\n  ------------------------------------------------------------\n  procedure SendBurstVector (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  VectorOfWords    : in    slv_vector ;\n    constant  Param            : in    std_logic_vector ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) is\n  begin\n    PushBurstVector(TransactionRec.BurstFifo, VectorOfWords) ;\n    LocalSendBurst(TransactionRec, SEND_BURST, VectorOfWords'length, Param, StatusMsgOn) ; \n  end procedure SendBurstVector ;\n  \n  ------------------------------------------------------------\n  procedure SendBurstVector (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  VectorOfWords    : in    slv_vector ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) is\n  begin\n    SendBurstVector(TransactionRec, VectorOfWords, \"\", StatusMsgOn) ; \n  end procedure SendBurstVector ;\n  \n  ------------------------------------------------------------\n  procedure SendBurstVector (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  VectorOfWords    : in    integer_vector ;\n    constant  Param            : in    std_logic_vector ;\n    constant  FifoWidth        : in    integer ; \n    constant  StatusMsgOn      : in    boolean := false\n  ) is\n  begin\n    PushBurstVector(TransactionRec.BurstFifo, VectorOfWords, FifoWidth) ;\n    LocalSendBurst(TransactionRec, SEND_BURST, VectorOfWords'length, Param, StatusMsgOn) ; \n  end procedure SendBurstVector ;\n  \n  ------------------------------------------------------------\n  procedure SendBurstVector (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  VectorOfWords    : in    integer_vector ;\n    constant  FifoWidth        : in    integer ; \n    constant  StatusMsgOn      : in    boolean := false\n  ) is\n  begin\n    SendBurstVector(TransactionRec, VectorOfWords, \"\", FifoWidth, StatusMsgOn) ; \n  end procedure SendBurstVector ;\n  \n  ------------------------------------------------------------\n  procedure SendBurstIncrement (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  FirstWord        : in    std_logic_vector ;\n    constant  NumFifoWords     : in    integer ;\n    constant  Param            : in    std_logic_vector ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) is\n  begin\n    PushBurstIncrement(TransactionRec.BurstFifo, FirstWord, NumFifoWords) ;\n    LocalSendBurst(TransactionRec, SEND_BURST, NumFifoWords, Param, StatusMsgOn) ; \n  end procedure SendBurstIncrement ;\n  \n  ------------------------------------------------------------\n  procedure SendBurstIncrement (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  FirstWord        : in    std_logic_vector ;\n    constant  NumFifoWords     : in    integer ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) is\n  begin\n    SendBurstIncrement(TransactionRec, FirstWord, NumFifoWords, \"\", StatusMsgOn) ; \n  end procedure SendBurstIncrement ;\n\n  ------------------------------------------------------------\n  procedure SendBurstRandom (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  FirstWord        : in    std_logic_vector ;\n    constant  NumFifoWords     : in    integer ;\n    constant  Param            : in    std_logic_vector ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) is\n  begin\n    PushBurstRandom(TransactionRec.BurstFifo, FirstWord, NumFifoWords) ;\n    LocalSendBurst(TransactionRec, SEND_BURST, NumFifoWords, Param, StatusMsgOn) ; \n  end procedure SendBurstRandom ;\n  \n  ------------------------------------------------------------\n  procedure SendBurstRandom (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  FirstWord        : in    std_logic_vector ;\n    constant  NumFifoWords     : in    integer ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) is\n  begin\n    SendBurstRandom(TransactionRec, FirstWord, NumFifoWords, \"\", StatusMsgOn) ; \n  end procedure SendBurstRandom ;\n\n  ------------------------------------------------------------\n  procedure SendBurstRandom (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  CoverID          : in    CoverageIDType ;\n    constant  NumFifoWords     : in    integer ;\n    constant  FifoWidth        : in    integer ;\n    constant  Param            : in    std_logic_vector ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) is\n  begin\n    PushBurstRandom(TransactionRec.BurstFifo, CoverID, NumFifoWords, FifoWidth) ;\n    LocalSendBurst(TransactionRec, SEND_BURST, NumFifoWords, Param, StatusMsgOn) ; \n  end procedure SendBurstRandom ;  \n\n  ------------------------------------------------------------\n  procedure SendBurstRandom (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  CoverID          : in    CoverageIDType ;\n    constant  NumFifoWords     : in    integer ;\n    constant  FifoWidth        : in    integer ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) is\n  begin\n    SendBurstRandom(TransactionRec, CoverID, NumFifoWords, FifoWidth, \"\", StatusMsgOn) ; \n  end procedure SendBurstRandom ;  \n\n\n  -- ========================================================\n  -- SendBurstAsync\n  -- Asynchronous / Non-Blocking Send Transaction\n  -- Param, when present, is an extra parameter used by the verification component\n  -- The UART verification component uses Param for error injection. \n  -- ========================================================\n\n  ------------------------------------------------------------\n  procedure SendBurstAsync (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  NumFifoWords     : in    integer ;\n    constant  Param            : in    std_logic_vector ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) is \n  begin\n    LocalSendBurst(TransactionRec, SEND_BURST_ASYNC, NumFifoWords, Param, StatusMsgOn) ;\n  end procedure SendBurstAsync ; \n\n  ------------------------------------------------------------\n  procedure SendBurstAsync (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  NumFifoWords     : in    integer ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) is \n  begin\n    LocalSendBurst(TransactionRec, SEND_BURST_ASYNC, NumFifoWords, \"\", StatusMsgOn) ;\n  end procedure SendBurstAsync ; \n\n  ------------------------------------------------------------\n  procedure SendBurstVectorAsync (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  VectorOfWords    : in    slv_vector ;\n    constant  Param            : in    std_logic_vector ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) is\n  begin\n    PushBurstVector(TransactionRec.BurstFifo, VectorOfWords) ;\n    LocalSendBurst(TransactionRec, SEND_BURST_ASYNC, VectorOfWords'length, Param, StatusMsgOn) ; \n  end procedure SendBurstVectorAsync ;\n  \n  ------------------------------------------------------------\n  procedure SendBurstVectorAsync (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  VectorOfWords    : in    slv_vector ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) is\n  begin\n    SendBurstVectorAsync(TransactionRec, VectorOfWords, \"\", StatusMsgOn) ; \n  end procedure SendBurstVectorAsync ;\n  \n  ------------------------------------------------------------\n  procedure SendBurstVectorAsync (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  VectorOfWords    : in    integer_vector ;\n    constant  Param            : in    std_logic_vector ;\n    constant  FifoWidth        : in    integer ; \n    constant  StatusMsgOn      : in    boolean := false\n  ) is\n  begin\n    PushBurstVector(TransactionRec.BurstFifo, VectorOfWords, FifoWidth) ;\n    LocalSendBurst(TransactionRec, SEND_BURST_ASYNC, VectorOfWords'length, Param, StatusMsgOn) ; \n  end procedure SendBurstVectorAsync ;\n  \n  ------------------------------------------------------------\n  procedure SendBurstVectorAsync (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  VectorOfWords    : in    integer_vector ;\n    constant  FifoWidth        : in    integer ; \n    constant  StatusMsgOn      : in    boolean := false\n  ) is\n  begin\n    SendBurstVectorAsync(TransactionRec, VectorOfWords, \"\", FifoWidth, StatusMsgOn) ; \n  end procedure SendBurstVectorAsync ;\n  \n  ------------------------------------------------------------\n  procedure SendBurstIncrementAsync (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  FirstWord        : in    std_logic_vector ;\n    constant  NumFifoWords     : in    integer ;\n    constant  Param            : in    std_logic_vector ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) is\n  begin\n    PushBurstIncrement(TransactionRec.BurstFifo, FirstWord, NumFifoWords) ;\n    LocalSendBurst(TransactionRec, SEND_BURST_ASYNC, NumFifoWords, Param, StatusMsgOn) ; \n  end procedure SendBurstIncrementAsync ;\n\n  ------------------------------------------------------------\n  procedure SendBurstIncrementAsync (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  FirstWord        : in    std_logic_vector ;\n    constant  NumFifoWords     : in    integer ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) is\n  begin\n    SendBurstIncrementAsync(TransactionRec, FirstWord, NumFifoWords, \"\", StatusMsgOn) ; \n  end procedure SendBurstIncrementAsync ;\n\n  ------------------------------------------------------------\n  procedure SendBurstRandomAsync (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  FirstWord        : in    std_logic_vector ;\n    constant  NumFifoWords     : in    integer ;\n    constant  Param            : in    std_logic_vector ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) is\n  begin\n    PushBurstRandom(TransactionRec.BurstFifo, FirstWord, NumFifoWords) ;\n    LocalSendBurst(TransactionRec, SEND_BURST_ASYNC, NumFifoWords, Param, StatusMsgOn) ; \n  end procedure SendBurstRandomAsync ;\n\n  ------------------------------------------------------------\n  procedure SendBurstRandomAsync (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  FirstWord        : in    std_logic_vector ;\n    constant  NumFifoWords     : in    integer ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) is\n    variable RV : RandomPType ; \n  begin\n    SendBurstRandomAsync(TransactionRec, FirstWord, NumFifoWords, \"\", StatusMsgOn) ; \n  end procedure SendBurstRandomAsync ;\n\n  ------------------------------------------------------------\n  procedure SendBurstRandomAsync (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  CoverID          : in    CoverageIDType ;\n    constant  NumFifoWords     : in    integer ;\n    constant  FifoWidth        : in    integer ;\n    constant  Param            : in    std_logic_vector ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) is\n  begin\n    PushBurstRandom(TransactionRec.BurstFifo, CoverID, NumFifoWords, FifoWidth) ;\n    LocalSendBurst(TransactionRec, SEND_BURST_ASYNC, NumFifoWords, Param, StatusMsgOn) ; \n  end procedure SendBurstRandomAsync ;  \n\n  ------------------------------------------------------------\n  procedure SendBurstRandomAsync (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  CoverID          : in    CoverageIDType ;\n    constant  NumFifoWords     : in    integer ;\n    constant  FifoWidth        : in    integer ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) is\n  begin\n    SendBurstRandomAsync(TransactionRec, CoverID, NumFifoWords, FifoWidth, \"\", StatusMsgOn) ; \n  end procedure SendBurstRandomAsync ;  \n\n\n  -- ========================================================\n  --  Receiver Transactions\n  -- ========================================================\n\n  -- ========================================================\n  -- Get\n  -- Blocking Get Transaction. \n  -- Param, when present, is an extra parameter used by the verification component\n  -- The UART verification component uses Param for received error status.\n  -- ========================================================\n\n  ------------------------------------------------------------\n  procedure Get (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    variable  Data             : out   std_logic_vector ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) is \n  begin\n    TransactionRec.Operation   <= GET ;\n    TransactionRec.IntToModel  <= Data'length ;\n    TransactionRec.BoolToModel <= StatusMsgOn ;     \n    RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ; \n    Data  := SafeResize(TransactionRec.DataFromModel, Data'length) ; \n  end procedure Get ; \n  \n  ------------------------------------------------------------\n  procedure Get (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    variable  Data             : out   std_logic_vector ;\n    variable  Param            : out   std_logic_vector ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) is \n  begin\n    Get(TransactionRec, Data, StatusMsgOn) ;\n    Param := SafeResize(TransactionRec.ParamFromModel, Param'length) ; \n  end procedure Get ;  \n\n  -- ========================================================\n  -- TryGet\n  -- Try Get Transaction\n  -- If Data is available, get it and return available TRUE,\n  -- otherwise Return Available FALSE.\n  -- Param, when present, is an extra parameter used by the verification component\n  -- The UART verification component uses Param for received error status.\n  -- ========================================================\n\n  ------------------------------------------------------------\n  procedure TryGet (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    variable  Data             : out   std_logic_vector ;\n    variable  Available        : out   boolean ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) is \n  begin\n    TransactionRec.Operation   <= TRY_GET ;\n    TransactionRec.IntToModel  <= Data'length ;\n    TransactionRec.BoolToModel <= StatusMsgOn ;     \n    RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ; \n    Data      := SafeResize(TransactionRec.DataFromModel, Data'length) ; \n    Available := TransactionRec.BoolFromModel ;\n  end procedure TryGet ; \n  \n  ------------------------------------------------------------\n  procedure TryGet (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    variable  Data             : out   std_logic_vector ;\n    variable  Param            : out   std_logic_vector ;\n    variable  Available        : out   boolean ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) is \n  begin\n    TryGet(TransactionRec, Data, Available, StatusMsgOn) ;\n    Param := SafeResize(TransactionRec.ParamFromModel, Param'length) ; \n  end procedure TryGet ;  \n\n\n  -- ========================================================\n  -- GetBurst\n  -- Blocking Get Burst Transaction. \n  -- Param, when present, is an extra parameter from the verification component\n  -- The UART verification component uses Param for received error status.\n  -- ========================================================\n\n  ------------------------------------------------------------\n  procedure LocalGetBurst (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  NumFifoWords     : in    integer ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) is \n  begin\n    TransactionRec.Operation   <= GET_BURST ;\n    TransactionRec.IntToModel  <= NumFifoWords ;  -- For models without burst framing (like UART)\n    TransactionRec.BoolToModel <= StatusMsgOn ;     \n    RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ; \n  end procedure LocalGetBurst ; \n  \n  ------------------------------------------------------------\n  procedure GetBurst (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    variable  NumFifoWords     : inout integer ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) is \n  begin\n    LocalGetBurst(TransactionRec, NumFifoWords, StatusMsgOn) ; \n    NumFifoWords := TransactionRec.IntFromModel ;\n  end procedure GetBurst ; \n  \n  ------------------------------------------------------------\n  procedure GetBurst (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    variable  NumFifoWords     : inout integer ;\n    variable  Param            : out   std_logic_vector ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) is \n  begin\n    LocalGetBurst(TransactionRec, NumFifoWords, StatusMsgOn) ; \n    NumFifoWords := TransactionRec.IntFromModel ;\n    Param := SafeResize(TransactionRec.ParamFromModel, Param'length) ; \n  end procedure GetBurst ;  \n\n  -- ========================================================\n  -- TryGetBurst\n  -- Try Get Burst Transaction\n  -- If Data is available, get it and return available TRUE,\n  -- otherwise Return Available FALSE.\n  -- Param, when present, is an extra parameter used by the verification component\n  -- The UART verification component uses Param for received error status.\n  -- ========================================================\n\n  ------------------------------------------------------------\n  procedure LocalTryGetBurst (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  NumFifoWords     : in    integer ;\n    variable  Available        : out   boolean ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) is \n  begin\n    TransactionRec.Operation   <= TRY_GET_BURST ;\n    TransactionRec.IntToModel  <= NumFifoWords ;  -- For models without burst framing (like UART)\n    TransactionRec.BoolToModel <= StatusMsgOn ;     \n    RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ; \n    Available := TransactionRec.BoolFromModel ;\n  end procedure LocalTryGetBurst ; \n\n  ------------------------------------------------------------\n  procedure TryGetBurst (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    variable  NumFifoWords     : inout integer ;\n    variable  Available        : out   boolean ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) is \n  begin\n    LocalTryGetBurst(TransactionRec, NumFifoWords, Available, StatusMsgOn) ;\n    NumFifoWords  := TransactionRec.IntFromModel ;\n  end procedure TryGetBurst ; \n\n  ------------------------------------------------------------\n  procedure TryGetBurst (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    variable  NumFifoWords     : inout integer ;\n    variable  Param            : out   std_logic_vector ;\n    variable  Available        : out   boolean ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) is \n  begin\n    LocalTryGetBurst(TransactionRec, NumFifoWords, Available, StatusMsgOn) ;\n    NumFifoWords  := TransactionRec.IntFromModel ;\n    Param := SafeResize(TransactionRec.ParamFromModel, Param'length) ; \n  end procedure TryGetBurst ;  \n\n\n  -- ========================================================\n  -- Check\n  -- Blocking Get Transaction. \n  -- Data is the expected value to be received.\n  -- Param, when present, is an extra parameter used by the verification component\n  -- The UART verification component uses Param for received error status.\n  -- ========================================================\n\n  ------------------------------------------------------------\n  procedure Check (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  Data             : in    std_logic_vector ;\n    constant  Param            : in    std_logic_vector ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) is \n    variable LocalParam : std_logic_vector(TransactionRec.ParamToModel'length -1 downto 0) := (others => '-') ;\n  begin\n    LocalParam(Param'length-1 downto 0) := Param ; \n    TransactionRec.Operation     <= CHECK ;\n    TransactionRec.DataToModel   <= SafeResize(Data, TransactionRec.DataToModel'length) ; \n    TransactionRec.ParamToModel  <= SafeResize(LocalParam, TransactionRec.ParamToModel'length) ; \n    TransactionRec.IntToModel    <= Data'length ;\n    TransactionRec.BoolToModel   <= StatusMsgOn ;     \n    RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ; \n  end procedure Check ; \n\n  ------------------------------------------------------------\n  procedure Check (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  Data             : in    std_logic_vector ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) is \n  begin\n    Check(TransactionRec, Data, \"\", StatusMsgOn) ;\n  end procedure Check ; \n\n\n  -- ========================================================\n  -- TryCheck\n  -- Try Check Transaction\n  -- If Data is available, check it and return available TRUE,\n  -- otherwise Return Available FALSE.\n  -- Param, when present, is an extra parameter used by the verification component\n  -- The UART verification component uses Param for received error status.\n  -- ========================================================\n\n  ------------------------------------------------------------\n  procedure TryCheck (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  Data             : in    std_logic_vector ;\n    constant  Param            : in    std_logic_vector ;\n    variable  Available        : out   boolean ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) is \n    variable LocalParam : std_logic_vector(TransactionRec.ParamToModel'length -1 downto 0) := (others => '-') ;\n  begin\n    LocalParam(Param'length-1 downto 0) := Param ; \n    TransactionRec.Operation     <= TRY_CHECK ;\n    TransactionRec.DataToModel   <= SafeResize(Data, TransactionRec.DataToModel'length) ; \n    TransactionRec.ParamToModel  <= SafeResize(LocalParam, TransactionRec.ParamToModel'length) ; \n    TransactionRec.IntToModel    <= Data'length ;\n    TransactionRec.BoolToModel   <= StatusMsgOn ;     \n    RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ; \n    Available := TransactionRec.BoolFromModel ;\n  end procedure TryCheck ; \n\n  ------------------------------------------------------------\n  procedure TryCheck (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  Data             : in    std_logic_vector ;\n    variable  Available        : out   boolean ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) is \n  begin\n    TryCheck(TransactionRec, Data, \"\", Available, StatusMsgOn) ;\n  end procedure TryCheck ; \n\n\n  -- ========================================================\n  -- CheckBurst\n  -- Blocking Check Burst Transaction. \n  -- Param, when present, is an extra parameter used by the verification component\n  -- The UART verification component uses Param for checking error injection.\n  -- ========================================================\n  ------------------------------------------------------------\n  procedure LocalCheckBurst (\n  -- Package Local - simplifies the other calls to Check\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  Operation        : in    StreamOperationType ;\n    constant  NumFifoWords     : in    integer ;\n    constant  Param            : in    std_logic_vector ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) is \n    variable LocalParam : std_logic_vector(TransactionRec.ParamToModel'length -1 downto 0) := (others => '-') ;\n  begin\n    LocalParam(Param'length-1 downto 0) := Param ; \n    TransactionRec.Operation     <= Operation ;\n    TransactionRec.IntToModel    <= NumFifoWords ; \n    TransactionRec.ParamToModel  <= SafeResize(LocalParam, TransactionRec.ParamToModel'length) ; \n    TransactionRec.BoolToModel   <= StatusMsgOn ; \n    RequestTransaction(Rdy => TransactionRec.Rdy, Ack => TransactionRec.Ack) ; \n  end procedure LocalCheckBurst ; \n\n  ------------------------------------------------------------\n  procedure CheckBurst (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  NumFifoWords     : in    integer ;\n    constant  Param            : in    std_logic_vector ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) is \n  begin\n    LocalCheckBurst(TransactionRec, CHECK_BURST, NumFifoWords, Param, StatusMsgOn) ;\n  end procedure CheckBurst ; \n  \n  ------------------------------------------------------------\n  procedure CheckBurst (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  NumFifoWords     : in    integer ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) is \n  begin\n    LocalCheckBurst(TransactionRec, CHECK_BURST, NumFifoWords, \"\", StatusMsgOn) ;\n  end procedure CheckBurst ; \n\n  ------------------------------------------------------------\n  procedure CheckBurstVector (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  VectorOfWords    : in    slv_vector ;\n    constant  Param            : in    std_logic_vector ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) is\n  begin\n    PushBurstVector(TransactionRec.BurstFifo, VectorOfWords) ;\n    LocalCheckBurst(TransactionRec, CHECK_BURST, VectorOfWords'length, Param, StatusMsgOn) ;\n  end procedure CheckBurstVector ;\n  \n  ------------------------------------------------------------\n  procedure CheckBurstVector (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  VectorOfWords    : in    slv_vector ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) is\n  begin\n    CheckBurstVector(TransactionRec, VectorOfWords, \"\", StatusMsgOn) ; \n  end procedure CheckBurstVector ;\n  \n  ------------------------------------------------------------\n  procedure CheckBurstVector (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  VectorOfWords    : in    integer_vector ;\n    constant  Param            : in    std_logic_vector ;\n    constant  FifoWidth        : in    integer ; \n    constant  StatusMsgOn      : in    boolean := false\n  ) is\n  begin\n    PushBurstVector(TransactionRec.BurstFifo, VectorOfWords, FifoWidth) ;\n    LocalCheckBurst(TransactionRec, CHECK_BURST, VectorOfWords'length, Param, StatusMsgOn) ;\n  end procedure CheckBurstVector ;\n  \n  ------------------------------------------------------------\n  procedure CheckBurstVector (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  VectorOfWords    : in    integer_vector ;\n    constant  FifoWidth        : in    integer ; \n    constant  StatusMsgOn      : in    boolean := false\n  ) is\n  begin\n    CheckBurstVector(TransactionRec, VectorOfWords, \"\", FifoWidth, StatusMsgOn) ; \n  end procedure CheckBurstVector ;\n  \n  ------------------------------------------------------------\n  procedure CheckBurstIncrement (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  FirstWord        : in    std_logic_vector ;\n    constant  NumFifoWords     : in    integer ;\n    constant  Param            : in    std_logic_vector ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) is\n  begin\n    PushBurstIncrement(TransactionRec.BurstFifo, FirstWord, NumFifoWords) ;\n    LocalCheckBurst(TransactionRec, CHECK_BURST, NumFifoWords, Param, StatusMsgOn) ;\n  end procedure CheckBurstIncrement ;\n\n  ------------------------------------------------------------\n  procedure CheckBurstIncrement (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  FirstWord        : in    std_logic_vector ;\n    constant  NumFifoWords     : in    integer ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) is\n  begin\n    CheckBurstIncrement(TransactionRec, FirstWord, NumFifoWords, \"\", StatusMsgOn) ; \n  end procedure CheckBurstIncrement ;\n\n  ------------------------------------------------------------\n  procedure CheckBurstRandom (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  FirstWord        : in    std_logic_vector ;\n    constant  NumFifoWords     : in    integer ;\n    constant  Param            : in    std_logic_vector ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) is\n  begin\n    PushBurstRandom(TransactionRec.BurstFifo, FirstWord, NumFifoWords) ;\n    LocalCheckBurst(TransactionRec, CHECK_BURST, NumFifoWords, Param, StatusMsgOn) ;\n  end procedure CheckBurstRandom ;\n  \n  ------------------------------------------------------------\n  procedure CheckBurstRandom (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  FirstWord        : in    std_logic_vector ;\n    constant  NumFifoWords     : in    integer ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) is\n  begin\n    CheckBurstRandom(TransactionRec, FirstWord, NumFifoWords, \"\", StatusMsgOn) ; \n  end procedure CheckBurstRandom ;\n\n  ------------------------------------------------------------\n  procedure CheckBurstRandom (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  CoverID          : in    CoverageIDType ;\n    constant  NumFifoWords     : in    integer ;\n    constant  FifoWidth        : in    integer ;\n    constant  Param            : in    std_logic_vector ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) is\n  begin\n    PushBurstRandom(TransactionRec.BurstFifo, CoverID, NumFifoWords, FifoWidth) ;\n    LocalCheckBurst(TransactionRec, CHECK_BURST, NumFifoWords, Param, StatusMsgOn) ;\n  end procedure CheckBurstRandom ;  \n\n  ------------------------------------------------------------\n  procedure CheckBurstRandom (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  CoverID          : in    CoverageIDType ;\n    constant  NumFifoWords     : in    integer ;\n    constant  FifoWidth        : in    integer ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) is\n  begin\n    CheckBurstRandom(TransactionRec, CoverID, NumFifoWords, FifoWidth, \"\", StatusMsgOn) ;\n  end procedure CheckBurstRandom ;  \n\n  -- ========================================================\n  -- TryCheckBurst\n  -- Try / Non-Blocking Check Burst Transaction\n  -- Param, when present, is an extra parameter used by the verification component\n  -- The UART verification component uses Param for error injection. \n  -- ========================================================\n  ------------------------------------------------------------\n  procedure TryCheckBurst (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  NumFifoWords     : in    integer ;\n    constant  Param            : in    std_logic_vector ;\n    variable  Available        : out   boolean ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) is \n  begin\n    LocalCheckBurst(TransactionRec, TRY_CHECK_BURST, NumFifoWords, Param, StatusMsgOn) ;\n    Available := TransactionRec.BoolFromModel ;\n  end procedure TryCheckBurst ; \n\n  ------------------------------------------------------------\n  procedure TryCheckBurst (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  NumFifoWords     : in    integer ;\n    variable  Available        : out   boolean ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) is \n  begin\n    LocalCheckBurst(TransactionRec, TRY_CHECK_BURST, NumFifoWords, \"\", StatusMsgOn) ;\n    Available := TransactionRec.BoolFromModel ;\n  end procedure TryCheckBurst ; \n\n  ------------------------------------------------------------\n  procedure TryCheckBurstVector (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  VectorOfWords    : in    slv_vector ;\n    constant  Param            : in    std_logic_vector ;\n    variable  Available        : out   boolean ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) is\n  begin\n    GotBurst(TransactionRec, VectorOfWords'length, Available) ; \n    if Available then \n      PushBurstVector(TransactionRec.BurstFifo, VectorOfWords) ;\n      LocalCheckBurst(TransactionRec, CHECK_BURST, VectorOfWords'length, Param, StatusMsgOn) ;\n    end if ; \n  end procedure TryCheckBurstVector ;\n    \n  ------------------------------------------------------------\n  procedure TryCheckBurstVector (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  VectorOfWords    : in    slv_vector ;\n    variable  Available        : out   boolean ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) is\n  begin\n    TryCheckBurstVector(TransactionRec, VectorOfWords, \"\", Available, StatusMsgOn) ;\n  end procedure TryCheckBurstVector ;\n  \n  ------------------------------------------------------------\n  procedure TryCheckBurstVector (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  VectorOfWords    : in    integer_vector ;\n    constant  Param            : in    std_logic_vector ;\n    variable  Available        : out   boolean ;\n    constant  FifoWidth        : in    integer ; \n    constant  StatusMsgOn      : in    boolean := false\n  ) is\n  begin\n    GotBurst(TransactionRec, VectorOfWords'length, Available) ; \n    if Available then \n      PushBurstVector(TransactionRec.BurstFifo, VectorOfWords, FifoWidth) ;\n      LocalCheckBurst(TransactionRec, CHECK_BURST, VectorOfWords'length, Param, StatusMsgOn) ;\n    end if ; \n  end procedure TryCheckBurstVector ;\n    \n  ------------------------------------------------------------\n  procedure TryCheckBurstVector (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  VectorOfWords    : in    integer_vector ;\n    variable  Available        : out   boolean ;\n    constant  FifoWidth        : in    integer ; \n    constant  StatusMsgOn      : in    boolean := false\n  ) is\n  begin\n    TryCheckBurstVector(TransactionRec, VectorOfWords, \"\", Available, FifoWidth, StatusMsgOn) ;\n  end procedure TryCheckBurstVector ;\n  \n  ------------------------------------------------------------\n  procedure TryCheckBurstIncrement (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  FirstWord        : in    std_logic_vector ;\n    constant  NumFifoWords     : in    integer ;\n    constant  Param            : in    std_logic_vector ;\n    variable  Available        : out   boolean ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) is\n  begin\n    GotBurst(TransactionRec, NumFifoWords, Available) ; \n    if Available then\n      PushBurstIncrement(TransactionRec.BurstFifo, FirstWord, NumFifoWords) ;\n      LocalCheckBurst(TransactionRec, CHECK_BURST, NumFifoWords, Param, StatusMsgOn) ;\n    end if ; \n  end procedure TryCheckBurstIncrement ;\n\n  ------------------------------------------------------------\n  procedure TryCheckBurstIncrement (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  FirstWord        : in    std_logic_vector ;\n    constant  NumFifoWords     : in    integer ;\n    variable  Available        : out   boolean ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) is\n  begin\n    TryCheckBurstIncrement(TransactionRec, FirstWord, NumFifoWords, \"\", Available, StatusMsgOn) ; \n  end procedure TryCheckBurstIncrement ;\n\n  ------------------------------------------------------------\n  procedure TryCheckBurstRandom (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  FirstWord        : in    std_logic_vector ;\n    constant  NumFifoWords     : in    integer ;\n    constant  Param            : in    std_logic_vector ;\n    variable  Available        : out   boolean ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) is\n  begin\n    GotBurst(TransactionRec, NumFifoWords, Available) ; \n    if Available then\n      PushBurstRandom(TransactionRec.BurstFifo, FirstWord, NumFifoWords) ;\n      LocalCheckBurst(TransactionRec, CHECK_BURST, NumFifoWords, Param, StatusMsgOn) ;\n    end if ; \n  end procedure TryCheckBurstRandom ;\n\n  ------------------------------------------------------------\n  procedure TryCheckBurstRandom (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  FirstWord        : in    std_logic_vector ;\n    constant  NumFifoWords     : in    integer ;\n    variable  Available        : out   boolean ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) is\n  begin\n    TryCheckBurstRandom(TransactionRec, FirstWord, NumFifoWords, \"\", Available, StatusMsgOn) ; \n  end procedure TryCheckBurstRandom ;\n\n  ------------------------------------------------------------\n  procedure TryCheckBurstRandom (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  CoverID          : in    CoverageIDType ;\n    constant  NumFifoWords     : in    integer ;\n    constant  FifoWidth        : in    integer ;\n    constant  Param            : in    std_logic_vector ;\n    variable  Available        : out   boolean ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) is\n  begin\n    GotBurst(TransactionRec, NumFifoWords, Available) ; \n    if Available then\n      PushBurstRandom(TransactionRec.BurstFifo, CoverID, NumFifoWords, FifoWidth) ;\n      LocalCheckBurst(TransactionRec, CHECK_BURST, NumFifoWords, Param, StatusMsgOn) ;\n    end if ; \n  end procedure TryCheckBurstRandom ;  \n\n  ------------------------------------------------------------\n  procedure TryCheckBurstRandom (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  CoverID          : in    CoverageIDType ;\n    constant  NumFifoWords     : in    integer ;\n    constant  FifoWidth        : in    integer ;\n    variable  Available        : out   boolean ;\n    constant  StatusMsgOn      : in    boolean := false\n  ) is\n  begin\n    TryCheckBurstRandom(TransactionRec, CoverID, NumFifoWords, FifoWidth, \"\", Available, StatusMsgOn) ;\n  end procedure TryCheckBurstRandom ;  \n\n\n  -- ========================================================\n  --  Send And Get Transactions\n  -- \n  -- ========================================================\n  ------------------------------------------------------------\n  procedure SendAndGet (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  iData            : in    std_logic_vector ;\n    constant  iParam           : in    std_logic_vector ;\n    variable  oData            : out   std_logic_vector ;\n    variable  oParam           : out   std_logic_vector ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) is \n  begin\n    LocalSend(TransactionRec, SEND_AND_GET, iData, iParam, StatusMsgOn) ;\n    oData  := SafeResize(TransactionRec.DataFromModel,  oData'length) ; \n    oParam := SafeResize(TransactionRec.ParamFromModel, oParam'length) ; \n  end procedure SendAndGet ;  \n\n  ------------------------------------------------------------\n  procedure SendAndGet (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  iData            : in    std_logic_vector ;\n    variable  oData            : out   std_logic_vector ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) is \n  begin\n    LocalSend(TransactionRec, SEND_AND_GET, iData, \"\", StatusMsgOn) ;\n    oData  := SafeResize(TransactionRec.DataFromModel, oData'length) ; \n  end procedure SendAndGet ;  \n\n  ------------------------------------------------------------\n  procedure SendAndGetBurst (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  iNumFifoWords    : in    integer ;\n    constant  iParam           : in    std_logic_vector ;\n    variable  oNumFifoWords    : out   integer ;\n    variable  oParam           : out   std_logic_vector ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) is \n  begin\n    LocalSendBurst(TransactionRec, SEND_AND_GET_BURST, iNumFifoWords, iParam, StatusMsgOn) ;\n    oNumFifoWords := TransactionRec.IntFromModel ;\n    oParam        := SafeResize(TransactionRec.ParamFromModel, oParam'length) ; \n  end procedure SendAndGetBurst ; \n\n  ------------------------------------------------------------\n  procedure SendAndGetBurst (\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType ;\n    constant  iNumFifoWords    : in    integer ;\n    variable  oNumFifoWords    : out   integer ;\n    constant  StatusMsgOn      : in    boolean := false \n  ) is \n  begin\n    LocalSendBurst(TransactionRec, SEND_AND_GET_BURST, iNumFifoWords, \"\", StatusMsgOn) ;\n    oNumFifoWords := TransactionRec.IntFromModel ;\n  end procedure SendAndGetBurst ; \n\n\n  -- ========================================================\n  --  Pseudo Transactions\n  --  Interact with the record only.\n  -- ========================================================\n  ------------------------------------------------------------\n  procedure ReleaseTransactionRecord (\n  --  Must run on same delta cycle as AcquireTransactionRecord\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType \n  ) is\n  begin\n    -- Set everything driven by TestCtrl to type'left (except Rdy)\n    TransactionRec.Rdy           <= RdyType'left ;   \n    TransactionRec.Operation     <= NOT_DRIVEN ;\n    TransactionRec.DataToModel   <= (TransactionRec.DataToModel'range => 'U') ;\n    TransactionRec.ParamToModel  <= (TransactionRec.ParamToModel'range => 'U') ;\n    TransactionRec.IntToModel    <= integer'left ; \n    TransactionRec.BoolToModel   <= boolean'left ; \n    TransactionRec.TimeToModel   <= time'left ; \n    TransactionRec.Options       <= integer'left ;    \n  end procedure ReleaseTransactionRecord ; \n  \n  ------------------------------------------------------------\n  procedure AcquireTransactionRecord (\n  --  Must run on same delta cycle as ReleaseTransactionRecord\n  ------------------------------------------------------------\n    signal    TransactionRec   : inout StreamRecType \n  ) is\n  begin\n    -- Start Driving Rdy on next delta cycle with the current value.  \n    TransactionRec.Rdy           <= TransactionRec.Rdy ; \n  end procedure AcquireTransactionRecord ; \n\n\n  -- ========================================================\n  --  Verification Component Support Functions\n  --  These help decode the operation value (StreamOperationType)  \n  --  to determine properties about the operation\n  -- ========================================================\n  ------------------------------------------------------------\n  function IsBlocking (\n  -----------------------------------------------------------\n    constant  Operation        : in StreamOperationType\n  ) return boolean is\n  begin\n    return (Operation = SEND) or (Operation = GET) or (Operation = CHECK) or \n           (Operation = SEND_BURST) or (Operation = GET_BURST) or (Operation = CHECK_BURST)  ;\n  end function IsBlocking ;\n\n  ------------------------------------------------------------\n  function IsTry (\n  -----------------------------------------------------------\n    constant  Operation        : in StreamOperationType\n  ) return boolean is\n  begin\n    return (Operation = TRY_GET) or (Operation = TRY_CHECK) or (Operation = TRY_GET_BURST) or (Operation = TRY_CHECK_BURST) ;\n  end function IsTry ;\n\n  ------------------------------------------------------------\n  function IsCheck (\n  -----------------------------------------------------------\n    constant  Operation        : in StreamOperationType\n  ) return boolean is\n  begin\n    return (Operation = CHECK) or (Operation = TRY_CHECK) or (Operation = CHECK_BURST) or (Operation = TRY_CHECK_BURST) ;\n  end function IsCheck ;\n  \n  ------------------------------------------------------------\n  function IsTransmitterOperation (\n  -----------------------------------------------------------\n    constant  Operation        : in StreamOperationType\n  ) return boolean is\n  begin\n    return (Operation < START_OF_RX_OPS) ;\n  end function IsTransmitterOperation ;\n\n  ------------------------------------------------------------\n  function IsReceiverOperation (\n  -----------------------------------------------------------\n    constant  Operation        : in StreamOperationType\n  ) return boolean is\n  begin\n    return (Operation < START_OF_TX_OPS) or (Operation > START_OF_RX_OPS) ;\n  end function IsReceiverOperation ;\n\n  ------------------------------------------------------------\n  function ClassifyUnimplementedOperation (\n  -----------------------------------------------------------\n    constant  Operation        : in StreamOperationType;\n    constant  TransactionCount : in natural\n  ) return string is\n  begin\n    if Operation = MULTIPLE_DRIVER_DETECT then\n      return \"Multiple Drivers on Transaction Record.\" & \n             \"  Transaction # \" & to_string(TransactionCount) ;\n    else\n      return \"Unimplemented Transaction: \" & to_string(Operation) & \n             \"  Transaction # \" & to_string(TransactionCount) ;\n    end if ; \n  end function ClassifyUnimplementedOperation ;\n\n  ------------------------------------------------------------\n  function ClassifyUnimplementedTransmitterOperation (\n  -----------------------------------------------------------\n    constant  Operation        : in StreamOperationType;\n    constant  TransactionCount : in natural\n  ) return string is\n  begin\n    if Operation = MULTIPLE_DRIVER_DETECT then\n      return \"Multiple Drivers on Transaction Record.\" & \n             \"  Transaction # \" & to_string(TransactionCount) ;\n    elsif IsReceiverOperation(Operation) then\n      return \"Not a Transmitter Transaction: \" & to_string(Operation) & \n             \"  Transaction # \" & to_string(TransactionCount) ;\n    else\n      return \"Unimplemented Transaction: \" & to_string(Operation) & \n             \"  Transaction # \" & to_string(TransactionCount) ;\n    end if ; \n  end function ClassifyUnimplementedTransmitterOperation ;\n  \n  ------------------------------------------------------------\n  function ClassifyUnimplementedReceiverOperation (\n  -----------------------------------------------------------\n    constant  Operation        : in StreamOperationType ;\n    constant  TransactionCount : in natural\n  ) return string is\n  begin\n    if Operation = MULTIPLE_DRIVER_DETECT then\n      return \"Multiple Drivers on Transaction Record.\" & \n             \"  Transaction # \" & to_string(TransactionCount) ;\n    elsif IsTransmitterOperation(Operation) then\n      return \"Not a Receiver Transaction: \" & to_string(Operation) & \n             \"  Transaction # \" & to_string(TransactionCount) ;\n    else\n      return \"Unimplemented Transaction: \" & to_string(Operation) & \n             \"  Transaction # \" & to_string(TransactionCount) ;\n    end if ; \n  end function ClassifyUnimplementedReceiverOperation ;\n\nend StreamTransactionPkg ;","lang":"vhdl"};
processSrcData(g_data);