var g_data = {"name":"C:/OsvvmLibraries/osvvm/NameStorePkg.vhd","src":"--\n--  File Name:         NameStorePkg.vhd\n--  Design Unit Name:  NameStorePkg\n--  Revision:          STANDARD VERSION\n--\n--  Maintainer:        Jim Lewis      email:  jim@synthworks.com\n--  Contributor(s):\n--     Jim Lewis          SynthWorks\n--\n--\n--  Package Defines\n--      Data structure for name. \n--\n--  Developed for:\n--        SynthWorks Design Inc.\n--        VHDL Training Classes\n--        11898 SW 128th Ave.  Tigard, Or  97223\n--        http://www.SynthWorks.com\n--\n--  Revision History:\n--    Date      Version    Description\n--    05/2024   2024.05    Calls to singleton forgot to pass ParentID and Search parameter to internal Protected type calls\n--    10/2022   2022.10    Changed enum value PRIVATE to PRIVATE_NAME due to VHDL-2019 keyword conflict.   \n--    02/2022   2022.02    Updated NewID for Updated NewID and Find with ParentID and Search.   \n--                         Supports searching in CoveragePkg, ScoreboardGenericPkg, and MemoryPkg.\n--    06/2021   2021.06    Initial revision.  Derrived from NamePkg.vhd\n--\n--\n--  This file is part of OSVVM.\n--  \n--  Copyright (c) 2021-2022 by SynthWorks Design Inc.  \n--  \n--  Licensed under the Apache License, Version 2.0 (the \"License\");\n--  you may not use this file except in compliance with the License.\n--  You may obtain a copy of the License at\n--  \n--      https://www.apache.org/licenses/LICENSE-2.0\n--  \n--  Unless required by applicable law or agreed to in writing, software\n--  distributed under the License is distributed on an \"AS IS\" BASIS,\n--  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n--  See the License for the specific language governing permissions and\n--  limitations under the License.\n--  \n\nuse std.textio.all ;\nuse work.ResolutionPkg.all ; \nuse work.AlertLogPkg.all ; \n\npackage NameStorePkg is\n \n  type NameIDType is record\n    ID : integer_max ;\n  end record NameIDType ; \n  alias NameStoreIDType is NameIDType ; \n  type NameIDArrayType is array (integer range <>) of NameIDType ;  \n  type NameSearchType is (PRIVATE_NAME, NAME, NAME_AND_PARENT, NAME_AND_PARENT_ELSE_PRIVATE) ; \n  constant ID_NOT_FOUND : NameIDType := (ID => -1) ; \n  \n  ------------------------------------------------------------\n  impure function NewID (\n    iName    : String ;\n    ParentID : AlertLogIdType := ALERTLOG_BASE_ID ;\n    Search   : NameSearchType := NAME \n  ) return NameIDType ;\n  \n  ------------------------------------------------------------\n  procedure Set (\n    ID       : NameIDType ; \n    iName    : String ;\n    ParentID : AlertLogIdType := ALERTLOG_BASE_ID ;\n    Search   : NameSearchType := NAME \n  ) ;\n  \n  impure function Get       (ID : NameIDType ;  DefaultName : string := \"\") return string ;\n  \n  ------------------------------------------------------------\n  impure function Find (\n    iName    : String ;\n    ParentID : AlertLogIdType := ALERTLOG_BASE_ID ;\n    Search   : NameSearchType := NAME \n  ) return NameIDType ;\n  \n  impure function GetOpt    (ID : NameIDType) return string ;\n  impure function IsSet     (ID : NameIDType) return boolean ; \n  procedure       Clear     (ID : NameIDType) ; -- clear name\n  procedure       Deallocate(ID : NameIDType) ; -- effectively alias to clear name\n  \n  ------------------------------------------------------------\n  -- Helper function for NewID in data structures\n  function ResolveSearch (\n    UniqueParent : boolean ;\n    Search       : NameSearchType  \n  ) return NameSearchType ;\n\n  type NameStorePType is protected\n\n    ------------------------------------------------------------\n    impure function NewID (\n      iName    : String ;\n      ParentID : AlertLogIdType := ALERTLOG_BASE_ID ;\n      Search   : NameSearchType := NAME \n    ) return integer ;\n\n    ------------------------------------------------------------\n    procedure Set (\n      ID       : integer ; \n      iName    : String ;\n      ParentID : AlertLogIdType := ALERTLOG_BASE_ID ;\n      Search   : NameSearchType := NAME \n    ) ;\n    \n    impure function Get       (ID : integer ;  DefaultName : string := \"\") return string ;\n    \n    ------------------------------------------------------------\n    impure function Find (\n      iName    : String ;\n      ParentID : AlertLogIdType := ALERTLOG_BASE_ID ;\n      Search   : NameSearchType := NAME \n    ) return integer ;\n    \n    impure function GetOpt    (ID : integer) return string ;\n    impure function IsSet     (ID : integer) return boolean ; \n    procedure       Clear     (ID : integer) ; -- clear name\n    procedure       Deallocate(ID : integer) ; -- effectively alias to clear name\n  end protected NameStorePType ;\n\nend package NameStorePkg ;\n\n--- ///////////////////////////////////////////////////////////////////////////\n--- ///////////////////////////////////////////////////////////////////////////\n--- ///////////////////////////////////////////////////////////////////////////\n\npackage body NameStorePkg is\n\n  type NameStorePType is protected body\n\n    type NameItemRecType is record\n      Name     : Line ; \n      ParentID : AlertLogIDType ; \n      Search   : NameSearchType ;  \n    end record NameItemRecType ; \n    \n    type  NameArrayType    is array (integer range <>) of NameItemRecType ; \n    type  NameArrayPtrType is access NameArrayType ;\n\n--    type  LineArrayType    is array (integer range <>) of Line ; \n--    type  LineArrayPtrType is access LineArrayType ;\n--    variable NameArrayPtr   : LineArrayPtrType ;   \n\n    variable NameArrayPtr   : NameArrayPtrType ;   \n    variable NumItems       : integer := 0 ; \n--    constant MIN_NUM_ITEMS  : integer := 4 ; -- Temporarily small for testing\n    constant MIN_NUM_ITEMS  : integer := 32 ; -- Min amount to resize array\n\n    ------------------------------------------------------------\n    -- Package Local\n    function NormalizeArraySize( NewNumItems, MinNumItems : integer ) return integer is\n    ------------------------------------------------------------\n      variable NormNumItems : integer ;\n      variable ModNumItems  : integer ;\n    begin\n      NormNumItems := NewNumItems ; \n      ModNumItems  := NewNumItems mod MinNumItems ; \n      if ModNumItems > 0 then \n        NormNumItems := NormNumItems + (MinNumItems - ModNumItems) ; \n      end if ; \n      return NormNumItems ; \n    end function NormalizeArraySize ;\n\n    ------------------------------------------------------------\n    -- Package Local\n    procedure GrowNumberItems (\n    ------------------------------------------------------------\n      variable ItemArrayPtr     : InOut NameArrayPtrType ;\n      variable NumItems         : InOut integer ;\n      constant GrowAmount       : in integer ;\n      constant MinNumItems      : in integer \n    ) is\n      variable oldItemArrayPtr  : NameArrayPtrType ;\n--!!Xc      constant NewNumItems      : integer := NumItems + GrowAmount ; \n--!!Xc      constant NewSize : integer := NormalizeArraySize(NewNumItems, MinNumItems) ;\n      variable NewNumItems  : integer ;\n      variable NewSize      : integer ;\n    begin\n      NewNumItems := NumItems + GrowAmount ; \n      NewSize     := NormalizeArraySize(NewNumItems, MinNumItems) ;\n      if ItemArrayPtr = NULL then\n        ItemArrayPtr := new NameArrayType(1 to NewSize) ;\n      elsif NewNumItems > ItemArrayPtr'length then\n        oldItemArrayPtr := ItemArrayPtr ;\n        ItemArrayPtr := new NameArrayType(1 to NewSize) ;\n        ItemArrayPtr.all(1 to NumItems) := oldItemArrayPtr.all(1 to NumItems) ;\n        deallocate(oldItemArrayPtr) ;\n      end if ;\n      NumItems := NewNumItems ; \n    end procedure GrowNumberItems ;\n\n    ------------------------------------------------------------\n    impure function NewID (\n    ------------------------------------------------------------\n      iName    : String ;\n      ParentID : AlertLogIdType := ALERTLOG_BASE_ID ;\n      Search   : NameSearchType := NAME \n    ) return integer is\n    begin\n      GrowNumberItems(NameArrayPtr, NumItems, 1, MIN_NUM_ITEMS) ;\n      Set(NumItems, iName, ParentID, Search) ; \n      return NumItems ; \n    end function NewID ;\n\n    ------------------------------------------------------------\n    procedure Set (\n    ------------------------------------------------------------\n      ID       : integer ; \n      iName    : String ;\n      ParentID : AlertLogIdType := ALERTLOG_BASE_ID ;\n      Search   : NameSearchType := NAME \n    ) is\n    begin\n      deallocate(NameArrayPtr(ID).Name) ;\n      NameArrayPtr(ID).Name     := new string'(iName) ;\n      NameArrayPtr(ID).Search   := Search ;\n      NameArrayPtr(ID).ParentID := ParentID ;\n    end procedure Set ;\n\n    ------------------------------------------------------------\n    impure function Get (ID : integer ; DefaultName : string := \"\") return string is\n    ------------------------------------------------------------\n    begin\n      if NameArrayPtr(ID).Name = NULL then \n        return DefaultName ; \n      else\n        return NameArrayPtr(ID).Name.all ; \n      end if ; \n    end function Get ;\n\n    ------------------------------------------------------------\n    -- Local\n    impure function FindName (iName : String) return integer is\n    ------------------------------------------------------------\n    begin\n      for ID in 1 to NumItems loop \n        -- skip if private\n        next when NameArrayPtr(ID).Search = PRIVATE_NAME ; \n        -- find Name\n        if iName = NameArrayPtr(ID).Name.all then \n          return ID ;\n        end if ;\n      end loop ;\n      return ID_NOT_FOUND.ID ;\n    end function FindName ;\n\n    ------------------------------------------------------------\n    -- Local\n    impure function FindNameAndParent (iName : String; ParentID : AlertLogIdType) return integer is\n    ------------------------------------------------------------\n    begin\n      for ID in 1 to NumItems loop \n        -- skip if private\n        next when NameArrayPtr(ID).Search = PRIVATE_NAME ; \n        -- find Name and Parent\n        if iName = NameArrayPtr(ID).Name.all and (ParentID = NameArrayPtr(ID).ParentID or NameArrayPtr(ID).Search = NAME) then \n          return ID ;\n        end if ;\n      end loop ;\n      return ID_NOT_FOUND.ID ;\n    end function FindNameAndParent ;\n\n    ------------------------------------------------------------\n    impure function Find (\n    ------------------------------------------------------------\n      iName    : String ;\n      ParentID : AlertLogIdType := ALERTLOG_BASE_ID ;\n      Search   : NameSearchType := NAME \n    ) return integer is\n    begin\n      case Search is\n        when PRIVATE_NAME =>       return ID_NOT_FOUND.ID ;\n        when NAME    =>       return FindName(iName) ;\n        when others  =>       return FindNameAndParent(iName, ParentID) ; \n      end case ; \n    end function Find ;\n\n    ------------------------------------------------------------\n    impure function GetOpt (ID : integer) return string is\n    ------------------------------------------------------------\n    begin\n      if NameArrayPtr(ID).Name = NULL then \n        return NUL & \"\" ; \n      else\n        return NameArrayPtr(ID).Name.all ; \n      end if ; \n    end function GetOpt ;\n\n    ------------------------------------------------------------\n    impure function IsSet (ID : integer) return boolean is \n    ------------------------------------------------------------\n    begin\n      return NameArrayPtr(ID).Name /= NULL ; \n    end function IsSet ;      \n    \n    ------------------------------------------------------------\n    procedure Clear (ID : integer) is\n    ------------------------------------------------------------\n    begin\n      deallocate(NameArrayPtr(ID).Name) ;\n    end procedure Clear ;\n    \n    ------------------------------------------------------------\n    procedure Deallocate(ID : integer) is\n    ------------------------------------------------------------\n    begin\n      Clear(ID) ;\n    end procedure Deallocate ;\n  end protected body NameStorePType ;\n  \n\n-- /////////////////////////////////////////\n-- /////////////////////////////////////////\n-- Singleton Data Structure\n-- /////////////////////////////////////////\n-- /////////////////////////////////////////\n  shared variable NameStore : NameStorePType ; \n  \n  ------------------------------------------------------------\n  impure function NewID (\n  ------------------------------------------------------------\n    iName    : String ;\n    ParentID : AlertLogIdType := ALERTLOG_BASE_ID ;\n    Search   : NameSearchType := NAME \n  ) return NameIDType is\n    variable Result : NameIDType ; \n  begin\n    Result.ID := NameStore.NewID(iName, ParentID, Search) ;\n    return Result ; \n  end function NewID ;\n\n  ------------------------------------------------------------\n  procedure Set (\n  ------------------------------------------------------------\n    ID       : NameIDType ; \n    iName    : String ;\n    ParentID : AlertLogIdType := ALERTLOG_BASE_ID ;\n    Search   : NameSearchType := NAME \n  ) is\n  begin\n    NameStore.set(ID.ID, iName, ParentID, Search) ;\n  end procedure Set ;\n\n  ------------------------------------------------------------\n  impure function Get (ID : NameIDType ; DefaultName : string := \"\") return string is\n  ------------------------------------------------------------\n  begin\n    return NameStore.Get(ID.ID, DefaultName) ;\n  end function Get ;\n\n  ------------------------------------------------------------\n  impure function Find (\n  ------------------------------------------------------------\n    iName    : String ;\n    ParentID : AlertLogIdType := ALERTLOG_BASE_ID ;\n    Search   : NameSearchType := NAME \n  ) return NameIDType is\n  begin\n    return NameIDType'(ID => NameStore.Find(iName, ParentID, Search)) ;\n  end function Find ;\n\n  ------------------------------------------------------------\n  impure function GetOpt (ID : NameIDType) return string is\n  ------------------------------------------------------------\n  begin\n    return NameStore.Get(ID.ID) ;\n  end function GetOpt ;\n\n  ------------------------------------------------------------\n  impure function IsSet (ID : NameIDType) return boolean is \n  ------------------------------------------------------------\n  begin\n    return NameStore.IsSet(ID.ID) ;\n  end function IsSet ;      \n  \n  ------------------------------------------------------------\n  procedure Clear (ID : NameIDType) is\n  ------------------------------------------------------------\n  begin\n    NameStore.Clear(ID.ID) ;\n  end procedure Clear ;\n  \n  ------------------------------------------------------------\n  procedure Deallocate(ID : NameIDType) is\n  ------------------------------------------------------------\n  begin\n    NameStore.Clear(ID.ID) ;\n  end procedure Deallocate ;\n  \n  ------------------------------------------------------------\n  -- Helper function for NewID in data structures\n  function ResolveSearch (\n  ------------------------------------------------------------\n    UniqueParent : boolean ;\n    Search       : NameSearchType  \n  ) return NameSearchType is\n    variable result : NameSearchType ; \n  begin\n    if search = NAME_AND_PARENT_ELSE_PRIVATE then \n      result := NAME_AND_PARENT when UniqueParent else PRIVATE_NAME ;\n    else \n      result := Search ; \n    end if ; \n    return result ; \n  end function ResolveSearch ; \n  \nend package body NameStorePkg ;","lang":"vhdl"};
processSrcData(g_data);