var g_data = {"name":"C:/OsvvmLibraries/AXI4/AxiStream/TestCases/TbStream_SendGetDemo1.vhd","src":"--\n--  File Name:         TbStream_SendGetDemo1.vhd\n--  Design Unit Name:  Architecture of TestCtrl\n--  Revision:          OSVVM MODELS STANDARD VERSION\n--\n--  Maintainer:        Jim Lewis      email:  jim@synthworks.com\n--  Contributor(s):\n--     Jim Lewis      jim@synthworks.com\n--\n--\n--  Description:\n--      Validates Stream Model Independent Transactions\n--      Send, Get, Check, \n--      WaitForTransaction, GetTransactionCount\n--      GetAlertLogID, GetErrorCount, \n--\n--\n--  Developed by:\n--        SynthWorks Design Inc.\n--        VHDL Training Classes\n--        http://www.SynthWorks.com\n--\n--  Revision History:\n--    Date      Version    Description\n--    01/2022   2022.01    Initial revision\n--\n--\n--  This file is part of OSVVM.\n--  \n--  Copyright (c) 2022 by SynthWorks Design Inc.  \n--  \n--  Licensed under the Apache License, Version 2.0 (the \"License\");\n--  you may not use this file except in compliance with the License.\n--  You may obtain a copy of the License at\n--  \n--      https://www.apache.org/licenses/LICENSE-2.0\n--  \n--  Unless required by applicable law or agreed to in writing, software\n--  distributed under the License is distributed on an \"AS IS\" BASIS,\n--  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n--  See the License for the specific language governing permissions and\n--  limitations under the License.\n--  \narchitecture SendGetDemo1 of TestCtrl is\n\n  signal   TestDone : integer_barrier := 1 ;\n   \nbegin\n\n  ------------------------------------------------------------\n  -- ControlProc\n  --   Set up AlertLog and wait for end of test\n  ------------------------------------------------------------\n  ControlProc : process\n  begin\n    -- Initialization of test\n    SetTestName(\"TbStream_SendGetDemo1\") ;\n    SetLogEnable(PASSED, TRUE) ;    -- Enable PASSED logs\n    SetLogEnable(INFO, TRUE) ;    -- Enable INFO logs\n\n    -- Wait for simulation elaboration/initialization \n    wait for 0 ns ;  wait for 0 ns ;\n    TranscriptOpen ;\n    SetTranscriptMirror(TRUE) ; \n\n    -- Wait for Design Reset\n    wait until nReset = '1' ;  \n    ClearAlerts ;\n\n    -- Wait for test to finish\n    WaitForBarrier(TestDone, 35 ms) ;\n    AlertIf(now >= 35 ms, \"Test finished due to timeout\") ;\n    AlertIf(GetAffirmCount < 1, \"Test is not Self-Checking\");\n    \n    TranscriptClose ; \n    AffirmIfTranscriptsMatch(OSVVM_VALIDATED_RESULTS_DIR) ;   \n    \n    -- Expecting two check errors at 128 and 256\n    EndOfTestReports(ExternalErrors => (0, 0, 0)) ; \n    std.env.stop ;\n    wait ; \n  end process ControlProc ; \n\n  \n  ------------------------------------------------------------\n  -- AxiTransmitterProc\n  --   Generate transactions for AxiTransmitter\n  ------------------------------------------------------------\n  TransmitterProc : process\n    variable CoverID : CoverageIdType ; \n  begin\n\n    wait until nReset = '1' ;  \n    WaitForClock(StreamTxRec, 2) ; \n    \n-- Send and Get    \n    log(\"Transmit 32 words\") ;\n    for I in 1 to 32 loop \n      Send( StreamTxRec, X\"0000_0000\" + I ) ; \n    end loop ; \n\n    WaitForClock(StreamTxRec, 1) ; \n\n-- Send and Check    \n    log(\"Transmit 32 words\") ;\n    for I in 1 to 32 loop \n      Send( StreamTxRec, X\"0000_1000\" + I ) ; \n    end loop ; \n\n    WaitForClock(StreamTxRec, 1) ; \n-- SendBurst and GetBurst    \n    log(\"Send 32 word burst\") ;\n    for I in 1 to 32 loop \n      Push( StreamTxRec.BurstFifo, X\"0000_2000\" + I  ) ; \n    end loop ; \n    SendBurst(StreamTxRec, 32) ;\n\n    WaitForClock(StreamTxRec, 1) ; \n-- SendBurst and CheckBurst    \n    log(\"Send 32 word burst\") ;\n    for I in 1 to 32 loop \n      Push( StreamTxRec.BurstFifo, X\"0000_3000\" + I ) ; \n    end loop ; \n    SendBurst(StreamTxRec, 32) ;\n\n    WaitForClock(StreamTxRec, 1) ; \n-- SendBurst and CheckBurst    \n    log(\"SendBurstVector 13 word burst\") ;\n    SendBurstVector(StreamTxRec, \n        (X\"0000_4001\", X\"0000_4003\", X\"0000_4005\", X\"0000_4007\", X\"0000_4009\",\n         X\"0000_4011\", X\"0000_4013\", X\"0000_4015\", X\"0000_4017\", X\"0000_4019\",\n         X\"0000_4021\", X\"0000_4023\", X\"0000_4025\") ) ;\n   \n\n-- SendBurstIncrement and CheckBurstIncrement    \n    WaitForClock(StreamTxRec, 1) ; \n    log(\"SendBurstIncrement 16 word burst\") ;\n    SendBurstIncrement(StreamTxRec, X\"0000_5000\", 16) ; \n\n-- SendBurstRandom and CheckBurstRandom    \n    WaitForClock(StreamTxRec, 1) ; \n    log(\"SendBurstRandom 24 word burst\") ;\n    SendBurstRandom   (StreamTxRec, X\"0000_6000\", 24) ; \n    \n-- Coverage:  SendBurstRandom and CheckBurstRandom    \n    CoverID := NewID(\"Cov1\") ; \n    InitSeed(CoverID, 5) ; -- Get a common seed in both processes\n    AddBins(CoverID, 1, GenBin(16#7000#, 16#7007#) & GenBin(16#7010#, 16#7017#) & GenBin(16#7020#, 16#7027#) & GenBin(16#7030#, 16#7037#)) ; \n\n    WaitForClock(StreamTxRec, 1) ; \n    log(\"SendBurstRandom 42 word burst\") ;\n    SendBurstRandom   (StreamTxRec, CoverID, 42, 32) ; \n    \n-- Burst Combining Patterns - Send Get\n    WaitForClock(StreamTxRec, 1) ; \n    log(\"Combining Patterns:  Vector, Increment, Random, Intelligent Coverage\") ;\n    PushBurstVector(StreamTxRec.BurstFifo, \n        (X\"0000_A001\", X\"0000_A003\", X\"0000_A005\", X\"0000_A007\", X\"0000_A009\",\n         X\"0000_A011\", X\"0000_A013\", X\"0000_A015\", X\"0000_A017\", X\"0000_A019\") ) ;\n    PushBurstIncrement(StreamTxRec.BurstFifo, X\"0000_A100\", 10) ; \n    PushBurstRandom(StreamTxRec.BurstFifo, X\"0000_A200\", 6) ; \n    CoverID := NewID(\"Cov1a\") ; \n    InitSeed(CoverID, 5) ; -- Get a common seed in both processes\n    AddBins(CoverID, 1, \n        GenBin(16#A000#, 16#A007#) & GenBin(16#A010#, 16#A017#) & \n        GenBin(16#A020#, 16#A027#) & GenBin(16#A030#, 16#A037#)) ; \n    PushBurstRandom(StreamTxRec.BurstFifo, CoverID, 16, 32) ; \n    SendBurst(StreamTxRec, 42) ; \n         \n-- Burst Combining Patterns\n    WaitForClock(StreamTxRec, 1) ; \n    log(\"Combining Patterns:  Vector, Increment, Random, Intelligent Coverage\") ;\n    PushBurstVector(StreamTxRec.BurstFifo, \n        (X\"0000_B001\", X\"0000_B003\", X\"0000_B005\", X\"0000_B007\", X\"0000_B009\",\n         X\"0000_B011\", X\"0000_B013\", X\"0000_B015\", X\"0000_B017\", X\"0000_B019\") ) ;\n    PushBurstIncrement(StreamTxRec.BurstFifo, X\"0000_A100\", 10) ; \n    PushBurstRandom(StreamTxRec.BurstFifo, X\"0000_A200\", 6) ; \n    CoverID := NewID(\"Cov1b\") ; \n    InitSeed(CoverID, 5) ; -- Get a common seed in both processes\n    AddBins(CoverID, 1, \n        GenBin(16#B000#, 16#B007#) & GenBin(16#B010#, 16#B017#) & \n        GenBin(16#B020#, 16#B027#) & GenBin(16#B030#, 16#B037#)) ; \n    PushBurstRandom(StreamTxRec.BurstFifo, CoverID, Count => 16, FifoWidth => 32) ; \n    SendBurst(StreamTxRec, 42) ; \n\n-- SendBurstVector - PopBurstVector slv_vector\n    WaitForClock(StreamTxRec, 1) ; \n    log(\"SendBurstVector 5 word burst\") ;\n    SendBurstVector(StreamTxRec, \n        (X\"0000_C001\", X\"0000_C003\", X\"0000_C005\", X\"0000_C007\", X\"0000_C009\") ) ;\n   \n-- SendBurstVector - PopBurstVector integer_vector\n    WaitForClock(StreamTxRec, 1) ; \n    log(\"SendBurstVector 5 word burst\") ;\n    PushBurstVector(StreamTxRec.BurstFifo, \n        (16#D001#, 16#D003#, 16#D005#, 16#D007#, 16#D009#), 32 ) ;\n    SendBurst(StreamTxRec, 5) ; \n   \n\n    -- Wait for outputs to propagate and signal TestDone\n    WaitForClock(StreamTxRec, 2) ;\n    WaitForBarrier(TestDone) ;\n    wait ;\n  end process TransmitterProc ;\n\n\n  ------------------------------------------------------------\n  -- AxiReceiverProc\n  --   Generate transactions for AxiReceiver\n  ------------------------------------------------------------\n  ReceiverProc : process\n    variable ExpData, RxData : std_logic_vector(DATA_WIDTH-1 downto 0) ;  \n    variable NumBytes : integer ; \n    variable CoverID : CoverageIdType ; \n    variable slvBurstVector : slv_vector(1 to 5)(31 downto 0) ; \n    variable intBurstVector : integer_vector(1 to 5) ; \n  begin\n    WaitForClock(StreamRxRec, 2) ; \n    \n--    log(\"Transmit 32 words\") ;\n    for I in 1 to 32 loop \n      Get(StreamRxRec, RxData) ;      \n      wait for 0 ns ; \n      AffirmIfEqual(RxData, X\"0000_0000\" + I, \"RxData\") ;\n    end loop ; \n\n--    log(\"Transmit 32 words\") ;\n    for I in 1 to 32 loop \n      Check(StreamRxRec, X\"0000_1000\" + I ) ;      \n    end loop ; \n\n--    log(\"Send 32 word burst\") ;\n    GetBurst(StreamRxRec, NumBytes) ;\n    wait for 0 ns ; \n    AffirmIfEqual(NumBytes, 32, \"Receiver: 32 Received\") ;\n    for I in 1 to 32 loop \n      RxData := Pop( StreamRxRec.BurstFifo ) ;      \n      AffirmIfEqual(RxData, X\"0000_2000\" + I , \"RxData\") ;\n    end loop ; \n\n--    log(\"Send 32 word burst\") ;\n    for I in 1 to 32 loop \n      Push( StreamRxRec.BurstFifo, X\"0000_3000\" + I  ) ; \n    end loop ; \n    CheckBurst(StreamRxRec, 32) ;\n\n    CheckBurstVector(StreamRxRec, \n        (X\"0000_4001\", X\"0000_4003\", X\"0000_4005\", X\"0000_4007\", X\"0000_4009\",\n         X\"0000_4011\", X\"0000_4013\", X\"0000_4015\", X\"0000_4017\", X\"0000_4019\",\n         X\"0000_4021\", X\"0000_4023\", X\"0000_4025\") ) ;\n   \n    CheckBurstIncrement(StreamRxRec, X\"0000_5000\", 16) ; \n\n    CheckBurstRandom   (StreamRxRec, X\"0000_6000\", 24) ; \n\n    CoverID := NewID(\"Cov2\") ; \n    InitSeed(CoverID, 5) ; -- Get a common seed in both processes\n    AddBins(CoverID, 1, \n        GenBin(16#7000#, 16#7007#) & GenBin(16#7010#, 16#7017#) & \n        GenBin(16#7020#, 16#7027#) & GenBin(16#7030#, 16#7037#)) ; \n\n    CheckBurstRandom   (StreamRxRec, CoverID, 42, 32) ; \n    \n--    log(\"Combining Patterns:  Vector, Increment, Random, Intelligent Coverage\") ;\n    PushBurstVector(StreamRxRec.BurstFifo, \n        (X\"0000_A001\", X\"0000_A003\", X\"0000_A005\", X\"0000_A007\", X\"0000_A009\",\n         X\"0000_A011\", X\"0000_A013\", X\"0000_A015\", X\"0000_A017\", X\"0000_A019\") ) ;\n    PushBurstIncrement(StreamRxRec.BurstFifo, X\"0000_A100\", 10) ; \n    PushBurstRandom(StreamRxRec.BurstFifo, X\"0000_A200\", 6) ; \n    CoverID := NewID(\"Cov2a\") ; \n    InitSeed(CoverID, 5) ; -- Get a common seed in both processes\n    AddBins(CoverID, 1, \n        GenBin(16#A000#, 16#A007#) & GenBin(16#A010#, 16#A017#) & \n        GenBin(16#A020#, 16#A027#) & GenBin(16#A030#, 16#A037#)) ; \n    PushBurstRandom(StreamRxRec.BurstFifo, CoverID, 16, 32) ; \n    CheckBurst(StreamRxRec, 42) ; \n\n--    log(\"Combining Patterns:  Vector, Increment, Random, Intelligent Coverage\") ;\n    GetBurst(StreamRxRec, NumBytes) ; \n    CheckBurstVector(StreamRxRec.BurstFifo, \n        (X\"0000_B001\", X\"0000_B003\", X\"0000_B005\", X\"0000_B007\", X\"0000_B009\",\n         X\"0000_B011\", X\"0000_B013\", X\"0000_B015\", X\"0000_B017\", X\"0000_B019\") ) ;\n    CheckBurstIncrement(StreamRxRec.BurstFifo, X\"0000_A100\", 10) ; \n    CheckBurstRandom(StreamRxRec.BurstFifo, X\"0000_A200\", 6) ; \n    CoverID := NewID(\"Cov2b\") ; \n    InitSeed(CoverID, 5) ; -- Get a common seed in both processes\n    AddBins(CoverID, 1, \n        GenBin(16#B000#, 16#B007#) & GenBin(16#B010#, 16#B017#) & \n        GenBin(16#B020#, 16#B027#) & GenBin(16#B030#, 16#B037#)) ; \n    CheckBurstRandom(StreamRxRec.BurstFifo, CoverID, 16, 32) ; \n\n--    log(\"SendBurstVector 5 word burst\") ;\n    GetBurst(StreamRxRec, NumBytes) ;\n    PopBurstVector(StreamRxRec.BurstFifo, slvBurstVector) ; \n    AffirmIf(slvBurstVector = \n        (X\"0000_C001\", X\"0000_C003\", X\"0000_C005\", X\"0000_C007\", X\"0000_C009\"),\n        \"slvBurstVector = C001, C003, C005, C007, C009\") ; --  & to_string(slvBurstVector)) ; -- to_string in 2019\n   \n--    log(\"SendBurstVector 5 word burst\") ;\n    GetBurst(StreamRxRec, NumBytes) ;\n    PopBurstVector(StreamRxRec.BurstFifo, intBurstVector) ; \n    AffirmIf(intBurstVector = \n        (16#D001#, 16#D003#, 16#D005#, 16#D007#, 16#D009#), \n        \"slvBurstVector = D001, D003, D005, D007, D009\") ; -- & to_string(slvBurstVector)) ; -- to_string in 2019\n\n    -- Wait for outputs to propagate and signal TestDone\n    WaitForClock(StreamRxRec, 2) ;\n    WaitForBarrier(TestDone) ;\n    wait ;\n  end process ReceiverProc ;\n\nend SendGetDemo1 ;\n\nConfiguration TbStream_SendGetDemo1 of TbStream is\n  for TestHarness\n    for TestCtrl_1 : TestCtrl\n      use entity work.TestCtrl(SendGetDemo1) ; \n    end for ; \n  end for ; \nend TbStream_SendGetDemo1 ; ","lang":"vhdl"};
processSrcData(g_data);