var g_data = {"name":"C:/OsvvmLibraries/Ethernet/TestStandAlone/Tb_xMii1.vhd","src":"--\n--  File Name:         Tb_xMii1.vhd\n--  Design Unit Name:  Architecture of TestCtrl\n--  Revision:          OSVVM MODELS STANDARD VERSION\n--\n--  Maintainer:        Jim Lewis      email:  jim@synthworks.com\n--  Contributor(s):\n--     Jim Lewis      jim@synthworks.com\n--\n--\n--  Description:\n--      GetBurst with no last, just ID and Dest changes\n--\n--\n--  Developed by:\n--        SynthWorks Design Inc.\n--        VHDL Training Classes\n--        http://www.SynthWorks.com\n--\n--  Revision History:\n--    Date      Version    Description\n--    10/2022   2022.10    Initial Release\n--\n--\n--  This file is part of OSVVM.\n--\n--  Copyright (c) 2022 by SynthWorks Design Inc.\n--  \n--  Licensed under the Apache License, Version 2.0 (the \"License\");\n--  you may not use this file except in compliance with the License.\n--  You may obtain a copy of the License at\n--  \n--      https://www.apache.org/licenses/LICENSE-2.0\n--  \n--  Unless required by applicable law or agreed to in writing, software\n--  distributed under the License is distributed on an \"AS IS\" BASIS,\n--  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n--  See the License for the specific language governing permissions and\n--  limitations under the License.\n--  \narchitecture xMii1 of TestCtrl is\n\n  signal   TestDone : integer_barrier := 1 ;\n  \n \nbegin\n\n  ------------------------------------------------------------\n  -- ControlProc\n  --   Set up AlertLog and wait for end of test\n  ------------------------------------------------------------\n  ControlProc : process\n  begin\n    -- Initialization of test\n    SetTestName(\"Tb_xMii1\") ;\n    SetLogEnable(PASSED, TRUE) ;    -- Enable PASSED logs\n    SetLogEnable(INFO, TRUE) ;    -- Enable INFO logs\n    -- SetLogEnable(DEBUG, TRUE) ;    -- Enable DEBUG logs\n\n    -- Wait for testbench initialization \n    wait for 0 ns ;  wait for 0 ns ;\n    TranscriptOpen(\"Tb_xMii1.txt\") ;\n    SetTranscriptMirror(TRUE) ; \n\n    -- Wait for Design Reset\n--    wait until nReset = '1' ;  \n    ClearAlerts ;\n\n    -- Wait for test to finish\n    WaitForBarrier(TestDone, 20 ms) ;\n    AlertIf(now >= 20 ms, \"Test finished due to timeout\") ;\n    AlertIf(GetAffirmCount < 1, \"Test is not Self-Checking\");\n    \n    TranscriptClose ; \n--    AffirmIfNotDiff(\"Tb_xMii1.txt\", OSVVM_PATH_TO_TESTS & \"/validated_results/TestStandAlone/Tb_xMii1.txt\", \"\") ; \n    \n    EndOfTestReports ; \n    std.env.stop ; \n    wait ; \n  end process ControlProc ; \n\n  \n  ------------------------------------------------------------\n  MacTxProc : process\n  ------------------------------------------------------------\n    variable CoverID : CoverageIdType ; \n  begin\n    for i in 3 to 6 loop \n      WaitForClock(MacTxRec, i) ; \n      \n  -- SendBurstIncrement and CheckBurstIncrement    \n      log(\"SendBurstIncrement 16 word burst\") ;\n      PushBurstIncrement(MacTxRec.BurstFifo, X\"00\", 1024) ; \n      SendBurst(MacTxRec, 16) ; \n      \n      SendBurst(MacTxRec, 16) ; \n\n      SendBurst(MacTxRec, 256) ; \n\n      SendBurst(MacTxRec, 32) ; \n      \n      SendBurst(MacTxRec, 64) ; \n\n      SendBurst(MacTxRec, 128) ; \n\n      SendBurst(MacTxRec, 256) ; \n      SendBurst(MacTxRec, 256) ; \n    end loop ; \n   \n    -- Wait for outputs to propagate and signal TestDone\n    WaitForClock(MacTxRec, 2) ;\n    WaitForBarrier(TestDone) ;\n    wait ;\n  end process MacTxProc ;\n\n\n  ------------------------------------------------------------\n  PhyTxProc : process\n  ------------------------------------------------------------\n    variable PacketLength : integer ; \n  begin\n    WaitForClock(PhyTxRec, 2) ; \n    \n    GetBurst(PhyTxRec, PacketLength) ;\n    AffirmIfEqual(PacketLength, 16, \"Tx Packet 1 Length\") ; \n    CheckBurstIncrement(PhyTxRec.BurstFifo, X\"00\", 16) ; \n    \n    GetBurst(PhyTxRec, PacketLength) ;\n    AffirmIfEqual(PacketLength, 16, \"Tx Packet 2 Length\") ; \n    CheckBurstIncrement(PhyTxRec.BurstFifo, X\"10\", 16) ; \n\n    GetBurst(PhyTxRec, PacketLength) ;\n    AffirmIfEqual(PacketLength, 256, \"Tx Packet 3 Length\") ; \n    CheckBurstIncrement(PhyTxRec.BurstFifo, X\"20\", 256) ; \n\n    GetBurst(PhyTxRec, PacketLength) ;\n    AffirmIfEqual(PacketLength, 32, \"Tx Packet 4 Length\") ; \n    CheckBurstIncrement(PhyTxRec.BurstFifo, X\"20\", 32) ; \n    \n    GetBurst(PhyTxRec, PacketLength) ;\n    AffirmIfEqual(PacketLength, 64, \"Tx Packet 5 Length\") ; \n    CheckBurstIncrement(PhyTxRec.BurstFifo, X\"40\", 64) ; \n\n    GetBurst(PhyTxRec, PacketLength) ;\n    AffirmIfEqual(PacketLength, 128, \"Tx Packet 6 Length\") ; \n    CheckBurstIncrement(PhyTxRec.BurstFifo, X\"80\", 128) ; \n\n    GetBurst(PhyTxRec, PacketLength) ;\n    AffirmIfEqual(PacketLength, 256, \"Tx Packet 7 Length\") ; \n    CheckBurstIncrement(PhyTxRec.BurstFifo, X\"00\", 256) ; \n\n    GetBurst(PhyTxRec, PacketLength) ;\n    AffirmIfEqual(PacketLength, 256, \"Tx Packet 8 Length\") ; \n    CheckBurstIncrement(PhyTxRec.BurstFifo, X\"00\", 256) ; \n    \n    WaitForClock(PhyTxRec, 2) ;\n    WaitForBarrier(TestDone) ;\n    wait ;\n  end process PhyTxProc ;\n  \n  ------------------------------------------------------------\n  PhyRxProc : process\n  ------------------------------------------------------------\n    variable CoverID : CoverageIdType ; \n  begin\n  \n    for i in 3 to 6 loop \n      WaitForClock(PhyRxRec, i) ; \n      \n  -- SendBurstIncrement and CheckBurstIncrement    \n      log(\"SendBurstIncrement 16 word burst\") ;\n      PushBurstIncrement(PhyRxRec.BurstFifo, X\"80\", 1024) ; \n      SendBurst(PhyRxRec, 128) ; \n\n      SendBurst(PhyRxRec, 128) ; \n\n      SendBurst(PhyRxRec, 16) ; \n      \n      SendBurst(PhyRxRec, 16) ; \n\n      SendBurst(PhyRxRec, 32) ; \n      \n      SendBurst(PhyRxRec, 64) ; \n\n      SendBurst(PhyRxRec, 128) ; \n\n      SendBurst(PhyRxRec, 256) ; \n      SendBurst(PhyRxRec, 256) ; \n    end loop ; \n   \n    -- Wait for outputs to propagate and signal TestDone\n    WaitForClock(PhyRxRec, 2) ;\n    WaitForBarrier(TestDone) ;\n    wait ;\n  end process PhyRxProc ;\n\n\n  ------------------------------------------------------------\n  MacRxProc : process\n  ------------------------------------------------------------\n    variable PacketLength : integer ; \n  begin\n    WaitForClock(MacRxRec, 2) ; \n    \n    GetBurst(MacRxRec, PacketLength) ;\n    AffirmIfEqual(PacketLength, 128, \"Rx Packet 1 Length\") ; \n    CheckBurstIncrement(MacRxRec.BurstFifo, X\"80\", 128) ; \n    \n    GetBurst(MacRxRec, PacketLength) ;\n    AffirmIfEqual(PacketLength, 128, \"Rx Packet 2 Length\") ; \n    CheckBurstIncrement(MacRxRec.BurstFifo, X\"00\", 128) ; \n\n    GetBurst(MacRxRec, PacketLength) ;\n    AffirmIfEqual(PacketLength, 16, \"Rx Packet 3 Length\") ; \n    CheckBurstIncrement(MacRxRec.BurstFifo, X\"80\", 16) ; \n\n    GetBurst(MacRxRec, PacketLength) ;\n    AffirmIfEqual(PacketLength, 16, \"Rx Packet 4 Length\") ; \n    CheckBurstIncrement(MacRxRec.BurstFifo, X\"90\", 16) ; \n\n    GetBurst(MacRxRec, PacketLength) ;\n    AffirmIfEqual(PacketLength, 32, \"Rx Packet 5 Length\") ; \n    CheckBurstIncrement(MacRxRec.BurstFifo, X\"A0\", 32) ; \n    \n    GetBurst(MacRxRec, PacketLength) ;\n    AffirmIfEqual(PacketLength, 64, \"Rx Packet 6 Length\") ; \n    CheckBurstIncrement(MacRxRec.BurstFifo, X\"C0\", 64) ; \n\n    GetBurst(MacRxRec, PacketLength) ;\n    AffirmIfEqual(PacketLength, 128, \"Rx Packet 7 Length\") ; \n    CheckBurstIncrement(MacRxRec.BurstFifo, X\"00\", 128) ; \n\n    GetBurst(MacRxRec, PacketLength) ;\n    AffirmIfEqual(PacketLength, 256, \"Rx Packet 8 Length\") ; \n    CheckBurstIncrement(MacRxRec.BurstFifo, X\"80\", 256) ; \n\n    GetBurst(MacRxRec, PacketLength) ;\n    AffirmIfEqual(PacketLength, 256, \"Rx Packet 9 Length\") ; \n    CheckBurstIncrement(MacRxRec.BurstFifo, X\"80\", 256) ; \n    \n    WaitForClock(MacRxRec, 2) ;\n    WaitForBarrier(TestDone) ;\n    wait ;\n  end process MacRxProc ;\nend xMii1 ;\n\nConfiguration Tb_xMii1 of TbStandAlone is\n  for TestHarness\n    for TestCtrl_1 : TestCtrl\n      use entity work.TestCtrl(xMii1) ; \n    end for ; \n  end for ; \nend Tb_xMii1 ; ","lang":"vhdl"};
processSrcData(g_data);