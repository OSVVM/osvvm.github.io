var g_data = {"name":"C:/OsvvmLibraries/AXI4/Axi4Lite/TestCases/TbAxi4_RandomReadWrite.vhd","src":"--\n--  File Name:         TbAxi4_RandomReadWrite.vhd\n--  Design Unit Name:  Architecture of TestCtrl\n--  Revision:          OSVVM MODELS STANDARD VERSION\n--\n--  Maintainer:        Jim Lewis      email:  jim@synthworks.com\n--  Contributor(s):\n--     Jim Lewis      jim@synthworks.com\n--\n--\n--  Description:\n--      Test transaction source\n--\n--\n--  Developed by:\n--        SynthWorks Design Inc.\n--        VHDL Training Classes\n--        http://www.SynthWorks.com\n--\n--  Revision History:\n--    Date      Version    Description\n--    09/2017   2017       Initial revision\n--    01/2020   2020.01    Updated license notice\n--    12/2020   2020.12    Updated signal and port names\n--\n--\n--  This file is part of OSVVM.\n--  \n--  Copyright (c) 2017 - 2020 by SynthWorks Design Inc.  \n--  \n--  Licensed under the Apache License, Version 2.0 (the \"License\");\n--  you may not use this file except in compliance with the License.\n--  You may obtain a copy of the License at\n--  \n--      https://www.apache.org/licenses/LICENSE-2.0\n--  \n--  Unless required by applicable law or agreed to in writing, software\n--  distributed under the License is distributed on an \"AS IS\" BASIS,\n--  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n--  See the License for the specific language governing permissions and\n--  limitations under the License.\n--  \n\narchitecture RandomReadWrite of TestCtrl is\n\n  signal TestDone : integer_barrier := 1 ;\n  \n  type OperationType is (WRITE_OP, READ_OP) ;  -- Add TEST_DONE?\n  constant WRITE_OP_INDEX : integer := OperationType'pos(WRITE_OP) ;\n  constant READ_OP_INDEX  : integer := OperationType'pos(READ_OP) ;\n  subtype OperationSlvType is std_logic_vector(0 downto 0) ;\n\n  shared variable OperationFifo  : osvvm.ScoreboardPkg_slv.ScoreboardPType ; \n  \n  signal TestActive : boolean := TRUE ;\n  \n  signal OperationCount : integer := 0 ; \n \nbegin\n\n  ------------------------------------------------------------\n  -- ControlProc\n  --   Set up AlertLog and wait for end of test\n  ------------------------------------------------------------\n  ControlProc : process\n  begin\n    -- Initialization of test\n    SetTestName(\"TbAxi4_RandomReadWrite\") ;\n    SetLogEnable(PASSED, TRUE) ;    -- Enable PASSED logs\n    SetLogEnable(INFO, TRUE) ;    -- Enable INFO logs\n\n    -- Wait for testbench initialization \n    wait for 0 ns ;  wait for 0 ns ;\n    TranscriptOpen(OSVVM_RESULTS_DIR & \"TbAxi4_RandomReadWrite.txt\") ;\n    SetTranscriptMirror(TRUE) ; \n\n    -- Wait for Design Reset\n    wait until nReset = '1' ;  \n    ClearAlerts ;\n\n    -- Wait for test to finish\n    WaitForBarrier(TestDone, 1 ms) ;\n    AlertIf(now >= 1 ms, \"Test finished due to timeout\") ;\n    AlertIf(GetAffirmCount < 1, \"Test is not Self-Checking\");\n    \n    TranscriptClose ; \n    -- Printing differs in different simulators due to differences in process order execution\n    -- AlertIfDiff(\"./results/TbAxi4_RandomReadWrite.txt\", \"../sim_shared/validated_results/TbAxi4_RandomReadWrite.txt\", \"\") ; \n\n    EndOfTestReports ; \n    std.env.stop ; \n    wait ; \n  end process ControlProc ; \n\n  \n  ------------------------------------------------------------\n  -- ManagerProc\n  --   Generate transactions for AxiManager\n  ------------------------------------------------------------\n  ManagerProc : process\n    variable OpRV      : RandomPType ;   \n    variable WaitForClockRV    : RandomPType ;   \n    variable OperationInt : integer ; \n    variable OperationSlv : OperationSlvType ; \n    variable Address   : std_logic_vector(AXI_ADDR_WIDTH-1 downto 0) ;\n    variable Data      : std_logic_vector(AXI_DATA_WIDTH-1 downto 0) ;    \n    variable ReadData  : std_logic_vector(AXI_DATA_WIDTH-1 downto 0) ;    \n    \n    variable counts : integer_vector(0 to OperationType'Pos(OperationType'Right)) ; \n  begin\n    -- Initialize Randomization Objects\n    OpRV.InitSeed(OpRv'instance_name) ;\n    WaitForClockRV.InitSeed(WaitForClockRV'instance_name) ;\n    \n    -- Find exit of reset\n    wait until nReset = '1' ;  \n    WaitForClock(ManagerRec, 2) ; \n    \n    -- Distribution for Test Operations\n    counts := (WRITE_OP_INDEX => 500, READ_OP_INDEX => 500) ;\n    \n    OperationLoop : loop\n      -- Calculate Address and Data if Write or Read Operation\n      Address   := OpRV.RandSlv(size => AXI_ADDR_WIDTH - 2) & \"00\" ;  -- Keep address word aligned\n      Data      := OpRV.RandSlv(size => AXI_DATA_WIDTH) ;\n--      Operation := to_slv(OpRV.DistInt(counts), Operation'length) ;\n      OperationInt := OpRV.DistInt(counts) ;\n      OperationSlv := to_slv(OperationInt, OperationSlv'length) ;\n      OperationFifo.push(OperationSlv & Address & Data) ;\n      Increment(OperationCount) ;\n      \n      -- 20 % of the time add a no-op cycle with a delay of 1 to 5 clocks\n      if WaitForClockRV.DistInt((8, 2)) = 1 then \n        WaitForClock(ManagerRec, WaitForClockRV.RandInt(1, 5)) ; \n      end if ; \n      \n      -- Do the Operation\n      case OperationType'val(OperationInt) is\n        when WRITE_OP =>  \n          counts(WRITE_OP_INDEX) := counts(WRITE_OP_INDEX) - 1 ; \n          -- Log(\"Starting: Manager Write with Address: \" & to_hstring(Address) & \"  Data: \" & to_hstring(Data) ) ;\n          Write(ManagerRec, Address, Data) ;\n          \n        when READ_OP =>  \n          counts(READ_OP_INDEX) := counts(READ_OP_INDEX) - 1 ; \n          -- Log(\"Starting: Manager Read with Address: \" & to_hstring(Address) & \"  Data: \" & to_hstring(Data) ) ;\n          Read(ManagerRec, Address, ReadData) ;\n          AffirmIf(ReadData = Data, \"AXI Manager Read Data: \"& to_hstring(ReadData), \n                   \"  Expected: \" & to_hstring(Data)) ;\n\n        when others =>\n          Alert(\"Invalid Operation Generated\", FAILURE) ;\n      end case ;\n      \n      exit when counts = (0, 0) ;\n    end loop OperationLoop ; \n    \n    TestActive <= FALSE ; \n    -- Allow Subordinate to catch up before signaling OperationCount (needed when WRITE_OP is last)\n    -- wait for 0 ns ;  -- this is enough\n    WaitForClock(ManagerRec, 2) ;\n    Increment(OperationCount) ;\n    \n    -- Wait for outputs to propagate and signal TestDone\n    WaitForClock(ManagerRec, 2) ;\n    WaitForBarrier(TestDone) ;\n    wait ;\n  end process ManagerProc ;\n\n\n  ------------------------------------------------------------\n  -- SubordinateProc\n  --   Generate transactions for AxiSubordinate\n  ------------------------------------------------------------\n  SubordinateProc : process\n    variable WaitForClockRV         : RandomPType ;   \n    variable OperationSlv   : OperationSlvType ; \n    variable Address        : std_logic_vector(AXI_ADDR_WIDTH-1 downto 0) ;\n    variable ActualAddress  : std_logic_vector(AXI_ADDR_WIDTH-1 downto 0) ;\n    variable Data           : std_logic_vector(AXI_DATA_WIDTH-1 downto 0) ;    \n    variable WriteData      : std_logic_vector(AXI_DATA_WIDTH-1 downto 0) ;    \n  begin\n    WaitForClockRV.InitSeed(WaitForClockRV'instance_name) ;\n\n    OperationLoop : loop   \n      if OperationFifo.empty then\n        WaitForToggle(OperationCount) ; \n      end if ; \n      \n      exit OperationLoop when TestActive = FALSE ; \n      \n      -- 20 % of the time add a no-op cycle with a delay of 1 to 5 clocks\n      if WaitForClockRV.DistInt((8, 2)) = 1 then \n        WaitForClock(SubordinateRec, WaitForClockRV.RandInt(1, 5)) ; \n      end if ; \n      \n      -- Get the Operation\n      (OperationSlv, Address, Data) := OperationFifo.pop ; \n      \n      -- Do the Operation\n      case OperationType'val(to_integer(OperationSlv)) is\n        when WRITE_OP =>  \n          -- Log(\"Starting: Subordinate Write with Expected Address: \" & to_hstring(Address) & \"  Data: \" & to_hstring(Data) ) ;\n          GetWrite(SubordinateRec, ActualAddress, WriteData) ;\n          AffirmIf(ActualAddress = Address, \"AXI Subordinate Write Address: \" & to_hstring(ActualAddress), \n                   \"  Expected: \" & to_hstring(Address)) ;\n          AffirmIf(WriteData = Data, \"AXI Subordinate Write Data: \"& to_hstring(WriteData), \n                   \"  Expected: \" & to_hstring(Data)) ;\n          \n        when READ_OP =>  \n          -- Log(\"Starting: Subordinate Read with Expected Address: \" & to_hstring(Address) & \"  Data: \" & to_hstring(Data) ) ;\n          SendRead(SubordinateRec, ActualAddress, Data) ; \n          AffirmIf(ActualAddress = Address, \"AXI Subordinate Read Address: \" & to_hstring(ActualAddress), \n                   \"  Expected: \" & to_hstring(Address)) ;\n\n        when others =>\n          Alert(\"Invalid Operation Generated\", FAILURE) ;\n          \n      end case ;\n      \n    end loop OperationLoop ; \n\n    -- Wait for outputs to propagate and signal TestDone\n    -- WaitForClock(SubordinateRec, 2) ;\n    WaitForBarrier(TestDone) ;\n    wait ;\n  end process SubordinateProc ;\n\n\nend RandomReadWrite ;\n\nConfiguration TbAxi4_RandomReadWrite of TbAxi4 is\n  for TestHarness\n    for TestCtrl_1 : TestCtrl\n      use entity work.TestCtrl(RandomReadWrite) ; \n    end for ; \n  end for ; \nend TbAxi4_RandomReadWrite ; ","lang":"vhdl"};
processSrcData(g_data);